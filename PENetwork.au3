#NoTrayIcon
;
; Author: Holger Kotsch
; Desc.: PE Network Manager (with ideas from XP itself, BartPE by Bart Lager. and PENetCfg by Pierre Mounir)
; Version: 0.59 Beta 12
; Compiler: AutoIt v3.3.0.0
;

;#RequireAdmin

Opt("WinTitleMatchMode", 2)


;**********************************************************************
; Constants
;**********************************************************************
Global Const $GUI_EVENT_CLOSE					= -3
Global Const $GUI_EVENT_MINIMIZE				= -4
Global Const $GUI_RUNDEFMSG						= "GUI_RUNDEFMSG"

Global Const $GUI_CHECKED						= 1
Global Const $GUI_INDETERMINATE					= 2
Global Const $GUI_UNCHECKED						= 4
Global Const $GUI_SHOW							= 16
Global Const $GUI_HIDE 							= 32
Global Const $GUI_ENABLE						= 64
Global Const $GUI_DISABLE						= 128
Global Const $GUI_FOCUS							= 256
Global Const $GUI_DEFBUTTON						= 512
Global Const $GUI_EXPAND						= 1024
Global Const $GUI_ONTOP							= 2048
Global Const $GUI_NOFOCUS						= 8192

Global Const $GUI_BKCOLOR_DEFAULT				= -1
Global Const $GUI_BKCOLOR_TRANSPARENT			= -2

Global Const $CLR_NONE							= 0xFFFFFFFF

Global Const $WS_TABSTOP						= 0x00010000
Global Const $WS_GROUP							= 0x00020000
Global Const $WS_SYSMENU						= 0x00080000
Global Const $WS_HSCROLL						= 0x00100000
Global Const $WS_VSCROLL						= 0x00200000
Global Const $WS_DLGFRAME						= 0x00400000
Global Const $WS_BORDER							= 0x00800000
Global Const $WS_CAPTION						= 0x00C00000
Global Const $WS_CLIPCHILDREN					= 0x02000000
Global Const $WS_CLIPSIBLINGS					= 0x04000000
Global Const $WS_DISABLED						= 0x08000000
Global Const $WS_VISIBLE						= 0x10000000
Global Const $WS_CHILD							= 0x40000000
Global Const $WS_POPUP							= 0x80000000
Global Const $WS_POPUPWINDOW					= 0x80880000

Global Const $DS_MODALFRAME						= 0x80

Global Const $WS_EX_DLGMODALFRAME				= 0x00000001
Global Const $WS_EX_TOPMOST						= 0x00000008
;Global Const $WS_EX_ACCEPTFILES				= 0x00000010
Global Const $WS_EX_TOOLWINDOW					= 0x00000080
Global Const $WS_EX_CONTROLPARENT				= 0x00010000
Global Const $WS_EX_NOACTIVATE					= 0x08000000

Global Const $WM_ACTIVATE						= 0x0006
Global Const $WM_PAINT							= 0x000F
Global Const $WM_SETCURSOR						= 0x0020
Global Const $WM_NEXTDLGCTL						= 0x0028
Global Const $WM_DRAWITEM						= 0x002B
;Global Const $WM_MEASUREITEM					= 0x002C
Global Const $WM_SETFONT						= 0x0030
Global Const $WM_NOTIFY							= 0x004E
Global Const $WM_CONTEXTMENU					= 0x007B
Global Const $WM_NCACTIVATE						= 0x0086
Global Const $WM_COMMAND						= 0x0111
Global Const $WM_SYSCOMMAND						= 0x0112
Global Const $WM_TIMER							= 0x0113
Global Const $WM_VSCROLL						= 0x0115
Global Const $WM_INITMENUPOPUP					= 0x0117
Global Const $WM_CTLCOLORSTATIC					= 0x0138
Global Const $WM_MOUSEWHEEL						= 0x020A
Global Const $WM_USER							= 0x0400

Global Const $STM_SETICON						= 0x0170
Global Const $STM_GETICON						= 0x0171

Global Const $SC_MINIMIZE						= 0xF020
Global Const $SC_CLOSE							= 0xF060

Global Const $NM_FIRST							= 0
Global Const $NM_CLICK							= $NM_FIRST - 2
Global Const $NM_DBLCLK							= $NM_FIRST - 3
Global Const $NM_RCLICK							= $NM_FIRST - 5
Global Const $NM_CUSTOMDRAW						= $NM_FIRST - 12

Global Const $DT_CENTER							= 0x00000001
Global Const $DT_RIGHT							= 0x00000002
Global Const $DT_VCENTER						= 0x00000004
Global Const $DT_BOTTOM							= 0x00000008
Global Const $DT_WORDBREAK						= 0x00000010
Global Const $DT_SINGLELINE						= 0x00000020
Global Const $DT_EXPANDTABS						= 0x00000040
Global Const $DT_NOCLIP							= 0x00000100
Global Const $DT_CALCRECT						= 0x00000400
Global Const $DT_END_ELLIPSIS					= 0x00008000
Global Const $DT_MODIFYSTRING					= 0x00010000

Global Const $COLOR_HIGHLIGHT					= 13
Global Const $COLOR_HIGHLIGHTTEXT				= 14
Global Const $COLOR_BTNFACE						= 15
Global Const $COLOR_GRAYTEXT					= 17
Global Const $COLOR_BTNTEXT						= 18

Global Const $ODS_SELECTED						= 0x0001
Global Const $ODS_GRAYED						= 0x0002
Global Const $ODS_DISABLED						= 0x0004
Global Const $ODS_FOCUS							= 0x0010

Global Const $BS_CENTER							= 0x0300
;Global Const $BS_ICON							= 0x0040
Global Const $BS_TOP							= 0x0400
Global Const $BS_MULTILINE						= 0x2000
Global Const $BS_NOTIFY							= 0x4000
Global Const $BS_AUTO3STATE						= 0x0006
Global Const $BS_OWNERDRAW						= 0x000B
Global Const $BM_SETSTATE						= 0x00F3

Global Const $CBS_DROPDOWN						= 0x0002 
Global Const $CBS_DROPDOWNLIST					= 0x0003
Global Const $CBS_AUTOHSCROLL					= 0x0040
Global Const $CBS_SORT							= 0x0100

Global Const $CB_LIMITTEXT						= 0x0141
Global Const $CB_DELETESTRING					= 0x0144
Global Const $CB_GETCOUNT						= 0x0146
Global Const $CB_GETCURSEL						= 0x0147
Global Const $CB_GETLBTEXT						= 0x0148
Global Const $CB_GETLBTEXTLEN					= 0x0149
Global Const $CB_RESETCONTENT					= 0x014B
Global Const $CB_SELECTSTRING					= 0x014D
Global Const $CB_SETCURSEL						= 0x014E

Global Const $sCOMBOBOXEXITEM					= "uint;int_ptr;long_ptr;int;int;int;int;int;long_ptr" 
Global Const $CBEM_SETIMAGELIST					= $WM_USER + 2
Global Const $CBEM_INSERTITEMW					= $WM_USER + 11
Global Const $CBEM_GETITEMW						= $WM_USER + 13
Global Const $CBEM_DELETEITEM					= $CB_DELETESTRING
Global Const $CBEIF_TEXT						= 0x00000001
Global Const $CBEIF_IMAGE						= 0x00000002
Global Const $CBEIF_SELECTEDIMAGE				= 0x00000004
Global Const $CBEIF_INDENT						= 0x00000010
	
Global Const $UDS_ALIGNRIGHT					= 0x0004
Global Const $UDS_NOTHOUSANDS					= 0x0080

Global Const $LVS_ICON							= 0x0000
Global Const $LVS_REPORT						= 0x0001

Global Const $LVS_SINGLESEL						= 0x0004
Global Const $LVS_SHOWSELALWAYS					= 0x0008
Global Const $LVS_SORTASCENDING					= 0x0010
Global Const $LVS_SORTDESCENDING				= 0x0020
Global Const $LVS_SHAREIMAGELISTS				= 0x0040
Global Const $LVS_OWNERDRAWFIXED				= 0x0400
Global Const $LVS_NOSCROLL						= 0x2000
Global Const $LVS_NOCOLUMNHEADER				= 0x4000
Global Const $LVS_NOSORTHEADER					= 0x8000

Global Const $LVS_EX_GRIDLINES					= 0x00000001
Global Const $LVS_EX_SUBITEMIMAGES				= 0x00000002
Global Const $LVS_EX_FULLROWSELECT				= 0x00000020
Global Const $LVS_EX_ONECLICKACTIVATE			= 0x00000040
Global Const $LVS_EX_FLATSB						= 0x00000100
Global Const $LVS_EX_UNDERLINEHOT				= 0x00000800
Global Const $LVS_EX_LABELTIP					= 0x00004000

Global Const $LVM_FIRST							= 0x1000
Global Const $LVM_SETIMAGELIST					= $LVM_FIRST + 3
Global Const $LVM_GETITEMCOUNT					= $LVM_FIRST + 4
Global Const $LVM_DELETEITEM					= $LVM_FIRST + 8
Global Const $LVM_DELETEALLITEMS				= $LVM_FIRST + 9
Global Const $LVM_GETNEXTITEM					= $LVM_FIRST + 12
Global Const $LVM_HITTEST						= $LVM_FIRST + 18
Global Const $LVM_GETCOLUMNWIDTH				= $LVM_FIRST + 29
Global Const $LVM_SETCOLUMNWIDTH				= $LVM_FIRST + 30
Global Const $LVM_SETITEMSTATE					= $LVM_FIRST + 43
Global Const $LVM_SETICONSPACING				= $LVM_FIRST + 53
Global Const $LVM_SETEXTENDEDLISTVIEWSTYLE		= $LVM_FIRST + 54
Global Const $LVM_SUBITEMHITTEST				= $LVM_FIRST + 57
Global Const $LVM_SETHOVERTIME					= $LVM_FIRST + 71
Global Const $LVM_GETITEMW						= $LVM_FIRST + 75
Global Const $LVM_SETITEMW						= $LVM_FIRST + 76
Global Const $LVM_INSERTITEMW					= $LVM_FIRST + 77
Global Const $LVM_SORTITEMSEX					= $LVM_FIRST + 81
Global Const $LVM_GETITEMTEXTW					= $LVM_FIRST + 115

Global Const $LVN_FIRST							= -100
Global Const $LVN_ITEMCHANGED					= $LVN_FIRST - 1
Global Const $LVN_BEGINDRAG						= $LVN_FIRST - 9
Global Const $LVN_HOTTRACK						= $LVN_FIRST - 21
Global Const $LVN_KEYDOWN						= $LVN_FIRST - 55

Global Const $LVNI_SELECTED						= 0x0002
Global Const $LVSIL_SMALL						= 1

Global Const $LVIF_TEXT							= 0x0001
Global Const $LVIF_IMAGE						= 0x0002
Global Const $LVIF_STATE						= 0x0008
Global Const $LVIS_SELECTED						= 0x0002

Global Const $TV_FIRST							= 0x1100
Global Const $TVM_DELETEITEM 					= $TV_FIRST + 1
Global Const $TVM_SETIMAGELIST					= $TV_FIRST + 9
Global Const $TVM_GETNEXTITEM					= $TV_FIRST + 10
Global Const $TVM_SELECTITEM					= $TV_FIRST + 11
Global Const $TVM_HITTEST						= $TV_FIRST + 17
Global Const $TVM_SORTCHILDREN					= $TV_FIRST + 19
Global Const $TVM_INSERTITEMW					= $TV_FIRST + 50
Global Const $TVM_GETITEMW						= $TV_FIRST + 62
Global Const $TVM_SETITEMW						= $TV_FIRST + 63

Global Const $TVIF_TEXT							= 0x0001
Global Const $TVIF_IMAGE						= 0x0002
Global Const $TVIF_STATE						= 0x0008
Global Const $TVIF_HANDLE						= 0x0010
Global Const $TVIF_SELECTEDIMAGE				= 0x0020
Global Const $TVIF_CHILDREN						= 0x0040

Global Const $TVGN_ROOT							= 0x0000
Global Const $TVGN_NEXT							= 0x0001
Global Const $TVGN_PREVIOUS						= 0x0002
Global Const $TVGN_PARENT						= 0x0003
Global Const $TVGN_CHILD						= 0x0004
Global Const $TVGN_CARET						= 0x0009

Global Const $TVI_ROOT							= -0x10000
Global Const $TVI_FIRST							= -0x0FFFF
Global Const $TVI_LAST							= -0x0FFFE

Global Const $TVHT_ONITEMICON					= 2
Global Const $TVHT_ONITEMLABEL					= 4
Global Const $TVHT_ONITEMSTATEICON				= 0x0040
Global Const $TVHT_ONITEM						= BitOr($TVHT_ONITEMICON, $TVHT_ONITEMLABEL, $TVHT_ONITEMSTATEICON)

Global Const $TVN_FIRST							= -400
Global Const $TVN_SELCHANGEDA					= $TVN_FIRST - 2
Global Const $TVN_SELCHANGEDW					= $TVN_FIRST - 51
Global Const $TVN_ITEMEXPANDINGA				= $TVN_FIRST - 5
Global Const $TVN_ITEMEXPANDINGW				= $TVN_FIRST - 54
Global Const $TVN_ITEMEXPANDEDA					= $TVN_FIRST - 6
Global Const $TVN_ITEMEXPANDEDW					= $TVN_FIRST - 55

Global Const $TVE_EXPAND						= 0x0002
Global Const $TVIS_EXPANDED						= 0x0020

Global Const $LBS_NOTIFY						= 0x0001
Global Const $LBS_OWNERDRAWVARIABLE				= 0x0020
Global Const $LBS_HASSTRINGS					= 0x0040
Global Const $LB_INSERTSTRING					= 0x0181
Global Const $LB_DELETESTRING					= 0x0182
Global Const $LB_RESETCONTENT					= 0x0184
Global Const $LB_SETCURSEL						= 0x0186
Global Const $LB_GETCURSEL						= 0x0188
Global Const $LB_GETTEXT						= 0x0189
Global Const $LB_GETTEXTLEN						= 0x018A
Global Const $LB_GETCOUNT						= 0x018B
Global Const $LB_SELECTSTRING					= 0x018C
Global Const $LB_GETITEMRECT					= 0x0198
Global Const $LB_ITEMFROMPOINT					= 0x01A9

Global Const $LBN_SELCHANGE						= 1
Global Const $LBN_DBLCLK						= 2
Global Const $LBN_KILLFOCUS						= 5

Global Const $TCS_MULTILINE						= 0x0200

Global Const $ES_RIGHT							= 0x0002
Global Const $ES_UPPERCASE						= 0x0008
Global Const $ES_PASSWORD						= 0x0020
Global Const $ES_AUTOVSCROLL					= 0x0040
Global Const $ES_AUTOHSCROLL					= 0x0080
Global Const $ES_READONLY						= 0x0800

Global Const $EN_SETFOCUS						= 0x0100
Global Const $EN_KILLFOCUS						= 0x0200
Global Const $EN_CHANGE							= 0x0300

Global Const $EM_SETPASSWORDCHAR				= 0x00CC
Global Const $EM_SETREADONLY					= 0x00CF

Global Const $PBS_SMOOTH						= 0x01

Global Const $SS_CENTERIMAGE					= 0x0200
Global Const $SS_SUNKEN							= 0x1000
Global Const $SS_LEFT							= 0
Global Const $SS_CENTER							= 1
Global Const $SS_RIGHT							= 2
Global Const $SS_ICON							= 0x00000003
Global Const $SS_LEFTNOWORDWRAP					= 0x0000000C
Global Const $SS_OWNERDRAW						= 0x0000000D
Global Const $SS_NOTIFY							= 0x00000100

Global Const $TRAY_CHECKED						= 1
Global Const $TRAY_UNCHECKED					= 4
Global Const $TRAY_DEFAULT						= 512

Global Const $IPM_CLEARADDRESS					= $WM_USER + 100
Global Const $IPM_SETADDRESS					= $WM_USER + 101
Global Const $IPM_GETADDRESS					= $WM_USER + 102
Global Const $IPN_FIRST							= -860
Global Const $IPN_FIELDCHANGED					= $IPN_FIRST - 0

Global Const $ERROR_ACCESS_DENIED				= 5
Global Const $ERROR_INVALID_DATA				= 13
Global Const $ERROR_INSUFFICIENT_BUFFER			= 122
Global Const $ERROR_NO_MORE_ITEMS				= 259
Global Const $INVALID_HANDLE_VALUE				= 0xFFFFFFFF

Global Const $DIGCF_PRESENT						= 0x00000002
Global Const $DIGCF_ALLCLASSES					= 0x00000004
Global Const $DIF_PROPERTYCHANGE				= 0x00000012
;Global Const $DICS_FLAG_GLOBAL					= 0x00000001
Global Const $DICS_FLAG_CONFIGSPECIFIC			= 0x00000002
Global Const $DICS_PROPCHANGE					= 0x00000003

Global Const $SPDRP_DEVICEDESC					= 0x00000000
Global Const $SPDRP_SERVICE						= 0x00000004
Global Const $SPDRP_FRIENDLYNAME				= 0x0000000C
Global Const $SPDRP_DRIVER						= 0x00000009

;Global Const $DIREG_DEV						= 0x00000001
;Global Const $DIREG_DRV						= 0x00000002

Global Const $FILE_SHARE_READ					= 0x00000001  
Global Const $FILE_SHARE_WRITE					= 0x00000002
Global Const $OPEN_EXISTING						= 3
Global Const $OID_802_3_CURRENT_ADDRESS			= 0x01010102
Global Const $IOCTL_NDIS_QUERY_GLOBAL_STATS		= 0x00170002

Global Const $NO_ERROR							= 0
Global Const $ERROR_SUCCESS						= 0
Global Const $ERROR_INVALID_STATE				= 5023

Global Const $MAX_COMPUTERNAME_LENGTH			= 15
Global Const $MAX_ADAPTER_NAME					= 128
Global Const $MAX_ADAPTER_ADDRESS_LENGTH		= 8
Global Const $MAX_ADAPTER_DESCRIPTION_LENGTH	= 128
Global Const $MAX_ADAPTER_NAME_LENGTH			= 256
Global Const $MAX_INTERFACE_NAME_LEN			= 256
Global Const $MAXLEN_PHYSADDR					= 6
Global Const $MAXLEN_IFDESCR					= 256

Global Const $sIP_ADDR_STRING					= "long_ptr;char[16];char[16];long_ptr"

Global Const $sIP_ADAPTER_INFO					= "long_ptr;" & _ ; Pointer to the next adapter
													"dword;" & _ ; Not used
													"char[" & ($MAX_ADAPTER_NAME_LENGTH + 4) & "];" & _ ; Name of the adapter
													"char[" & ($MAX_ADAPTER_DESCRIPTION_LENGTH + 4) & "];" & _ ; Description for the adapter
													"uint;" & _ ; Length of the adapter hardware address
													"ubyte[" & $MAX_ADAPTER_ADDRESS_LENGTH & "];" & _ ; Adapter hardware address
													"dword;" & _ ; Adapter index
													"uint;" & _ ; Adapter type
													"uint;" & _ ; Dhcp enabled
													"long_ptr;" & _ ; Not used
													$sIP_ADDR_STRING & ";" & _ ; IP address list (Pointer to next address; IP, SM, NTE)
													$sIP_ADDR_STRING & ";" & _ ; Gateway address list (Pointer to next address; IP, SM, NTE)
													$sIP_ADDR_STRING & ";" & _ ; DHCP server address list
													"long_ptr;" & _ ; Have Wins entries
													$sIP_ADDR_STRING & ";" & _ ; Primary WINS server address list
													$sIP_ADDR_STRING & ";" & _ ; Secondary  WINS server address list
													"long_ptr;" & _ ; DHCP lease obtain time
													"long_ptr" ; DHCP lease expire time

Global Const $sIP_ADAPTER_ADDRESSES				= 	"ulong;" & _ ; Length of the structure
													"dword;" & _ ; IPv4 Adapter index
													"long_ptr;" & _ ; Pointer to the next adapter
													"long_ptr;" & _ ; Pointer to name of the adapter
													"long_ptr;" & _ ; First unicast address
													"long_ptr;" & _ ; First anycast adddress
													"long_ptr;" & _ ; First multicast address
													"long_ptr;" & _ ; First DNS server address
													"long_ptr;" & _ ; DNS suffix
													"long_ptr;" & _ ; Description
													"long_ptr;" & _ ; Friendly name
													"byte[" & $MAX_ADAPTER_ADDRESS_LENGTH & "];" & _ ; Adapter hardware address
													"dword;" & _ ; Length of the adapter hardware address
													"ulong;" & _ ; Flags
													"dword;" & _ ; MTU
													"dword;" & _ ; Interface type
													"int;" & _ ; Operation state
													"dword;" & _ ; IPv6 Adapter index
													"dword[16];" & _ ; Zone indices
													"long_ptr;" & _ ; First prefix
													"uint64;" & _ ; Transmit link speed
													"uint64;" & _ ; Receive link speed
													"long_ptr;" & _ ; First WINS server address
													"long_ptr;" & _ ; First Gateway address
													"ulong;" & _ ; IPv4 metric
													"ulong;" & _ ; IPv6 metric
													"uint64;" & _ ; LUID >= Vista
													"long_ptr;" & _ ; DHCP v4 server socket address
													"int;" & _ ; DHCP v4 server socket address length
													"long_ptr;" & _ ; Compartment ID
													"dword;ushort;ushort;ubyte[8];" & _ ; GUID
													"int;" & _ ; Connection type
													"int;" & _ ; Tunnel type
													"long_ptr;" & _ ; DHCP v6 server socket address
													"int;" & _ ; DHCP v6 server socket address length
													"byte[130];" & _ ; Dhcpv6ClientDuid
													"ulong;" & _ ; DHCP v6 client Duid length
													"long_ptr;" & _ ; DHCP v6 Iaid
													"long_ptr" ; First DNS suffix

Global Const $sSOCKADDR							= "short;ushort;byte[4];char[8]"										
Global Const $sSOCKADDR_IN6						= "short;ushort;ulong;byte[16];ulong"
													
Global Const $sIP_PER_ADAPTER_INFO				= "uint;" & _ ; APIPA (AutoConfigEnabled)
													"uint;" & _ ; AutoConfigActive
													"ptr;" & _ ; Not used
													$sIP_ADDR_STRING ; DNS server list
		
Global Const $sIP_ADAPTER_INDEX_MAP				= "uint;" & _ ; IfIndex
													"wchar[" & $MAX_ADAPTER_NAME & "]" ; Unicode adapter name

Global Const $sMIB_IFROW						= "wchar[" & $MAX_INTERFACE_NAME_LEN & "];" & _
													"dword;" & _ ; Adapter index
													"dword;" & _ ; Interface type
													"dword;" & _ ; MTU
													"dword;" & _ ; Speed
													"dword;" & _ ; Physical addrress length for next
													"ubyte[" & $MAXLEN_PHYSADDR & "];" & _ ; Physical address 
													"dword;" & _ ; Admin status
													"dword;" & _ ; Operation status
													"dword;" & _ ; Last change
													"dword;" & _ ; Number of octets of data received
													"dword;" & _ ; Number of unicast packets received 
													"dword;" & _ ; Number of non-unicast packets received 
													"dword;" & _ ; Number of incoming packets discarded;
													"dword;" & _ ; Number of incoming packets discarded cause of errors
													"dword;" & _ ; Number of incoming packets discarded cause of unknown protocol
													"dword;" & _ ; Number of octets of data sent 
													"dword;" & _ ; Number of unicast packets sent 
													"dword;" & _ ; Number of non-unicast packets sent 
													"dword;" & _ ; Number of outgoing packets discarded
													"dword;" & _ ; Number of outgoing packets discarded cause of errors
													"dword;" & _ ; Output queue length
													"dword;" & _ ; Description length for next
													"byte[" & $MAXLEN_IFDESCR & "]"
													
Global Const $nMIB_IFROW_Elements				= 24

Global Const $sIP_ADAPTER_UNICAST_ADDRESS		= "ulong;" & _ ; Length of the structure
													"dword;" & _ ; Flags
													"long_ptr;" & _ ; Pointer to the next address structure
													"long_ptr;" & _ ; Pointer to socket address
													"int_ptr;" & _ ; Socket address length
													"int;" & _ ; Prefix origin
													"int;" & _ ; Sufix origin
													"int;" & _ ; DAD state
													"ulong;" & _ ; Valid lifetime
													"ulong;" & _ ; Preferred lifetime
													"ulong;" & _ ; Lease lifetime
													"ubyte" ; Prefix length
													
Global Const $sIP_ADAPTER_DNS_SERVER_ADDRESS	= "ulong;" & _ ; Length of the structure
													"dword;" & _ ; Reserved
													"long_ptr;" & _ ; Pointer to the next address structure	
													"long_ptr;" & _ ; Pointer to socket address
													"int" ; Socket address length										

Global Const $sLVI								= "uint;int;int;uint;uint;long_ptr;int;int;dword;int"
;Global Const $sTVI								= "uint;hwnd;uint;uint;long_ptr;int;int;int;int;long_ptr"
Global Const $sTVI								= "uint_ptr;hwnd;uint;uint;long_ptr;int;int;int;int;long_ptr"

Global Const $HKEY_LOCAL_MACHINE				= 0x80000002
Global Const $KEY_WRITE							= 0x20006
Global Const $REG_MULTI_SZ						= 7

Global Const $ILC_MASK							= 0x00000001
Global Const $ILC_COLOR16						= 0x00000010
Global Const $ILC_COLOR32						= 0x00000020

Global Const $BCM_FIRST							= 0x1600
Global Const $BCM_SETIMAGELIST					= $BCM_FIRST + 0x0002

Global Const $BUTTON_IMAGELIST_ALIGN_LEFT		= 0

Global Const $GENERIC_READ						= 0x80000000
;Global Const $GENERIC_WRITE					= 0x40000000
Global Const $GENERIC_EXECUTE					= 0x20000000
;Global Const $GENERIC_ALL						= 0x10000000

Global Const $SC_MANAGER_ALL_ACCESS				= 0xF003F
Global Const $SC_MANAGER_CONNECT				= 0x0001
Global Const $SC_MANAGER_ENUMERATE_SERVICE		= 0x0004

Global Const $SERVICE_CONTROL_STOP				= 0x1
Global Const $SERVICE_CONTROL_INTERROGATE		= 0x4

Global Const $SERVICE_ALL_ACCESS				= 0xF01FF
Global Const $SERVICE_QUERY_STATUS				= 0x0004
Global Const $SERVICE_ENUMERATE_DEPENDENTS		= 0x0008
Global Const $SERVICE_START						= 0x0010
Global Const $SERVICE_STOP						= 0x0020
Global Const $SERVICE_PAUSE_CONTINUE			= 0x0040
Global Const $SERVICE_INTERROGATE				= 0x0080
Global Const $SERVICE_STOPPED					= 0x00000001
Global Const $SERVICE_START_PENDING				= 0x00000002
Global Const $SERVICE_STOP_PENDING				= 0x00000003
Global Const $SERVICE_RUNNING 					= 0x00000004
Global Const $SERVICE_CONTINUE_PENDING			= 0x00000005
Global Const $SERVICE_PAUSE_PENDING				= 0x00000006
Global Const $SERVICE_PAUSED					= 0x00000007
Global Const $SERVICE_ACTIVE					= 0x00000001
Global Const $SERVICE_INACTIVE					= 0x00000002
Global Const $SERVICE_STATE_ALL					= 0x00000003 


Global Const $sSERVICE_STATUS					= "dword;dword;dword;dword;dword;dword;dword"

Global Const $AF_INET							= 2
Global Const $INADDR_NONE						= 4294967295 ; 0xFFFFFFFF

Global Const $WSADESCRIPTION_LEN				= 256

Global Const $sWSADATA							= "ushort;ushort;char[" & $WSADESCRIPTION_LEN + 1 & "];char[" & $WSADESCRIPTION_LEN + 1 & "];ushort;short;ptr"
Global Const $shostent							= "ptr;ptr;short;short;ptr"

Global Const $sIP_OPTION_INFORMATION			= "ubyte;ubyte;ubyte;ubyte;ptr"
Global Const $sICMP_ECHO_REPLY					= "ulong;ulong;ulong;ushort;ushort;ptr;" & $sIP_OPTION_INFORMATION

Global Const $IP_TTL_EXPIRED_TRANSIT			= 11013

Global Const $BN_CLICKED						= 0
Global Const $BN_KILLFOCUS						= 7

Global Const $EN_UPDATE							= 0x0400
Global Const $EN_MAXTEXT						= 0x0501

Global Const $sSID								= "byte;byte;byte[6];dword[5]"
Global Const $sUSER_INFO_1						= "ptr;ptr;dword;dword;ptr;ptr;dword;ptr"
Global Const $sUSER_INFO_23						= "ptr;ptr;ptr;dword;ptr"

Global Const $USER_PRIV_USER					= 1
Global Const $USER_PRIV_ADMIN					= 2

Global Const $UF_SCRIPT							= 0x0001
Global Const $UF_ACCOUNTDISABLE					= 0x0002

Global Const $UF_NORMAL_ACCOUNT					= 0x0200
Global Const $UF_DONT_EXPIRE_PASSWD				= 0x10000

Global Const $SidTypeUser						= 1
Global Const $SidTypeWellKnownGroup				= 5
Global Const $sLOCALGROUP_MEMBERS_INFO_1		= "ptr;int;ptr"

Global Const $NERR_Success						= 0
Global Const $NERR_UserExists					= 2224
Global Const $NERR_PasswordTooShort				= 2245
Global Const $ERROR_MEMBER_IN_ALIAS				= 1378

Global Const $WinWorldSid						= 1
Global Const $WinBuiltinAdministratorsSid		= 26

Global Const $UNLEN								= 256
Global Const $PWLEN								= 256

Global Const $sSHARE_INFO_1						= "ptr;dword;ptr"
Global Const $sSHARE_INFO_2						= "ptr;dword;ptr;dword;dword;dword;ptr;ptr"
Global Const $MAX_PREFERRED_LENGTH				= -1

Global Const $sUSE_INFO_1						= "ptr;ptr;ptr;dword;dword;dword;dword"
Global Const $USE_DISKDEV						= 0

Global Const $CBN_SELCHANGE						= 1
Global Const $CBN_EDITCHANGE					= 5
Global Const $CBN_DROPDOWN						= 7
Global Const $CBN_CLOSEUP						= 8
Global Const $CBN_SELENDOK						= 9
Global Const $CBN_SELENDCANCEL					= 10

Global Const $MB_SETFOREGROUND					= 0x00010000

Global Const $STYPE_PRINTQ						= 1
Global Const $STYPE_IPC							= 3
Global Const $STYPE_SPECIAL						= 0x80000000

Global Const $ERROR_MORE_DATA					= 234

Global Const $MAX_PATH							= 256
Global Const $_MAX_PATH							= 260

Global Const $FILTER_NORMAL_ACCOUNT				= 0x0002

Global Const $sGUID								=	"dword;" & _
													"ushort;" & _
													"ushort;" & _
													"ubyte[8]"
											
Global Const $sWLAN_INTERFACE_INFO				=	$sGUID & ";" & _		; Interface Guid
													"wchar[256];" & _		; Unicode description of the interface
													"dword"					; Current state of the interface


Global Const $sWLAN_PROFILE_INFO				=	"wchar[256];" & _		; Unicode name of the profile
													"dword"					; Flags: 0 (XPSP2)

Global Const $sWLAN_PROFILE_INFO_LIST			= 	"dword;" & _			; Number of items	
													"dword;" & _			; Index (0 based) of the current item
													$sWLAN_PROFILE_INFO		; Array of profiles	

Global Const $sWLAN_AVAILABLE_NETWORK			=	"wchar[256];" & _
													"ulong;char[32];" & _
													"uint;" & _
													"ulong;" & _
													"int;" & _
													"dword;" & _
													"ulong;" & _
													"uint[8];" & _
													"int;" & _
													"ulong;" & _
													"int;" & _
													"uint;" & _
													"uint;" & _
													"dword;" & _
													"dword"

Global Const $sWLAN_CONNECTION_PARAMETERS		=	"dword;" & _			; only 0 for XPSP2 valid
													"ptr;" & _
													"ptr;" & _
													"ptr;" & _				; only 0 for XPSP2 valid
													"dword;" & _
													"dword"					; only 0 for XPSP2 valid

Global Const $sWLAN_CONNECTION_ATTRIBUTES		=	"uint;uint;wchar[256];" & _
													"ulong;char[32];uint;ubyte[6];uint;ulong;ushort;ushort;" & _ ; WLAN_ASSOCIATION_ATTRIBUTES
													"int;uint;uint"			; sWLAN_SECURITY_ATTRIBUTES
													
Global Const $DOT11_AUTH_ALGO_80211_OPEN			= 1
Global Const $DOT11_AUTH_ALGO_80211_SHARED_KEY		= 2
Global Const $DOT11_AUTH_ALGO_WPA					= 3
Global Const $DOT11_AUTH_ALGO_WPA_PSK				= 4
Global Const $DOT11_AUTH_ALGO_WPA_NONE				= 5
Global Const $DOT11_AUTH_ALGO_RSNA					= 6
Global Const $DOT11_AUTH_ALGO_RSNA_PSK				= 7
Global Const $DOT11_AUTH_ALGO_IHV_START				= 0x80000000
Global Const $DOT11_AUTH_ALGO_IHV_END				= 0xffffffff

Global Const $DOT11_CIPHER_ALGO_NONE				= 0x00
Global Const $DOT11_CIPHER_ALGO_WEP40				= 0x01
Global Const $DOT11_CIPHER_ALGO_TKIP				= 0x02
Global Const $DOT11_CIPHER_ALGO_CCMP				= 0x04
Global Const $DOT11_CIPHER_ALGO_WEP104				= 0x05
Global Const $DOT11_CIPHER_ALGO_BIP					= 0x06
Global Const $DOT11_CIPHER_ALGO_GCMP				= 0x08
Global Const $DOT11_CIPHER_ALGO_WPA_USE_GROUP		= 0x100
Global Const $DOT11_CIPHER_ALGO_RSN_USE_GROUP		= 0x100
Global Const $DOT11_CIPHER_ALGO_WEP					= 0x101
Global Const $DOT11_CIPHER_ALGO_IHV_START			= 0x80000000
Global Const $DOT11_CIPHER_ALGO_IHV_END				= 0xffffffff

Global Const $WLAN_AVAILABLE_NETWORK_CONNECTED		= 0x00000001
Global Const $WLAN_AVAILABLE_NETWORK_HAS_PROFILE	= 0x00000002
Global Const $WLAN_PROFILE_GET_PLAINTEXT_KEY		= 0x00000004

Global Const $sMRUINFO								= "dword;uint;uint;hwnd;ptr;ptr"
Global Const $HKEY_CURRENT_USER						= 0x80000001

Global Const $LINE_LEN								= 256
Global Const $sSP_DEVINFO_DATA						= "dword;dword;ushort;ushort;ubyte[8];dword;ulong_ptr"
Global Const $sSP_DEVINSTALL_PARAMS_W				= "dword;dword;dword;hwnd;ptr;ptr;hwnd;ulong_ptr;dword;wchar[" & $_MAX_PATH & "]"

Global Const $sSP_DRVINFO_DATA_W					= "align 1;dword;dword;ulong_ptr;wchar[" & $LINE_LEN & "];" & _
														"wchar[" & $LINE_LEN & "];wchar[" & $LINE_LEN & "];dword[2];uint64"

Global Const $sSP_DRVINFO_DETAIL_DATA_W				= "align " & (1 + @AutoItx64 * 7) & ";dword;dword[2];dword;dword;ulong_ptr;wchar[" & $LINE_LEN & "];" & _
														"wchar[" & $_MAX_PATH & "];wchar[" & $LINE_LEN & "];wchar[1]"
														
Global Const $SPDIT_COMPATDRIVER					= 0x00000002
Global Const $DN_HAS_PROBLEM						= 0x00000400
Global Const $DI_FLAGSEX_ALLOWEXCLUDEDDRVS			= 0x00000800
Global Const $DI_PROPERTIES_CHANGE					= 0x00004000
Global Const $DI_QUIETINSTALL						= 0x00800000
Global Const $DI_NOFILECOPY							= 0x01000000
Global Const $INSTALLFLAG_FORCE						= 0x00000001
Global Const $INSTALLFLAG_READONLY					= 0x00000002

Global Const $SPINST_LOGCONFIG						= 0x00000001
;Global Const $SPINST_INIFILES						= 0x00000002
Global Const $SPINST_REGISTRY						= 0x00000004

Global Const $GWL_STYLE								= -16

Global Const $sINFCONTEXT							= "ptr;ptr;uint;uint"

Global Const $RESOURCE_CONNECTED					= 0x00000001
Global Const $RESOURCE_GLOBALNET					= 0x00000002
Global Const $RESOURCE_CONTEXT						= 0x00000005
Global Const $RESOURCEUSAGE_CONTAINER				= 0x00000002
Global Const $RESOURCETYPE_DISK						= 0x00000001
Global Const $sNETRESOURCE							= "dword;dword;dword;dword;ptr;ptr;ptr;ptr"


Global $sNOTIFYICONDATAW							=	"dword;" & _ ; Struct size
														"hwnd;" & _ ; Callback window handle
														"uint;" & _ ; Icon ID
														"uint;" & _ ; Flags
														"uint;" & _ ; Callback message ID
														"hwnd;" & _ ; Icon handle
														"wchar[128];" & _ ; ToolTip text
														"dword;" & _ ; Icon state
														"dword;" & _ ; Icon state mask
														"wchar[256];" & _ ; Balloon ToolTip text
														"uint;" & _ ; Timeout / Version -> NIM_SETVERSION values 0, 3, 4
														"wchar[64];" & _ ; Balloon ToolTip title text
														"dword" ; Balloon ToolTip info flags

Global Const $NIM_ADD								= 0x00000000
Global Const $NIM_MODIFY							= 0x00000001
Global Const $NIM_DELETE							= 0x00000002
Global Const $NIM_SETVERSION						= 0x00000004
Global Const $NIF_MESSAGE							= 0x00000001

Global Const $NIF_ICON								= 0x00000002
Global Const $NIF_TIP								= 0x00000004
Global Const $NIF_STATE								= 0x00000008
Global Const $NIF_INFO								= 0x00000010
				
Global Const $WM_MENUSELECT							= 0x011F
Global Const $WM_MOUSEMOVE							= 0x0200
Global Const $WM_LBUTTONDOWN						= 0x0201
Global Const $WM_LBUTTONUP							= 0x0202
Global Const $WM_LBUTTONDBLCLK						= 0x0203
Global Const $WM_RBUTTONUP							= 0x0205

Global Const $sWKSTA_INFO_100						= "dword;ptr;ptr;dword;dword"

Global Const $CDDS_PREPAINT							= 0x00000001
Global Const $CDDS_ITEMPREPAINT						= 0x00010001
;Global Const $CDDS_SUBITEM							= 0x00020000
Global Const $CDRF_NEWFONT							= 0x00000002
Global Const $CDRF_SKIPDEFAULT						= 0x00000004
Global Const $CDRF_NOTIFYITEMDRAW					= 0x00000020
Global Const $CDIS_DISABLED							= 0x0004

Global Const $LOGPIXELSX							= 88

Global Const $CW_USEDEFAULT							= 0x80000000

Global Const $TTS_ALWAYSTIP							= 0x01
Global Const $TTS_NOPREFIX							= 0x02
Global Const $TTS_BALLOON							= 0x40
Global Const $TTF_IDISHWND							= 0x0001
Global Const $TTF_SUBCLASS							= 0x0010
Global Const $TTM_ADDTOOLW							= $WM_USER + 50

Global Const $SWP_NOSIZE							= 0x0001
Global Const $SWP_NOMOVE							= 0x0002
Global Const $SWP_NOACTIVATE						= 0x0010

Global Const $sTEXTMETRIC							= "long;long;long;long;long;long;long;long;long;long;long;wchar;wchar;wchar;wchar;byte;byte;byte;byte;byte"
Global Const $sSCROLLINFO							= "uint;uint;int;int;uint;int;int"
Global Const $SB_VERT								= 1
Global Const $SB_LINEUP								= 0
Global Const $SB_LINEDOWN							= 1
Global Const $SB_PAGEUP								= 2
Global Const $SB_PAGEDOWN							= 3
Global Const $SB_THUMBPOSITION						= 4
Global Const $SB_THUMBTRACK							= 5
Global Const $SB_TOP								= 6
Global Const $SB_BOTTOM								= 7
Global Const $VK_PRIOR								= 0x21
Global Const $VK_NEXT								= 0x22
Global Const $VK_END								= 0x23
Global Const $VK_HOME								= 0x24
Global Const $VK_UP									= 0x26
Global Const $VK_DOWN								= 0x28
Global Const $SIF_RANGE								= 0x0001
Global Const $SIF_PAGE								= 0x0002
Global Const $SIF_POS								= 0x0004
Global Const $SIF_ALL								= BitOr(0x1, 0x2, 0x4, 0x10)
Global Const $sCHOOSEFONT							= "dword;hwnd;hwnd;long_ptr;int;dword;dword;long_ptr;long_ptr;long_ptr;hwnd;long_ptr;ushort;int;int"

Global Const $GAA_FLAG_INCLUDE_WINS_INFO			= 0x0040
Global Const $GAA_FLAG_INCLUDE_GATEWAYS				= 0x0080
Global Const $GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER	= 0x0400

Dim $sClassNet										= "{4D36E972-E325-11CE-BFC1-08002BE10318}"
Dim $arSec[1]
Dim $arFileQueue[2][1]
Dim $bDebug											= FALSE
Dim $bClassNetOnly									= TRUE


;**********************************************************************
; Pre-Main
;**********************************************************************
Dim $hAdvapi32	= DllOpen("advapi32.dll")
Dim $hComctl32	= DllOpen("comctl32.dll")
Dim $hGdi32		= DllOpen("gdi32.dll")
Dim $hIphlpapi	= DllOpen("iphlpapi.dll")
Dim $hKernel32	= DllOpen("kernel32.dll")
Dim $hMpr		= DllOpen("mpr.dll")
Dim $hMsimg32	= DllOpen("msimg32.dll")
Dim $hNetapi32	= DllOpen("netapi32.dll")
Dim $hSetupapi	= DllOpen("setupapi.dll")
Dim $hShell32	= DllOpen("shell32.dll")
Dim $hUser32	= DllOpen("user32.dll")
Dim $hWlanapi	= DllOpen("wlanapi.dll")
Dim $hWs2_32	= DllOpen("ws2_32.dll")

Dim $sVersion	= "0.59.B12"
Dim $sLogFile	= @TempDir & "\PENMDrvCpy.txt"


;**********************************************************************
; Get Desktop DPI settings
;**********************************************************************
; At 1st try to use DPI API
;Dim $hDesktop = GetDesktopWindow()
;Dim $nLogPixelX = GetDpiForWindow($hDesktop)
;If $nLogPixelX = 0 Then
	; 2nd try with device capabilities and registry
Dim $hDC		= GetDC(0)
Dim $nLogPixelX	= GetDeviceCaps($hDC, $LOGPIXELSX)
$stTM = DllStructCreate($sTEXTMETRIC)
GetTextMetricsW($hDC, DllStructGetPtr($stTM))
Dim $nYChar = DllStructGetData($stTM, 1) + DllStructGetData($stTM, 5)
ReleaseDC(0, $hDC)
Dim $nLogPixelR	= RegRead("HKCU\Control Panel\Desktop\WindowMetrics", "AppliedDPI")
If $nLogPixelR = 0 Or $nLogPixelR = "" Then $nLogPixelR = RegRead("HKCU\Control Panel\Desktop", "LogPixels")
If $nLogPixelR <> $nLogPixelX And $nLogPixelR > 0 Then $nLogPixelX = $nLogPixelR
;EndIf

Dim $nSBSize		= GetSystemMetrics(2); SM_CXVSCROLL
Dim $nIconSizeBig	= GetSystemMetrics(11) ; SM_CXICON
Dim $nIconSizeSmall	= GetSystemMetrics(49) ; SM_CXSMICON
Dim $nChkSize		= GetSystemMetrics(71) + 4; SM_CXMENUCHECK
Dim $hCursorArrow	= LoadCursor(0, 32512)
Dim $hCursorHand	= LoadCursor(0, 32649)
Dim $hCursorWait	= LoadCursor(0, 32650) ;32514
Dim $hCursorCurrent	= $hCursorArrow

;$nLogPixelX = 144

Dim $nTargetSize= $nLogPixelX / 96 * 16
If $nTargetSize >= 20 Then
	If $nTargetSize >= 24 Then
		$nIconSizeSmall = 24
		$nIconSizeBig = 48
	Else
		$nIconSizeSmall = 20
		$nIconSizeBig = 40
	EndIf
EndIf

If Not (@OSversion = "WIN_XP" Or @OSVersion = "WIN_2003") Then $nRes = SetProcessDPIAware()

;**********************************************************************
; Just ini-patching
;**********************************************************************
If StringInStr($CmdLineRaw, "/inipatch") Then
	If $CmdLine[0] <> 2 Then Exit
	$sInfDir = $CmdLine[2]
	If Not FileExists($sInfDir) Then Exit
	
	Opt("GUICloseOnESC", 0)
	
	GUICreate("Patching INF-files", 160, 50, -1, -1, BitOr($WS_POPUP, $WS_DLGFRAME), $WS_EX_TOOLWINDOW)
	Local $nLblText = GUICtrlCreateLabel("", 10, 10, 140, 20, $SS_CENTER)
	GUICtrlSetFont(-1, 9)
	Local $nProg = GUICtrlCreateProgress(10, 32, 140, 10, $PBS_SMOOTH)
	GUISetState()
	
	$sInfFile = $sInfDir & "\nettcpip.inf"
	If FileExists($sInfFile) Then
		GUICtrlSetData($nLblText, "Patching ""nettcpip.inf""...")
		IniWrite($sInfFile, "ControlFlags", "ExcludeFromSelect", "MS_NetBT,MS_NETBT_SMB")
		IniWrite($sInfFile, "MS_TCPIP.PrimaryInstall", "Characteristics", "0x80")
		IniDelete($sInfFile, "Registry.MS_TCPIP.PrimaryInstall")
		IniWriteSection($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "")
		GUICtrlSetData($nProg, 10)
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "HKR,Ndi,ClsId,,""{A907657F-6FDF-11D0-8EFB-00C04FD912B2}""")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "HKR,Ndi,HelpText,,""@netcfgx.dll,-50001""")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "HKR,Ndi,Service,,""Tcpip""")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "HKR,Ndi,CoServices,%FLG_ADDREG_TYPE_MULTI_SZ%,""Tcpip"",""Netbt"",""Lmhosts"",""Dhcp"",""Dnscache"",""PolicyAgent"",""Nla""")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "HKR,Ndi,ExcludeSetupStartServices,0x00010000,""Tcpip"",""Netbt"",""Lmhosts"",""Dhcp"",""Dnscache"",""PolicyAgent"",""Nla""")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "HKR,Ndi\Interfaces,UpperRange,,""tdi""")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.PrimaryInstall", "HKR,Ndi\Interfaces,LowerRange,,""ndis4,ndis5,ndisatm,ndiswanip,ndis5_ip,ndis1394""")
		GUICtrlSetData($nProg, 20)
		IniDelete($sInfFile, "MS_TCPIP.PrimaryInstall.Services")
		IniWriteSection($sInfFile, "MS_TCPIP.PrimaryInstall.Services", "")
		IniWriteLine($sInfFile, "MS_TCPIP.PrimaryInstall.Services", "AddService=Tcpip,0,Install.AddService.TCPIP,NetEventLog")
		IniWriteLine($sInfFile, "MS_TCPIP.PrimaryInstall.Services", "AddService=Dhcp,0x400,Install.AddService.DHCP,DhcpEventLog")
		IniWriteLine($sInfFile, "MS_TCPIP.PrimaryInstall.Services", "AddService=IPSec,1,Install.AddService.IPSEC,NetEventLog")
		IniWriteLine($sInfFile, "MS_TCPIP.PrimaryInstall.Services", "AddService=PolicyAgent,0,Install.AddService.PolicyAgent,PolicyAgentEventLog")
		IniWriteLine($sInfFile, "MS_TCPIP.PrimaryInstall.Services", "AddService=Atmarpc,0,ATMARPC.AddService,NetEventLog")
		IniWriteLine($sInfFile, "MS_TCPIP.PrimaryInstall.Services", "AddService=Nla,0,Install.AddService.NLA,NetEventLog")
		GUICtrlSetData($nProg, 30)
		IniWrite($sInfFile, "Install.AddService.TCPIP", "AddReg", "Registry.Service.TCPIP")
		IniWrite($sInfFile, "Install.AddService.DHCP", "AddReg", "Registry.Service.DHCP")
		IniWrite($sInfFile, "Install.AddService.DHCP", "StartName", "LocalSystem")
		IniDelete($sInfFile, "Install.AddService.DHCP", "Security")
		GUICtrlSetData($nProg, 40)
		IniWrite($sInfFile, "Install.AddService.DNSCACHE", "AddReg", "Registry.Service.DNSCACHE")
		IniDelete($sInfFile, "Install.AddService.DNSCACHE", "Security")
		IniWrite($sInfFile, "Install.AddService.IPSEC", "AddReg", "Registry.Service.IPSEC")
		IniDelete($sInfFile, "Registry.Service.IPSEC")
		IniWrite($sInfFile, "Install.AddService.LMHosts", "StartName", "LocalSystem")
		IniWrite($sInfFile, "Install.AddService.NLA", "StartType", "2")
		IniDelete($sInfFile, "Install.AddService.NLA", "Security")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP","HKLM,SOFTWARE\Microsoft\Rpc\ClientProtocols,ncacn_nb_tcp,,""rpcrt4.dll""")
		GUICtrlSetData($nProg, 50)
		IniDelete($sInfFile, "Registry.MS_TCPIP.Legacy.Remove")
		IniWriteSection($sInfFile, "Registry.MS_TCPIP.Legacy.Remove", "")
		IniWriteLine($sInfFile, "Registry.MS_TCPIP.Legacy.Remove", "HKLM,SOFTWARE\Microsoft\Tcpip")
		IniDelete($sInfFile, "Registry.Service.DHCP.Secure")
		IniDelete($sInfFile, "Registry.Service.DHCP.Secure.Security")
		IniDelete($sInfFile, "Registry.Service.TCPIP.Secure")
		IniDelete($sInfFile, "Registry.Service.TCPIP.Secure.Security")
		GUICtrlSetData($nProg, 60)
		IniDelete($sInfFile, "Registry.Service.TCPIP")
		IniWriteSection($sInfFile, "Registry.Service.TCPIP", "")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKLM,""System\CurrentControlSet\Control\ServiceProvider\Order"",""ExcludedProviders"",%FLG_ADDREG_SZ_NO_CLOBBER%,""""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKLM,""System\CurrentControlSet\Control\ServiceProvider\Order"",""ProviderOrder"",%FLG_ADDREG_MULTI_SZ_APPEND%,""Tcpip""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Performance,Close,,""CloseTcpIpPerformanceData""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Performance,Collect,,""CollectTcpIpPerformanceData""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Performance,Library,,""Perfctrs.dll""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Performance,Open,,""OpenTcpIpPerformanceData""")
		GUICtrlSetData($nProg, 70)
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,ServiceProvider,Class,%FLG_ADDREG_TYPE_DWORD%,8")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,ServiceProvider,DnsPriority,%FLG_ADDREG_TYPE_DWORD%,2000")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,ServiceProvider,HostsPriority,%FLG_ADDREG_TYPE_DWORD%,500")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,ServiceProvider,LocalPriority,%FLG_ADDREG_TYPE_DWORD%,499")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,ServiceProvider,ProviderPath,%FLG_ADDREG_TYPE_EXPAND_SZ%,""%%SystemRoot%%\System32\wsock32.dll""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,ServiceProvider,NetbtPriority,%FLG_ADDREG_TYPE_DWORD%,2001")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,ServiceProvider,Name,,""TCP/IP""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Parameters,DataBasePath,%FLG_ADDREG_TYPE_EXPAND_SZ%,""%%SystemRoot%%\System32\drivers\etc""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Parameters,NameServer,%FLG_ADDREG_SZ_NO_CLOBBER%,""""")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Parameters,ForwardBroadcasts,%FLG_ADDREG_DWORD_NO_CLOBBER%,0")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Parameters,IPEnableRouter,%FLG_ADDREG_TYPE_DWORD%,0")
		IniWriteLine($sInfFile, "Registry.Service.TCPIP", "HKR,Parameters\Winsock,""UseDelayedAcceptance"",%FLG_ADDREG_TYPE_DWORD%,0x0000")
		GUICtrlSetData($nProg, 80)
		IniDelete($sInfFile, "Registry.Service.DNSCACHE.Secure")
		IniDelete($sInfFile, "Registry.Service.DNSCACHE.Secure.Security")
		IniWrite($sInfFile, "Install.AddService.LMHosts", "StartName", "LocalSystem")
		IniWrite($sInfFile, "Install.AddService.NetBT", "AddReg", "Registry.Service.NetBT")
		IniDelete($sInfFile, "Install.AddService.NetBT", "Security")
		IniDelete($sInfFile, "Registry.Service.NetBT.Secure")
		IniDelete($sInfFile, "Registry.Service.NetBT.Secure.Security")
		GUICtrlSetData($nProg, 90)
		IniDelete($sInfFile, "PolicyAgentEventLog.AddReg")
		IniWriteSection($sInfFile, "PolicyAgentEventLog.AddReg", "")
		IniWriteLine($sInfFile, "PolicyAgentEventLog.AddReg", "HKR,,EventMessageFile,0x00020000,""%%SystemRoot%%\System32\polagent.dll""")
		IniWriteLine($sInfFile, "PolicyAgentEventLog.AddReg", "HKR,,TypesSupported,0x00010001,7")
		IniDelete($sInfFile, "Install.AddService.Smb")
		IniDelete($sInfFile, "Registry.MS_SMB.Install")
		IniDelete($sInfFile, "Registry.Service.Smb")
		IniDelete($sInfFile, "Registry.Service.Smb.DelReg")
		IniDelete($sInfFile, "MS_SMB.Install")
		IniDelete($sInfFile, "MS_SMB.Install.Remove")
		IniDelete($sInfFile, "MS_SMB.Install.Remove.Services")
		IniDelete($sInfFile, "MS_SMB.Install.Services")
		GUICtrlSetData($nProg, 100)
	EndIf
	
	$sInfFile = $sInfDir & "\netmscli.inf"
	If FileExists($sInfFile) Then
		GUICtrlSetData($nLblText, "Patching ""netmscli.inf""...")
		IniWrite($sInfFile, "Alerter_Service_Inst", "StartType", "3")
		GUICtrlSetData($nProg, 10)
		IniWrite($sInfFile, "NetLogon_Service_Inst", "LoadOrderGroup", "MS_WindowsRemoteValidation")
		IniWrite($sInfFile, "Messenger_Service_Inst", "StartType", "2")
		GUICtrlSetData($nProg, 20)
		IniWrite($sInfFile, "Messenger_Service_Inst", "StartName", """NT AUTHORITY""\LocalService")
		IniWrite($sInfFile, "RpcLocator_Service_Inst", "StartName", "LocalSystem")
		GUICtrlSetData($nProg, 30)
		IniWriteLine($sInfFile, "MSClient.DelReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 16")
		IniWriteLine($sInfFile, "MSClient.DelReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 14")
		GUICtrlSetData($nProg, 40)
		IniWriteLine($sInfFile, "MSClient.DelReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 10")
		IniWriteLine($sInfFile, "MSClient.DelReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 9")
		GUICtrlSetData($nProg, 50)
		IniWriteLine($sInfFile, "MSClient.AddReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 16, , secur32.dll")
		IniWriteLine($sInfFile, "MSClient.AddReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 14, , schannel.dll")
		GUICtrlSetData($nProg, 70)
		IniWriteLine($sInfFile, "MSClient.AddReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 10, , secur32.dll")
		IniWriteLine($sInfFile, "MSClient.AddReg", "HKLM, Software\Microsoft\Rpc\SecurityService, 9,  , secur32.dll")
		GUICtrlSetData($nProg, 90)
		IniDelete($sInfFile, "MSClient.ndi.PrintProvider")
		IniWriteLine($sInfFile, "MSClient.NetLogon.AddReg", "HKR, Parameters, DBFlag, 0, 0")
		GUICtrlSetData($nProg, 100)
	EndIf
		
	$sInfFile = $sInfDir & "\ndisuio.inf"
	If FileExists($sInfFile) Then
		GUICtrlSetData($nLblText, "Patching ""ndisuio.inf""...")
		IniDelete($sInfFile, "Install", "CopyFiles")
	EndIf
	
	$sInfFile = $sInfDir & "\netwzc.inf"
	If FileExists($sInfFile) Then
		GUICtrlSetData($nLblText, "Patching ""netwzc.inf""...")
		IniDelete($sInfFile, "WZCSVC.ndi", "CopyFiles")
	EndIf
	
	$sInfFile = $sInfDir & "\netrass.inf"
	If FileExists($sInfFile) Then
		GUICtrlSetData($nLblText, "Patching ""netwzc.inf""...")
		IniDelete($sInfFile, "Reg-RasAuto-Params", "Security")
		IniDelete($sInfFile, "Reg-RemoteAccess-Params.Secure.Security")
	EndIf
	
	GUIDelete()
	
	Exit
EndIf


;**********************************************************************
; Just drivers-copying
;**********************************************************************
If StringInStr($CmdLineRaw, "/drvcopy") Then
	If $CmdLine[0] < 3 Then Exit
	
	$sSrc = $CmdLine[2]
	$sTgt = $CmdLine[3]
	
	If ChkCmdParam("/allclass") Then $bClassNetOnly = FALSE
	
	If Not FileExists($sSrc) Then Exit

	Opt("GUICloseOnESC", 0)
	
	GUICreate("Copying driver files", 260, 40, -1, -1, BitOr($WS_POPUP, $WS_BORDER), $WS_EX_TOOLWINDOW)
	Local $nLblText = GUICtrlCreateLabel("", 5, 10, 250, 20, $SS_CENTER)
	GUICtrlSetFont(-1, 9)
	GUISetState()
	
	If StringRight($sSrc, 1) <> "\" Then $sSrc &= "\"
	If StringRight($sTgt, 1) <> "\" Then $sTgt &= "\"
	
	If FileExists($sLogFile) Then FileDelete($sLogFile)
	
	Local $sOSType	= "x86"
	If ChkCmdParam("x64") Or ChkCmdParam("/x64") Then $sOSType = "amd64"
	
	; XP
	Local $nOSMaj	= 5
	Local $nOSMin	= 1
	Local $bChkOS	= FALSE
	
	If FileExists($sTgt & "txtsetup.sif") Then
		$nOSMaj	= IniRead($sTgt & "txtsetup.sif", "SetupData", "MajorVersion", "5")
		$nOSMin	= IniRead($sTgt & "txtsetup.sif", "SetupData", "MinorVersion", "1")
	EndIf
	
	If ChkCmdParam("XP") Or ChkCmdParam("/XP") Then
		$nOSMaj	= 5
		$nOSMin	= 1
		$bChkOS = TRUE
	ElseIf ChkCmdParam("2003") Or ChkCmdParam("/2003") Then
		$nOSMaj	= 5
		$nOSMin	= 2
		$bChkOS = TRUE
	ElseIf ChkCmdParam("Vista") Or ChkCmdParam("/Vista") Then
		$nOSMaj	= 6
		$nOSMin	= 0
		$bChkOS = TRUE
	ElseIf ChkCmdParam("Win7") Or ChkCmdParam("/Win7") Then
		$nOSMaj = 6
		$nOSMin = 1
		$bChkOS = TRUE
	ElseIf ChkCmdParam("Win8") Or ChkCmdParam("/Win8") Then
		$nOSMaj = 6
		$nOSMin = 2
		$bChkOS = TRUE
	ElseIf ChkCmdParam("Win8.1") Or ChkCmdParam("/Win8.1") Then
		$nOSMaj = 6
		$nOSMin = 3
		$bChkOS = TRUE
	ElseIf ChkCmdParam("Win10") Or ChkCmdParam("/Win10") Then
		$nOSMaj = 10
		$nOSMin = 0
		$bChkOS = TRUE
	EndIf
			
	Dim $sRoot	= ""; "i386"
	
	CopyDrvLog("IN: Driver copy process version: " & $sVersion)
	CopyDrvLog("IN: Source: " & $sSrc)
	CopyDrvLog("IN: Target: " & $sTgt)
	CopyDrvLog("IN: Search for network drivers only: " & $bClassNetOnly)
	CopyDrvLog("IN: Check for correct target OS: " & $bChkOS)
	
	If $bChkOS Then
		CopyDrvLog("IN: Search for OS driver version: " & $nOSMaj & "." & $nOSMin & " - " & $sOSType)
	Else
		CopyDrvLog("IN: Search for OS driver version: Ignored (5.X, 6.X) - " & $sOSType)
	EndIf
	
	$arFileQueue[0][0] = 0	
	
	CopyDrvLog("IN: >>> Copying driver files... <<<")
	EnumCopyDrv($sSrc, $sTgt, $nLblText, $sLogFile, $nOSMaj, $nOSMin, $sOSType, $sRoot, $bChkOS)
	CopyDrvLog("IN: >>> End of copying driver files <<<")
	
	GUIDelete()
	
	Exit
EndIf


;**********************************************************************
; Variables
;**********************************************************************													
Dim $hMainGUI = 0, $hLastGUI = 0, $hPCG = 0, $hPSG = 0, $hTrayGUI = 0, $hTraySubGUI, $hAboutGUI = 0, $hTrayWiFiGUI = 0
Dim $hConfGUI, $hIdentGUI, $hSharesGUI, $hDrivesGUI, $hOtherGUI, $hProfilesGUI, $hSchemesGUI
Dim $hCMDChangeGUI, $hCMDStartGUI, $hWiFiGUI, $hGlobalGUI, $hDescGUI, $hPrevGUI, $hPrevBkGUI, $hPrevBlackGUI
Dim $bAboutCreated = FALSE, $bSharesCreated = FALSE, $bDrivesCreated = FALSE, $bProfilesCreated = FALSE
Dim $bIdentCreated = FALSE, $bWiFiCreated = FALSE, $bOtherCreated = FALSE, $bExtCreated = FALSE, $bDrvCreated = FALSE
Dim $hLastConfGUI = 0, $hConfIPGUI, $hConfWINSGUI, $hConfPreWiFiGUI, $hConfWiFiGUI, $hConfExtGUI, $hConfFWGUI
Dim $hLastWiFiGUI = 0, $hWiFiAvailGUI, $hWiFiPrefGUI, $hWiFiSrvGUI, $hWiFiConnGUI = 0, $hConfAltIPGUI = 0
Dim $hSubGUI = 0, $hAddrGUI = 0, $hStartNetGUI = 0, $hHelperGUI = 0
Dim $nBtnSpeed, $nMenuSpeed, $nDummySpeed, $nIconState, $nLblMac, $nBtnRefresh, $nComboNA, $nComboNATray
Dim $nLblAdapterState, $nLblAdapterSpeed, $nChkScan
Dim $nBtnAdapterMAC, $nLblCurMAC, $nLblNewMAC, $nInpCurMAC, $nInpNewMAC
Dim $nTIConf, $nTIIdent, $nTISharing, $nTIDrives, $nTIProfiles, $nTIOther, $nTIAbout, $nTISize
Dim $nTIGlobal, $nTIDesc, $nTIAdapter, $nTINetIdent, $nTINetShares, $nTINetDrives, $nTIPreview
Dim $nTIWireless, $nTIColorSchemes, $nTICMDStartup, $nTICMDChange	
Dim $nLblLeft1, $nLblTop1, $nLblRight1, $nLblBottom1
Dim $nLblLeft2, $nLblTop2, $nLblRight2, $nLblBottom2
Dim $nLblLeft3, $nLblTop3, $nLblRight3, $nLblBottom3
Dim $nTIIP, $nTIWiFi, $nTIAdv, $nTabWiFi, $nTIFirewall
Dim $nTIWiFiAV, $nTIWiFiPref, $nTIWiFiSrv, $nLblWiFiState, $nLblWiFiCurState, $nBtnWiFi
Dim $nBtnIP, $nBtnDG
Dim $nBtnDhcpInfo, $nBtnDhcpRelease, $nBtnDhcpRenew, $nRadIPNone
Dim $nRadDNSDHCP, $nRadDNSStatic, $nBtnDNS, $nLblDNS
Dim $nRadWINSDHCP, $nRadWINSStatic, $nBtnWINS, $nLblWINS
Dim $nRadIPDHCP, $nRadIPStatic, $nChkDGMode, $nBtnIPAltShow, $nBtnIPAltHide, $nRadIPPrivate, $nRadIPUser
Dim $nBtnMACApply, $nBtnMACCancel, $nBtnMACRestore
Dim $hIP, $hSM, $hDG, $hDNS, $hWINS, $hAddr1 = 0, $hAddr2 = 0
Dim $nLblAltIPConf, $nLblAltIP, $nLblAltSM, $nLblAltDG, $nLblAltDNS1, $nLblAltDNS2, $nLblAltWINS1, $nLblAltWINS2
Dim $hAltIP, $hAltSM, $hAltDG, $hAltDNS1, $hAltDNS2, $hAltWINS1, $hAltWINS2
Dim $nLblStaticIP, $nLblStaticSM, $nLblStaticDG
Dim $nBtnApply, $nBtnOK, $nBtnCancel, $nBtnYes, $nBtnNo
Dim $nListAddr, $nLblState
Dim $nBtnAddrUp, $nBtnAddrDown, $nBtnAddrAdd, $nBtnAddrDel, $nBtnAddrOK, $nBtnAddrCancel
Dim $nBtnAddAddrAdd, $nBtnAddAddrCancel
Dim $nLblCNI, $nLblCN, $nLblWG, $nLblPriDNS
Dim $nInpPCName, $nInpPCWG = 0, $nInpPCDNS
Dim $nLinkWB, $nLinkAI, $nLblStartTxt, $nPrgrStart, $nLblUsing1
Dim $nLblAbout, $nLblAboutAI3, $nLblAboutAuthor, $hLblAboutAI3, $hLblAboutAuthor
Dim $bLblAboutAI3 = FALSE, $bLblAboutAuthor = FALSE
Dim $nLblFileShr, $nLblShrInfo, $nBtnShr, $nLblShrUsr, $nComboShrUsr, $nLVShares
Dim $hCbEditShrUsr, $nBtnShrUsrDel
Dim $nBtnShrRef, $nBtnShrAdd, $nBtnShrDel, $nBtnShrAddShow
Dim $nLblShrName, $nInpShrName, $nLblShrPath, $nInpShrPath, $nBtnShrPath
Dim $nLblShrPW, $nInpShrPW, $nChkShrAll, $nBtnShrSetPW, $nEditShrAdmin, $nLblShrFolders
Dim $nLblPing, $nBtnPing, $nComboPing, $nAddrPing, $nLimPing, $nChkPing, $nInpTime, $nLVPing, $nLVTrace
Dim $nLblTime, $nLblCount, $nBtnTrace, $nChkTrace, $nLblTrace, $nInpTrace, $nChkReverse, $hCbEditPing
Dim $nComboDrv, $nLVDrives, $nBtnDrvAdd, $nBtnDrvDel, $nLblDrvCon, $nLblDrvPath, $nComboDrvPath, $hCbEditDrvPath
Dim $nLblDrvLetter, $nBtnDrvNet, $nBtnDrvNetShow, $nBtnDrvNetAdd, $nBtnDrvNetDel, $nTVDrvNet, $hTVDrvNet
Dim $nLblDrvNet, $nInpDrvNet, $nLblDrvNetLine, $nBtnDrvNetReset, $nEditDrvDesc
Dim $nLblDrvUsr, $nInpDrvUsr, $nLblDrvPW, $nInpDrvPW, $nBtnDrvRef
Dim $nConMenuDrv, $nMIBrowseDrv, $nMIDelDrv, $nConMenuNetDrv, $nMIBrowseNetDrv, $bContext = FALSE
Dim $nConMenuShr, $nMIBrowseShr, $nMIDelShr
Dim $nLblProfFile, $nInpProfFile, $nBtnProfFile, $nBtnProfRef, $nLblProfList, $nBtnProfApply
Dim $nListProf, $nLblProfDesc, $nEditProfDesc, $nBtnProfExt, $nBtnProfClean, $nBtnProfNew
Dim $nLblTrayOpt, $nChkStartTray, $nChkMinTray, $nChkEndTray, $nChkShowAct, $nLblLang, $nBtnProfInt
Dim $nTIShoGUI, $nTIShoAct, $nTIExit, $nLblSurface, $nChkShowTip, $nChkShowOnlyCon
Dim $nChkTrayLimitInfo, $nChkTrayAdaptWiFi, $nChkTrayShowMAC, $nChkTrayShowIPv6, $nChkTrayWiFiHeight, $nLblOtherOpt
Dim $nChkLastPage, $nComboLastPage, $hComboLastPage, $nLblLastPage, $nChkUseWMI
Dim $nLblWLNot, $nLblWLNoApi, $nBtnWLRef, $nLVWLAvail, $nBtnWLCon, $nBtnWLDiscon, $nLVWLAvailTray
Dim $nBtnWLRefTray, $nBtnWLConTray
Dim $nLblPreWiFiState, $nLblPreWiFiCurState, $nBtnPreWiFi
Dim	$nLVWLPref, $nBtnWLRefPref, $nBtnWLAdd, $nBtnWLDel, $nBtnWLEdit, $nChkWLEditUI
Dim $nBtnWLImport, $nBtnWLExport, $nBtnWLUp, $nBtnWLDown
Dim $nBtnAuthOK, $nBtnAuthCancel, $nBtnConnOK, $nBtnConnCancel
Dim $nLblProfile, $nInpProfile, $nLblSSID, $nInpSSID, $nLblAuth, $nComboAuth, $nLblEnc, $nComboEnc, $nLblKey
Dim $nInpKey, $nChkKey, $nChkAuto, $nChkHidden, $nChkAdhoc
Dim $nLblConnKey, $nInpConnKey, $nChkConnKey, $nChkConnAuto, $nLblConnSSID, $nInpConnSSID
Dim $nLblExtProp, $nLblProp, $nLblPropVal
Dim $nListExtProp, $nComboExtVal, $nInpExtVal, $nInpExtNumVal, $nUDInpExtVal
Dim $nRadioExtSet, $nRadioExtNotSet
Dim $nComboLang, $nBtnLangExt
Dim $nLblCMDActions, $nChkCMDIPChg, $nLblCMDIPChg, $nComboCMDIPChg, $hCbEditCMDIPChg
Dim $nLblTrouble, $nChkDebug, $nBtnDebug, $nBtnLogDel
Dim $nLblCMDLineMode, $nLblCMDLineNum
Dim $nComboCMD, $nComboRunMode, $nComboRunWait
Dim $nComboRunChgNumber, $nComboRunChgMode, $nComboRunChgWait, $nBtnCmdChgAdd, $nBtnCmdChgDel, $hCbEditRunChgMode
Dim $nLblClr, $nComboScheme, $nChkLastPos, $nRadioOSFont, $nRadioFont, $nInpFont, $nBtnFont, $nChkIcons
Dim $sCurLangFile = "", $sCurLang = "", $sCurLangAuthor, $sCurLangVer
Dim $hILLVShares = 0, $hILLVWLA = 0, $hILBtn = 0, $hILBtn2 = 0, $hILTVDrv = 0, $hILLVWLP = 0, $hILCombo = 0, $hILTrayWiFi = 0, $hILTrayRS = 0
Dim $nCurItem = -1, $nCurCol = -1, $hLVTT = 0, $nCurConItem = -1, $hILLVWLATray = 0
Dim $hLblMac = 0, $hEditProfDesc = 0, $hEditDrvDesc = 0, $hInpPCName = 0, $hInpPCWG = 0, $hInpPCDNS = 0
Dim $hAddrPing = 0, $hLimPing = 0, $hInpProfFile = 0, $hInpTime = 0, $hInpProfile = 0, $hInpSSID = 0, $hInpKey = 0
Dim $hInpCurMAC = 0, $hInpTrace = 0, $hComboShrUsr = 0, $hInpShrPW = 0, $hEditShrAdmin = 0
Dim $hInpConnSSID = 0
Dim $nLVNetConDet, $nBtnSubOK, $nAccDummy1, $nAccDummy2, $nBtnSubCancel
Dim $nLblFWState, $nLblFWCurState, $nBtnFW
Dim $nChkWait, $nChkShowAlways
Dim $nIconWiFiState, $nIconPreWiFiState, $nIconFWState, $nIconIdent, $nIconPing, $nIconShareState
Dim $nIconLang, $nIconScheme, $nIconDebug, $nIconStartTray, $nIconMinTray, $nIconCloseTray
Dim $nIconShowTrayAct, $nIconShowTrayAlways, $nIconTrayTip, $nIconShowOnlyCon
Dim $nIconTrayLimitInfo, $nIconTrayAdaptWiFi, $nIconTrayShowMAC, $nIconTrayShowIPv6
Dim $nIconLastPos, $nIconLastPage, $nIconWMI, $nIconAbout, $nIconAboutAI3
Dim $nConMenuWiFi, $nMIWiFiDel

Dim $nLastItemGUI		= 0
Dim $nLastItemGUIClick	= 0
Dim $nLastItemConf		= 0
Dim $nLastItemWiFi		= 0
Dim $nLastItemEditor	= 0
Dim $nLastItemPrev		= 0
Dim $nCurFocus			= 0
Dim $nCurFocusEditor	= 0
Dim $nLastBtn			= 0
DIm $nLastOD			= 0
Dim $nLastPr			= 0
Dim $nLastLB			= -1
Dim $nTimerDiff			= 0


Dim $sIconLib			= @ScriptDir & "\PENetwork.icl"
Dim $bIconLib			= FALSE
If FileExists($sIconLib) Then $bIconLib = TRUE
Dim $sPENMiniName		= "PENetwork.ini"
Dim $sPENMini			= @ScriptDir & "\" & $sPENMiniName
Dim $sGSection			= "PENetwork"
Dim $sGRegKey			= "HKLM\Software\PENetwork"
Dim $sGURegKey			= "HKCU\Software\PENetwork"
Dim $sLanguageFile		= @ScriptDir & "\PENetwork.lng"
Dim $sDebugFile			= EnvGet("Temp") & "\PENMDebug.txt" ; @TempDir sometimes not working under PE
Dim $sUrlHome			= "https://www.penetworkmanager.de"
Dim $sUrlAI3			= "https://www.autoitscript.com/"
Dim $sPreTitle			= "PE"
Dim $sGlobalFont		= "Microsoft Sans Serif"
Dim $nGlobalFontSize	= 8.5
Dim $hGlobalFont		= 0
Dim $hGlobalBoldFont	= 0
Dim $hGlobalBigFont		= 0
Dim $nGlobalBigFontSize	= 11
Dim $hGlobalBigBoldFont	= 0
Dim $nWiFiBigFont		= 10
Dim $hWiFiBigFont		= 0
Dim $hWiFiBigBoldFont	= 0
Dim $bUseOSFont			= TRUE
Dim $nOldMode			= Opt("ExpandEnvStrings", 1)
Dim $sPEInfDir			= RegRead("HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion", "DevicePath")
$sPEInfDir = String($sPEInfDir)
If $sPEInfDir = "" Or FileExists($sPEInfDir) = FALSE Then $sPEInfDir = @WindowsDir & "\inf"
Opt("ExpandEnvStrings", $nOldMode)
Dim $sProfFile			= $sPENMini
Dim $bUseWiFiExport		= FALSE
If ChkCmdParam("/wifiexporter") Then
	$bUseWiFiExport = TRUE
EndIf
Dim $bUseEditor			= FALSE
If ChkCmdParam("/profileeditor") Then
	$bUseEditor	= TRUE
	$sProfFile	= ""
	
	If RegRead($sGURegKey & "\Editor", "UseOSFont") = 1 Then
		$bUseOSFont = TRUE
	ElseIf @Error = 0 Then
		$bUseOSFont = FALSE
	EndIf
EndIf

Dim $hAddrFont			= 0
Dim $hPrevFont			= 0
Dim $hBrushGUI			= 0
Dim $hBrushWiFiGUI		= 0
Dim $hBrushTrayGUI		= 0

Dim $arNAList[20][3] ; Desc, ServiceName (GUID), Desc (unpatched) for WMI -> Network Adapter List ; Max. 20 network adapters
$arNAList[0][0]			= 0
Dim $arNAListSort[20][2] ; NAL-Index, ServiceName
$arNAListSort[0][0]		= 0
Dim $sNAList			= ""
Dim $arWLANList[10] ; GUID -> WLAN Adapter List ; Max. 10 WLAN adapters
$arWLANList[0]			= 0
Dim $arWLAVNList[300][8] ; WLAN Available Network List -> Signal, SSID, Profile, Security, Physical Type, BitType, UnicodeSSID, UnicodeProfile
$arWLAVNList[0][0]		= 0
Dim $arStatic[50]
$arStatic[0]			= 0

Dim $sLastIP			= ""
Dim $sLastIPDef			= ""
Dim $sLastSM			= ""
Dim $sLastSMDef			= ""
Dim $sLastDG			= ""
Dim $sLastDGDef			= ""
Dim $sLastDNS			= ""
Dim $sLastDNSPref		= ""
Dim $sLastWINS			= ""
Dim $sLastWINSPref		= ""
Dim $nLastStateDG		= 0
Dim $nLastStateDNS		= 0
Dim $nLastStateWINS		= 0
Dim $nLastIndex			= -1

Dim $bIsLV				= FALSE
Dim $bMainAddrChg		= FALSE
Dim $bSubAddrChg		= FALSE
Dim $bGlobalAddrChg		= FALSE
Dim $bGlobalCNChg		= FALSE
Dim $sDefData			= ""
Dim $sLastDefData		= ""
Dim $sLastAdapterSel	= ""
Dim $sLastAdapterShow	= ""
Dim $nLastAdapterState	= -1
Dim $nLastAdapterSpeed	= -1
Dim $nLastAdapterMAC	= ""
Dim $nLastAdapterIcon	= -1
Dim $nLastWiFiSrvState	= -1
Dim $sLastWiFiShow		= ""
Dim $sLastWiFiSSID		= ""
Dim $nLastWiFiState		= 0
Dim $nLastWiFiIcon		= 0
Dim $nTimerStart		= 0
Dim $nTimerCount		= 1.5 ; Seconds
Dim $nWaitRestart		= 1000
Dim $bAddBtnIcons		= TRUE
Dim $bIsWinPE			= FALSE
Dim $bIsWinPE20			= FALSE
Dim $bIsVista			= FALSE
Dim $bIsWin8			= FALSE
Dim $bIsWin10			= FALSE
Dim $sDefNetUtil		= "startnet.exe"
Dim $nLastError			= 0
Dim $bLoopPing			= FALSE
Dim $bInputPingCleared	= FALSE
Dim $bShareShowInp		= FALSE
Dim $bHelperRun			= FALSE
Dim $bRegOverride		= TRUE
Dim $bNoNetcards		= FALSE
Dim $bForceServices		= FALSE
Dim $bLimitBlankPW		= FALSE
Dim $bAutoStart			= TRUE
Dim $bFirstCompleted	= FALSE
Dim $bFirstRun			= FALSE
Dim $bForceSearchDevice	= FALSE
Dim $bMinToTray			= FALSE
Dim $bCloseToTray		= FALSE
Dim $bStartToTray		= FALSE
Dim $bInTray			= FALSE
Dim $bShowTrayAct		= FALSE
Dim $bShowTrayTip		= FALSE
Dim $bShowTrayAlways	= FALSE
Dim $bShowMainGUI		= TRUE
Dim $bEnableAutoIP		= TRUE
Dim $nStartMode			= 1
Dim $bUseStartCount		= FALSE
Dim $nStartCount		= 0
Dim $bUseProfiles		= FALSE
Dim $bUseProfileSelect	= TRUE
Dim $sProfile			= ""
Dim $sProfileDefault	= ""
Dim $sProfileSelected	= ""
Dim $bUseProfileCount	= FALSE
Dim $nProfileCount		= 0
Dim $nProfileCountCtrl	= 0
Dim $sProfileCountText	= ""
Dim $sProfPath			= ""
Dim $bWLAPIOK			= FALSE
Dim $bIniOK				= FALSE
Dim $bStartSharing		= FALSE
Dim $bShareAllDrives	= FALSE
Dim $bTCPInst			= FALSE
Dim $bTopMost			= FALSE
Dim $bTabSmall			= FALSE
Dim $bStartTabSmall		= FALSE
Dim $bPaint				= TRUE
Dim $bUseWMI			= FALSE
Dim $bEditAuth			= FALSE
Dim $oWMISrv			= ObjGet("winmgmts:\\" & @ComputerName & "\root\cimv2")
Dim $bDrvShowInp		= FALSE
Dim $bOpenPage			= FALSE
Dim $bOpenLastPage		= TRUE
Dim $bSaveWinPos		= TRUE
Dim $bFocusNo			= FALSE
Dim $bUseIniIcons		= FALSE
Dim $bPrevStarted		= FALSE
Dim $bSortList			= TRUE
Dim $bUseConName		= FALSE
Dim $bShowTrayOnlyCon	= FALSE
Dim $bShellLoaded		= FALSE
Dim $bReloadAfterWait	= FALSE
Dim $bShowAltConfig		= FALSE
Dim $bWaitConnect		= FALSE
Dim $nWaitConnectTime	= 120
Dim $bComboNADrop		= FALSE
Dim $bComboNATrayDrop	= FALSE
Dim $bTrayLimitInfo		= FALSE
Dim $bTrayAdaptWiFi		= FALSE
Dim $bTrayShowMAC		= FALSE
Dim $bTrayShowIPv6		= FALSE
Dim $nTrayInfoHeight	= 0
Dim $nTrayWiFiHeight	= 0
	
Dim $sCurKey[2]
$sCurKey[0] = ""
$sCurKey[1] = ""
Dim $arCurConn[5]
$arCurConn[0] = ""
$arCurConn[1] = ""
$arCurConn[2] = ""
$arCurConn[3] = ""
$arCurConn[4] = ""

Dim $arConState[8]
Dim $arOctets[50][4]
$arOctets[0][0]			= 0

Dim $nTimerID			= 3
Dim $nTimerTimeOut		= 500;1200
Dim $nInstTime			= 5
Dim $nInstTimeCount

Dim $hTrayMsgWnd		= 0
Dim $nTrayNotifyID		= 0
Dim $TRAYMSGID			= $WM_USER + 1
Dim $bTrayIconCreated	= FALSE
Dim $hTrayIcon			= 0
Dim $hTrayIconData		= 0
Dim $hTrayIconNoData	= 0
Dim $hTrayIconSendData	= 0
Dim $hTrayIconRecData	= 0
Dim $hTrayIconNoConnect	= 0

Dim $hTrayIconWiFiAvail	= 0
Dim $hTrayIconWiFiNull	= 0
Dim $hTrayIconWiFiSR1	= 0 ; Send & receive
Dim $hTrayIconWiFiSR2	= 0
Dim $hTrayIconWiFiSR3	= 0
Dim $hTrayIconWiFiSR4	= 0
Dim $hTrayIconWiFiSR5	= 0
Dim $hTrayIconWiFiS1	= 0 ; Send
Dim $hTrayIconWiFiS2	= 0
Dim $hTrayIconWiFiS3	= 0
Dim $hTrayIconWiFiS4	= 0
Dim $hTrayIconWiFiS5	= 0
Dim $hTrayIconWiFiR1	= 0 ; Receive
Dim $hTrayIconWiFiR2	= 0
Dim $hTrayIconWiFiR3	= 0
Dim $hTrayIconWiFiR4	= 0
Dim $hTrayIconWiFiR5	= 0
Dim $hTrayIconWiFiND1	= 0 ; No data
Dim $hTrayIconWiFiND2	= 0
Dim $hTrayIconWiFiND3	= 0
Dim $hTrayIconWiFiND4	= 0
Dim $hTrayIconWiFiND5	= 0

Dim $nTrayTimerIDInit	= 10
Dim $nTrayTimerID		= 11
Dim $nTrayTimerTimeOut	= 100
Dim $nTrayTimerIDEnum	= 12
Dim $nTrayTimerTimeOutEnum = 500
Dim $bTrayTrackMouse	= TRUE
Dim $bTrayWndCreating	= FALSE
Dim $bTrayWndWiFi		= FALSE
Dim $bTrayWndConnect	= FALSE
Dim $bTrayTimerStop		= FALSE
Dim	$bTraySBVisible		= FALSE
Dim $nTrayMenu			= 0
Dim $hTrayMenu			= 0
Dim $stTrayPnt			= DllStructCreate("long;long")
Dim $nTaskbarCreatedMsg	= 0
Dim $nLastTrayState		= 0
Dim $nTrayWinHeight		= 0
Dim $nTrayCurScrollPos	= 0
Dim $arScrollInfo[3][2] ; Scroll for OtherGUI, TrayInfo and GlobalSettings in editor: CurPos, MaxPos

Dim $nSvcST				= 750 ; Service Sleep Time
Dim $sCCS				= "HKLM\SYSTEM\CurrentControlSet"
Dim $sMACChkPattern		= "([[:xdigit:]][[:xdigit:]]-){5}[[:xdigit:]][[:xdigit:]]"

; CtrlID/Text/IsIcon/TextColor/BkColor/IconIdx/State/Mode/GridColor/Handle
Dim $ODBUTTONS[1][10]
$ODBUTTONS[0][0] = 0

Dim $arODBtnMain[160]
$arODBtnMain[0] = 0
Dim $arODBtnSub[30]
$arODBtnSub[0] = 0
Dim $arODBtnAddr[10]
$arODBtnAddr[0] = 0
Dim $arODBtnTray[5]
$arODBtnTray[0] = 0
Dim $arODBtnConn[3]
$arODBtnConn[0] = 0

Dim $nClrStateGreen, $nClrStateRed, $nClrSvcStart, $nClrSvcStop
Dim $nClrBtnChkTxt, $nClrBtnChkBk, $nClrBtnChkGrad, $nClrBtnUnchkTxt, $nClrBtnUnchkBk, $nClrBtnUnchkGrad
Dim $nClrBtnDhcpTxt, $nClrBtnDhcpBk, $nClrBtnDhcpGrad, $nClrBtnTxtDisabled, $nClrBtnBkActive, $nClrBtnFocus
Dim $nClrBtnNormalTxt, $nClrBtnNormalBk, $nClrBtnNormalGrad, $nClrBtnFrame, $nClrWiFiConnect, $nClrBtnFrameDisabled
Dim $nClrTITxt, $nClrTIBk, $nClrTIGrad, $nClrTISelTxt, $nClrTISelBk, $nClrTISelGrad, $nClrTIFocus
Dim $nClrTIConfTxt, $nClrTIConfBk, $nClrTIConfGrad, $nClrTIConfSelTxt, $nClrTIConfSelBk, $nClrTIConfSelGrad
Dim $nClrTIWiFiTxt, $nClrTIWiFiBk, $nClrTIWiFiGrad, $nClrTIWiFiSelTxt, $nClrTIWiFiSelBk, $nClrTIWiFiSelGrad
Dim $nClrGUIBkMain, $nClrGUIBk, $nClrGUIBkSub, $nClrGUIBkConf, $nClrGUIBkWiFi, $nClrGUIBkAuth
Dim $nClrLblNormal, $nClrLblConf, $nClrLblWiFi, $nClrLVWiFiBk, $nClrLVWiFiTxt
Dim $nClrLVSharesBk, $nClrLVSharesTxt, $nClrLVDrivesBk, $nClrLVDrivesTxt
Dim $nClrLVPingBk, $nClrLVPingTxt, $nClrLProfileBk, $nClrLProfileTxt, $nClrLExtTxt, $nClrLExtBk
Dim $nClrGUIBkFrame, $nClrGUIBkConfFrame, $nClrGUIBkWiFiFrame
Dim $nClrTrayBk, $nClrTrayTxt, $nClrTrayTrans, $nClrTraySelBk, $nClrTraySelTxt, $nClrTrayConnect, $nClrTrayTxtGray
Dim $nClrTrayBtnTxt, $nClrTrayBtnBk, $nClrTrayBtnGrad, $nClrTrayBtnFrame, $nClrTrayBtnFocus

Dim $sSpeedKeyStr		= "connectiontype|" & _
							"conntype|" & _
							"duplexmode|" & _
							"duplexspeed|" & _
							"forcespeeddpx|" & _
							"forcespeedduplex|" & _
							"lineconfig|" & _
							"linespeed|" & _
							"linkselection|" & _
							"linkspeed|" & _
							"media|" & _
							"mediamode|" & _
							"mediaspeed|" & _
							"mediatype|" & _
							"media_type|" & _
							"networkmedia|" & _
							"requestedmediatype|" & _
							"speed|" & _
							"speedandduplex|" & _
							"speedduplex|" & _
							"*speedduplex"

Dim $arSpeedItems[1][3] ; ID/Desc/ValName
$arSpeedItems[0][0] = 0

Dim $sWiFiProfName	= "WiFiProfNameDummy"
Dim $sWiFiSSID		= "WiFiSSIDDummy"
Dim $sWiFiNonBcast	= "WiFiNoneBcastDummy"
Dim $sWiFiConnType	= "WiFiConnTypeDummy"
Dim $sWiFiConnMode	= "WiFiConnModeDummy"
Dim $sWiFiAuthType	= "WiFiAuthTypeDummy"
Dim $sWiFiEncType	= "WiFiEncTypeDummy"
Dim $sWiFiKey		= "WiFiKeyDummy"
Dim $sWiFiKeyType	= "WiFiKeyTypeDummy"
Dim $sWiFiKeyProt	= "WiFiKeyProtDummy"
Dim $sWiFiKeyIdx	= "WiFiKeyIdxDummy"
Dim $sWiFiOnexCfg	= "WiFiOnexCfgDummy"

Dim $sWiFiScheme		=	"<?xml version=""1.0""?>" & _
							"<WLANProfile xmlns=""http://www.microsoft.com/networking/WLAN/profile/v1"">" & _
								"<name>" & $sWiFiProfName & "</name>" & _ ; Adhoc: sWiFiSSID + "-adhoc"
								"<SSIDConfig>" & _
									"<SSID>" & _
										"<name>" & $sWiFiSSID & "</name>" & _
									"</SSID>" & _
									"<nonBroadcast>" & $sWiFiNonBcast & "</nonBroadcast>" & _ 
								"</SSIDConfig>" & _
								"<connectionType>" & $sWiFiConnType & "</connectionType>" & _
								"<connectionMode>" & $sWiFiConnMode & "</connectionMode>" & _ ; Adhoc=manual, WEP. networkKey
								"<MSM>" & _
									"<security>" & _
										"<authEncryption>" & _
											"<authentication>" & $sWiFiAuthType & "</authentication>" & _
											"<encryption>" & $sWiFiEncType & "</encryption>" & _
											"<useOneX>" & $sWiFiOnexCfg & "</useOneX>" & _ ; Infrastr=false, Adhoc=true
										"</authEncryption>"
										

Dim $sWiFiSchemeKey		=			"<sharedKey>" & _
											"<keyType>" & $sWiFiKeyType & "</keyType>" & _ ; WEP: networkKey
											"<protected>" & $sWiFiKeyProt & "</protected>" & _
											"<keyMaterial>" & $sWiFiKey & "</keyMaterial>" & _
										"</sharedKey>"
										
Dim $sWiFiSchemeEnd		=			"</security>" & _
								"</MSM>" & _
							"</WLANProfile>"
						
Dim $sWiFiNoneScheme	= $sWiFiScheme & $sWiFiSchemeEnd 	
Dim $sWiFiWPAScheme		= $sWiFiScheme & $sWiFiSchemeKey & $sWiFiSchemeEnd
Dim $sWiFiAdhocScheme	= $sWiFiScheme & $sWiFiSchemeKey & "<keyIndex>" & $sWiFiKeyIdx & "</keyIndex>" & $sWiFiSchemeEnd
	#cs
	$sWiFiScheme & "<keyIndex>" & $sWiFiKeyIdx & "</keyIndex>" & _
										"<OneX xmlns=""http://www.microsoft.com/networking/OneX/v1"">" & _
											"<authMode>machineOrUser</authMode>" & _
											"<EAPConfig>" & _
												"<EapHostConfig xmlns=""http://www.microsoft.com/provisioning/EapHostConfig"">" & _
													"<EapMethod>" & _
														"<Type xmlns=""http://www.microsoft.com/provisioning/EapCommon"">13</Type>" & _
														"<VendorId xmlns=""http://www.microsoft.com/provisioning/EapCommon"">0</VendorId>" & _
														"<VendorType xmlns=""http://www.microsoft.com/provisioning/EapCommon"">0</VendorType>" & _
														"<AuthorId xmlns=""http://www.microsoft.com/provisioning/EapCommon"">0</AuthorId>" & _
													"</EapMethod>" & _
													"<ConfigBlob>00000000280000000500000000000000000000000000000000000000000000000000000000000000</ConfigBlob>" & _
												"</EapHostConfig>" & _
											"</EAPConfig>" & _
										"</OneX>" & $sWiFiSchemeEnd

#ce
Dim $arAuthType[9][3]
$arAuthType[0][0] = "open"
$arAuthType[0][1] = 3
$arAuthType[0][2] = "Open-WEP"
$arAuthType[1][0] = "shared"
$arAuthType[1][1] = 3
$arAuthType[1][2] = "Shared-WEP"
$arAuthType[2][0] = "WPA"
$arAuthType[2][1] = 12
$arAuthType[2][2] = "WPA"
$arAuthType[3][0] = "WPAPSK"
$arAuthType[3][1] = 12
$arAuthType[3][2] = "WPA-PSK"
$arAuthType[4][0] = "" ; WPA-None, Not supported
$arAuthType[4][1] = 0
$arAuthType[4][2] = "WPA-None"
$arAuthType[5][0] = "WPA2"
$arAuthType[5][1] = 12
$arAuthType[5][2] = "WPA2"
$arAuthType[6][0] = "WPA2PSK"
$arAuthType[6][1] = 12
$arAuthType[6][2] = "WPA2-PSK"
$arAuthType[7][0] = "WPA3"
$arAuthType[7][1] = 56 ; Change needed 2019
$arAuthType[7][2] = "WPA3"
$arAuthType[8][0] = "WPA3SAE"
$arAuthType[8][1] = 8 ; Change needed 2019
$arAuthType[8][2] = "WPA3-SAE"

Dim $arEncType[6][2]
$arEncType[0][0] = "none"
$arEncType[0][1] = 1
$arEncType[1][0] = "WEP"
$arEncType[1][1] = 2
$arEncType[2][0] = "TKIP"
$arEncType[2][1] = 4
$arEncType[3][0] = "AES"
$arEncType[3][1] = 8
$arEncType[4][0] = "BIP"
$arEncType[4][1] = 16
$arEncType[5][0] = "GCMP"
$arEncType[5][1] = 32

Dim $arDot11Enc[7]
$arDot11Enc[0]			= "none"
$arDot11Enc[1]			= "WEP"
$arDot11Enc[2]			= "TKIP"
$arDot11Enc[3]			= "AES"
$arDot11Enc[4]			= "Enterprise"
$arDot11Enc[5]			= "BIP"
$arDot11Enc[6]			= "GCMP"

Dim $bKeyEnabled = 16

Dim $arExtVal[100][5] ; Key/Val/NewVal/Type/Desc
$arExtVal[0][0] = 0

Dim $arSrvState[8]
$arSrvState[0]			= "Unknown"
$arSrvState[1]			= "Stopped"
$arSrvState[2]			= "Starting"
$arSrvState[3]			= "Stopping"
$arSrvState[4]			= "Running"
$arSrvState[5]			= "Continue pending"
$arSrvState[6]			= "Pause pending"
$arSrvState[7]			= "Paused"	

Dim $nLVShrLast			= -1
Dim $nLVDrvLast			= -1
Dim $nLProfLast			= -1
Dim $nLVWALast			= -1
Dim $nLVWLast			= -1
Dim $nLVWALastTray		= -1
Dim $nWiFiCard			= 0
Dim $nValPagelast		= 0

Dim $sHiddenInput		= "<-|**|->"
Dim $sOSVersion			= "WIN_XP"
Dim $bOSCanEncKey		= FALSE

Dim $nClrChkWrong		= 0xD80000
Dim $nGUIDisable		= 0 ; All tabs are shown
; 1 - Computer, 2 - Sharing, 4 - Drives, 8 - Profiles, 16 - Other, 32 - WiFi, 64 - Advanced
; 128 - WiFi prefered, 256 - WiFi service, 512 - Size button
; Sample: 16 + 32 -> Hide Other (16) and WiFi (32)
; "Config"/"IP-Settings" and "About" tabs are always shown
; If "WiFi" tab is enabled then "Available networks" tab is always shown

Dim $arMousePos[2]
$arMousePos[0] = -1
$arMousePos[1] = -1

Dim $nScrollLines = 0

;**********************************************************************
; Predefined string variables
;**********************************************************************
Dim $sMainTitle, $sBtnAdd, $sBtnAddShort, $sBtnDelete, $sBtnApply, $sBtnCancel
Dim $sStateReady, $sBtnChange, $sBtnOK, $sBtnYes, $sBtnNo, $sBtnRestore
Dim $sTIConfig, $sTIIdent, $sTISharing, $sTIDrives, $sTIProfiles, $sTIOther, $sTIAbout
Dim $sTTRefresh, $sLblAdapterState, $sLblAdapterSpeed, $sAdapterSpeed
Dim $sLblAdapterMAC, $sLblCurMac, $sLblNewMac, $sTChangeMAC, $sMsgMACChangeErr, $sMsgMACApply, $sMsgMACRestore
Dim $sChkForceScan, $sBtnIPDHCP, $sBtnDHCPInfo, $sBtnDHCPRelease, $sBtnDHCPRenew, $sBtnIPAutoOn, $sBtnIPAutoOff, $sTDHCPInfo
Dim $sLblDHCPAdapter, $sLblDHCPDNSSrv, $sLblDHCPWINSSrv, $sLblDHCPSrv, $sLblDHCPLTO, $sLblDHCPLTE
Dim $sBtnIPStatic, $sLblStaticIP, $sLblStaticSM, $sLblStaticDG, $sBtnStatic, $sBtnDynamic, $sUserConf
Dim $sBtnDNSDHCP, $sBtnDNSStatic, $sLblDNS, $sBtnWINSDHCP, $sBtnWINSStatic, $sLblWINS
Dim $sLblComputer, $sLblWorkgroup, $sLblPriDNS, $sTTAltIP, $sTTAltConf, $sTTGenConf
Dim $sTAddIP, $sTAddDG, $sTAddDNS, $sTAddWINS, $sTAddIPAddr, $sTAddDGAddr, $sTAddDNSAddr, $sTAddWINSAddr
Dim $sTTShareRefresh, $sTTDrivesRefresh, $sTTWiFiRefresh, $sTTWiFiRefPref
Dim $sChkShowActivity, $sTrayShowGUI, $sTrayShowAni, $sTrayExit, $sChkShowTip, $sChkLastPage, $sLblLastPage
Dim $sChkUseWMI, $sChkShowOnlyCon, $sChkShowAlways, $sChkTrayLimitInfo, $sChkTrayAdaptWiFi, $sChkTrayShowMAC, $sChkTrayShowIPv6
Dim $sMsgDllNotFound, $sMsgWait, $sMsgChangesApply, $sMsgReleaseAddr, $sMsgRenewAddr, $sMsgInitWait
Dim $sTIWiFiAvailable, $sBtnWiFiConnect, $sBtnWiFiDisconnect, $sLVWiFiList, $sLVWiFiPref
Dim $sTIWiFiPreferred, $sTIWiFiService, $sLblWiFiCurState, $sLblWiFiNoDevice, $sLblWiFiWlanApiNF
Dim $sServiceNotInst, $sServiceStop, $sServiceStopped, $sServiceStart, $sServiceStarted
Dim $sTIIPSettings, $sTIWINS, $sTIWiFi, $sLblCNI
Dim $sLblPing, $sBtnPingStart, $sBtnPingStop, $sLblPingCount, $sLblPingTime, $sChkPingLimit
Dim $sLVPing, $sLVIReply, $sLVIReplyTime, $sLVIReplyTimeMS, $sLVITimeOut, $sLVIUnreachable, $sLVIInvalid, $sLVIGeneral
Dim $sLblFileSharing, $sBtnShareStart, $sLblShareUser, $sLblSharePW, $sChkShareAll, $sTTShareAll, $sBtnShareSetPW
Dim $sEditShareAdmin, $sLblSharedFolders, $sLVShares, $sLblShareName, $sTTShareName, $sLblSharePath, $sMIShareBrowse, $sMIShareDel
Dim $sTTShareUser, $sTTShareUserLen, $sTTInputChars, $sTTSharePWLen, $sLblDriveLetter, $sTTDriveLetter, $sTTDriveNoFree1, $sTTDriveNoFree2
Dim $sBtnConnect, $sBtnDisconnect, $sLblDrivePath, $sLblDriveUser, $sLblDrivePW, $sLblDrivesCon, $sLVDrivesCon, $sMIDriveBrowse, $sMIDriveDiscon
Dim $sGrpTrayOptions, $sChkTrayStart, $sChkTrayMin, $sChkTrayClose, $sGrpTrouble, $sChkDebug, $sBtnDebug, $sLblAboutAI3
Dim $sLVIPSM, $sWiFiUnnamed, $sWiFiNone, $sERROR, $sINFO, $sWARNING, $sQUESTION
Dim $sProfSelTitle, $sLblProfSelect, $sLblProfDesc, $sLblProfFile, $sLblProfList, $sTTProfRefresh, $sTTProfIniFiles, $sLblProfApply
Dim $sProfIn, $sProfSec, $sLblSearchDevice, $sDeviceFound, $sDeviceSucces
Dim $sErrorNetShared, $sNetShareOK, $sNetShareOKAs, $sNetShrNotExist, $sNetShrAccDen, $sNetShrInvName, $sNetShrPNE, $sNetShrNameDup
Dim $sErrorNetSharing, $sTTCharsMax, $sTTCharsNoAllow, $sNetStartNet, $sLblStartNet, $sLblStartNetWpe
Dim $sNetRegisterObj, $sNetChkDrv, $sNetDetectDev, $sNetDetectNew, $sNetInstTCP, $sNetApplyProfile, $sNetInstMSClient, $sNetChkServices
Dim $sNetStartTCPIP, $sNetStartDHCP, $sNetStartNLA, $sNetStartLMH, $sNetNoNetcards, $sProgramExit
Dim $sShareSelFolder, $sShareChkDrv, $sShareInstSrv, $sServiceChkSrv, $sShareStartSrv, $sShareStopSrv, $sServiceInstFinish, $sShareSetPW
Dim $sShareStopInfo1, $sShareStopInfo2, $sShareStopInfo3, $sShareStopInfo4, $sShareMsgOpen, $sShareMsgRemove, $sShareMsgSpecial
Dim $sShareMsgDel1, $sShareMsgDel2, $sShareMsgDel3, $sShareMsgDel4, $sShareMsgDel5, $sLblShareRemove
Dim $sNetShrNameNotEx, $sNetErrShareInfo, $sNetShareRemSucc, $sNetShareRemErr
Dim $sLblDriveConnect, $sNetDriveSucc1, $sNetDriveSucc2, $sNetDriveAddErr1, $sNetDriveAddErr2, $sNetDriveAddErr3
Dim $sNetDriveAddErr4, $sNetDriveAddErr5, $sNetDriveAddErr6, $sNetDriveAddErr7, $sNetDriveMsgDel1, $sNetDriveMsgDel2
Dim $sLblDriveDel, $sNetDriveDelErr, $sMsgUtilNotFnd1, $sMsgUtilNotFnd2, $sNetErrRegister, $sNetErrTCPNotFnd, $sNetErrMSCNotFnd
Dim $sNetErrDetDev, $sNetErrTCPInst, $sNetErrMSCInst, $sNetErrTCPStart, $sNetErrDHCPStart, $sNetErrTCPRegStart
Dim $sNetErrStatOnly, $sNetErrNLAStart, $sNetErrLMHStart
Dim $sServiceStopping, $sServiceDesc, $sServiceStarting
Dim $sShareErrInf, $sShareErrInst, $sShareErrInst2, $sShareErrStart, $sShareErrCB, $sShareErrStop, $sShareErrPW
Dim $sShareErrUsr, $sShareErrAdmin, $sShareAddUser, $sGrpLanguage, $sLblLangAuthor, $sLblLangVersion
Dim $sWiFiChkDrv, $sWiFiErrInf, $sWiFiErrInf2, $sWiFiErrInf3, $sWiFiErrInst, $sWiFiErrInst2
Dim $sWiFiRegXML, $sWiFiInstSrv, $sWiFiInstSrv2, $sWiFiInstSrv3, $sWiFiStop, $sWiFiStartSrv, $sWiFiStopSrv, $sWiFiStartSrv2
Dim $sWiFiStopSrv2, $sWiFiErrStart, $sWiFiErrStart2, $sWiFiErrStart3, $sWiFiErrStart4, $sWiFiErrStop, $sWiFiErrStop2
Dim $sCMDActions, $sCMDIPChange, $sCMDIPModeN, $sCMDIPModeH, $sCMDIPModeMin, $sCMDIPModeMax
Dim $sCMDIPModeWait, $sCMDIPModeNowait, $sCMDLine, $sCMDLineMode, $sCMDLIneNumber, $sWiFiConnected, $sLblNoNetcards
Dim $sBtnSearchDevice, $sTWiFiProp, $sLblWiFiProfile, $sLblWiFiSSID, $sLblWiFiAuth, $sLblWiFiEnc, $sLblWiFiKey, $sChkWiFiKey, $sChkWiFiAuto
Dim $sChkWiFiAdhoc, $sChkWiFiHidden, $sCMDStart, $sTWiFiConn
Dim $sTIAdvanced, $sLblExtProp, $sLblExtNoProp, $sLblProp, $sLblPropVal, $sRadioNotSet, $sTTCon, $sTTDiscon, $sLblWiFiCon
Dim $sWiFiBalConTo, $sWiFiBalNetSec, $sWiFiBalNetNonSec, $sWiFiBalNetPref, $sWiFiBalNetInfra
Dim $sWiFiBalNetAdhoc, $sWiFiDelProf, $sWiFiDelTxt, $sWiFiDelWarn
Dim $sBtnWiFiImport, $sTTWiFiImport, $sTTWiFiXMLFiles, $sWiFiImportOK, $sWiFiErrImport
Dim $sBtnWiFiExport, $sTTWiFiExport, $sWiFiExportOK, $sWiFiErrExport, $sWiFiErrAddProf
Dim $sCurScheme, $sAllSchemes, $sLblClr, $sLblDefault, $sLblClassic
Dim $sLblCurrent, $sBtnDrvNet, $sBtnDrvNetShow, $sLblDrvNet, $sTTNetConDetails, $sLVNetConPropVal, $sLblNetResSearch
Dim $sBtnDrvNetReset, $sBtnLogDel, $sLblTCPtoIP, $sLblIPtoTCP, $sChkWiFiEditUI, $sMsgLogDel
Dim $sBtnProfFile, $sBtnProfInt, $sBtnProfExt, $sTTDriveLetterNo, $sNetworkAccess
Dim $sBtnTrace, $sChkTrace, $sLblTrace, $sChkReverse, $sStateTrace, $sLblSurface, $sBtnLangExt
Dim $sGrpOtherOptions, $sLblLastOpened, $sChkLastPos, $sRadioFont, $sRadioOSFont, $sChkIcons
Dim $sTIFirewall, $sFWStartSrv, $sFWStopSrv, $sFWErrStart, $sFWErrStop
Dim $sWiFiBalSignal, $sWiFiBalSec, $sWiFiBalRadio
Dim $sWiFiSecured, $sWiFiOpen, $sWiFiConnecting, $sWiFiUnknown
Dim $sLblNetbiosEnabled, $sLblYes, $sLblNo


;**********************************************************************
; Main
;**********************************************************************
Dim $stNetGUID = DllStructCreate($sGUID)
CreateGUIDFromString($stNetGUID, "{4D36E972-E325-11CE-BFC1-08002BE10318}") ; Network adapters class GUID

If RegRead($sGURegKey, "Debug") = 1 Or _
	RegRead($sGRegKey, "Debug") = 1 Or _
	ChkCmdParam("/debug") Then $bDebug = TRUE

RegRead($sGURegKey, "Debug")
If @Error <> 0 Then ; Not set by user
	If IniRead($sPENMini, $sGSection, "Debug", "No") = "Yes" Then
		$bDebug = TRUE
	EndIf
EndIf
	
SetDefaultLang()

GetSchemeDefault()
$sCurScheme		= $sLblDefault
$sAllSchemes	= $sLblDefault

Debug("----------------------------------------------------------------")
Debug("IN: PENM version: " & $sVersion)
Debug("IN: Check for CMDline parameters...")

Dim $i, $n, $sFile, $arSections
For $i = 1 To $CmdLine[0]
	If StringInStr($CmdLine[$i], "/ini=") Then
		$sFile = StringTrimLeft($CmdLine[$i], 5)
		Debug("IN: Correct CMDline parameter found with value: " & $CmdLine[$i])
		If FileExists($sFile) Then
			$arSections = IniReadSectionNames($sFile)
			If @Error = 0 Then
				For $n = 1 To $arSections[0]
					If $arSections[$n] = "PENetwork" Then
						$sPENMini = $sFile
						$sProfFile = $sFile
						ExitLoop
					EndIf
				Next
			EndIf
		EndIf
	ElseIf StringInStr($CmdLine[$i], "/profile=") Then
		$sProfile = StringTrimLeft($CmdLine[$i], 9)
		Debug("IN: Correct CMDline parameter found with value: " & $CmdLine[$i])
	EndIf
Next

If FileExists($sPENMini) Then
	If IniRead($sPENMini, $sGSection, "UseIniIcons", "No") = "Yes" Then $bUseIniIcons = TRUE
	$nGUIDisable = Number(IniRead($sPENMini, $sGSection, "GUIDisable", "0"))
	If Not $bUseEditor Then
		If IniRead($sPENMini, $sGSection, "UseOSFont", "Yes") = "No" Then
			$bUseOSFont = FALSE
			$sGlobalFont = IniRead($sPENMini, $sGSection, "GlobalFont", $sGlobalFont)
		EndIf
	EndIf

	If IniRead($sPENMini, $sGSection, "TrayLimitInfo", "No") = "Yes" Then $bTrayLimitInfo = TRUE
	If IniRead($sPENMini, $sGSection, "TrayAdaptWiFi", "No") = "Yes" Then $bTrayAdaptWiFi = TRUE
	If IniRead($sPENMini, $sGSection, "TrayShowMAC", "No") = "Yes" Then $bTrayShowMAC = TRUE
	If IniRead($sPENMini, $sGSection, "TrayShowIPv6", "No") = "Yes" Then $bTrayShowIPv6 = TRUE
	$nTrayInfoHeight = Int(IniRead($sPENMini, $sGSection, "TrayInfoHeight", "0"))
	$nTrayWiFiHeight = Int(IniRead($sPENMini, $sGSection, "TrayWiFiHeight", "0"))
EndIf

If Not $bUseEditor Then
	Dim $nTmpVal = RegRead($sGURegKey, "UseOSFont")
	If @Error <> 0 Or (@Error = 0 And $nTmpVal = 1) Then
		$bUseOSFont = TRUE
	Else
		$bUseOSFont = FALSE
		$sGlobalFont = RegRead($sGURegKey, "GlobalFont")
		If $sGlobalFont = "" Then $sGlobalFont = "Microsoft Sans Serif"
	EndIf
EndIf

If RegRead($sGURegKey, "UseIniIcons") = 1 Then
	$bUseIniIcons = TRUE
Else
	$bUseIniIcons = FALSE
EndIf
If $bUseEditor Or $bUseWiFiExport Then $bUseIniIcons = FALSE

;SPI_GETNONCLIENTMETRICS
Dim $sLOGFONTW = "long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;wchar[32]"
Dim $stNCM = DllStructCreate("uint;int;int;int;int;int;" & $sLOGFONTW & ";int;int;" & $sLOGFONTW & ";int;int;" & _
								$sLOGFONTW & ";" & $sLOGFONTW & ";" & $sLOGFONTW)
DllStructSetData($stNCM, 1, DllStructGetSize($stNCM))
If SystemParametersInfoW(0x29, DllStructGetSize($stNCM), DllStructGetPtr($stNCM), 0) Then
	If $bUseOSFont Then $sGlobalFont = DllStructGetData($stNCM, 80)
EndIf
$stNCM = 0

;SPI_GETWHEELSCROLLLINES
Dim $stScrollLines = DllStructCreate("uint")
SystemParametersInfoW(0x68, 0, DllStructGetPtr($stScrollLines), 0)
$nScrollLines = DllStructGetData($stScrollLines, 1)
$stScrollLines = 0

CreateGlobalFont(0, $nGlobalFontSize, 400, 0, $sGlobalFont, $hGlobalFont)
CreateGlobalFont(0, $nGlobalFontSize, 600, 0, $sGlobalFont, $hGlobalBoldFont)
CreateGlobalFont(0, $nGlobalBigFontSize, 400, 0, $sGlobalFont, $hGlobalBigFont)
CreateGlobalFont(0, $nGlobalBigFontSize, 600, 0, $sGlobalFont, $hGlobalBigBoldFont)

CreateGlobalFont(0, $nWiFiBigFont, 400, 0, $sGlobalFont, $hWiFiBigFont)
CreateGlobalFont(0, $nWiFiBigFont, 600, 0, $sGlobalFont, $hWiFiBigBoldFont)

CheckSchemes()

CreateODBtnIL() ; Normal buttons
CreateODBtnIL2() ; Tab items

CheckPE()
ChkWlanAPI()

GUIRegisterMsg($WM_DRAWITEM, "WndProc")

Dim $sExportPath = ""

; WiFi profile exporter
If $bUseWiFiExport Then
	If Not $bWLAPIOK Then
		;MsgBox(....
		Exit
	EndIf
	
	If $CmdLine[0] >= 2 And FileExists($CmdLine[2]) Then $sExportPath = $CmdLine[2]
	
	CreateWiFiExporter($sExportPath)
	
	Exit
EndIf

; Profile Editor (CreateProfileEditor)
If $bUseEditor Then
	Dim $nSubType
	Dim $nEditDesc, $nInpNetPath
	Dim $nInpIP, $nInpSM, $nInpDG, $nInpDNS, $nInpWINS, $nInpMAC, $nInpFilter
	Dim $nBtnAdd, $nBtnDel, $nBtnSave, $nBtnLoad, $nBtnRename, $nBtnCopy, $nBtnExit
	Dim $nBtnAddAdapter, $nBtnDelAdapter
	Dim $nDmyAdd, $nDmyAddCon, $nAddNA1, $nAddNA2, $nAddNA3, $nAddNA4, $nAddNA5, $nAddNA6
	Dim $nComboDefProf, $nChkCount, $nInpCount, $sComboProf, $nChkProf, $nChkProfUse
	Dim $nChkStartPrompt, $nChkFocusNo, $nChkStartCount, $nInpStartCount, $nComboStartMode
	Dim $sCurProfile, $sCurAdapter
	Dim $nLVCMDStart, $nInpCMDStart, $nComboStartRun, $nComboStartWait, $nBtnCMDStartClear
	Dim $nBtnCmdStartAdd, $nBtnCmdStartDel, $nBtnCMDStartEdit, $nBtnCMDStartUp, $nBtnCMDStartDown
	Dim $nLVCMDChange, $nInpCMDChange, $nComboChangeRun, $nComboChangeWait, $nBtnCMDChangeClear
	Dim $nBtnCmdChangeAdd, $nBtnCmdChangeDel, $nBtnCmdChangeChg, $nBtnCmdChangeUp, $nBtnCmdChangeDown
	Dim $nChkShrAuto, $nBtnAddUser, $nBtnDelUser
	Dim $nLblIPBk, $nComboElement, $nLblBkMain1, $nLblBkMain2, $nLblConfBk1
	Dim $nFrmBkMain1, $nFrmBkMain2, $nFrmBkMain3, $nFrmBkMain4, $nFrmBkMain5, $nFrmBkMain6
	Dim $nFrmBkConf1, $nFrmBkConf2, $nFrmBkConf3, $nFrmBkConf4
	Dim $nLblConf, $nBtnSchemeApply, $nBtnSchemeOK, $nBtnSchemeClose, $nBtnSchemeRef, $nLblStateMain, $nBtnSchemeRefClr
	Dim $nBtnSchemeTxt, $nBtnSchemeBk1, $nBtnSchemeBk2, $nBtnSchemeDef, $nLblDefault, $nLblSrvStart, $nLblSrvStop
	Dim $nBtnSchemeRen, $nBtnSchemeSave, $nBtnSchemeDel, $nChkShrPW, $nChkDrvPW, $nLblSchemeTxt, $nLblSchemeBk1, $nLblSchemeBk2
	Dim $nBtnWiFiAdd, $nBtnWiFiDel, $nBtnWiFiChg, $nBtnWiFiUp, $nBtnWiFiDown, $nBtnWiFiClear
	Dim $nBtnProfManage, $nBtnProfAdd, $nBtnProfDel, $nChkAutoIP, $nChkForceScan, $nRadioShowMain, $nRadioStartToTray, $nRadioCloseMain
	Dim $nInpWait, $nInpLimit, $nInpWiFiHeight
	Dim $nMIProfNew, $nMIProfOpen, $nMIProfOpenExt, $nMILoad, $nMISave, $nMISaveAs, $nMIExit, $nMIHelpFile, $nMIAbout
	Dim $nComboProfiles, $nBtnProfCopy, $nMIPrefs, $nBtnPrevStart, $nLVPrev, $nListProfiles, $nEditInfo, $nIconTray, $nIconInst, $nIconPrev
	Dim $nLblInstTitle, $nLblInst, $nLblInstLine, $nLblPrevTime, $nBtnAboutOK, $nBtnPrefsOK, $nBtnPrefsCancel
	Dim $nChkOpenLastFile, $nChkSaveWinPos, $nLblWiFi, $nLblStateProgress, $nLblBkWiFi, $nFrmBkWiFi1, $nFrmBkWiFi2, $nFrmBkWiFi3, $nFrmBkWiFi4
	Dim $nBtnPENMApply, $nBtnPENMOK, $nBtnPENMCancel, $nChkOpenLastProfile, $nChkUseOSFont
	Dim $nTIPrevConf, $nTIPrevIdent, $nTIPrevSharing, $nTIPrevDrives, $nTIPrevProfiles, $nTIPrevOther, $nTIPrevAbout
	Dim $hPrefsGUI			= 0
	Dim $nInpListCtrlStart	= 0
	Dim $nInpListCtrlChange	= 0
	Dim $nCmbElementLast	= -1
	Dim $nWiFiIdxLast		= -1
	Dim $arShrUsr[50][2] ; Username, Pass
	$arShrUsr[0][0] = 0
	Dim $arNetDrv[30][4] ; Path, Username, Pass, Letter
	$arNetDrv[0][0] = 0
	Dim $arWiFiPref[50][7] ; SSID, Key, Auth, Enc, Auto, Hidden, Adhoc
	$arWiFiPref[0][0] = 0
	Dim $sDrvLetters = "|*||A:|B:|C:|D:|E:|F:|G:|H:|I:|J:|K:|L:|M:|N:|O:|P:|Q:|R:|S:|T:|U:|V:|W:|X:|Y:|Z:"
	Dim $sNewLetters = ""
	Dim $sStartModes = "|0 - Hidden|1 - Center|2 - TopLeft|3 - TopRight|4 - BottomLeft|5 - BottomRight|6 - Depends on systray position"
	Dim $bAdapterAdded		= FALSE
	Dim $bUserChanged		= FALSE
	Dim $bDriveChanged		= FALSE
	Dim $bWiFiChanged		= FALSE
	Dim $bPrevStartup		= FALSE
	Dim $bPrevProfiles		= FALSE
	Dim $bPrevInstStarted	= FALSE
	Dim $bPrevPENMStarted	= FALSE
	Dim $bOpenLastFile		= TRUE
	Dim $bOpenLastProfile	= FALSE
		
	If RegRead($sGURegKey & "\Editor", "OpenLastFile") = 1 Then
		$bOpenLastFile = TRUE
	ElseIf @Error = 0 Then
		$bOpenLastFile = FALSE
	EndIf
	
	If RegRead($sGURegKey & "\Editor", "OpenLastProfile") = 1 Then
		$bOpenLastProfile = TRUE
	ElseIf @Error = 0 Then
		$bOpenLastProfile = FALSE
	EndIf
	
	$bSaveWinPos		= TRUE
	If RegRead($sGURegKey & "\Editor", "SaveWinPos") = 1 Then
		$bSaveWinPos = TRUE
	ElseIf @Error = 0 Then
		$bSaveWinPos = FALSE
	EndIf
	
	#cs
		Possible situations/modes:
		--------------------------
		/profileeditor -> plain or file/profile loading depends on options lastfile/lastprofile
		/profileeditor D:\Projekte\PENetwork -> D:\Projekte\PENetwork\PENetwork.ini if exist and no profile loading
		/profileeditor D:\Projekte\PENetwork\ -> D:\Projekte\PENetwork\PENetwork.ini if exist and no profile loading
		/profileeditor D:\Projekte\PENetwork\Network.ini -> D:\Projekte\PENetwork\Network.ini if exist and no profile loading
		/profileeditor D:\Projekte\PENetwork\Network.ini /profile=Profile1 -> D:\Projekte\PENetwork\Network.ini if exist and load Profile1 if exist
		/profileeditor /ini=D:\Projekte\PENetwork\Network.ini -> D:\Projekte\PENetwork\Network.ini if exist and no profile loading
		/profileeditor /ini=D:\Projekte\PENetwork\Network.ini /profile=Profile1 -> D:\Projekte\PENetwork\Network.ini if exist and load Profile1 if exist
	#ce
	
	If $CmdLine[0] < 2 Then
		If $bOpenLastFile Then $sProfFile = RegRead($sGURegKey & "\Editor", "LastFile")
		If $bOpenLastProfile Then $sProfile = RegRead($sGURegKey & "\Editor", "LastProfile")
	ElseIf FileExists($CmdLine[2]) Then
		$sProfPath = $CmdLine[2]
		If Not StringInStr(FileGetAttrib($sProfPath), "D") Then $sProfFile = $CmdLine[2]
	EndIf

	If $sProfFile <> "" Then
		Dim $stDrive = DllStructCreate("wchar[" & $MAX_PATH & "]")
		Dim $stFolder = DllStructCreate("wchar[" & $MAX_PATH & "]")
		_wsplitpath($sProfFile, DllStructGetPtr($stDrive), DllStructGetPtr($stFolder), 0, 0)
		$sProfPath = DllStructGetData($stDrive, 1) & DllStructGetData($stFolder, 1)
	EndIf
	
	If $sProfPath = "" Then $sProfPath = @ScriptDir
	If StringRight($sProfPath, 1) = "\" Then $sProfPath = StringTrimRight($sProfPath, 1)

	ProfileAddToList($sProfFile, $sProfile)
	
	$bStartSharing		= FALSE
	$bShareAllDrives	= FALSE
	
	Dim $nClrBkSub		= 0xE8E8E6 ;0xECEAE8
	Dim $nClrBtnBk		= 0xFCFAF8
	Dim $nClrBtnGrad	= 0xACAAA8
	
	Dim $arClr[47][6]
	$arClr[0][0]		= "Label state OK"
	$arClr[0][1]		= "ClrStateGreen"
	$arClr[0][2]		= -1
	$arClr[0][3]		= -3 ; Disabled
	$arClr[0][4]		= -3 ; Disabled
	$arClr[0][5]		= FALSE
	$arClr[1][0]		= "Label state progress"
	$arClr[1][1]		= "ClrStateRed"
	$arClr[1][2]		= -1
	$arClr[1][3]		= -3
	$arClr[1][4]		= -3
	$arClr[1][5]		= FALSE
	$arClr[2][0]		= "Label service started"
	$arClr[2][1]		= "ClrSvcStart"
	$arClr[2][2]		= -3
	$arClr[2][3]		= -1
	$arClr[2][4]		= -3
	$arClr[2][5]		= FALSE
	$arClr[3][0]		= "Label service stopped"
	$arClr[3][1]		= "ClrSvcStop"
	$arClr[3][2]		= -3
	$arClr[3][3]		= -1
	$arClr[3][4]		= -3
	$arClr[3][5]		= FALSE
	$arClr[4][0]		= "Button IP DHCP"
	$arClr[4][1]		= "ClrBtnChk"
	$arClr[4][2]		= -1
	$arClr[4][3]		= -1
	$arClr[4][4]		= -1
	$arClr[4][5]		= FALSE
	$arClr[5][0]		= "Button IP static"
	$arClr[5][1]		= "ClrBtnUnchk"
	$arClr[5][2]		= -1
	$arClr[5][3]		= -1
	$arClr[5][4]		= -1
	$arClr[5][5]		= FALSE
	$arClr[6][0]		= "Button DHCP functions"
	$arClr[6][1]		= "ClrBtnDHCP"
	$arClr[6][2]		= -1
	$arClr[6][3]		= -1
	$arClr[6][4]		= -1
	$arClr[6][5]		= FALSE
	$arClr[7][0]		= "Button disabled text"
	$arClr[7][1]		= "ClrBtnTxtDisabled"
	$arClr[7][2]		= -1
	$arClr[7][3]		= -3
	$arClr[7][4]		= -3
	$arClr[7][5]		= FALSE
	$arClr[8][0]		= "Button active rect"
	$arClr[8][1]		= "ClrBtnBkActive"
	$arClr[8][2]		= -1
	$arClr[8][3]		= -3
	$arClr[8][4]		= -3
	$arClr[8][5]		= FALSE
	$arClr[9][0]		= "Button focus rect"
	$arClr[9][1]		= "ClrBtnFocus"
	$arClr[9][2]		= -1
	$arClr[9][3]		= -3
	$arClr[9][4]		= -3
	$arClr[9][5]		= TRUE
	$arClr[10][0]		= "Button defaults"
	$arClr[10][1]		= "ClrBtnNormal"
	$arClr[10][2]		= -1
	$arClr[10][3]		= -1
	$arClr[10][4]		= -1
	$arClr[10][5]		= TRUE
	$arClr[11][0]		= "Button frame"
	$arClr[11][1]		= "ClrBtnFrame"
	$arClr[11][2]		= -1
	$arClr[11][3]		= -3
	$arClr[11][4]		= -3
	$arClr[11][5]		= TRUE
	$arClr[12][0]		= "Listview WiFi connected entry"
	$arClr[12][1]		= "ClrWiFiConnect"
	$arClr[12][2]		= -1
	$arClr[12][3]		= -3
	$arClr[12][4]		= -3
	$arClr[12][5]		= TRUE
	$arClr[13][0]		= "Tabitems left side"
	$arClr[13][1]		= "ClrTI"
	$arClr[13][2]		= -1
	$arClr[13][3]		= -1
	$arClr[13][4]		= -1
	$arClr[13][5]		= TRUE
	$arClr[14][0]		= "Tabitems left side selected"
	$arClr[14][1]		= "ClrTISel"
	$arClr[14][2]		= -1
	$arClr[14][3]		= -1
	$arClr[14][4]		= -1
	$arClr[14][5]		= TRUE
	$arClr[15][0]		= "Tabitems focused"
	$arClr[15][1]		= "ClrTIFocus"
	$arClr[15][2]		= -1
	$arClr[15][3]		= -3
	$arClr[15][4]		= -3
	$arClr[15][5]		= TRUE
	$arClr[16][0]		= "Tabitems property page"
	$arClr[16][1]		= "ClrTIConf"
	$arClr[16][2]		= -1
	$arClr[16][3]		= -1
	$arClr[16][4]		= -1
	$arClr[16][5]		= TRUE
	$arClr[17][0]		= "Tabitems property pg. selected"
	$arClr[17][1]		= "ClrTIConfSel"
	$arClr[17][2]		= -1
	$arClr[17][3]		= -1
	$arClr[17][4]		= -1
	$arClr[17][5]		= TRUE
	$arClr[18][0]		= "Tabitems WiFi"
	$arClr[18][1]		= "ClrTIWiFi"
	$arClr[18][2]		= -1
	$arClr[18][3]		= -1
	$arClr[18][4]		= -1
	$arClr[18][5]		= TRUE
	$arClr[19][0]		= "Tabitems WiFi selected"
	$arClr[19][1]		= "ClrTIWiFiSel"
	$arClr[19][2]		= -1
	$arClr[19][3]		= -1
	$arClr[19][4]		= -1
	$arClr[19][5]		= TRUE
	$arClr[20][0]		= "Background main GUI"
	$arClr[20][1]		= "ClrGUIBkMain"
	$arClr[20][2]		= -3
	$arClr[20][3]		= -1
	$arClr[20][4]		= -3
	$arClr[20][5]		= FALSE
	$arClr[21][0]		= "Background main sub GUI"
	$arClr[21][1]		= "ClrGUIBk"
	$arClr[21][2]		= -3
	$arClr[21][3]		= -1
	$arClr[21][4]		= -3
	$arClr[21][5]		= FALSE
	$arClr[22][0]		= "Background helper GUI"
	$arClr[22][1]		= "ClrGUIBkSub"
	$arClr[22][2]		= -3
	$arClr[22][3]		= -1
	$arClr[22][4]		= -3
	$arClr[22][5]		= FALSE
	$arClr[23][0]		= "Background properties GUI"
	$arClr[23][1]		= "ClrGUIBkConf"
	$arClr[23][2]		= -3
	$arClr[23][3]		= -1
	$arClr[23][4]		= -3
	$arClr[23][5]		= FALSE
	$arClr[24][0]		= "Background WiFi GUI"
	$arClr[24][1]		= "ClrGUIBkWiFi"
	$arClr[24][2]		= -3
	$arClr[24][3]		= -1
	$arClr[24][4]		= -3
	$arClr[24][5]		= FALSE
	$arClr[25][0]		= "Background WiFi auth GUI"
	$arClr[25][1]		= "ClrGUIBkAuth"
	$arClr[25][2]		= -3
	$arClr[25][3]		= -1
	$arClr[25][4]		= -3
	$arClr[25][5]		= FALSE
	$arClr[26][0]		= "Label defaults"
	$arClr[26][1]		= "ClrLblNormal"
	$arClr[26][2]		= -1
	$arClr[26][3]		= -3
	$arClr[26][4]		= -3
	$arClr[26][5]		= FALSE
	$arClr[27][0]		= "Labels properties page"
	$arClr[27][1]		= "ClrLblConf"
	$arClr[27][2]		= -1
	$arClr[27][3]		= -3
	$arClr[27][4]		= -3
	$arClr[27][5]		= FALSE
	$arClr[28][0]		= "Labels WiFi page"
	$arClr[28][1]		= "ClrLblWiFi"
	$arClr[28][2]		= -1
	$arClr[28][3]		= -3
	$arClr[28][4]		= -3
	$arClr[28][5]		= FALSE
	$arClr[29][0]		= "Listview WiFi"
	$arClr[29][1]		= "ClrLVWiFi"
	$arClr[29][2]		= -1
	$arClr[29][3]		= -1
	$arClr[29][4]		= -3
	$arClr[29][5]		= FALSE
	$arClr[30][0]		= "Listview shares"
	$arClr[30][1]		= "ClrLVShares"
	$arClr[30][2]		= -1
	$arClr[30][3]		= -1
	$arClr[30][4]		= -3
	$arClr[30][5]		= FALSE
	$arClr[31][0]		= "Listview network drives"
	$arClr[31][1]		= "ClrLVNetDrv"
	$arClr[31][2]		= -1
	$arClr[31][3]		= -1
	$arClr[31][4]		= -3
	$arClr[31][5]		= FALSE
	$arClr[32][0]		= "Listview ident ping"
	$arClr[32][1]		= "ClrLVPing"
	$arClr[32][2]		= -1
	$arClr[32][3]		= -1
	$arClr[32][4]		= -3
	$arClr[32][5]		= FALSE
	$arClr[33][0]		= "List profiles"
	$arClr[33][1]		= "ClrLProfile"
	$arClr[33][2]		= -1
	$arClr[33][3]		= -1
	$arClr[33][4]		= -3
	$arClr[33][5]		= FALSE
	$arClr[34][0]		= "List advanced properties"
	$arClr[34][1]		= "ClrLExt"
	$arClr[34][2]		= -1
	$arClr[34][3]		= -1
	$arClr[34][4]		= -3
	$arClr[34][5]		= FALSE
	$arClr[35][0]		= "Background main GUI frame"
	$arClr[35][1]		= "ClrGUIBkFrame"
	$arClr[35][2]		= -1
	$arClr[35][3]		= -3
	$arClr[35][4]		= -3
	$arClr[35][5]		= FALSE
	$arClr[36][0]		= "Background properties GUI frame"
	$arClr[36][1]		= "ClrGUIBkConfFrame"
	$arClr[36][2]		= -1
	$arClr[36][3]		= -3
	$arClr[36][4]		= -3
	$arClr[36][5]		= FALSE
	$arClr[37][0]		= "Background WiFi GUI frame"
	$arClr[37][1]		= "ClrGUIBkWiFiFrame"
	$arClr[37][2]		= -1
	$arClr[37][3]		= -3
	$arClr[37][4]		= -3
	$arClr[37][5]		= FALSE
	$arClr[38][0]		= "Button disabled frame"
	$arClr[38][1]		= "ClrBtnFrameDisabled"
	$arClr[38][2]		= -1
	$arClr[38][3]		= -3
	$arClr[38][4]		= -3
	$arClr[38][5]		= TRUE
	$arClr[39][0]		= "Tray info background and text"
	$arClr[39][1]		= "ClrTrayBk"
	$arClr[39][2]		= -1
	$arClr[39][3]		= -1
	$arClr[39][4]		= -3
	$arClr[39][5]		= FALSE
	$arClr[40][0]		= "Tray info transparency"
	$arClr[40][1]		= "ClrTrayTrans"
	$arClr[40][2]		= -4
	$arClr[40][3]		= -4
	$arClr[40][4]		= -4
	$arClr[40][5]		= FALSE
	$arClr[41][0]		= "Tray WiFi listview selected items"
	$arClr[41][1]		= "ClrTraySel"
	$arClr[41][2]		= -1
	$arClr[41][3]		= -1
	$arClr[41][4]		= -3
	$arClr[41][5]		= FALSE
	$arClr[42][0]		= "Tray WiFi listview connected entry"
	$arClr[42][1]		= "ClrTrayConnect"
	$arClr[42][2]		= -1
	$arClr[42][3]		= -3
	$arClr[42][4]		= -3
	$arClr[42][5]		= TRUE
	$arClr[43][0]		= "Tray button focus rect"
	$arClr[43][1]		= "ClrTrayBtnFocus"
	$arClr[43][2]		= -1
	$arClr[43][3]		= -3
	$arClr[43][4]		= -3
	$arClr[43][5]		= TRUE
	$arClr[44][0]		= "Tray button defaults"
	$arClr[44][1]		= "ClrTrayBtn"
	$arClr[44][2]		= -1
	$arClr[44][3]		= -1
	$arClr[44][4]		= -1
	$arClr[44][5]		= TRUE
	$arClr[45][0]		= "Tray button frame"
	$arClr[45][1]		= "ClrTrayBtnFrame"
	$arClr[45][2]		= -1
	$arClr[45][3]		= -3
	$arClr[45][4]		= -3
	$arClr[45][5]		= TRUE
	$arClr[46][0]		= "Tray grayed text"
	$arClr[46][1]		= "ClrTrayTxtGray"
	$arClr[46][2]		= -1
	$arClr[46][3]		= -3
	$arClr[46][4]		= -3
	$arClr[46][5]		= FALSE
	CreateProfileEditor()
	
	$arShrUsr		= 0
	$arNetDrv		= 0
	
	Exit
EndIf

CheckLanguage()
ReadLanguageFile($sCurLangFile, $sGSection)

Debug("IN: OS: " & $sOSVersion)
Debug("IN: SP: " & @OSServicePack)
Debug("IN: OS lang: " & @OSLang)
Debug("IN: OS arch: " & @OSArch)

If $bIsWinPE Then
	; Check for BartPE system
	If Not FileExists(@ScriptDir & "\startnet.exe") And FileExists(@SystemDir & "\bartpe.exe") Then _
		$sDefNetUtil = "bartpe.exe"
	
	If $bIsVista And FileExists(@SystemDir & "\netcfg.exe") Then $sDefNetUtil = "netcfg.exe"			
	
	Debug("IN: Default net utility: " & $sDefNetUtil)
	
	$sVal = RegRead($sGRegKey, "FirstCompleted")
	If $sVal = 1 Then $bFirstCompleted = TRUE	
	If $bFirstCompleted = FALSE Then $bFirstRun = TRUE
		
	Debug("IN: First run: " & $bFirstRun)
EndIf

Debug("IN: Config file: " & $sPENMini)

GUIRegisterMsg($WM_INITMENUPOPUP, "WndProc")
GUIRegisterMsg($WM_MENUSELECT, "WndProc")
GUIRegisterMsg($WM_CONTEXTMENU, "WndProc")
GUIRegisterMsg($WM_VSCROLL, "WndProc")
GUIRegisterMsg($WM_MOUSEWHEEL, "WndProc")
GUIRegisterMsg($WM_SETCURSOR, "WndProc")
GUIRegisterMsg($WM_ACTIVATE, "WndProc")
GUIRegisterMsg($WM_CTLCOLORSTATIC, "WndProc")
GUIRegisterMsg($WM_COMMAND, "WndProc")
GUIRegisterMsg($WM_SYSCOMMAND, "WndProc")

If $sProfile = "" Or $bFirstRun Then CheckInstance()
	
; Registry settings override ini-settings
If $bIsWinPE Then
	If RegRead($sCCS & "\Control\Lsa", "limitblankpassworduse") = 1 Then
		$bLimitBlankPW = TRUE
	Else
		$bLimitBlankPW = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "ForceServices", "")
	If $sResult = "Yes" Then
		$bForceServices = TRUE
	ElseIf $sResult = "No" Then
		$bForceServices = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "Speed", "")
	If $sResult <> "" Then $sSpeedKeyStr &= "|" & $sResult
	
	If RegRead($sGRegKey, "ForceServices") = "1" Then
		$bForceServices = TRUE
	ElseIf @Error = 0 Then
		$bForceServices = FALSE
	EndIf
	
	If ChkCmdParam("/forceservices") Then $bForceServices = TRUE
	If ChkCmdParam("/starttotray") Then RegWrite($sGURegKey, "StartToTray", "REG_DWORD", 1)
	
	RegRead("HKLM\SOFTWARE\Microsoft\Tcpip\CurrentVersion", "")
	If @Error = 0 Or @Error = -1 Then
	; 2nd check TCPIP service state
		If IsServiceRunning("tcpip") And IsServiceRunning("lanmanworkstation") Then $bTCPInst = TRUE
	EndIf
	
	If $bTCPInst Then
		Debug("IN: Network check - TCPIP network support already installed")
	Else
		Debug("IN: Network check - TCPIP network support not installed yet")
	EndIf
	
	If $bFirstRun Then
		If Not $bTCPInst Then
			$nSSIP = Number(RegRead("HKLM\SYSTEM\Setup", "SystemSetupInProgress"))
			If $nSSIP = 0 Then
				Debug("IN: SystemSetupInProgress - value: " & $nSSIP)
				$nResult = RegWrite("HKLM\SYSTEM\Setup", "SystemSetupInProgress", "REG_DWORD", 0x1)
				Debug("IN: SystemSetupInProgress - set to 0x1 - result: " & $nResult)
				Run(@AutoItExe & " /reinitsetup")
				Exit
			Else
				Debug("IN: SystemSetupInProgress - value: " & $nSSIP)
			EndIf
		EndIf
		
		If FileExists($sPENMini) Then GetFirstIni()
		
		GetFirstReg()
		
		If ChkCmdParam("/startprompt") Then $bAutoStart = FALSE
		If ChkCmdParam("/useprofiles") Then $bUseProfiles = TRUE
		If ChkCmdParam("/noprofileselect") Then $bUseProfileSelect = FALSE
		If ChkCmdParam("/startsharing") Then $bStartSharing = TRUE
		If ChkCmdParam("/shareall") Then $bShareAllDrives = TRUE
		If ChkCmdParam("/topmost") Then $bTopMost = TRUE
		If ChkCmdParam("/smalltab") Then $bStartTabSmall = TRUE
		If ChkCmdParam("/focusno") Then $bFocusNo = TRUE
		
		Debug("IN: FirstRun - AutoStart: " & $bAutoStart)
		Debug("IN: FirstRun - TopMostStartup: " & $bTopMost)
		Debug("IN: FirstRun - SmallTabStartup: " & $bStartTabSmall)
		Debug("IN: FirstRun - ForceScanOnStartup: " & $bForceSearchDevice)
		Debug("IN: FirstRun - ShowMain: " & $bShowMainGUI)
		Debug("IN: FirstRun - StartToTray: " & $bStartToTray)
		Debug("IN: FirstRun - MinimizeToTray: " & $bMinToTray)
		Debug("IN: FirstRun - CloseToTray: " & $bCloseToTray)
		Debug("IN: FirstRun - ShowTrayActivity: " & $bShowTrayAct)
		Debug("IN: FirstRun - ShowOnlyCon: " & $bShowTrayOnlyCon)
		Debug("IN: FirstRun - EnableAutoIP: " & $bEnableAutoIP)
		Debug("IN: FirstRun - UseStartCountdown: " & $bUseStartCount)
		Debug("IN: FirstRun - StartCount: " & $nStartCount)
		Debug("IN: FirstRun - FocusNo: " & $bFocusNo)
		Debug("IN: FirstRun - StartSharing: " & $bStartSharing)
		Debug("IN: FirstRun - ShareAll: " & $bShareAllDrives)
		Debug("IN: FirstRun - WaitConnect: " & $bWaitConnect)
		Debug("IN: FirstRun - WaitConnectTime: " & $nWaitConnectTime)
				
		If $bMinToTray Then RegWrite($sGURegKey, "MinimizeToTray", "REG_DWORD", 1)
		If $bCloseToTray Then RegWrite($sGURegKey, "CloseToTray", "REG_DWORD", 1)
		If $bShowTrayAct Then RegWrite($sGURegKey, "ShowTrayActivity", "REG_DWORD", 1)
		;If $bStartToTray Then RegWrite($sGURegKey, "StartToTray", "REG_DWORD", 1)
	Else
		If RegRead($sGRegKey, "ShareAll") = 1 Then $bShareAllDrives = TRUE
		;If ChkCmdParam("/starttotray") Then RegWrite($sGURegKey, "StartToTray", "REG_DWORD", 1)
	EndIf
	
	If $sProfile <> "" Then
		$bUseProfiles = TRUE
		$bUseProfileSelect = FALSE
		$sProfileDefault = $sProfile
	EndIf
	
	If $bFirstRun Then
		Debug("IN: FirstRun - UseProfiles: " & $bUseProfiles)
		Debug("IN: FirstRun - UseProfileSelect: " & $bUseProfileSelect)
		Debug("IN: FirstRun - Profile-Default: " & $sProfileDefault)
		Debug("IN: FirstRun - UseProfileCountdown: " & $bUseProfileCount)
		Debug("IN: FirstRun - ProfileCount: " & $nProfileCount)	
	ElseIf $sProfileDefault <> "" Then
		Debug("IN: Option - Apply profile: " & $sProfileDefault)
		ApplyProfile($sPENMini, $sProfileDefault, TRUE)
		Exit
	EndIf

	$nStartMode = RegRead($sGURegKey, "StartMode") 
	If @Error <> 0 And $nStartMode = 0 Then $nStartMode = 1
	;If ChkCmdParam("/starttotray") Then $nStartMode = 0
	If $bReloadAfterWait Then $nStartMode = 0

	$nCheck = CheckNetwork($bTCPInst)
		
	If ChkCmdParam("/reinitsetup") Then
		$nResult = RegWrite("HKLM\SYSTEM\Setup", "SystemSetupInProgress", "REG_DWORD", 0)
		Debug("IN: SystemSetupInProgress - set back to 0x0 - result: " & $nResult)
	EndIf
	
	If $nCheck = 0 Then Exit
	
	If $bFirstCompleted = FALSE Then
		RegWrite($sGRegKey, "FirstCompleted", "REG_DWORD", 1)		
		If $bShowMainGUI = FALSE And $bStartToTray = FALSE Then Exit
	EndIf
EndIf

ChkStartOptions()

If StringInStr($CmdLineRaw, "/guidisable=") Then
	For $i = 1 To $CmdLine[0]
		If StringInStr($CmdLine[$i], "/guidisable=") Then
			Debug("IN: Correct CMDline parameter found with value: " & $CmdLine[$i])
			$nGUIDisable = Number(StringTrimLeft($CmdLine[$i], 12))
			ExitLoop
		EndIf
	Next
EndIf
Debug("IN: Option - GUIDisable: " & $nGUIDisable)

;SetThemeAppProperties(0)

If $bNoNetcards Then StartSimpleMode()

$bShellLoaded = CheckShellState()
If $bIsWinPE And $bStartToTray And $bShellLoaded = FALSE Then
	Debug("IN: Shell not running. Starting another instance and closing.")
	Run(@AutoItExe & " /waitforshell")
	Exit
EndIf

If Not @Compiled Then $bShellLoaded = TRUE

EnumNetworkAdapters()

If $bWLAPIOK Then EnumWlanAdapters()

Dim $oConf = 0
Dim $oConfigs = 0
Dim $oConfItem	= 0

For $i = 1 To $arNAList[0][0]
	$sNAList = $sNAList & "|" & $arNAList[$i][0]
	If $bUseWMI Then
		$oConfigs	= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
		
		For $oConfItem In $oConfigs
			$oConf = $oConfItem
		Next
	EndIf
	
	If $sDefData = "" And _
		(GetAdapterProperty($arNAList[$i][1], 1, $oConf) <> "" Or _
		GetAdapterProperty($arNAList[$i][1], 6, $oConf) <> "" Or _
		GetAdapterProperty($arNAList[$i][1], 0, $oConf)) Then _
		$sDefData = $arNAList[$i][0]
Next

GUIRegisterMsg(0x7FFF, "WndProc") ; Callback if you open the program again over shortcut
GUIRegisterMsg($TRAYMSGID, "WndProc")
GUIRegisterMsg($WM_NOTIFY, "WndProc")
GUIRegisterMsg($WM_TIMER, "WndProc")

CreateMainGUI()

; Because of graphical overlappings with the tray GUI's create all main sub GUI's too
CreateWiFiGUI()
CreateIdentGUI()
GUICtrlSetData($nInpPCName, @ComputerName)
GUICtrlSetData($nInpPCWG, GetWorkGroup())
GUICtrlSetData($nInpPCDNS, GetDNSSuffix())
CreateSharesGUI()
CreateDrivesGUI()
CreateProfilesGUI()
CreateOtherGUI()
CreateAboutGUI()
TrayInit()

GUISwitch($hMainGUI)
SetODBtnState($nBtnCancel, $GUI_FOCUS, FALSE)	

If $sDefData <> "" Then
	UpdateWiFiTab($sDefData)
	Net2GUI($sDefData)
	Infos2GUI($sDefData)
EndIf

If $bShowTrayAct Or $bStartToTray Or $bShowTrayAlways Then
	TrayIconSetState()
	If $bShowTrayTip Then TrayIconSetToolTip($sMainTitle & @LF & Infos2Tray())
	
	If $bStartToTray Or $bShowTrayAlways Then $bInTray = TRUE

	SetTrayIcon()
			
	If $bShowTrayAct Then SetTimer($hMainGUI, $nTimerID, $nTimerTimeOut, 0)
EndIf

LoadLastPage()

If $bStartToTray = FALSE Then
	If $bShowMainGUI Or $bReloadAfterWait = FALSE Then GUISetState(@SW_SHOW, $hMainGUI)
EndIf


Dim $sLine, $sText, $nCB, $nLV, $nCol, $bRestartReq = FALSE

; Main GUI message loop
While 1
	$nTimerDiff = Round(TimerDiff($nTimerStart) / 1000)
	If $nTimerDiff >= $nTimerCount Then
		$nTimerStart = TimerInit()
		If $bComboNADrop = FALSE Then
			If Infos2GUI(GUICtrlRead($nComboNA)) <> $NO_ERROR Then RefreshAdapterList()
		EndIf
	EndIf
	
	;***************************
	; GUI messages
	;***************************
	$Msg = GUIGetMsg(1)
	
	Switch $Msg[0]
		Case 0
			ContinueLoop
			
		Case $GUI_EVENT_CLOSE, $nBtnCancel
			Switch $Msg[1]
				Case $hMainGUI
					SaveWinPos($hMainGUI, $sGURegKey)
					If $bShellLoaded Then
						If $bCloseToTray Then
							$bInTray = TRUE
							If Not $bShowTrayAct Then CheckTrayIcon(0)
							GUISetState(@SW_HIDE, $hMainGUI)
							ShowWindow($hMainGUI, @SW_HIDE)
						Else
							If $bOpenPage And $bOpenLastPage Then
								$nVal = $nValPagelast
								RegWrite($sGURegKey, "LastPage", "REG_DWORD", $nVal)
							EndIf
							
							ExitLoop
						EndIf
					Else
						Debug("IN: Shell not running. Starting another instance and closing.")
						Run(@AutoItExe & " /waitforshell")
						ExitLoop
					EndIf
			
				Case $hSubGUI
					GUISetState(@SW_ENABLE, $hMainGUI)
					If $hSubGUI <> 0 Then
						GUIDelete($hSubGUI)
						DelODBtnGrp($arODBtnSub)
						$hSubGUI = 0
					EndIf				
				
				Case $hAddrGUI
					GUISetState(@SW_ENABLE, $hSubGUI)
					If $hAddrGUI <> 0 Then
						If $hAddr1 <> 0 Then
							DestroyWindow($hAddr1)
							$hAddr1 = 0
						EndIf
						
						If $hAddr2 <> 0 Then
							DestroyWindow($hAddr2)
							$hAddr2 = 0
						EndIf
						
						DeleteObject($hAddrFont)
						$hAddrFont = 0
						
						GUIDelete($hAddrGUI)
						
						DelODBtnGrp($arODBtnAddr)
						$nBtnAddAddrAdd		= 0
						$nBtnAddAddrCancel	= 0						
						$hAddrGUI			= 0						
					EndIf
					
				Case $hWiFiConnGUI
					SetGUICursor($hCursorArrow, $hWiFiConnGUI)
					GUICtrlSetColor($nLblState, $nClrStateGreen)
					GUICtrlSetData($nLblState, $sStateReady)
					GUISetState(@SW_ENABLE, $hMainGUI)
					GUISetState(@SW_ENABLE, $hTrayWiFiGUI)
					
					GUIDelete($hWiFiConnGUI)
					DelODBtnGrp($arODBtnConn)
					$hWiFiConnGUI = 0
					
					;If $bTrayWndConnect Then SetTimer($hTrayMsgWnd, $nTrayTimerID, $nTrayTimerTimeOut, 0)
					
					$bTrayWndConnect = FALSE
						
					$arCurConn[0] = ""
					$arCurConn[1] = ""
					$arCurConn[2] = ""
					$arCurConn[3] = ""
					$arCurConn[4] = ""
				
				Case $hTrayWiFiGUI
					KillTimer($hTrayMsgWnd, $nTrayTimerID)
					KillTimer($hTrayWiFiGUI, $nTrayTimerIDEnum)
					GUISetState(@SW_HIDE, $hTrayWiFiGUI)
					$bTrayWndWiFi = FALSE
					$bTrayTimerStop = FALSE
					SetTimer($hTrayMsgWnd, $nTrayTimerID, $nTrayTimerTimeOut, 0)
			EndSwitch
			
		Case $GUI_EVENT_MINIMIZE
			If $bMinToTray And $bShellLoaded Then
				GUISetState(@SW_HIDE, $hMainGUI)
				ShowWindow($hMainGUI, @SW_HIDE)
				$bInTray = TRUE
				If $bShowTrayAct Then
					CheckTrayIcon(0, TRUE)
				Else
					CheckTrayIcon(0)
				EndIf
			EndIf
			
		Case $nBtnApply, $nBtnOK
			If $Msg[0] = $nBtnOK Then
				SaveWinPos($hMainGUI, $sGURegKey)
				If $bOpenPage And $bOpenLastPage Then
					$nVal = $nValPagelast
					RegWrite($sGURegKey, "LastPage", "REG_DWORD", $nVal)
				EndIf
			EndIf
			
			$sText = GUICtrlRead($nInpFont)
			If $sText <> "" Then RegWrite($sGURegKey, "GlobalFont", "REG_SZ", $sText)
						
			If BitAnd(GUICtrlRead($nRadioFont), $GUI_CHECKED) Then
				RegWrite($sGURegKey, "UseOSFont", "REG_DWORD", 0)
			Else
				RegWrite($sGURegKey, "UseOSFont", "REG_DWORD", 1)
			EndIf
			
			$sDesc = GUICtrlRead($nComboNA)
			CheckSettings($sDesc)
			If Not $bGlobalAddrChg And Not $bGlobalCNChg Then
				If $Msg[0] = $nBtnApply Then
					ContinueLoop
				Else
					If $bShowTrayAct Or $bCloseToTray Or $bShowTrayAlways Then
						If $bShellLoaded Then
							$bInTray = TRUE
							If $bShowTrayAct Then
								CheckTrayIcon(0, TRUE)
							Else
								CheckTrayIcon(0)
							EndIf
							
							GUISetState(@SW_HIDE, $hMainGUI)
							ShowWindow($hMainGUI, @SW_HIDE)
							
							ContinueLoop
						Else
							Debug("IN: Shell not running. Starting another instance and closing.")
							Run(@AutoItExe & " /waitforshell")
							ExitLoop
						EndIf
					Else
						ExitLoop
					EndIf
				EndIf
			EndIf
			
			GUICtrlSetData($nLblState, $sMsgChangesApply)
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			GUISetState(@SW_DISABLE, $hMainGUI)
			
			If $bGlobalCNChg Then
				$bRestartWS	= FALSE
				
				$sText = GUICtrlRead($nInpPCName)
				If $sText <> @ComputerName And $sText <> "" Then
					SetCN($sText)
					$bRestartWS	= TRUE
				EndIf
				
				$sText = GUICtrlRead($nInpPCWG)
				If $sText <> GetWorkGroup() Then
					SetWorkGroup($sText)
					$bRestartWS	= TRUE
				EndIf
				
				$sText = GUICtrlRead($nInpPCDNS)
				If $sText <> GetDNSSuffix() Then
					SetDNSSuffix($sText)
					$bRestartWS	= TRUE
				EndIf
				
				If $bRestartWS Then
					DelDriveAll()
					
					StopSvc("lanmanworkstation", FALSE)
					StartSvc("lanmanworkstation", FALSE)
					
					If IsServiceRunning("lanmanserver") Then
						StopSvc("lanmanserver", FALSE)
						StartSvc("lanmanserver", FALSE)			
					EndIf
				EndIf
			EndIf
			
			If $bGlobalAddrChg Then
				If $bUseWMI And $bIsVista Then
					Dim $oConf		= 0	
					Dim $oConfigs	= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapter Where Description = """ & $arNAList[GetNetAdapterIndex($sDesc)][2] & """")
					Dim $oConfItem	= 0
					For $oConfItem In $oConfigs
						$oConf = $oConfItem
					Next
					
					$oConf.Disable
					$oConf.Enable					
					
					Sleep(2500)
				Else
					RestartNetDevice(GUICtrlRead($nComboNA))
				EndIf
			EndIf
			
			If $bGlobalCNChg Or $bGlobalAddrChg Then
				$sProfile = RegRead($sGURegKey, "Profile")
				If $sProfile <> "" Then
					GUICtrlSetData($nLblState, $sCMDStart)
					ProfileStartCMD($sProfile)
				EndIf				
			EndIf
			
			$bGlobalCNChg = FALSE
			
			GUISetState(@SW_ENABLE, $hMainGUI)
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
			$nOldMode = Opt("ExpandEnvStrings", 1)
			$sCMDIPChg = GUICtrlRead($nComboCMDIPChg)
			If BitAnd(GUICtrlRead($nChkCMDIPChg), $GUI_CHECKED) And $sCMDIPChg <> "" Then
				$nMode = @SW_SHOW
				Run($sCMDIPChg, "", $nMode)
			EndIf
			Opt("ExpandEnvStrings", $nOldMode)
					
			If $Msg[0] = $nBtnOK Then
				If $bShellLoaded Then
					If $bShowTrayAct Then
						CheckTrayIcon(0, TRUE)
						GUISetState(@SW_HIDE, $hMainGUI)
						ShowWindow($hMainGUI, @SW_HIDE)
					Else
						If $bShowTrayAct Or $bCloseToTray Or $bShowTrayAlways Then
							$bInTray = TRUE
							If $bShowTrayAct Then
								CheckTrayIcon(0, TRUE)
							Else
								CheckTrayIcon(0)
							EndIf
							
							GUISetState(@SW_HIDE, $hMainGUI)
							ShowWindow($hMainGUI, @SW_HIDE)
							
							ContinueLoop
						Else
							ExitLoop
						EndIf
					EndIf
				Else
					Debug("IN: Shell not running. Starting another instance and closing.")
					Run(@AutoItExe & " /waitforshell")
					ExitLoop
				EndIf				
			EndIf
			
			If $bGlobalAddrChg Then
				$bGlobalAddrChg	= FALSE
				RefreshAdapterList()
				If ($bStartToTray Or $bShowTrayAct Or $bShowTrayAlways) And $bShowTrayTip Then TrayIconSetToolTip($sMainTitle & @LF & Infos2Tray())
			EndIf
			
		Case $nBtnAddrOK, $nBtnAddrCancel
			If $Msg[0] = $nBtnAddrOK Then GetAddrList($nLastIndex)
			GUISetState(@SW_ENABLE, $hMainGUI)
			If $hSubGUI <> 0 Then
				GUIDelete($hSubGUI)
				DelODBtnGrp($arODBtnSub)				
				$hSubGUI = 0				
			EndIf
			
			$nBtnAddrUp		= 0
			$nBtnAddrDown	= 0
			$nBtnAddrAdd	= 0
			$nBtnAddrDel	= 0
			$nBtnAddrOK		= 0
			$nBtnAddrCancel	= 0			
		
		Case $nBtnAddAddrAdd, $nBtnAddAddrCancel
			If $Msg[0] = $nBtnAddAddrAdd Then GetNewAddr(GUICtrlRead($nComboNA), $nLastIndex)
			GUISetState(@SW_ENABLE, $hSubGUI)
			If $hAddrGUI <> 0 Then
				If $hAddr1 <> 0 Then
					DestroyWindow($hAddr1)
					$hAddr1 = 0
				EndIf
				
				If $hAddr2 <> 0 Then
					DestroyWindow($hAddr2)
					$hAddr2 = 0
				EndIf
				
				DeleteObject($hAddrFont)
				$hAddrFont = 0	
				
				GUIDelete($hAddrGUI)
				
				DelODBtnGrp($arODBtnAddr)
				$nBtnAddAddrAdd		= 0
				$nBtnAddAddrCancel	= 0				
				$hAddrGUI			= 0				
			EndIf

		Case $nComboNA
			$sLastAdapterSel = GUICtrlRead($nComboNA)
			ResetLastAddr()
			GUICtrlSetTip($nComboNA, GetConName($sLastAdapterSel))
			Net2GUI($sLastAdapterSel)
			Infos2GUI($sLastAdapterSel)
			AltIP2GUI($sLastAdapterSel)
			UpdateWiFiInfo($sLastAdapterSel)
			UpdateWiFiTab($sLastAdapterSel)
			
		Case $nBtnSpeed
			ShowSpeedMenu(GUICtrlRead($nComboNA))

		Case $nRadIPDHCP
			DHCPIPMode(1, 1)
			
		Case $nRadIPStatic
			DHCPIPMode(0, 1)
			Net2GUI(GUICtrlRead($nComboNA), TRUE, FALSE)
			
		Case $nBtnIPAltShow
			$bShowAltConfig = TRUE
			AltIP2GUI(GUICtrlRead($nComboNA))
			If $hLastConfGUI <> $hConfAltIPGUI Then
				SwitchConfGUI($hConfAltIPGUI)
				SetODBtnState($nBtnIPAltHide, $GUI_DEFBUTTON, FALSE)
				SetODBtnState($nBtnIPAltHide, $GUI_FOCUS)
			EndIf
			
		Case $nBtnIPAltHide
			$bShowAltConfig = FALSE
			If $hLastConfGUI <> $hConfIPGUI Then
				SwitchConfGUI($hConfIPGUI)
				SetODBtnState($nBtnIPAltShow, $GUI_DEFBUTTON, FALSE)
				SetODBtnState($nBtnIPAltShow, $GUI_FOCUS)
			EndIf

		Case $nBtnRefresh
			GUICtrlSetData($nLblState, $sNetDetectDev)
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			GUISetState(@SW_DISABLE, $hMainGUI)
					
			If BitAnd(GUICtrlRead($nChkScan), $GUI_CHECKED) Then
				GUICtrlSetData($nLblState, $sNetDetectNew)
				DetectDevices(TRUE, $nLblState)
				If RegRead($sGURegKey, "WiFiCards") = 0 Then
					$nWiFiCard = EnumWlanDevices()
					If $nWiFiCard > 0 Then
						RegWrite($sGURegKey, "WiFiCards", "REG_DWORD", $nWiFiCard)
						Dim $sWiFiSrv = "wzcsvc"
						If $bIsVista Then $sWiFiSrv = "wlansvc"
						ChkWlanAPI()
						If $bWLAPIOK Then
							If (IsCompInstalled("nettrans", "ms_ndisuio") = FALSE) Or _
								($bIsVista And (IsCompInstalled("netservice", "ms_nativewifip") = FALSE)) Or _
								(IsServiceInstalled($sWiFiSrv) = FALSE) Then
								StartWiFi()
								LoadWiFiProfiles(RegRead($sGURegKey, "Profile"))
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			
			RefreshAdapterList()
						
			GUISetState(@SW_ENABLE, $hMainGUI)
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
				
		Case $nBtnAdapterMAC
			If GUICtrlRead($nLblMac) <> "" Then
				SetODBtnState($nBtnCancel, $GUI_FOCUS)
				GUISetState(@SW_DISABLE, $hMainGUI)
				
				If Not ShowChangeMAC(GUICtrlRead($nComboNA)) Then
					GUISetState(@SW_ENABLE, $hMainGUI)
					GUIDelete($hSubGUI)
					DelODBtnGrp($arODBtnSub)
					$hSubGUI = 0
				EndIf			
			EndIf
						
		Case $nBtnMACApply, $nBtnMACCancel, $nBtnMACRestore
			If $Msg[0] = $nBtnMACApply Then
				$sNewMAC = GUICtrlRead($nInpNewMAC)
				If StringRegExp($sNewMAC, $sMACChkPattern) Then
					GUICtrlSetData($nLblState, $sMsgMACApply)
					GUICtrlSetColor($nLblState, $nClrStateRed)
					SetGUICursor($hCursorWait, $hSubGUI)
					ApplyNewMAC(GUICtrlRead($nComboNA), $sNewMAC, FALSE)
					GUICtrlSetData($nInpCurMac, $sNewMAC)
				Else
					MsgBoxEx(48, $sERROR, $sMsgMACChangeErr, $hSubGUI)
					ContinueLoop
				EndIf
			ElseIf $Msg[0] = $nBtnMACRestore Then
				GUICtrlSetData($nLblState, $sMsgMACRestore)
				GUICtrlSetColor($nLblState, $nClrStateRed)
				SetGUICursor($hCursorWait, $hSubGUI)
				ApplyNewMAC(GUICtrlRead($nComboNA), "", TRUE)
			EndIf
			
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)			
			GUISetState(@SW_ENABLE, $hMainGUI)
			GUISetState(@SW_HIDE, $hSubGUI)
			GUIDelete($hSubGUI)
			DelODBtnGrp($arODBtnSub)
			$hSubGUI = 0
			
			SetGUICursor($hCursorArrow, $hMainGUI)
					
			SetODBtnState($nBtnAdapterMAC, $GUI_FOCUS)
				
			$nBtnMACApply	= 0
			$nBtnMACCancel	= 0
			$nBtnMACRestore	= 0
			
		Case $nBtnDhcpInfo
			GUISetState(@SW_DISABLE, $hMainGUI)
			ShowDHCPInfo(GUICtrlRead($nComboNA))
			
		Case $nBtnDhcpRelease
			If IsDHCP(GUICtrlRead($nComboNA)) Then
				GUICtrlSetData($nLblState, $sMsgReleaseAddr)
				GUICtrlSetColor($nLblState, $nClrStateRed)
				SetGUICursor($hCursorWait, $hMainGUI)
				GUISetState(@SW_DISABLE, $hMainGUI)
				
				RenewAdapter(GUICtrlRead($nComboNA), FALSE)
				
				GUISetState(@SW_ENABLE, $hMainGUI)
				SetGUICursor($hCursorArrow, $hMainGUI)
				GUICtrlSetColor($nLblState, $nClrStateGreen)
				GUICtrlSetData($nLblState, $sStateReady)
			EndIf
			
		Case $nBtnDhcpRenew
			If IsDHCP(GUICtrlRead($nComboNA)) Then
				GUICtrlSetData($nLblState, $sMsgRenewAddr)
				GUICtrlSetColor($nLblState, $nClrStateRed)
				SetGUICursor($hCursorWait, $hMainGUI)
				GUISetState(@SW_DISABLE, $hMainGUI)
				
				RenewAdapter(GUICtrlRead($nComboNA), TRUE)
				
				GUISetState(@SW_ENABLE, $hMainGUI)
				SetGUICursor($hCursorArrow, $hMainGUI)
				GUICtrlSetColor($nLblState, $nClrStateGreen)
				GUICtrlSetData($nLblState, $sStateReady)
			EndIf
	
		Case $nChkDGMode
			If $Msg[0] = $nChkDGMode And BitAnd(GUICtrlRead($nChkDGMode), $GUI_CHECKED) Then
				SetAddress($hDG, "")
				SetCtrlState($hDG, @SW_DISABLE)
				If Not BitAnd(GetODBtnState($nBtnDG), $GUI_DISABLE) Then _
					SetODBtnState($nBtnDG, $GUI_DISABLE)
				EnableDGChange(0)
			Else
				SetCtrlState($hDG, @SW_ENABLE)
				If Not BitAnd(GetODBtnState($nBtnDG), $GUI_ENABLE) Then _
					SetODBtnState($nBtnDG, $GUI_ENABLE)
				EnableDGChange(1)
			EndIf

		Case $nRadDNSDHCP
			EnableDNSChange(0)
		
		Case $nRadDNSStatic
			EnableDNSChange(1)
		
		Case $nRadWINSDHCP
			EnableWINSChange(0)
			
		Case $nRadWINSStatic
			EnableWinsChange(1)
			
		Case $nBtnIP
			SwitchToAddrGUI(GUICtrlRead($nComboNA), 1)
			
		Case $nBtnDG
			SwitchToAddrGUI(GUICtrlRead($nComboNA), 3)
			
		Case $nBtnDNS
			SwitchToAddrGUI(GUICtrlRead($nComboNA), 4)
			
		Case $nBtnWINS
			SwitchToAddrGUI(GUICtrlRead($nComboNA), 5)

		Case $nBtnAddrUp
			MoveListData($nListAddr, TRUE)
			CheckListButton()
			
		Case $nBtnAddrDown
			MoveListData($nListAddr)
			CheckListButton()
		
		Case $nBtnAddrAdd
			SwitchToAddAddrGUI(GUICtrlRead($nComboNA), $nLastIndex)
			
		Case $nBtnAddrDel
			DeleteListData()
			
		Case $nListAddr
			If Not $bIsLV Then CheckListButton()
			
		Case $nBtnShr
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			
			StartSharing(FALSE)
			
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
		Case $nBtnShrUsrDel
			DelShareUsr()
			
		Case $nBtnShrSetPW
			SetSharingPW()
		
		Case $nChkShrAll
			If BitAnd(GUICtrlRead($nChkShrAll), $GUI_CHECKED) Then
				$bShareAllDrives = TRUE
				If $bIsWinPE Then RegWrite($sGRegKey, "ShareAll", "REG_DWORD", 1)
			Else
				$bShareAllDrives = FALSE
				If $bIsWinPE Then RegWrite($sGRegKey, "ShareAll", "REG_DWORD", 0)
			EndIf
			
		Case $nBtnShrRef
			SetGUICursor($hCursorWait, $hMainGUI)
			EnumShares()
			SetGUICursor($hCursorArrow, $hMainGUI)
		
		Case $nBtnShrAdd, $nBtnShrAddShow
			AddShare($Msg[0])
	
		Case $nBtnShrPath
			SelectFolderShare()
			
		Case $nBtnShrDel, $nMIDelShr
			DelShare()
			
		Case $nMIBrowseShr
			BrowseDrive($nLVShares)
			
		Case $nBtnPing
			PingAddress()
			
		Case $nBtnTrace
			TraceAddress()
		
		Case $nBtnDrvRef
			SetGUICursor($hCursorWait, $hMainGUI)
			EnumDrives()
			EnumDriveLetters()
			SetGUICursor($hCursorArrow, $hMainGUI)
		
		Case $nBtnDrvAdd, $nMIBrowseNetDrv
			MapDrive(GUICtrlRead($nComboDrv), _
					GUICtrlRead($nComboDrvPath), _
					GUICtrlRead($nInpDrvUsr), _
					GUICtrlRead($nInpDrvPW))
			
		Case $nBtnDrvDel, $nMIDelDrv
			DelDrive()
		
		Case $nMIBrowseDrv
			BrowseDrive($nLVDrives)
		
		Case $nChkStartTray
			If BitAnd(GUICtrlRead($nChkStartTray), $GUI_CHECKED) Then
				RegWrite($sGURegKey, "StartToTray", "REG_DWORD", 1)
			Else
				RegWrite($sGURegKey, "StartToTray", "REG_DWORD", 0)
			EndIf
			
		Case $nChkMinTray
			If BitAnd(GUICtrlRead($nChkMinTray), $GUI_CHECKED) Then
				$bMinToTray = TRUE
				RegWrite($sGURegKey, "MinimizeToTray", "REG_DWORD", 1)
			Else
				$bMinToTray = FALSE
				RegWrite($sGURegKey, "MinimizeToTray", "REG_DWORD", 0)
			EndIf
		
		Case $nChkEndTray
			If BitAnd(GUICtrlRead($nChkEndTray), $GUI_CHECKED) Then
				$bCloseToTray = TRUE
				RegWrite($sGURegKey, "CloseToTray", "REG_DWORD", 1)
			Else
				$bCloseToTray = FALSE
				RegWrite($sGURegKey, "CloseToTray", "REG_DWORD", 0)
			EndIf	
			
		Case $nChkShowAct
			CheckTrayIcon($nChkShowAct)
			
		Case $nTIConf
			$nValPagelast = 1
			If $hLastGUI <> $hConfGUI Then
				$bLoopPing = FALSE
				RefreshAdapterList()
				SwitchGUI($hConfGUI)
				If $bWiFiCreated Then UpdateWiFiState()
				;If $hLastConfGUI = $hConfWiFiGUI Then UpdateWiFiInfo(GUICtrlRead($nComboNA))
			EndIf
										
		Case $nTIIdent
			$nValPagelast = 7
			If $hLastGUI <> $hIdentGUI Then
				$bLoopPing = FALSE
				If Not $bIdentCreated Then CreateIdentGUI()
				GUICtrlSetData($nInpPCName, @ComputerName)
				GUICtrlSetData($nInpPCWG, GetWorkGroup())
				GUICtrlSetData($nInpPCDNS, GetDNSSuffix())
				SwitchGUI($hIdentGUI)
			EndIf

		Case $nTISharing
			$nValPagelast = 8
			If $hLastGUI <> $hSharesGUI Then
				$bLoopPing = FALSE
				If Not $bSharesCreated Then CreateSharesGUI()
				If $bIsWinPE Then UpdateShareUsrCombo()
				UpdateSharingInfo(FALSE)
				EnumShares()
				SwitchGUI($hSharesGUI)
			EndIf
			
		Case $nTIDrives	
			$nValPagelast = 9
			If $bDrvShowInp Then $nValPagelast = 10
			If $hLastGUI <> $hDrivesGUI Then
				$bLoopPing = FALSE
				If Not $bDrivesCreated Then CreateDrivesGUI()
				EnumDrives()
				EnumDriveLetters()
				SwitchGUI($hDrivesGUI)
			EndIf
			
		Case $nTIProfiles
			$nValPagelast = 11
			If $hLastGUI <> $hProfilesGUI Then
				$bLoopPing = FALSE
				If Not $bProfilesCreated Then CreateProfilesGUI()
				SwitchGUI($hProfilesGUI)
				If GUICtrlRead($nInpProfFile) <> $sProfFile Then UpdateProfileList()
			EndIf
			
		Case $nTIOther
			$nValPagelast = 12
			If $hLastGUI <> $hOtherGUI Then
				$bLoopPing = FALSE
				If Not $bOtherCreated Then CreateOtherGUI()
				SwitchGUI($hOtherGUI)
			EndIf
			
		Case $nTIAbout
			$nValPagelast = 13
			If $hLastGUI <> $hAboutGUI Then
				$bLoopPing = FALSE
				If Not $bAboutCreated Then CreateAboutGUI()
				SwitchGUI($hAboutGUI)					
			EndIf
			
		Case $nTISize
			ApplyGUIChange()
			If $bTabSmall Then
				RegWrite($sGURegKey, "SmallTab", "REG_DWORD", 1)
			Else
				RegWrite($sGURegKey, "SmallTab", "REG_DWORD", 0)
			EndIf

		Case $nTIIP
			$nValPagelast = 1
			If $hLastConfGUI <> $hConfIPGUI And $hLastConfGUI <> $hConfAltIPGUI Then
				If $bShowAltConfig Then
					SwitchConfGUI($hConfAltIPGUI)
				Else
					SwitchConfGUI($hConfIPGUI)
				EndIf
			EndIf
			
		Case $nTIWiFi
			$nValPagelast = 2
			If $hLastConfGUI <> $hConfWiFiGUI And $hLastConfGUI <> $hConfPreWiFiGUI Then _
				UpdateWiFiInfo(GUICtrlRead($nComboNA), TRUE)

		Case $nTIAdv
			$nValPagelast = 6
			If $hLastConfGUI <> $hConfExtGUI Then UpdateExtConf(GUICtrlRead($nComboNA), TRUE)
			
		Case $nTIFirewall
			$nValPageLast = 14
			If $hLastConfGUI <> $hConfFWGUI Then UpdateFWGUI()						

		Case $nTIWiFiAV
			$nValPagelast = 3
			If $hLastWiFiGUI <> $hWiFiAvailGUI Then
				SetGUICursor($hCursorWait, $hMainGUI)
				EnumWlanAvailNetworks(GUICtrlRead($nComboNA))
				SwitchWiFiGUI($hWiFiAvailGUI)
				SetGUICursor($hCursorArrow, $hMainGUI)
			EndIf
			
		Case $nTIWiFiPref
			$nValPagelast = 4
			If $hLastWiFiGUI <> $hWiFiPrefGUI Then
				SetGUICursor($hCursorWait, $hMainGUI)
				EnumWlanPrefNetworks(GUICtrlRead($nComboNA))
				SwitchWiFiGUI($hWiFiPrefGUI)
				SetGUICursor($hCursorArrow, $hMainGUI)
			EndIf
					
		Case $nTIWiFiSrv
			$nValPagelast = 5
			If $hLastWiFiGUI <> $hWiFiSrvGUI Then
				SetGUICursor($hCursorWait, $hMainGUI)
				UpdateWiFiState()
				SwitchWiFiGUI($hWiFiSrvGUI)
				SetGUICursor($hCursorArrow, $hMainGUI)
			EndIf
			
		Case $nBtnWLRef
			GUICtrlSetData($nLblState, $sTTWiFiRefresh & "...")
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			EnumWlanAvailNetworks(GUICtrlRead($nComboNA), TRUE)
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
		Case $nBtnWLCon
			GUICtrlSetData($nLblState, $sLblWiFiCon)
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			
			$nResult = ConnectWlan(GUICtrlRead($nComboNA))
			If $nResult = $ERROR_SUCCESS Then
				Sleep(3000)
				EnumWlanAvailNetworks(GUICtrlRead($nComboNA))
			ElseIf $nResult = -9999 Then
				ContinueLoop
			EndIf
			
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
		Case $nBtnWLDiscon
			DisconnectWlan(GUICtrlRead($nComboNA))
			Sleep(2000)
			EnumWlanAvailNetworks(GUICtrlRead($nComboNA))
		
		Case $nBtnWLRefPref
			SetGUICursor($hCursorWait, $hMainGUI)
			EnumWlanPrefNetworks(GUICtrlRead($nComboNA))
			SetGUICursor($hCursorArrow, $hMainGUI)
			
		Case $nBtnWLAdd
			GUISetState(@SW_DISABLE, $hMainGUI)
			CreateAuthGUI()
		
		Case $nComboAuth
			GetAuthEnc(GUICtrlRead($nComboAuth))
		
		Case $nComboEnc
			SetEncState(GUICtrlRead($nComboAuth), GUICtrlRead($nComboEnc))
			
		Case $nBtnAuthOK, $nBtnAuthCancel
			$nResult = 1
			If $Msg[0] = $nBtnAuthOK Then
				SetGUICursor($hCursorWait, $hMainGUI)
				$nResult = AddWLANProfilePref(GUICtrlRead($nComboNA), GUICtrlRead($nInpKey))
				Sleep(2500)
				EnumWlanPrefNetworks(GUICtrlRead($nComboNA))
				SetGUICursor($hCursorArrow, $hMainGUI)
			EndIf
			
			If $nResult Then
				GUISetState(@SW_ENABLE, $hMainGUI)
				GUIDelete($hSubGUI)
				DelODBtnGrp($arODBtnSub)
				$hSubGUI		= 0					
				$nBtnAuthOK		= 0
				$nBtnAuthCancel	= 0
			EndIf
			
		Case $nBtnConnOK, $nBtnConnCancel
			If $Msg[0] = $nBtnConnOK Then
				If $arCurConn[0] == $sWifiUnnamed Then $arCurConn[0] = GUICtrlRead($nInpConnSSID)
				If $bTrayWndConnect Then
					$nCB = $nComboNATray
					$nLV = $nLVWLAvailTray
					$nCol = 1
				Else
					$nCB = $nComboNA
					$nLV = $nLVWLAvail
					$nCol = 1
				EndIf
				If AddWlanProfile(GUICtrlRead($nCB), GUICtrlRead($nInpConnKey), BitAnd(GUICtrlRead($nChkConnAuto), $GUI_CHECKED)) Then
					EnumWlanPrefNetworks(GUICtrlRead($nCB), FALSE)
					ConnectWlan(GUICtrlRead($nCB), FALSE, $nLV, $nCol)
				EndIf
			EndIf
			
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
			GUISetState(@SW_ENABLE, $hMainGUI)
			GUISetState(@SW_ENABLE, $hTrayWiFiGUI)
			
			GUIDelete($hWiFiConnGUI)
			DelODBtnGrp($arODBtnConn)
			$hWiFiConnGUI = 0
			
			$bTrayWndConnect = FALSE
				
			$arCurConn[0] = ""
			$arCurConn[1] = ""
			$arCurConn[2] = ""
			$arCurConn[3] = ""
			$arCurConn[4] = ""
			
		Case $nChkKey
			Dim $sKey = GUICtrlRead($nInpKey)
			If BitAnd(GUICtrlRead($nChkKey), $GUI_CHECKED) Then
				GUICtrlSendMsg($nInpKey, $EM_SETPASSWORDCHAR, 0, 0)
				If $sKey = $sHiddenInput Then
					If IsAdmin() And $bOSCanEncKey Then
						$sKey = GetWlanKey()
					Else
						$sKey = ""
					EndIf
				EndIf
				GUICtrlSetData($nInpKey, $sKey)
			Else
				GUICtrlSendMsg($nInpKey, $EM_SETPASSWORDCHAR, 0x25CF, 0)
				GUICtrlSetData($nInpKey, $sKey)
			EndIf
			
		Case $nChkConnKey
			If BitAnd(GUICtrlRead($nChkConnKey), $GUI_CHECKED) Then
				GUICtrlSendMsg($nInpConnKey, $EM_SETPASSWORDCHAR, 0, 0)
			Else
				GUICtrlSendMsg($nInpConnKey, $EM_SETPASSWORDCHAR, 0x25CF, 0) ; Round circle
			EndIf
			GUICtrlSetData($nInpConnKey, GUICtrlRead($nInpConnKey))
			
		Case $nBtnWLDel
			SetGUICursor($hCursorWait, $hMainGUI)
			DelWlanProfile(GUICtrlRead($nComboNA))
			SetGUICursor($hCursorArrow, $hMainGUI)
			
		Case $nBtnWLEdit
			EditWlanProfile(GUICtrlRead($nComboNA))
		
		Case $nBtnWLImport
			ImportWlanProfile(GUICtrlRead($nComboNA))
			
		Case $nBtnWLExport
			ExportWlanProfile(GUICtrlRead($nComboNA))
			
		Case $nBtnWiFi, $nBtnPreWiFi
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			StartWiFi()
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
		Case $nListExtProp
			GetExtVal(GUICtrlRead($nComboNA), GUICtrlRead($nListExtProp))
			
		Case $nComboExtVal, $nInpExtNumVal
			SetExtVal(GUICtrlRead($nComboNA), GUICtrlRead($nListExtProp), GUICtrlRead($nComboExtVal))

		Case $nRadioExtNotSet
			GUICtrlSetData($nInpExtVal, "")
			
		Case $nComboLang
			$sTmpLang = GUICtrlRead($nComboLang)
			If $sCurLang <> $sTmpLang Then
				$sCurLang = $sTmpLang
				GetLangInfos($sCurLang)
			EndIf
			
		Case $nChkDebug
			If BitAnd(GUICtrlRead($nChkDebug), $GUI_CHECKED) Then
				SetODBtnState($nBtnDebug, $GUI_ENABLE)
				RegWrite($sGURegKey, "Debug", "REG_DWORD", 1)
				$bDebug = TRUE
			Else
				SetODBtnState($nBtnDebug, $GUI_DISABLE)
				RegWrite($sGURegKey, "Debug", "REG_DWORD", 0)
				$bDebug = FALSE
			EndIf
			
		Case $nBtnDebug
			If FileExists($sDebugFile) Then ShellExecute($sDebugFile)
			
		Case $nBtnLogDel
			If FileExists($sDebugFile) Then
				If MsgBoxEx(36, $sBtnLogDel & "?", $sMsgLogDel & ":" & @LF & _
							"""" & $sDebugFile & """ ?", $hMainGUI) = 6 Then
					FileDelete($sDebugFile)
					FileWrite($sDebugFile, "")
				EndIf
			EndIf
		
		Case $nBtnProfFile
			$sProfFile = FileOpenDialog($sMainTitle, "", $sTTProfIniFiles, 8, "PENetwork.ini", $hProfilesGUI)
			If @Error Then $sProfFile = GUICtrlRead($nInpProfFile)
			If $sProfFile <> "" Then
				GUICtrlSetData($nEditProfDesc, "")
				UpdateProfileList($sProfFile)
			EndIf
			
		Case $nBtnProfRef
			GUICtrlSetData($nEditProfDesc, "")
			$sProfFile = GUICtrlRead($nInpProfFile)
			If $sProfFile <> "" And FileExists($sProfFile) Then UpdateProfileList($sProfFile)
			SetODBtnState($nBtnProfApply, $GUI_DISABLE)
			$nLProfLast = -1
			
		Case $nListProf
			Dim $nCurSel = GUICtrlSendMsg($nListProf, $LB_GETCURSEL, 0, 0)
			If $nCurSel > -1 And $nCurSel <> $nLProfLast Then
				GetProfileDesc($sProfFile)
				$nLProfLast = $nCurSel
			EndIf
			
		Case $nBtnProfApply
			SetODBtnState($nBtnProfApply, $GUI_DISABLE)
			GUICtrlSetData($nLblState, $sLblProfApply)
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			
			$sLine = GUICtrlRead($nListProf)
			If $sLine <> "" And StringRight($sLine, StringLen($sLblCurrent) + 3) = " (" & $sLblCurrent & ")" Then _
				$sLine = StringTrimRight($sLine, StringLen($sLblCurrent) + 3)
			
			ApplyProfile(GUICtrlRead($nInpProfFile), GUICtrlRead($nListProf), TRUE)
			UpdateProfileList($sProfFile)
			If ($bInTray Or $bShowTrayAct Or $bShowTrayAlways) And $bShowTrayTip Then TrayIconSetToolTip($sMainTitle & @LF & Infos2Tray())
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			SetODBtnState($nBtnProfApply, $GUI_ENABLE)
			
		Case $nComboScheme
			$sTmpScheme = GUICtrlRead($nComboScheme)
			If $sTmpScheme <> $sCurScheme Then
				ReadScheme($sTmpScheme)
				$sCurScheme = $sTmpScheme
				
				$bPaint = FALSE
		
				ApplyIcons()
				ApplyCtrlColors(0xFFFFFF)
				ApplyGUIColors()
			
				$bPaint = TRUE
			
				GUISetBkColor($nClrGUIBk, $hOtherGUI)
				GUISetBkColor($nClrGUIBkMain, $hMainGUI)
			EndIf
			
			RegWrite($sGURegKey, "Scheme", "REG_SZ", $sCurScheme)
			
			If $sCurScheme = $sLblDefault Then
				RegWrite($sGURegKey, "SchemeDefault", "REG_DWORD", 1)
			Else
				RegWrite($sGURegKey, "SchemeDefault", "REG_DWORD", 0)
			EndIf
			If $sCurScheme = $sLblClassic Then
				RegWrite($sGURegKey, "SchemeClassic", "REG_DWORD", 1)
			Else
				RegWrite($sGURegKey, "SchemeClassic", "REG_DWORD", 0)
			EndIf
		
		Case $nLblAboutAuthor
			GUICtrlSetFont($nLblAboutAuthor, $nGlobalFontSize, 400, 0)
			ShellExecute($sUrlHome)
			
		Case $nLblAboutAI3
			GUICtrlSetFont($nLblAboutAI3, $nGlobalFontSize, 400, 0)
			ShellExecute($sUrlAI3)
			
		Case $nBtnDrvNet, $nBtnDrvNetShow
			If $Msg[0] = $nBtnDrvNetShow Then
				SetGUICursor($hCursorWait, $hMainGUI)
				EnumDrives()
				EnumDriveLetters()
				SetGUICursor($hCursorArrow, $hMainGUI)
			EndIf
			ShowNetBrowse($Msg[0])
			
		Case $nBtnDrvNetAdd
			AddNetBrowse()
			
		Case $nBtnDrvNetDel
			DelNetBrowse()
		
		Case $nBtnProfInt
			$sLine = GUICtrlRead($nInpProfFile)
			$sText = GUICtrlRead($nListProf)
			ProfileAddToList($sLine, $sText)
			
			If @Compiled Then
				Run(@AutoItExe & " /profileeditor /ini=""" & $sLine & """ /profile=""" & $sText & """")
			Else
				Run(@AutoItExe & " " & @ScriptFullPath & " /profileeditor /ini=""" & $sLine & """ /profile=""" & $sText & """")
			EndIf
			
		Case $nBtnProfExt
			$sLine = GUICtrlRead($nInpProfFile)
			If FileExists($sLine) Then ShellExecute($sLine, "", "", "open")
			
		Case $nBtnSubOK
			GUISetState(@SW_ENABLE, $hMainGUI)
			GUIDelete($hSubGUI)
			DelODBtnGrp($arODBtnSub)
			$hSubGUI	= 0					
			$nBtnSubOK	= 0
			
		Case $nBtnDrvNetReset
			GUICtrlSendMsg($nTVDrvNet, $TVM_DELETEITEM, 0, 0)
			Dim $sWG = ""
			If $nInpPCWG > 0 Then $sWG = GUICtrlRead($nInpPCWG)
			If $sWG = "" Then $sWG = GetWorkGroup()
			CreateAdvTVItem($sWG, $nTVDrvNet, $TVI_ROOT, $TVI_LAST, 0, TRUE)
			SetODBtnState($nBtnDrvNetDel, $GUI_DISABLE, FALSE)
			GUICtrlSetData($nEditDrvDesc, "")
			
		Case $nBtnWLUp, $nBtnWLDown
			ChangeWlanProfilePos($Msg[0])
			
		Case $nBtnLangExt
			If $sCurLangFile <> "" And FileExists($sCurLangFile) Then
				If RegRead("HKCR\.lng", "") = "" And FileExists(@SystemDir & "\notepad.exe") Then
					Run("notepad.exe " & $sCurLangFile)
				Else
					ShellExecute($sCurLangFile, "", "", "open")
				EndIf				
			EndIf

		Case $nChkShowAlways
			CheckTrayIcon($nChkShowAlways)
						
		Case $nChkShowTip
			If BitAnd(GUICtrlRead($nChkShowTip), $GUI_CHECKED) Then
				$bTrayTrackMouse = FALSE
				TrayIconSetToolTip($sMainTitle & @LF & Infos2Tray())
				RegWrite($sGURegKey, "ShowTrayTip", "REG_DWORD", 1)
				$bShowTrayTip = TRUE
			Else
				$bTrayTrackMouse = TRUE
				TrayIconSetToolTip("")
				RegWrite($sGURegKey, "ShowTrayTip", "REG_DWORD", 0)
				$bShowTrayTip = FALSE
			EndIf
			
		Case $nChkLastPage
			If BitAnd(GUICtrlRead($nChkLastPage), $GUI_CHECKED) Then
				$bOpenPage = TRUE
				RegWrite($sGURegKey, "OpenPage", "REG_DWORD", "1")
				$nIdx = SendMessage($hComboLastPage, $CB_GETCURSEL, 0, 0)
				If $nIdx > -1 Then
					If $nIdx = 0 Then
						$bOpenLastPage = TRUE
						RegWrite($sGURegKey, "OpenLastPage", "REG_DWORD", 1)
					Else
						$nValPagelast = $nIdx
						$bOpenLastPage = FALSE
						RegWrite($sGURegKey, "OpenLastPage", "REG_DWORD", 0)
						RegWrite($sGURegKey, "LastPage", "REG_DWORD", $nIdx)
					EndIf
				EndIf
			Else
				$bOpenPage = FALSE
				RegWrite($sGURegKey, "OpenPage", "REG_DWORD", 0)
			EndIf
			
		Case $nChkUseWMI
			If BitAnd(GUICtrlRead($nChkUseWMI), $GUI_CHECKED) Then
				$bUseWMI = TRUE
				RegWrite($sGURegKey, "UseWMI", "REG_DWORD", 1)			
			Else
				$bUseWMI = FALSE
				RegWrite($sGURegKey, "UseWMI", "REG_DWORD", 0)
			EndIf
			
		Case $nComboShrUsr
			GUICtrlSetData($nInpShrPW, $sHiddenInput)
			
		Case $nAccDummy1
			DHCPInfos2Clip()
			
		Case $nAccDummy2
			DHCPInfos2Clip(TRUE)
			
		Case $nChkLastPos
			If BitAnd(GUICtrlRead($nChkLastPos), $GUI_CHECKED) Then
				$bSaveWinPos = TRUE
				RegWrite($sGURegKey, "SaveWinPos", "REG_DWORD", 1)			
			Else
				$bSaveWinPos = FALSE
				RegWrite($sGURegKey, "SaveWinPos", "REG_DWORD", 0)
			EndIf
			
		Case $nRadioOSFont
			GUICtrlSetState($nRadioFont, $GUI_UNCHECKED)
			
		Case $nRadioFont
			GUICtrlSetState($nRadioOSFont, $GUI_UNCHECKED)
			
		Case $nBtnFont
			$sText = GUICtrlRead($nInpFont)
			If $sText <> "" Then
				ShowFontDialog($sText)
			Else
				ShowFontDialog($sGlobalFont)
			EndIf
			
		Case $nChkIcons
			If BitAnd(GUICtrlRead($nChkIcons), $GUI_CHECKED) Then
				RegWrite($sGURegKey, "UseIniIcons", "REG_DWORD", 1)
			Else
				RegWrite($sGURegKey, "UseIniIcons", "REG_DWORD", 0)
			EndIf
			
		Case $nBtnFW
			GUICtrlSetColor($nLblState, $nClrStateRed)
			SetGUICursor($hCursorWait, $hMainGUI)
			StartFW()
			SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
		Case $nChkShowOnlyCon
			If BitAnd(GUICtrlRead($nChkShowOnlyCon), $GUI_CHECKED) Then
				$bShowTrayOnlyCon = TRUE
				RegWrite($sGURegKey, "ShowOnlyCon", "REG_DWORD", 1)
			Else
				$bShowTrayOnlyCon = FALSE
				RegWrite($sGURegKey, "ShowOnlyCon", "REG_DWORD", 0)
			EndIf

		Case $nChkTrayLimitInfo
			If BitAnd(GUICtrlRead($nChkTrayLimitInfo), $GUI_CHECKED) Then
				$bTrayLimitInfo = TRUE
				RegWrite($sGURegKey, "TrayLimitInfo", "REG_DWORD", 1)
			Else
				$bTrayLimitInfo = FALSE
				RegWrite($sGURegKey, "TrayLimitInfo", "REG_DWORD", 0)
			EndIf

		Case $nChkTrayAdaptWiFi
			If BitAnd(GUICtrlRead($nChkTrayAdaptWiFi), $GUI_CHECKED) Then
				$bTrayAdaptWiFi = TRUE
				RegWrite($sGURegKey, "TrayAdaptWiFi", "REG_DWORD", 1)
			Else
				$bTrayAdaptWiFi = FALSE
				RegWrite($sGURegKey, "TrayAdaptWiFi", "REG_DWORD", 0)
			EndIf
						
		Case $nChkTrayShowMAC
			If BitAnd(GUICtrlRead($nChkTrayShowMAC), $GUI_CHECKED) Then
				$bTrayShowMAC = TRUE
				RegWrite($sGURegKey, "TrayShowMAC", "REG_DWORD", 1)
			Else
				$bTrayShowMAC = FALSE
				RegWrite($sGURegKey, "TrayShowMAC", "REG_DWORD", 0)
			EndIf
			
		Case $nChkTrayShowIPv6
			If BitAnd(GUICtrlRead($nChkTrayShowIPv6), $GUI_CHECKED) Then
				$bTrayShowIPv6 = TRUE
				RegWrite($sGURegKey, "TrayShowIPv6", "REG_DWORD", 1)
			Else
				$bTrayShowIPv6 = FALSE
				RegWrite($sGURegKey, "TrayShowIPv6", "REG_DWORD", 0)
			EndIf			
			
		Case $nComboNATray, $nBtnWLRefTray
			SetGUICursor($hCursorWait, $hMainGUI)
			$sText = GUICtrlRead($nComboNATray)
			GUICtrlSetTip($nComboNATray, GetConName($sText))
			$sLastWiFiShow = $sText
			If $Msg[0] = $nComboNATray Then				
				EnumWlanAvailNetworks($sText, FALSE, $nLVWLAvailTray)
			Else
				EnumWlanAvailNetworks($sText, TRUE, $nLVWLAvailTray)
			EndIf
			SetGUICursor($hCursorArrow, $hMainGUI)
			
		Case $nBtnWLConTray
			GUICtrlSetData($nLblState, $sLblWiFiCon)
			GUICtrlSetColor($nLblState, $nClrStateRed)
			;SetGUICursor($hCursorWait, $hMainGUI)
			
			If GUICtrlRead($nBtnWLConTray) = $sBtnConnect Then
				$bTrayWndConnect = TRUE
				$nResult = ConnectWlan(GUICtrlRead($nComboNATray), TRUE, $nLVWLAvailTray, 1)
				If $nResult = $ERROR_SUCCESS Then
					$bTrayWndConnect = FALSE
				ElseIf $nResult = -9999 Then
					ContinueLoop
				EndIf
			Else
				DisconnectWlan(GUICtrlRead($nComboNATray))
			EndIf
			;SetGUICursor($hCursorArrow, $hMainGUI)
			GUICtrlSetColor($nLblState, $nClrStateGreen)
			GUICtrlSetData($nLblState, $sStateReady)
			
		Case $nRadIPPrivate, $nRadIPNone
			AltIP2GUI(GUICtrlRead($nComboNA), TRUE, TRUE)
			
		Case $nRadIPUser
			AltIP2GUI(GUICtrlRead($nComboNA), TRUE)
			
		Case $nMIWiFiDel
			DelWlanProfile(GUICtrlRead($nComboNATray), $nLVWLAvailTray, $hTrayWiFiGUI)	
	EndSwitch
WEnd

Exit


;**********************************************************************
; CleanUp
;**********************************************************************
Func OnAutoItExit()
	If Not (ChkCmdParam("/inipatch") Or ChkCmdParam("/drvcopy")) Then
		; Delete button image lists
		DelODBtnGrp($arODBtnMain)
		DelODBtnGrp($arODBtnSub)
		DelODBtnGrp($arODBtnTray)
		
		If $hILLVShares <> 0 Then ImageList_Destroy($hILLVShares)
		If $hILLVWLA <> 0 Then ImageList_Destroy($hILLVWLA)
		If $hILTVDrv <> 0 Then ImageList_Destroy($hILTVDrv)
		If $hILLVWLP <> 0 Then ImageList_Destroy($hILLVWLP)
		If $hILCombo <> 0 Then ImageList_Destroy($hILCombo)
		If $hILLVWLATray <> 0 Then ImageList_Destroy($hILLVWLATray)
		
		CleanIPCtrls()
	
		KillTimer($hMainGUI, $nTimerID)
	
		$arNAList = 0
		$arOctets = 0
		
		If $hGlobalFont <> 0 Then DeleteObject($hGlobalFont)
		If $hGlobalBoldFont <> 0 Then DeleteObject($hGlobalBoldFont)
		
		If $bTrayIconCreated Then TrayIconSetState(2)
		
		If $hTrayIcon <> 0 Then DestroyIcon($hTrayIcon)
		If $hTrayIconData <> 0 Then DestroyIcon($hTrayIconData)
		If $hTrayIconNoData <> 0 Then DestroyIcon($hTrayIconNoData)
		If $hTrayIconSendData <> 0 Then DestroyIcon($hTrayIconSendData)
		If $hTrayIconRecData <> 0 Then DestroyIcon($hTrayIconRecData)
		If $hTrayIconNoConnect <> 0 Then DestroyIcon($hTrayIconNoConnect)
		
		If $hTrayIconWiFiAvail <> 0 Then DestroyIcon($hTrayIconWiFiAvail)
		If $hTrayIconWiFiNull <> 0 Then DestroyIcon($hTrayIconWiFiNull)
		If $hTrayIconWiFiSR1 <> 0 Then DestroyIcon($hTrayIconWiFiSR1)
		If $hTrayIconWiFiSR2 <> 0 Then DestroyIcon($hTrayIconWiFiSR2)
		If $hTrayIconWiFiSR3 <> 0 Then DestroyIcon($hTrayIconWiFiSR3)
		If $hTrayIconWiFiSR4 <> 0 Then DestroyIcon($hTrayIconWiFiSR4)
		If $hTrayIconWiFiSR5 <> 0 Then DestroyIcon($hTrayIconWiFiSR5)
		If $hTrayIconWiFiS1 <> 0 Then DestroyIcon($hTrayIconWiFiS1)
		If $hTrayIconWiFiS2 <> 0 Then DestroyIcon($hTrayIconWiFiS2)
		If $hTrayIconWiFiS3 <> 0 Then DestroyIcon($hTrayIconWiFiS3)
		If $hTrayIconWiFiS4 <> 0 Then DestroyIcon($hTrayIconWiFiS4)
		If $hTrayIconWiFiS5 <> 0 Then DestroyIcon($hTrayIconWiFiS5)
		If $hTrayIconWiFiR1 <> 0 Then DestroyIcon($hTrayIconWiFiR1)
		If $hTrayIconWiFiR2 <> 0 Then DestroyIcon($hTrayIconWiFiR2)
		If $hTrayIconWiFiR3 <> 0 Then DestroyIcon($hTrayIconWiFiR3)
		If $hTrayIconWiFiR4 <> 0 Then DestroyIcon($hTrayIconWiFiR4)
		If $hTrayIconWiFiR5 <> 0 Then DestroyIcon($hTrayIconWiFiR5)
		If $hTrayIconWiFiND1 <> 0 Then DestroyIcon($hTrayIconWiFiND1)
		If $hTrayIconWiFiND2 <> 0 Then DestroyIcon($hTrayIconWiFiND2)
		If $hTrayIconWiFiND3 <> 0 Then DestroyIcon($hTrayIconWiFiND3)
		If $hTrayIconWiFiND4 <> 0 Then DestroyIcon($hTrayIconWiFiND4)
		If $hTrayIconWiFiND5 <> 0 Then DestroyIcon($hTrayIconWiFiND5)
		
		If $hILTrayWiFi <> 0 Then ImageList_Destroy($hILTrayWiFi)
		If $hILTrayRS <> 0 Then ImageList_Destroy($hILTrayRS)
		
		If $hBrushGUI <> 0 Then DeleteObject($hBrushGUI)
		If $hBrushWiFiGUI <> 0 Then DeleteObject($hBrushWiFiGUI)
		If $hBrushTrayGUI <> 0 Then DeleteObject($hBrushTrayGUI)
		
		If $hPrevFont <> 0 Then DeleteObject($hPrevFont)
	EndIf
	
	$arSec = 0
		
	If $hAdvapi32 <> -1 Then DllClose($hAdvapi32)
	If $hComctl32 <> -1 Then DllClose($hComctl32)
	If $hGdi32 <> -1 Then DllClose($hGdi32)
	If $hIphlpapi <> -1 Then DllClose($hIphlpapi)
	If $hKernel32 <> -1 Then DllClose($hKernel32)
	If $hMpr <> -1 Then DllClose($hMpr)
	If $hMsimg32 <> -1 Then DllClose($hMsimg32)
	If $hNetapi32 <> -1 Then DllClose($hNetapi32)
	If $hSetupapi <> -1 Then DllClose($hSetupapi)
	If $hShell32 <> -1 Then DllClose($hShell32)
	If $hUser32 <> -1 Then DllClose($hUser32)
	If $hWlanapi <> -1 Then DllClose($hWlanapi)
	If $hWs2_32 <> -1 Then DllClose($hWs2_32)
EndFunc


;**********************************************************************
; Get first run ini settings
;**********************************************************************
Func GetFirstIni()
	Debug("IN: GetFirstIni")
	
	Local $sResult = ""
	
	$sResult = IniRead($sPENMini, $sGSection, "AutoStart", "")
	If $sResult = "Yes" Then
		$bAutoStart = TRUE
	ElseIf $sResult = "No" Then
		$bAutoStart = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "Debug", "")
	If $sResult = "Yes" Then
		$bDebug = TRUE
	ElseIf $sResult = "No" Then
		$bDebug = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "FocusNo", "")
	If $sResult = "Yes" Then
		$bFocusNo = TRUE
	ElseIf $sResult = "No" Then
		$bFocusNo = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "ForceScanOnStartup", "")
	If $sResult = "Yes" Then
		$bForceSearchDevice = TRUE
	ElseIf $sResult = "No" Then
		$bForceSearchDevice = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "ShowTrayActivity", "")
	If $sResult = "Yes" Then
		$bShowTrayAct = TRUE
	ElseIf $sResult = "No" Then
		$bShowTrayAct = FALSE
	EndIf

	$sResult = IniRead($sPENMini, $sGSection, "ShowTrayAlways", "")
	If $sResult = "Yes" Then
		$bShowTrayAlways = TRUE
	ElseIf $sResult = "No" Then
		$bShowTrayAlways = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "ShowOnlyConnected", "")
	If $sResult = "Yes" Then
		$bShowTrayOnlyCon = TRUE
	ElseIf $sResult = "No" Then
		$bShowTrayOnlyCon = FALSE
	EndIf
		
	$sResult = IniRead($sPENMini, $sGSection, "ShowMain", "")
	If $sResult = "Yes" Then
		$bShowMainGUI = TRUE
	ElseIf $sResult = "No" Then
		$bShowMainGUI = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "MinimizeToTray", "")
	If $sResult = "Yes" Then
		$bMinToTray = TRUE
	ElseIf $sResult = "No" Then
		$bMinToTray = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "EnableAutoIP", "")
	If $sResult = "Yes" Then
		$bEnableAutoIP = TRUE
	ElseIf $sResult = "No" Then
		$bEnableAutoIP = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "UseProfiles", "")
	If $sResult = "Yes" Then
		$bUseProfiles = TRUE
		$sProfileDefault = IniRead($sPENMini, $sGSection, "ProfileDefault", "")
	ElseIf $sResult = "No" Then
		$bUseProfiles = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "UseProfileSelect", "")
	If $sResult = "Yes" Then
		$bUseProfileSelect = TRUE
	ElseIf $sResult = "No" Then
		$bUseProfileSelect = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "UseStartCountdown", "")
	If $sResult = "Yes" Then
		$bUseStartCount	= TRUE
		$nStartCount = Number(IniRead($sPENMini, $sGSection, "StartCountdown", "0"))
	ElseIf $sResult = "No" Then
		$bUseStartCount	= FALSE
	EndIf
		
	$sResult = IniRead($sPENMini, $sGSection, "UseProfileCountdown", "")
	If $sResult = "Yes" Then
		$bUseProfileCount = TRUE
		$nProfileCount = Number(IniRead($sPENMini, $sGSection, "ProfileCountdown", "0"))
	ElseIf $sResult = "No" Then
		$bUseProfileCount = FALSE
	EndIf
	
	$sResult = IniRead($sPENMini, $sGSection, "StartSharing", "")
	If $sResult = "Yes" Then
		$bStartSharing = TRUE
	ElseIf $sResult = "No" Then
		$bStartSharing = FALSE
	EndIf
		
	$sResult = IniRead($sPENMini, $sGSection, "ShareAll", "")
	If $sResult = "Yes" Then
		$bShareAllDrives = TRUE
		RegWrite($sGRegKey, "ShareAll", "REG_DWORD", 1)
	ElseIf $sResult = "No" Then
		$bShareAllDrives = FALSE
		RegWrite($sGRegKey, "ShareAll", "REG_DWORD", 0)
	EndIf
	
	$nStartMode = Number(IniRead($sPENMini, $sGSection, "StartMode", "1"))
	
	$sResult = IniRead($sPENMini, $sGSection, "WaitConnect", "")
	If $sResult = "Yes" Then
		$bWaitConnect = TRUE
		$nWaitConnectTime = Number(IniRead($sPENMini, $sGSection, "WaitConnectTime", "120")) ; Default 2 minutes wait
	ElseIf $sResult = "No" Then
		$bWaitConnect = FALSE
	EndIf
EndFunc


;**********************************************************************
; Get first run registry settings
;**********************************************************************
Func GetFirstReg()
	Debug("IN: GetFirstReg")
	
	Local $nVal
	
	$nVal = RegRead($sGRegKey, "AutoStart") 
	If $nVal = 1 Then
		$bAutoStart = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bAutoStart = FALSE
	EndIf
	
	$nVal = RegRead($sGRegKey, "FocusNo") 
	If $nVal = 1 Then
		$bFocusNo = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bFocusNo = FALSE
	EndIf
		
	$nVal = RegRead($sGRegKey, "ForceScanOnStartup")
	If $nVal = 1 Then
		$bForceSearchDevice = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bForceSearchDevice = FALSE
	EndIf
	
	$nVal = RegRead($sGURegKey, "StartToTray")
	If $nVal = 1 Then
		$bStartToTray = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bStartToTray = FALSE
	EndIf
	
	$nVal = RegRead($sGURegKey, "MinimizeToTray")
	If $nVal = 1 Then
		$bMinToTray = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bMinToTray = FALSE
	ElseIf RegRead($sGRegKey, "MinimizeToTray") = 1 Then
		$bMinToTray = TRUE	
	EndIf
	
	$nVal = RegRead($sGURegKey, "CloseToTray")
	If $nVal = 1 Then
		$bCloseToTray = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bCloseToTray = FALSE
	ElseIf RegRead($sGRegKey, "CloseToTray") = 1 Then
		$bCloseToTray = TRUE	
	EndIf
	
	$nVal = RegRead($sGURegKey, "ShowTrayActivity") 
	If $nVal = 1 Then
		$bShowTrayAct = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowTrayAct = FALSE
	ElseIf RegRead($sGRegKey, "ShowTrayActivity") = 1 Then
		$bShowTrayAct = TRUE	
	EndIf

	$nVal = RegRead($sGURegKey, "ShowTrayAlways") 
	If $nVal = 1 Then
		$bShowTrayAlways = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowTrayAlways = FALSE
	ElseIf RegRead($sGRegKey, "ShowTrayAlways") = 1 Then
		$bShowTrayAlways = TRUE	
	EndIf
	
	$nVal = RegRead($sGURegKey, "ShowOnlyCon") 
	If $nVal = 1 Then
		$bShowTrayOnlyCon = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowTrayOnlyCon = FALSE
	ElseIf RegRead($sGRegKey, "ShowOnlyCon") = 1 Then
		$bShowTrayOnlyCon = TRUE	
	EndIf
		
	$nVal = RegRead($sGRegKey, "CloseAfterStartnet")
	If $nVal = 1 Then
		$bShowMainGUI = FALSE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowMainGUI = TRUE
	EndIf
	
	$nVal = RegRead($sGRegKey, "EnableAutoIP")
	If $nVal = 1 Then
		$bEnableAutoIP = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bEnableAutoIP = FALSE
	EndIf
	
	If RegRead($sGRegKey, "UseProfiles") = 1 And FileExists($sPENMini) Then
		$bUseProfiles = TRUE
		$sProfileDefault = IniRead($sPENMini, $sGSection, "ProfileDefault", "")
	Else
		$bUseProfiles = FALSE
	EndIf
	
	$nVal = RegRead($sGRegKey, "UseProfileSelect")
	If $nVal = 1 Then
		$bUseProfileSelect = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bUseProfileSelect = FALSE
	EndIf

	$nVal = RegRead($sGRegKey, "UseStartCountdown")
	If $nVal = 1 Then
		$bUseStartCount	= TRUE
		$nStartCount = Number(RegRead($sGRegKey, "StartCountdown"))
	ElseIf $nVal = 0 And @Error = 0 Then
		$bUseStartCount	= FALSE
	EndIf

	$nVal = RegRead($sGRegKey, "ShareAll")
	If $nVal = 1 Then
		$bShareAllDrives = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShareAllDrives = FALSE
	EndIf
	
	$nVal = RegRead($sGRegKey, "TopMost")
	If $nVal = 1 Then
		$bTopMost = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bTopMost = FALSE
	EndIf
	
	$nVal = RegRead($sGURegKey, "SmallTab")
	If $nVal = 1 Then
		$bStartTabSmall = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bStartTabSmall = FALSE
	ElseIf RegRead($sGRegKey, "SmallTab") = 1 Then
		$bStartTabSmall = TRUE
	EndIf
	
	$nVal = RegRead($sGURegKey, "WaitConnect")
	If $nVal = 1 Then
		$bWaitConnect	= TRUE
		$nVal = Number(RegRead($sGURegKey, "WaitConnectTime"))
		If $nVal > 0 Then $nWaitConnectTime = $nVal
	ElseIf $nVal = 0 And @Error = 0 Then
		$bWaitConnect	= FALSE
	EndIf
EndFunc


;**********************************************************************
; Get misc options from registry before start
;**********************************************************************
Func ChkStartOptions()
	Local $nVal = RegRead($sGURegKey, "StartToTray")
	If $nVal = 1 Then
		$bStartToTray = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then ; 0 or something different was read
		$bStartToTray = FALSE
	EndIf
	Debug("IN: Option - StartToTray: " & $bStartToTray)
	
	$nVal = RegRead($sGURegKey, "CloseToTray")
	If $nVal = 1 Then
		$bCloseToTray = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bCloseToTray = FALSE
	ElseIf RegRead($sGRegKey, "CloseToTray") = 1 Then
		$bCloseToTray = TRUE
	EndIf
	Debug("IN: Option - CloseToTray: " & $bCloseToTray)
	
	$nVal = RegRead($sGURegKey, "MinimizeToTray")
	If $nVal = 1 Then
		$bMinToTray = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bMinToTray = FALSE
	ElseIf RegRead($sGRegKey, "MinimizeToTray") = 1 Then
		$bMinToTray = TRUE
	EndIf
	Debug("IN: Option - MinimizeToTray: " & $bMinToTray)
		
	$nVal = RegRead($sGURegKey, "ShowTrayActivity")
	If $nVal = 1 Then
		$bShowTrayAct = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowTrayAct = FALSE
	ElseIf RegRead($sGRegKey, "ShowTrayActivity") = 1 Then
		$bShowTrayAct = TRUE
	EndIf
	Debug("IN: Option - ShowTrayActivity: " & $bShowTrayAct)

	$nVal = RegRead($sGURegKey, "ShowTrayAlways")
	If $nVal = 1 Then
		$bShowTrayAlways = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowTrayAlways = FALSE
	ElseIf RegRead($sGRegKey, "ShowTrayAlways") = 1 Then
		$bShowTrayAlways = TRUE
	EndIf
	Debug("IN: Option - ShowTrayAlways: " & $bShowTrayAlways)
	
	$nVal = RegRead($sGURegKey, "ShowTrayTip")
	If $nVal = 1 Then
		$bShowTrayTip = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowTrayTip = FALSE
	EndIf
	Debug("IN: Option - ShowTrayTip: " & $bShowTrayTip)

	$nVal = RegRead($sGURegKey, "ShowOnlyCon")
	If $nVal = 1 Then
		$bShowTrayOnlyCon = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bShowTrayOnlyCon = FALSE
	ElseIf RegRead($sGRegKey, "ShowOnlyCon") = 1 Then
		$bShowTrayOnlyCon = TRUE
	EndIf
	Debug("IN: Option - ShowTrayOnlyConnected: " & $bShowTrayOnlyCon)
		
	$nVal = RegRead($sGURegKey, "SmallTab")
	If $nVal = 1 Then
		$bStartTabSmall = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bStartTabSmall = FALSE
	ElseIf RegRead($sGRegKey, "SmallTab") = 1 Then
		$bStartTabSmall = TRUE
	EndIf
	Debug("IN: Option - SmallTab: " & $bStartTabSmall)
	
	$nVal =	RegRead($sGURegKey, "OpenPage")
	If $nVal = 1 Then
		$bOpenPage = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bOpenPage = FALSE
	EndIf
	
	If $bOpenPage Then
		$nVal =	RegRead($sGURegKey, "LastPage")
		Debug("IN: Option - OpenPage: " & $bOpenPage & " -> " & $nVal)
		
		$nVal =	RegRead($sGURegKey, "OpenLastPage")
		If $nVal = 1 Then
			$bOpenLastPage = TRUE
		ElseIf $nVal = 0 And @Error = 0 Then
			$bOpenLastPage = FALSE
		EndIf
		Debug("IN: Option - OpenLastPage: " & $bOpenLastPage)
	Else
		Debug("IN: Option - OpenPage: " & $bOpenPage)
	EndIf
	
	$nVal = RegRead($sGURegKey, "UseWMI")
	If $nVal = 1 Then
		$bUseWMI = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bUseWMI = FALSE
	EndIf
	Debug("IN: Option - UseWMI: " & $bUseWMI)
	
	$nVal = RegRead($sGURegKey, "SaveWinPos")
	If $nVal = 1 Then
		$bSaveWinPos = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bSaveWinPos = FALSE
	EndIf
	Debug("IN: Option - SaveWinPos: " & $bSaveWinPos)	
	
	$nVal = RegRead($sGURegKey, "GUIDisable")
	If @Error = 0 Then
		$nGUIDisable = $nVal
	Else
		$nVal = RegRead($sGRegKey, "GUIDisable")
		If @Error = 0 Then $nGUIDisable = $nVal
	EndIf

	$nVal = RegRead($sGURegKey, "TrayLimitInfo")
	If $nVal = 1 Then
		$bTrayLimitInfo = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bTrayLimitInfo = FALSE
	EndIf
	Debug("IN: Option - TrayLimitInfo: " & $bTrayLimitInfo)

	$nVal = RegRead($sGURegKey, "TrayAdaptWiFi")
	If $nVal = 1 Then
		$bTrayAdaptWiFi = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bTrayAdaptWiFi = FALSE
	EndIf
	Debug("IN: Option - TrayAdaptWiFi: " & $bTrayAdaptWiFi)
		
	$nVal = RegRead($sGURegKey, "TrayShowMAC")
	If $nVal = 1 Then
		$bTrayShowMAC = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bTrayShowMAC = FALSE
	EndIf
	Debug("IN: Option - TrayShowMAC: " & $bTrayShowMAC)
	
	$nVal = RegRead($sGURegKey, "TrayShowIPv6")
	If $nVal = 1 Then
		$bTrayShowIPv6 = TRUE
	ElseIf $nVal = 0 And @Error = 0 Then
		$bTrayShowIPv6 = FALSE
	EndIf
	Debug("IN: Option - TrayShowIPv6: " & $bTrayShowIPv6)
EndFunc


;**********************************************************************
; Just iniPatch
;**********************************************************************
Func IniWriteLine($sFile, $sSection, $sText)
	Local $arFile[5000], $i, $sLine, $bData, $nMode
	
	;Detect file type
	Local $hFile = FileOpen($sFile, 16)
	If $hFile = -1 Then
		$arFile = 0
		Return
	EndIf
	
	$bData = FileRead($hFile, 2)
	FileClose($hFile)
	
	$nMode = 0
	If $bData = 0xFFFE Then
		$nMode = 32
	ElseIf $bData = 0xFEFF Then
		$nMode = 64
	EndIf
	
	Local $hFile = FileOpen($sFile, $nMode)
	If $hFile = -1 Then
		$arFile = 0
		Return
	EndIf
	
	$arFile[0] = 0
	
	While 1
		$sLine = FileReadLine($hFile)
		If @Error = -1 Then ExitLoop

		$arFile[0] += 1
		$arFile[$arFile[0]] = $sLine
	WEnd
	
	FileClose($hFile)
	FileDelete($sFile)
	
	$hFile = FileOpen($sFile, BitOr($nMode, 2))
	If $hFile = -1 Then
		$arFile = 0
		Return
	EndIf
	
	For $i = 1 To $arFile[0]
		FileWriteLine($hFile, $arFile[$i])
		If StringInStr($arFile[$i], "[" & $sSection & "]") Then FileWriteLine($hFile, $sText)
	Next
	
	FileClose($hFile)
	
	$arFile = 0
EndFunc


;**********************************************************************
; Change big and small window icon
;**********************************************************************
Func SetWindowIcon($hWnd, $sFile, $nIdx)
	GUISetIcon($sFile, $nIdx, $hWnd)
	Local $stFile = DllStructCreate("wchar[" & (StringLen($sFile) + 1) & "]")
	DllStructSetData($stFile, 1, $sFile)
		
	Local $hModule = LoadLibraryExW(DllStructGetPtr($stFile), 0, 0x00000032)
	Local $sIdx = String($nIdx)
	Local $stIdx = DllStructCreate("wchar[" & (StringLen($sIdx) + 2) & "]")
	DllStructSetData($stIdx, 1, "#" & $sIdx)
	
	Local $hOldIcon = 0
	Local $hIconBig = 0
	
	Local $hIconSmall = LoadImageW($hModule, DllStructGetPtr($stIdx), 1, $nIconSizeSmall, $nIconSizeSmall, 0)
	
	If $bIsWin10 Then
		$hIconBig = LoadImageW($hModule, DllStructGetPtr($stIdx), 1, GetScaled(24), GetScaled(24), 0) ; MS changed big taskbar icons from 32 to 24 at 96 dpi in Windows 10 !!!???
	Else
		$hIconBig = LoadImageW($hModule, DllStructGetPtr($stIdx), 1, $nIconSizeBig, $nIconSizeBig, 0)
	EndIf
	
	If $hIconSmall <> 0 Then
		$hOldIcon = SendMessage($hWnd, 0x0080, 0, $hIconSmall)
		DestroyIcon($hOldIcon)
	EndIf
	
	If $hIconBig <> 0 Then
		$hOldIcon = SendMessage($hWnd, 0x0080, 1, $hIconBig)
		DestroyIcon($hOldIcon)
	EndIf

	If $hModule <> 0 Then FreeLibrary($hModule)
EndFunc


;**********************************************************************
; Network startup with timer
;**********************************************************************
Func ShowNetworkStartup()
	Local $nResult = 6, $nGUIWidth = 210, $nGUIHeight = 72, $nWidth = 170, $nBtnWidth = 110, $nBtnHeight = 23
	If $bFocusNo Then $nResult = 7
	
	SetODBtnSize(0, 0, $sNetStartNet, $nWidth, 20, FALSE, FALSE)
	
	$nGUIWidth = $nWidth + 50
	If $nGUIWidth < (2 * $nBtnWidth + 15) Then
		$nGUIWidth = 2 * $nBtnWidth + 15
	Else
		$nBtnWidth = Round(($nGUIWidth - 15) / 2)
	EndIf
	
	Local $nExStyle = 0
	If $bTopMost Then $nExStyle = $WS_EX_TOPMOST
	
	;$hPSG		= GUICreate($sMainTitle, $nGUIWidth, $nGUIHeight, -1, -1, BitOr($DS_MODALFRAME, $WS_CAPTION), $nExStyle)
	$hPSG		= CreateGUI($sMainTitle, $nGUIWidth, $nGUIHeight, -1, -1, BitOr($DS_MODALFRAME, $WS_CAPTION), $nExStyle)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hPSG, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkSub)
	
	If $bIconLib Then
		SetWindowIcon($hPSG, $sIconLib, 4)
	Else
		SetWindowIcon($hPSG, @AutoItExe, 161)
	EndIf
	
	CreateCtrlIcon("user32.dll", -3, 5, 5, $nIconSizeBig, $nIconSizeBig)
	
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $WS_GROUP))
	CreateCtrlLabel($sNetStartNet, 45, 15, $nWidth, 20)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	$nBtnYes	= CreateODBtn($sBtnYes, 5, $nGUIHeight - $nBtnHeight - 5, $nBtnWidth, $nBtnHeight, $arODBtnMain, 2)
	$nBtnNo		= CreateODBtn($sBtnNo, $nBtnWidth + 10, $nGUIHeight - $nBtnHeight - 5, $nBtnWidth, $nBtnHeight, $arODBtnMain, 3)
	
	If $bFocusNo Then
		SetODBtnState($nBtnNo, $GUI_DEFBUTTON, FALSE)
		SetODBtnState($nBtnNo, $GUI_FOCUS)
	Else
		SetODBtnState($nBtnYes, $GUI_DEFBUTTON, FALSE)
		SetODBtnState($nBtnYes, $GUI_FOCUS)
	EndIf
	
	GUISetState()

	GUIRegisterMsg($WM_TIMER, "PreStartWndProc")
	
	If $bUseStartCount Then
		SetTimer($hPSG, $nTimerID, 1000, 0)
		If $bFocusNo Then
			SetODBtnData($nBtnNo, $sBtnNo & " " & $sProfIn & " " & $nStartCount & " " & $sProfSec & ".")
		Else
			SetODBtnData($nBtnYes, $sBtnYes & " " & $sProfIn & " " & $nStartCount & " " & $sProfSec & ".")
		EndIf
	EndIf
	
	While 1
		If $bUseStartCount Then
			If $nStartCount <= 0 Then
				If $bFocusNo Then
					$nResult = 7
				Else
					$nResult = 6
				EndIf
				ExitLoop
			EndIf
		EndIf
		
		$Msg = GUIGetMsg()
		
		Switch $Msg
			Case $nBtnYes
				$nResult = 6
				ExitLoop
				
			Case $nBtnNo, $GUI_EVENT_CLOSE
				$nResult = 7
				ExitLoop
		EndSwitch
	WEnd
	
	KillTimer($hPSG, $nTimerID)
	GUIDelete($hPSG)
	DelODBtnGrp($arODBtnMain)
	
	$nBtnYes = 0
	$nBtnNo = 0
		
	Return $nResult
EndFunc


;**********************************************************************
; Profile Selector GUI
;**********************************************************************
Func ShowProfileSelector()
	Local $arNetProfiles = IniReadSection($sPENMini, "NetProfiles")
	If @Error Then Return
	
	Local $i, $c, $sProfiles = "", $bFound = FALSE, $sListProfile = "", $sLine
	
	For $i = 1 To $arNetProfiles[0][0]
		$sProfiles = $sProfiles & $arNetProfiles[$i][0] & "|"
		If $sProfileDefault <> "" And _
			(StringInStr($arNetProfiles[$i][0], $sProfileDefault) Or _
			$arNetProfiles[$i][0] = $sProfileDefault) Then
			$sListProfile = $sProfileDefault
			$bFound = TRUE
		EndIf
	Next
	
	If Not $bFound Then $sProfileDefault = ""
	If StringRight($sProfiles, 1) = "|" Then $sProfiles = StringTrimRight($sProfiles, 1)
	
	Debug("IN: Profileselector -> Profiles: " & $sProfiles & " -> Default: " & $sProfileDefault)
	
	GUIRegisterMsg($WM_TIMER, "PreWndProc")
	
	Local $nW = 380
	
	;$hPSG		= GUICreate($sMainTitle & " " & $sProfSelTitle, $nW, 312, -1, -1, BitOr($DS_MODALFRAME, $WS_CAPTION))
	$hPSG		= CreateGUI($sMainTitle & " " & $sProfSelTitle, $nW, 312, -1, -1, BitOr($DS_MODALFRAME, $WS_CAPTION))
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)	
	SendMessage($hPSG, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkSub)
	
	If $bIconLib Then
		SetWindowIcon($hPSG, $sIconLib, 4)
	Else
		SetWindowIcon($hPSG, @AutoItExe, 161)
	EndIf
	
	CreateCtrlIcon(@AutoitExe, -1, 5, 5, $nIconSizeBig, $nIconSizeBig)
	
	CreateCtrlLabel($sLblProfSelect & ":", 45, 15, $nW - 55, 20)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	$nListAddr	= CreateCtrlList("", 5, 45, $nW - 10, 100, BitOr($WS_BORDER, $WS_VSCROLL))
	GUICtrlSetData(-1, $sProfiles, $sListProfile)
	;GUICtrlSetStyle(-1, BitOr($WS_BORDER, $WS_VSCROLL, $WS_TABSTOP))
	
	CreateCtrlLabel($sLblProfDesc & ":", 5, 150, $nW - 15, 20)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	Local $nEditInfo	= CreateCtrlEdit("", 5, 170, $nW - 10, 100, BitOr($WS_VSCROLL, $ES_AUTOVSCROLL, $ES_READONLY))
	
	$nBtnOK		= CreateODBtn($sBtnOK, 5, 280, ($nW / 2) - 10, 25, $arODBtnMain, 2)
	$nBtnCancel	= CreateODBtn($sBtnCancel, ($nW / 2) + 5, 280, ($nW / 2) - 10, 25, $arODBtnMain, 3)
	
	GUISetState()
	
	If $sListProfile <> "" Then GUICtrlSetData($nEditInfo, ReadProfileDesc($sPENMini, $sListProfile, "Desc.Line"))

	$nProfileCountCtrl = $nBtnOK
	If $sProfileDefault = "" Then
		$sProfileCountText = $sBtnCancel
		$nProfileCountCtrl = $nBtnCancel
	Else
		$sProfileCountText = $sBtnOK
	EndIf	
	
	SetODBtnState($nProfileCountCtrl, $GUI_DEFBUTTON)
	SetODBtnState($nProfileCountCtrl, $GUI_FOCUS)
	
	If $bUseProfileCount Then
		SetTimer($hPSG, $nTimerID, 1000, 0)
		SetODBtnData($nProfileCountCtrl, $sProfileCountText & " " & $sProfIn & " " & $nProfileCount & " " & $sProfSec & ".")
	EndIf
	
	While 1
		If $bUseProfileCount Then
			If $nProfileCount = 0 Then
				If $nProfileCountCtrl = $nBtnOK Then $sProfileSelected = $sProfileDefault
				ExitLoop
			EndIf
		EndIf
		
		$Msg = GUIGetMsg()
		
		Switch $Msg
			Case $GUI_EVENT_CLOSE, $nBtnCancel
				ExitLoop
		
			Case $nListAddr
				KillTimer($hPSG, $nTimerID)
				$bUseProfileCount = FALSE
				SetODBtnData($nProfileCountCtrl, $sProfileCountText)
				GUICtrlSetData($nEditInfo, ReadProfileDesc($sPENMini, GUICtrlRead($nListAddr), "Desc.Line"))
			
			Case $nBtnOK
				$sProfileSelected = GUICtrlRead($nListAddr)
				If $sProfileSelected <> "" Then ExitLoop
		EndSwitch
	WEnd
	
	KillTimer($hPSG, $nTimerID)
EndFunc


;**********************************************************************
; Read the new description from profile
;**********************************************************************
Func ReadProfileDesc($sFile, $sSection, $sDescString)
	Local $i = 1
	Local $sDesc = "", $sLine = ""
	
	While 1
		$sLine = IniRead($sFile, $sSection, $sDescString & $i, "IniReadError")
		If $sLine = "IniReadError" Then ExitLoop
		
		$sDesc &= $sLine & @CRLF

		$i += 1
	WEnd
	
	If StringRight($sDesc, 2) = @CRLF Then $sDesc = StringTrimRight($sDesc, 2)
	
	; Description compatibility mode
	If $sDesc = "" Then $sDesc = IniRead($sFile, $sSection, "Desc", "")
	
	Return $sDesc
EndFunc


;**********************************************************************
; Countdown timer
;**********************************************************************
Func PreWndProc($hWnd, $Msg, $wParam, $lParam)
	If $Msg = $WM_TIMER Then
		If $hWnd = $hPSG And $wParam = $nTimerID Then
			KillTimer($hPSG, $nTimerID)
			$nProfileCount -= 1
			If $nProfileCount > 0 Then
				SetODBtnData($nProfileCountCtrl, $sProfileCountText & " " & $sProfIn & " " & $nProfileCount & " " & $sProfSec & ".")
				SetTimer($hPSG, $nTimerID, 1000, 0)
			EndIf
   		EndIf
	EndIf
EndFunc


Func PreStartWndProc($hWnd, $Msg, $wParam, $lParam)
	If $Msg = $WM_TIMER Then
		If $hWnd = $hPSG And $wParam = $nTimerID Then
			KillTimer($hPSG, $nTimerID)
			$nStartCount -= 1
			If $nStartCount > 0 Then
				If $bFocusNo Then
					SetODBtnData($nBtnNo, $sBtnNo & " " & $sProfIn & " " & $nStartCount & " " & $sProfSec & ".")
				Else
					SetODBtnData($nBtnYes, $sBtnYes & " " & $sProfIn & " " & $nStartCount & " " & $sProfSec & ".")
				EndIf
				SetTimer($hPSG, $nTimerID, 1000, 0)
			EndIf
   		EndIf
	EndIf
EndFunc


Func PreInstProc($hWnd, $Msg, $wParam, $lParam)
	If $Msg = $WM_TIMER Then
		If $hWnd = $hPrevBkGUI And $wParam = $nTimerID Then
			KillTimer($hPrevBkGUI, $nTimerID)
			
			$nInstTimeCount -= 1
			
			Local $nPerc, $sProg
						
			If $nInstTimeCount > 0 Then
				$nPerc = Round(100 - 100 / $nInstTime * $nInstTimeCount)
				Switch $nPerc
					Case 0 To 20
						$sProg = $sNetRegisterObj
					Case 21 To 40
						$sProg = $sNetDetectDev
					Case 41 To 60
						$sProg = $sNetInstTCP
					Case 61 To 80
						$sProg = $sNetApplyProfile
					Case 81 To 100
						$sProg = $sCMDStart
				EndSwitch
				
				GUICtrlSetData($nPrgrStart, $nPerc)
				GUICtrlSetData($nLblStartTxt, $sProg)
				SetTimer($hPrevBkGUI, $nTimerID, 50, 0)
			Else
				GUICtrlSetData($nPrgrStart, 100)
				GUICtrlSetData($nLblStartTxt, $sCMDStart)
			EndIf			
   		EndIf
	EndIf
EndFunc


;**********************************************************************
; WiFi Exporter GUI
;**********************************************************************
Func CreateWiFiExporter($sExportPath = "")
	$hPCG = CreateGUI("PENetwork WiFi Exporter " & $sVersion, 390, 230)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hPCG, $WM_SETFONT, $hGlobalFont, 1)

	If $bIconLib Then
		GUISetIcon($sIconLib, -4)
	Else
		SetWindowIcon($hPCG, @AutoItExe, 161)
	EndIf
	
	CreateCtrlLabel("Wireless Adapter:", 5, 8, 90, 20)
	$nComboNA		= CreateCtrlCombo("", 95, 5, 290, 40, BitOr($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	
	$nLVWLPref		= CreateCtrlListView(" |SSID|Mode", 5, 30, 380, 165, _
											BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_NOSORTHEADER))
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_SUBITEMIMAGES, $LVS_EX_SUBITEMIMAGES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, 26)	; Type
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, 250)	; SSID
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 2, 55)	; Mode
	
	$hILLVWLP = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	GUICtrlSendMsg(-1, $LVM_SETIMAGELIST, $LVSIL_SMALL, $hILLVWLP)
	
	AddILIcon($hILLVWLP, -213, 44, "Icon54") ; Preferred Infra
	AddILIcon($hILLVWLP, -214, 45, "Icon55") ; Preferred Infra connected
	AddILIcon($hILLVWLP, -215, 46, "Icon56") ; Preferred Adhoc
	AddILIcon($hILLVWLP, -216, 47, "Icon57") ; Preferred Adhoc connected
	
	$nBtnRefresh	= CreateODBtn("&Refresh list", 5, 200, 120, 25, $arODBtnMain, 7, FALSE, -1, 0xFEFEFE, 4, 0xACACB0)
	$nBtnWLExport	= CreateODBtn("&Export", 135, 200, 120, 25, $arODBtnMain, 16, FALSE, -1, 0xFEFEFE, 4, 0xACACB0)
	$nBtnCancel		= CreateODBtn("&Close", 265, 200, 120, 25, $arODBtnMain, 3, FALSE, -1, 0xFEFEFE, 4, 0xACACB0)
	SetODBtnState($nBtnCancel, $GUI_FOCUS, FALSE)
	
	GUIRegisterMsg($WM_COMMAND, "WndProcExp")
	GUIRegisterMsg($WM_NOTIFY, "WndProcExp")
	
	EnumNetworkAdapters()
	EnumWlanAdapters()
	
	Local $i, $sNAList = "", $sDefData = ""
	
	For $i = 1 To $arNAList[0][0]
		If IsWLANI($arNAList[$i][0]) Then
			$sNAList = $sNAList & "|" & $arNAList[$i][0]
		
			If $sDefData = "" Then $sDefData = $arNAList[$i][0]
		EndIf			
	Next
	
	If $sNAList <> "" Then
		GUICtrlSetData($nComboNA, $sNAList, $sDefData)	
		EnumWlanPrefNetworks($sDefData, FALSE)
	EndIf
	
	Local $bFound = FALSE
	
	GUISetState()
	GUICtrlSetTip($nComboNA, GUICtrlRead($nComboNA))
	
	While 1
		$Msg = GUIGetMsg()
		If $Msg = 0 Then ContinueLoop
		
		Switch $Msg
			Case $GUI_EVENT_CLOSE, $nBtnCancel
				ExitLoop
				
			Case $nComboNA
				EnumWlanPrefNetworks(GUICtrlRead($nComboNA), FALSE)
				GUICtrlSetTip($nComboNA, GUICtrlRead($nComboNA))
				
			Case $nBtnRefresh
				EnumNetworkAdapters()
				EnumWlanAdapters()
				
				$sOldData	= GUICtrlRead($nComboNA)
				$sNAList	= ""
				$sDefData	= ""
				$bFound		= FALSE
				
				For $i = 1 To $arNAList[0][0]
					If IsWLANI($arNAList[$i][0]) Then
						$sNAList = $sNAList & "|" & $arNAList[$i][0]
						If $sDefData = "" Then $sDefData = $arNAList[$i][0]
						If $arNAList[$i][0] = $sOldData Then $bFound = TRUE
					EndIf		
				Next
				
				If $bFound Then $sDefData = $sOldData				
				
				If $sNAList <> "" Then
					GUICtrlSetData($nComboNA, $sNAList, $sDefData)					
					EnumWlanPrefNetworks($sDefData, FALSE)
				EndIf
				
			Case $nBtnWLExport
				ExportWlanProfile(GUICtrlRead($nComboNA), $sExportPath)			
		EndSwitch			
	WEnd		
EndFunc


;**********************************************************************
; Exporter message procedure
;**********************************************************************
Func WndProcExp($hWnd, $Msg, $wParam, $lParam)
	Local $hCtrl, $nCode, $nID
	
	Switch $Msg
		Case $WM_COMMAND
			$hCtrl = $lParam
			$nCode = BitShift($wParam, 16)
    		$nID = BitAnd($wParam, 0x0000FFFF)
			
    		If $nID = 1 And $nCode = 0 Then
    			Local $hFocus = GetFocus()
				If $hFocus <> 0 Then
					Local $nDlgID = GetDlgCtrlID($hFocus)
					If $nDlgID <> 0 Then PostMessage($hWnd, $WM_COMMAND, BitAnd($nDlgID, 0x0000FFFF), $hFocus)
				EndIf
				Return 0
			EndIf
						
		Case $WM_NOTIFY
			Local $sNMHDR = "hwnd;uint_ptr;int"
			Local $stNMHDR = DllStructCreate($sNMHDR, $lParam)
			
			If DllStructGetData($stNMHDR, 3) = $LVN_BEGINDRAG Then Return 0	
	EndSwitch
EndFunc


;**********************************************************************
; High DPI functions
;**********************************************************************
Func GetScaled($nValue, $nMode = 1)
	Local $nResult = 0
	
	Switch $nMode
		Case 1 ; Scaled
			$nResult = MulDiv($nValue, $nLogPixelX, 96)
		Case 2 ; Unscaled
			$nResult = MulDiv($nValue, 96, $nLogPixelX)
	EndSwitch

	Return $nResult
EndFunc


Func GetScaledPos(ByRef $arValue, $nMode)
	Switch $nMode
		Case 1 ; Scale
			$arValue[0] = MulDiv($arValue[0], $nLogPixelX, 96) ; nX
			$arValue[1] = MulDiv($arValue[1], $nLogPixelX, 96) ; nY
			$arValue[2] = MulDiv($arValue[2], $nLogPixelX, 96) ; nW
			$arValue[3] = MulDiv($arValue[3], $nLogPixelX, 96) ; nH
		Case 2 ; Unscale
			$arValue[0] = MulDiv($arValue[0], 96, $nLogPixelX) ; nX
			$arValue[1] = MulDiv($arValue[1], 96, $nLogPixelX) ; nY
			$arValue[2] = MulDiv($arValue[2], 96, $nLogPixelX) ; nW
			$arValue[3] = MulDiv($arValue[3], 96, $nLogPixelX) ; nH
	EndSwitch
EndFunc


Func CreateGUI($sTitle, $nW, $nH, $nX = -1, $nY = -1, $nStyle = -1, $nExStyle = -1, $hParent = 0)
	Local $hGUI = 0
	
	If $nW <> -1 Then $nW = GetScaled($nW)
	If $nH <> -1 Then $nH = GetScaled($nH)
	If $nX <> -1 Then $nX = GetScaled($nX)
	If $nY <> -1 Then $nY = GetScaled($nY)
	
	$hGUI = GUICreate($sTitle, $nW, $nH, $nX, $nY, $nStyle, $nExStyle, $hParent)
	Return $hGUI
EndFunc


Func CreateCtrl($nType, $sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1, $nParam = -1)
	Local $nCtrl = 0, $nTmp, $i
	
	If $nX <> -1 Then $nX = GetScaled($nX)
	If $nY <> -1 Then $nY = GetScaled($nY)
	If $nType = 7 Then
		;$nX += Round(($nIconSizeSmall - GetScaled($nIconSizeSmall, 2)) / 2)
		;$nY += Round(($nIconSizeSmall - GetScaled($nIconSizeSmall, 2)) / 2)
	ElseIf $nType = 2 Or $nType = 12 Then
		If $nParam <> 0 Then
			$nTmp = GetScaled($nW)
			$nW = GetTextSize($nParam, $sText) + $nChkSize
			If $nW > $nTmp Then $nW = $nTmp
		Else
			If $nW <> -1 Then $nW = GetScaled($nW)
		EndIf
		If $nH <> -1 Then $nH = GetScaled($nH)
	ElseIf $nType = 1 Then
		If $nParam = 1 Then
			$nX += Round(($nIconSizeSmall - GetScaled($nIconSizeSmall, 2)) / 2)
			$nY += Round(($nIconSizeSmall - GetScaled($nIconSizeSmall, 2)) / 2)
		ElseIf $nParam = 2 Then
			If $nW <> -1 Then $nW = GetScaled($nW)
		ElseIf $nParam = 3 Then
			If $nH <> -1 Then $nH = GetScaled($nH)
		Else
			If $nW <> -1 Then $nW = GetScaled($nW)
			If $nH <> -1 And $sText <> "" Then $nH = GetScaled($nH)
		EndIf
	Else
		If $nW <> -1 Then $nW = GetScaled($nW)
		If $nH <> -1 Then $nH = GetScaled($nH)
	EndIf	
	
	Switch $nType
		Case 1
			$nCtrl = GUICtrlCreateLabel($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 2
			$nCtrl = GUICtrlCreateCheckbox($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 3
			$nCtrl = GUICtrlCreateInput($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 4
			$nCtrl = GUICtrlCreateCombo($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 5
			$nCtrl = GUICtrlCreateListView($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 6
			$nCtrl = GUICtrlCreateButton($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 7
			$nCtrl = GUICtrlCreateIcon($sText, $nParam, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 8
			$nCtrl = GUICtrlCreateEdit($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 9
			$nCtrl = GUICtrlCreateList($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 10
			$nCtrl = GUICtrlCreateProgress($nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 11
			$nCtrl = GUICtrlCreateTreeView($nX, $nY, $nW, $nH, $nStyle, $nExStyle)
		Case 12
			$nCtrl = GUICtrlCreateRadio($sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
	EndSwitch
	
	Return $nCtrl
EndFunc


Func CreateCtrlLabel($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1, $nParam = -1)
	Return CreateCtrl(1, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle, $nParam)
EndFunc


Func CreateCtrlCheck($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1, $nParam = 0)
	Return CreateCtrl(2, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle, $nParam)
EndFunc


Func CreateCtrlInput($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(3, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlCombo($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(4, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlListView($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(5, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlButton($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(6, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlIcon($sFileName, $nIconIdx, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(7, $sFileName, $nX, $nY, $nW, $nH, $nStyle, $nExStyle, $nIconIdx)
EndFunc


Func CreateCtrlEdit($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(8, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlList($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(9, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlProg($nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(10, "", $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlTreeView($nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1)
	Return CreateCtrl(11, "", $nX, $nY, $nW, $nH, $nStyle, $nExStyle)
EndFunc


Func CreateCtrlRadio($sText, $nX, $nY, $nW = -1, $nH = -1, $nStyle = -1, $nExStyle = -1, $nParam = 0)
	Return CreateCtrl(12, $sText, $nX, $nY, $nW, $nH, $nStyle, $nExStyle, $nParam)
EndFunc


Func SetCtrlPos($hGUI, $nID, $sText, $nX, $nY, $nW = -1, $nH = -1, $bIsChkCtrl = TRUE)
	Local $nTmp
	
	If $sText <> "" Then
		$nTmp = GetScaled($nW)
		If $bIsChkCtrl Then
			$nW = GetTextSize($hGUI, $sText) + $nChkSize
		Else
			$nW = GetTextSize($hGUI, $sText)
		EndIf
		If $nW > $nTmp Then $nW = $nTmp
	EndIf
	
	If $nX <> -1 Then $nX = GetScaled($nX)
	If $nY <> -1 Then $nY = GetScaled($nY)
	If $nH <> -1 Then $nH = GetScaled($nH)
	
	GUICtrlSetPos($nID, $nX, $nY, $nW, $nH)
EndFunc


;**********************************************************************
; Profile Editor GUI
;**********************************************************************
Func CreateProfileEditor()
	$hPCG = CreateGUI("PE Network Manager " & $sVersion & " - configuration/profile editor", 535, 420)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hPCG, $WM_SETFONT, $hGlobalFont, 1)

	If $bIconLib Then
		GUISetIcon($sIconLib, -4)
	Else
		SetWindowIcon($hPCG, @AutoItExe, 161)
	EndIf
	
	Local $nChkTmp = GUICtrlCreateCheckBox("CHECKBOX", 0, 0, -1, -1)
	GUICtrlSetState(-1, $GUI_HIDE)
	Local $nSize = GetTextSize($hMainGUI, "CHECKBOX")
	Local $arSize = WinGetClientSize(GUICtrlGetHandle($nChkTmp))
	If IsArray($arSize) Then $nChkSize = GetScaled($arSize[0] - $nSize)
	GUICtrlDelete($nChkTmp)
	
	Local $nMIFile		= GUICtrlCreateMenu("&File")
	$nMIProfNew			= GUICtrlCreateMenuItem("New config file" & @Tab & "Ctrl+N", $nMIFile)
	GUICtrlCreateMenuItem("", $nMIFile)
	$nMIProfOpen		= GUICtrlCreateMenuItem("Open..." & @Tab & "Ctrl+O", $nMIFile)
	$nMIProfOpenExt		= GUICtrlCreateMenuItem("Open file with external editor" & @Tab & "Alt+Shift+O", $nMIFile)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlCreateMenuItem("", $nMIFile)
	$nMILoad			= GUICtrlCreateMenuItem("Reload" & @Tab & "Ctrl+R", $nMIFile)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlCreateMenuItem("", $nMIFile)
	$nMISave			= GUICtrlCreateMenuItem("Save" & @Tab & "Ctrl+S", $nMIFile)
	GUICtrlSetState(-1, $GUI_DISABLE)
	$nMISaveAs			= GUICtrlCreateMenuItem("Save as..." & @Tab & "Alt+Shift+S", $nMIFile)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlCreateMenuItem("", $nMIFile)
	$nMIExit			= GUICtrlCreateMenuItem("Exit" & @Tab & "Ctrl+X", $nMIFile)
	Local $nMIOptions	= GUICtrlCreateMenu("&Options")
	$nMIPrefs			= GUICtrlCreateMenuItem("Preferences..." & @Tab & "Ctrl+P", $nMIOptions)
	Local $nMIHelp		= GUICtrlCreateMenu("&?")
	;$nMIHelpFile		= GUICtrlCreateMenuItem("Help topics (in progress)", $nMIHelp)
	;GUICtrlCreateMenuItem("", $nMIHelp)
	$nMIAbout			= GUICtrlCreateMenuItem("About", $nMIHelp)
	
	Local $arAcc[8][2]
	$arAcc[0][0] = "^n"
	$arAcc[0][1] = $nMIProfNew
	$arAcc[1][0] = "^o"
	$arAcc[1][1] = $nMIProfOpen
	$arAcc[2][0] = "!+o"
	$arAcc[2][1] = $nMIProfOpenExt
	$arAcc[3][0] = "^r"
	$arAcc[3][1] = $nMILoad
	$arAcc[4][0] = "^s"
	$arAcc[4][1] = $nMISave
	$arAcc[5][0] = "!+s"
	$arAcc[5][1] = $nMISaveAs
	$arAcc[6][0] = "^x"
	$arAcc[6][1] = $nMIExit
	$arAcc[7][0] = "^p"
	$arAcc[7][1] = $nMIPrefs
	
	GUISetAccelerators($arAcc)
	
	CreateCtrlLabel("", 0, 0, 536, 2, $SS_SUNKEN)
	
	CreateCtrlIcon("shell32.dll", -1, 10, 9, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, $SS_ICON)
	If $bIconLib Then
		GUICtrlSetImage(-1, $sIconLib, -7)
	Else
		GUICtrlSetImage(-1, @AutoItExe, 183)
	EndIf
	
	CreateCtrlLabel("Config file:", 30, 11, 79, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	
	$nInpProfFile		= CreateCtrlCombo("", 110, 8, 330, 40, BitOr($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	
	Local $nBtnX	= GetScaled(445)
	Local $nBtnY	= GetScaled(8)
	Local $nBtnH	= GetScaled(21)
	Local $nBtnL	= GetScaled(22)
	
	$nBtnProfFile		= CreateODBtn("...", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, -1, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Open config file")
	$nBtnX += $nBtnL - 1
	$nBtnProfNew		= CreateODBtn("N", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 5, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Create new config file")
	$nBtnX += $nBtnL - 1
	$nBtnProfExt		= CreateODBtn("O", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 16, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Open config file with external editor")
	$nBtnX += $nBtnL - 1
	$nBtnProfClean		= CreateODBtn("C", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 3, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Clear list of last open files")
	
	CreateCtrlLabel("", 0, 35, 536, 2, $SS_SUNKEN)
	
	CreateCtrlIcon("shell32.dll", -1, 10, 44, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, $SS_ICON)
	If $bIconLib Then
		GUICtrlSetImage(-1, $sIconLib, -57)
	Else
		GUICtrlSetImage(-1, @AutoItExe, 227)
	EndIf
	CreateCtrlLabel("Network Profile:", 30, 46, 114, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	$nComboProfiles		= CreateCtrlCombo("", 145, 43, 295, 40, BitOr($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nBtnX = GetScaled(445)
	$nBtnY = GetScaled(43)
	
	$nBtnProfManage		= CreateODBtn("...", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, -1, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Manage profiles")
	SetODBtnState($nBtnProfManage, $GUI_DISABLE, FALSE)
	$nBtnX += $nBtnL - 1
	$nBtnProfAdd		= CreateODBtn("A", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 5, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Add new profile")
	SetODBtnState($nBtnProfAdd, $GUI_DISABLE, FALSE)
	$nBtnX += $nBtnL - 1
	$nBtnProfDel		= CreateODBtn("D", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 6, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Delete selected profile")
	SetODBtnState($nBtnProfDel, $GUI_DISABLE, FALSE)
	$nBtnX += $nBtnL - 1
	$nBtnProfCopy		= CreateODBtn("C", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 4, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad, FALSE)
	GUICtrlSetTip(-1, "Copy selected profile settings to new one")
	SetODBtnState($nBtnProfCopy, $GUI_DISABLE, FALSE)
	
	$nBtnX		= GetScaled(5)
	$nBtnY		= GetScaled(70)
	$nBtnH		= GetScaled(25)
	$nBtnL		= GetScaled(140)
	Local $nX	= $nBtnX + $nBtnL - 1
	Local $nY	= GetScaled(70)
	Local $nR	= GetScaled(529)
	Local $nB	= GetScaled(362)
	
	GUICtrlCreateLabel("", $nBtnX + $nBtnL - 1, $nY, $nR - $nBtnX - $nBtnL + 1, 1) ; Top
	GUICtrlSetBkColor(-1, 0x0)
	GUICtrlCreateLabel("", $nBtnX + $nBtnL - 1, $nY, 1, $nB - $nY) ; Left
	GUICtrlSetBkColor(-1, 0x0)
	GUICtrlCreateLabel("", $nBtnX + $nBtnL - 1, $nB, $nR - $nBtnX - $nBtnL + 2, 1) ; Bottom
	GUICtrlSetBkColor(-1, 0x0)
	GUICtrlCreateLabel("", $nR, $nY, 1, $nB - $nY) ; Right
	GUICtrlSetBkColor(-1, 0x0)
	
	$nTIGlobal		= CreateODTab($hPCG, "Global Settings", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 10, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTIDesc		= CreateODTab($hPCG, "Profile Description", $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 6, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTINetIdent	= CreateODTab($hPCG, "Identity",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 1, FALSE, -1, -1, 5, -1)
	$nBtnY += $nBtnH - 1
	$nTIAdapter		= CreateODTab($hPCG, "Network Adapter",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 0, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTIWireless	= CreateODTab($hPCG, "Wireless Settings",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 7, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTINetShares	= CreateODTab($hPCG, "Sharing",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 2, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTINetDrives	= CreateODTab($hPCG, "Network Drives",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 3, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTICMDStartup	= CreateODTab($hPCG, "CMDs after startup",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 11, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTICMDChange	= CreateODTab($hPCG, "CMDs after IP change",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 11, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTIColorSchemes= CreateODTab($hPCG, "Color Schemes",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 5, FALSE, -1, -1, 5)
	$nBtnY += $nBtnH - 1
	$nTIPreview		= CreateODTab($hPCG, "Preview",  $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 12, FALSE, -1, -1, 5)
		
	$nLastItemEditor = $nTIGlobal
	
	$nBtnSave			= CreateODBtn("&Save", 144, 370, 125, 24, $arODBtnMain, 4, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnLoad			= CreateODBtn("&Reload", 275, 370, 125, 24, $arODBtnMain, 7, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	GUICtrlSetTip(-1, "Reload all settings from config file")
	$nBtnExit			= CreateODBtn("&Close", 406, 370, 124, 24, $arODBtnMain, 3, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	;GUISetState()
	; *** Global settings GUI ***
	$hGlobalGUI			= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP, $WS_VSCROLL), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hGlobalGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrBkSub)
	
	CreateCtrlLabel("These options will be applied on PENM startup", 6, 5, 375, 18)
	GUICtrlSetFont(-1, $nGlobalFontSize, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	
	$nChkStartPrompt	= CreateCtrlCheck("Prompt for starting network support", 6, 20, 378 - $nSBSize, 18, -1, -1, $hGlobalGUI)
	$nChkFocusNo		= CreateCtrlCheck("Set focus to 'No' button", 25, 38, 359, 18, -1, -1, $hGlobalGUI)
	$nChkStartCount		= CreateCtrlCheck("Show countdown in startup prompt  ->  Time in sec:", 25, 56, 280, 18, -1, -1, $hGlobalGUI)
	$nInpStartCount		= CreateCtrlInput("10", 308, 56, 70 - $nSBSize, 20)
	GUICtrlCreateUpDown($nInpStartCount)
	GUICtrlSetLimit(-1, 300, 0)
	CreateCtrlLabel("Progress window position:", 25, 80, 140, 18)
	$nComboStartMode	= CreateCtrlCombo("", 168, 77, 210 - $nSBSize, 40, BitOr($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	GUICtrlSetData(-1, $sStartModes, "1 - Center")
	
	$nChkProfUse		= CreateCtrlCheck("Use profiles at startup", 6, 101, 378, 18, -1, -1, $hGlobalGUI)
	$nChkProf			= CreateCtrlCheck("Show profile selection dialog", 25, 119, 359, 18, -1, -1, $hGlobalGUI)
	GUICtrlSetState(-1, $GUI_CHECKED)
	$nChkCount			= CreateCtrlCheck("Show countdown in profile selection  ->  Time in sec:", 25, 137, 280, 18, -1, -1, $hGlobalGUI)
	$nInpCount			= CreateCtrlInput("10", 308, 137, 70 - $nSBSize, 20)
	GUICtrlCreateUpDown($nInpCount)
	GUICtrlSetLimit(-1, 300, 0)
	CreateCtrlLabel("Default profile:", 25, 161, 140, 18)
	$nComboDefProf		= CreateCtrlCombo("", 168, 158, 210 - $nSBSize, 40, BitOr($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	
	CreateCtrlIcon("shell32.dll", -1, 5, 182, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 184, -8)

	$nChkDebug			= CreateCtrlCheck("Enable Debug mode (usefull for analyse specific problems)", 25, 182, 359, 17, -1, -1, $hGlobalGUI)
	$nChkAutoIP			= CreateCtrlCheck("Enable Auto IP configuration (APIPA)", 25, 200, 359, 17, -1, -1, $hGlobalGUI)
	$nChkForceScan		= CreateCtrlCheck("Force scanning for new devices on every startup", 25, 218, 359, 17, -1, -1, $hGlobalGUI)
	
	CreateCtrlIcon("shell32.dll", -1, 5, 236, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 240, -70)

	$nRadioShowMain		= CreateCtrlRadio("Show main window after starting network", 25, 236, 359, 17, $WS_GROUP)
	
	CreateCtrlIcon("shell32.dll", -1, 5, 254, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 233, -63)

	$nRadioStartToTray	= CreateCtrlRadio("Automatically minimize to tray after startup", 25, 254, 359, 17)

	CreateCtrlIcon("shell32.dll", -1, 5, 272, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 208, -39)
	
	$nRadioCloseMain	= CreateCtrlRadio("Close program after starting network", 25, 272, 359, 17)

	CreateCtrlIcon("shell32.dll", -1, 5, 290, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 208, -40)
	
	$nChkShowAct	= CreateCtrlCheck("Automatically show tray network activity", 25, 290, 359, 17, -1, -1, $hGlobalGUI)
	
	$nRadioOSFont		= CreateCtrlRadio("Use OS default font for GUI", 25, 308, 359, 17, $WS_GROUP)
	
	$nRadioFont			= CreateCtrlRadio("Use following font:", 25, 326, 110, 17)
	$nInpFont			= CreateCtrlInput("", 140, 326, 220, 20)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nChkIcons			= CreateCtrlCheck("Load GUI icons from ini file", 25, 350, 359, 17, -1, -1, $hGlobalGUI)
	
	$nChkWait			= CreateCtrlCheck("Wait for connected state  -> Time in sec:", 25, 370, 280, 17, -1, -1, $hGlobalGUI)
	$nInpWait			= CreateCtrlInput($nWaitConnectTime, 308, 370, 70 - $nSBSize, 20)
	GUICtrlCreateUpDown($nInpWait)
	GUICtrlSetLimit(-1, 3600, 0)
	
	CreateCtrlIcon("shell32.dll", -1, 5, 393, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 288, -111)

	$nChkTrayLimitInfo	= CreateCtrlCheck("Limit tray info height (default '0' = 1/2 desktop)", 25, 392, 359, 17, -1, -1, $hGlobalGUI)
	$nInpLimit			= CreateCtrlInput($nTrayInfoHeight, 308, 392, 70 - $nSBSize, 20)
	GUICtrlCreateUpDown($nInpLimit)
	GUICtrlSetLimit(-1, 3600, 0)
	
	CreateCtrlIcon("shell32.dll", -1, 5, 411, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 289, -112)

	$nChkTrayAdaptWiFi	= CreateCtrlCheck("Adapt tray wifi height to tray info height", 25, 410, 359, 17, -1, -1, $hGlobalGUI)
	
	$nChkTrayWiFiHeight	= CreateCtrlCheck("Set tray wifi height ('0' = default height of 380)", 25, 428, 359, 17, -1, -1, $hGlobalGUI)
	$nInpWiFiHeight		= CreateCtrlInput($nTrayInfoHeight, 308, 428, 70 - $nSBSize, 20)
	GUICtrlCreateUpDown($nInpWiFiHeight)
	GUICtrlSetLimit(-1, 3600, 0)
	
	CreateCtrlIcon("shell32.dll", -1, 5, 447, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 290, -113)

	$nChkTrayShowMAC	= CreateCtrlCheck("Show MAC addresses in tray info", 25, 446, 359, 17, -1, -1, $hGlobalGUI)
	
	CreateCtrlIcon("shell32.dll", -1, 5, 464, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 291, -114)

	$nChkTrayShowIPv6	= CreateCtrlCheck("Show IPv6 addresses in tray info", 25, 464, 359, 17, -1, -1, $hGlobalGUI)

	Local $stSI = DllStructCreate($sSCROLLINFO)
	DllStructSetData($stSI, 1, DllStructGetSize($stSI))
	DllStructSetData($stSI, 2, BitOr($SIF_PAGE, $SIF_RANGE))
	DllStructSetData($stSI, 3, 0)
	DllStructSetData($stSI, 4, GetScaled(484))
	DllStructSetData($stSI, 5, $nB - $nY - 1)
	SetScrollInfo($hGlobalGUI, $SB_VERT, DllStructGetPtr($stSI), FALSE)
	$arScrollInfo[2][0] = 0
	$arScrollInfo[2][1] = GetScaled(484) - ($nB - $nY - 1)
	$stSI = 0
	GUISetState()
	
	; *** Description GUI ***
	$hDescGUI			= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	CreateCtrlLabel("This text will be shown in profile selection dialog", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)	
	$nEditDesc			=  CreateCtrlEdit("", 6, 25, 372, 260)
	GUICtrlSetLimit(-1, 250)
	
	; *** Ident GUI ***	
	$hIdentGUI			= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	CreateCtrlLabel("For more information please move the mouse over the labels", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)	
	
	
	CreateCtrlLabel("Computername:", 6, 28, 80, 20)
	GUICtrlSetTip(-1, "For random characters/numbers in computername use:" & @LF & _
						"'?' for 'A-Z' and '+' for 0-9, i.e. MINIPE++??" & @LF & _
						"Limited to " & $MAX_COMPUTERNAME_LENGTH & " characters")
	$nInpPCName			=  CreateCtrlInput("", 88, 25, 290, 20)
	GUICtrlSetLimit(-1, $MAX_COMPUTERNAME_LENGTH)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	CreateCtrlLabel("Workgroup:", 6, 53, 80, 20)
	GUICtrlSetTip(-1, "Limited to " & $MAX_COMPUTERNAME_LENGTH & " characters")
	$nInpPCWG			=  CreateCtrlInput("", 88, 50, 290, 20, BitOr($ES_AUTOHSCROLL, $ES_UPPERCASE))
	GUICtrlSetLimit(-1, $MAX_COMPUTERNAME_LENGTH)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	CreateCtrlLabel("DNS-suffix:", 6, 78, 80, 20)
	GUICtrlSetTip(-1, "Limited to " & (255 - $MAX_COMPUTERNAME_LENGTH) & " characters")
	$nInpPCDNS			=  CreateCtrlInput("", 88, 75, 290, 20, $ES_AUTOHSCROLL)
	GUICtrlSetLimit(-1, 255 - $MAX_COMPUTERNAME_LENGTH)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	;GUISetState()

	; *** Adapter Properties GUI ***
	$hConfGUI			= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)	
	CreateCtrlLabel("For more information please move the mouse over the labels", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	
	CreateCtrlLabel("Adapter:", 6, 28, 90, 20)
	$nComboNA			= CreateCtrlCombo("", 88, 25, 150, 40, BitOr($CBS_SORT, $CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	
	$nBtnAddAdapter		= CreateODBtn("Add", 242, 25, 65, 20, $arODBtnMain, 5, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnDelAdapter		= CreateODBtn("Del", 312, 25, 65, 20, $arODBtnMain, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	$nDmyAdd			= GUICtrlCreateDummy()
	$nDmyAddCon			= GUICtrlCreateContextMenu($nDmyAdd)
	$nAddNA1			= GUICtrlCreateMenuItem("NetAdapter1", $nDmyAddCon)
	$nAddNA2			= GUICtrlCreateMenuItem("NetAdapter2", $nDmyAddCon)
	$nAddNA3			= GUICtrlCreateMenuItem("NetAdapter3", $nDmyAddCon)
	$nAddNA4			= GUICtrlCreateMenuItem("NetAdapter4", $nDmyAddCon)
	$nAddNA5			= GUICtrlCreateMenuItem("NetAdapter5", $nDmyAddCon)
	$nAddNA6			= GUICtrlCreateMenuItem("NetAdapter6", $nDmyAddCon)
	
	CreateCtrlLabel("Static IP:", 6, 53, 80, 20)
	GUICtrlSetTip(-1, "IP addresses comma separated, i.e.  192.168.0.120,192.168.10.12")
	$nInpIP				= CreateCtrlInput("", 88, 50, 290, 20)
		
	CreateCtrlLabel("SubnetMask:", 6, 78, 80, 20)
	GUICtrlSetTip(-1, "SubnetMasks comma separated, i.e.  255.255.255.0,255.255.0.0")
	$nInpSM				= CreateCtrlInput("", 88, 75, 290, 20)
		
	CreateCtrlLabel("Static Gateway:", 6, 103, 80, 20)
	GUICtrlSetTip(-1, "Gateway addresses comma separated, i.e.  192.168.0.1,192.168.10.2")
	$nInpDG				= CreateCtrlInput("", 88, 100, 290, 20)
		
	CreateCtrlLabel("Static DNS:", 6, 128, 80, 20)
	GUICtrlSetTip(-1, "DNS addresses comma separated, i.e.  192.168.0.2,192.168.10.12")
	$nInpDNS			= CreateCtrlInput("", 88, 125, 290, 20)
	
	CreateCtrlLabel("Static WINS:", 6, 153, 80, 20)
	GUICtrlSetTip(-1, "WINS addresses comma separated, i.e.  192.168.0.3,192.168.10.20")
	$nInpWINS			= CreateCtrlInput("", 88, 150, 290, 20)
	
	CreateCtrlLabel("MAC:", 6, 178, 80, 20)
	GUICtrlSetTip(-1, "MAC address in the format: XX-XX-XX-XX-XX-XX")
	$nInpMAC			= CreateCtrlInput("", 88, 175, 290, 20, BitOr($ES_AUTOHSCROLL, $ES_UPPERCASE))
	GUICtrlSetLimit(-1, 17)
	
	CreateCtrlLabel("Filter:", 6, 203, 80, 20)
	GUICtrlSetTip(-1, "Sample: 'devicename::intel||lowerrange::wifi||lowerrange::wireless||devicename::realtek||servicename=rtl8187b'" & @LF & _
						"Means: Network adapter from 'Intel' or 'WiFi'/'Wireless' device or from 'Realtek' or RTL8187B as it's servicename too." & @LF & _
						"The filter string is case sensitive if '==' is used and not case sensitive if '=' is used." & @LF & _
						"A found filter part can contain the filter string if '::' is used." & @LF & _
						"More possibilities are coming soon...")
						
	$nInpFilter			= CreateCtrlInput("", 88, 200, 290, 20)
	
	; *** Sharing GUI ***
	$hSharesGUI			= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	CreateCtrlLabel("Define network shares and PE local user accounts", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	
	$nChkShrAuto		= CreateCtrlCheck("Start file sharing automatically after starting network", 6, 25, 378, 20, $BS_AUTO3STATE, -1, $hSharesGUI)
	GUICtrlSetState(-1, $GUI_INDETERMINATE)
	$nChkShrAll			= CreateCtrlCheck("Share all drives", 6, 45, 378, 20, $BS_AUTO3STATE, -1, $hSharesGUI)
	GUICtrlSetState(-1, $GUI_INDETERMINATE)
	
	CreateCtrlLabel("Accounts to add:", 6, 75, 120, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	CreateCtrlLabel("Username:", 6, 98, 58, 20)
	GUICtrlSetTip(-1, "With this account you can later connect to your PE shares (" & $UNLEN & " chars limit).")	
	$nComboShrUsr		= CreateCtrlCombo("", 88, 95, 290, 40)
	GUICtrlSendMsg(-1, $CB_LIMITTEXT, $UNLEN, 0)
	
	CreateCtrlLabel("Password:", 6, 123, 58, 20)
	GUICtrlSetTip(-1, $PWLEN & " chars limit.")
	$nInpShrPW			= CreateCtrlInput("", 88, 120, 290, 20, BitOr($ES_AUTOHSCROLL, $ES_PASSWORD))
	GUICtrlSetLimit(-1, $PWLEN)
	$nChkShrPW			= CreateCtrlCheck("Show password", 88, 145, 150, 20, -1, -1, $hSharesGUI)
		
	$nBtnAddUser		= CreateODBtn("Add", 242, 145, 65, 22, $arODBtnMain, 5, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnDelUser		= CreateODBtn("Del", 312, 145, 65, 22, $arODBtnMain, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	; *** Network drives GUI ***
	$hDrivesGUI			= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	CreateCtrlLabel("Define network drives and paths to auto connect with", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	
	CreateCtrlLabel("Network path:", 6, 28, 80, 20)
	GUICtrlSetTip(-1, "Predefined network path's comma separated, i.e.  \\server1\share1,\\server2.domain\share2" & @LF & _
						"These path's will appear in the connectable network drives list.")
	$nInpNetPath		=  CreateCtrlInput("", 88, 25, 290, 20)
	
	CreateCtrlLabel("Network drives to map:", 6, 60, 200, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	
	CreateCtrlLabel("Remote path:", 6, 83, 70, 20)
	$nComboDrvPath		= CreateCtrlCombo("", 88, 80, 290, 40)
	GUICtrlSetLimit(-1, $MAX_PATH)
	
	CreateCtrlLabel("Username:", 6, 108, 70, 20)
	$nInpDrvUsr			= CreateCtrlInput("", 88, 105, 290,20)
	
	CreateCtrlLabel("Password:", 6, 133, 70, 20)
	$nInpDrvPW			= CreateCtrlInput("", 88, 130, 290, 20, BitOr($ES_AUTOHSCROLL, $ES_PASSWORD))
	
	CreateCtrlLabel("Drive letter:", 6, 158, 70, 20)
	GUICtrlSetTip(-1, "<*> - automatically select an unused drive letter." & @LF & "< > - do not assign a drive letter.")
	
	$nComboDrv			= CreateCtrlCombo("", 88, 155, 50, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, $sDrvLetters, "*")
	
	CreateCtrlLabel("Current:", 150, 158, 45, 22)
	$nLblDrvLetter		= CreateCtrlLabel("", 196, 155, 30, 22, BitOr($SS_SUNKEN, $SS_CENTERIMAGE, $SS_CENTER))
	
	$nBtnDrvAdd			= CreateODBtn("Add", 242, 155, 65, 22, $arODBtnMain, 5, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnDrvDel			= CreateODBtn("Del", 312, 155, 65, 22, $arODBtnMain, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	$nChkDrvPW			= CreateCtrlCheck("Show password", 88, 180, 290, 20, -1, -1, $hDrivesGUI)
	
	; *** CMD GUI - after starting network ***
	$hCMDStartGUI		= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	
	CreateCtrlLabel("List of commands to run after starting network support", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	GUICtrlSetTip(-1, "Put a command line here which will be executed after network startup." & @LF & _
						"Also % chars are possible (ie. for environment variables)." & @LF & _
						"Sample: %systemroot%\system32\regedit.exe /s %systemroot%\refresh.reg")
							
	$nLVCMDStart		= CreateCtrlListView("Command|Start|Wait", 6, 25, 345, 170)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(220))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(65))
	
	$nBtnCMDStartUp		= CreateODBtn("^", 357, 25, 20, 82, $arODBtnMain, 0, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCMDStartDown	= CreateODBtn("v", 357, 112, 20, 82, $arODBtnMain, 1, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)

	CreateCtrlLabel("Command:", 6, 204, 55, 20)
	$nInpCMDStart		= CreateCtrlInput("", 65, 201, 285, 20)
	
	CreateCtrlLabel("Start it", 6, 230, 53, 20, $SS_RIGHT)
	$nComboStartRun		= CreateCtrlCombo("", 65, 227, 85, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, "Normal|Hidden|Minimized|Maximized", "Hidden")
	
	CreateCtrlLabel("and", 155, 230, 25, 20)
	
	$nComboStartWait	= CreateCtrlCombo("", 180, 227, 70, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, "Wait|Nowait", "Wait")
	
	CreateCtrlLabel("until it's finished.", 255, 230, 250, 20)
	
	$nBtnCMDStartClear	= CreateODBtn("Clear", 6, 262, 65, 22, $arODBtnMain, 7, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCMDStartEdit	= CreateODBtn("Change", 78, 262, 95, 22, $arODBtnMain, 9, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCmdStartAdd	= CreateODBtn("Add", 180, 262, 95, 22, $arODBtnMain, 5, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCmdStartDel	= CreateODBtn("Del", 282, 262, 95, 22, $arODBtnMain, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	; *** CMD GUI - after IP change***
	$hCMDChangeGUI		= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	
	CreateCtrlLabel("List of commands to run after changing IP settings", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	GUICtrlSetTip(-1, "Put a command line here which will be executed after IP changing." & @LF & _
						"Also % chars are possible (ie. for environment variables)." & @LF & _
						"Sample: %systemroot%\system32\regedit.exe /s %systemroot%\refresh.reg")
							
	$nLVCMDChange		= CreateCtrlListView("Command|Start|Wait", 6, 25, 345, 170)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(220))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(65))
	
	$nBtnCMDChangeUp	= CreateODBtn("^", 357, 25, 20, 82, $arODBtnMain, 0, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCMDChangeDown	= CreateODBtn("v", 357, 112, 20, 82, $arODBtnMain, 1, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	CreateCtrlLabel("Command:", 6, 204, 55, 20)
	$nInpCMDChange		= CreateCtrlInput("", 65, 201, 285, 20)

	CreateCtrlLabel("Start it", 6, 230, 53, 20, $SS_RIGHT)
	$nComboChangeRun	= CreateCtrlCombo("", 65, 227, 85, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, "Normal|Hidden|Minimized|Maximized", "Hidden")
	
	CreateCtrlLabel("and", 155, 230, 25, 20)
	
	$nComboChangeWait	= CreateCtrlCombo("", 180, 227, 70, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, "Wait|Nowait", "Wait")

	CreateCtrlLabel("until it's finished.", 255, 230, 250, 20)
	
	$nBtnCMDChangeClear	= CreateODBtn("Clear", 6, 262, 65, 22, $arODBtnMain, 7, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCmdChangeChg	= CreateODBtn("Change", 78, 262, 95, 22, $arODBtnMain, 9, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCmdChangeAdd	= CreateODBtn("Add", 180, 262, 95, 22, $arODBtnMain, 5, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnCmdChangeDel	= CreateODBtn("Del", 282, 262, 95, 22, $arODBtnMain, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	; *** Color schemes GUI ***
	$hSchemesGUI		= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	
	CreateCtrlLabel("Change the color scheme for the UI", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	
	Local $nBtnXS	= GetScaled(6)
	Local $nBtnYS	= GetScaled(25)
	Local $nBtnHS	= GetScaled(25)
	Local $nBtnLS	= GetScaled(100)
	Local $nXS		= $nBtnXS + $nBtnLS - 1
	Local $nYS		= GetScaled(70)
	Local $nRS		= GetScaled(376)
	Local $nBS		= GetScaled(184)
	Local $nBS2		= GetScaled(148)
	
	$nTIConf		= CreateODTab($hSchemesGUI, $sTIConfig, $nBtnXS, $nBtnYS, $nBtnLS, $nBtnHS, $arODBtnMain, 0, FALSE, -1, -1, 1)
	$nBtnYS += $nBtnHS - 1
	$nTIIdent		= CreateODTab($hSchemesGUI, $sTIIdent, $nBtnXS, $nBtnYS, $nBtnLS, $nBtnHS, $arODBtnMain, 1, FALSE, -1, -1, 1)
	$nBtnYS += $nBtnHS
	
	GUICtrlSendMsg($nTIConf, $BM_SETSTATE, TRUE, 0)
	$nLastItemGUI = $nTIConf
	
	$nFrmBkMain1		= GUICtrlCreateLabel("", $nBtnXS, $nBtnYS, 1, $nBS - $nBtnYS) ; Left Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	$nFrmBkMain2		= GUICtrlCreateLabel("", $nBtnXS + $nBtnLS, $nBtnHS, $nRS - $nBtnXS - $nBtnLS, 1) ; Top Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	$nFrmBkMain3		= GUICtrlCreateLabel("", $nBtnXS, $nBS, $nRS - $nBtnXS + 1, 1) ; Bottom Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	$nFrmBkMain4		= GUICtrlCreateLabel("", $nBtnXS + $nBtnLS - 1, $nBtnYS, 1, $nBS2 - $nBtnYS + 1) ; Left tab side main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)	
	$nFrmBkMain5		= GUICtrlCreateLabel("", $nBtnXS + $nBtnLS, $nBS2, $nRS - $nBtnXS - $nBtnLS, 1) ; Bottom tab side main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)	
	$nFrmBkMain6		= GUICtrlCreateLabel("", $nRS, $nBtnHS, 1, $nBS - $nBtnHS) ; Right Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	
	$nLblBkMain1	= GUICtrlCreateLabel("", $nBtnXS + 1, $nBtnYS, $nBtnLS - 2, $nBS - $nBtnYS) ; Left side back main
	GUICtrlSetBkColor(-1, $nClrGUIBkMain)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nLblBkMain2	= GUICtrlCreateLabel("", $nBtnXS + $nBtnLS - 1, $nBS2 + 1, _
												$nRS - $nBtnXS - $nBtnLS + 1, $nBS - $nBS2 - 1) ; Right side back main
	GUICtrlSetBkColor(-1, $nClrGUIBkMain)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nLblStateMain		= CreateCtrlLabel("Ready.", 12, 160, 35, 18)
	GUICtrlSetBkColor(-1, $nClrGUIBkMain)
	$nLblStateProgress	= CreateCtrlLabel("Search...", 50, 160, 50, 18)
	GUICtrlSetBkColor(-1, $nClrGUIBkMain)
	
	$nLblConfBk1	= GUICtrlCreateLabel("", $nBtnXS + $nBtnLS, $nBtnHS + 1, $nRS - $nBtnXS - $nBtnLS, $nBS2 - $nBtnHS - 1) ; Back properties
	GUICtrlSetBkColor(-1, $nClrGUIBk)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nLblDefault	= CreateCtrlLabel("State:", 248, 57, 27, 18)
	$nLblSrvStart	= CreateCtrlLabel("Started", 280, 56, 45, 16, BitOr($SS_CENTER, $SS_CENTERIMAGE, $SS_SUNKEN))
	GUICtrlSetBkColor(-1, $nClrSvcStart)
	$nLblSrvStop	= CreateCtrlLabel("Stopped", 325, 56, 45, 16, BitOr($SS_CENTER, $SS_CENTERIMAGE, $SS_SUNKEN))
	GUICtrlSetBkColor(-1, $nClrSvcStop)
		
	$nBtnSchemeRefClr	= CreateODBtn(">", 112, 30, 22, 20, $arODBtnMain, 7, TRUE)
	
	CreateCtrlCombo("", 140, 30, 230, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, "Network Adapter", "Network Adapter")
	
	$nBtnXS	= GetScaled(112)
	$nBtnYS	= GetScaled(55)
	$nBtnHS	= GetScaled(23)
	$nBtnLS	= GetScaled(63)
	$nXS	= GetScaled(6)
	$nRS	= GetScaled(368)
	$nLS	= GetScaled(257)
	$nYS	= GetScaled(140)
	
	$nFrmBkConf1		= GUICtrlCreateLabel("", $nBtnXS, $nBtnYS + $nBtnHS, 1, $nYS - $nBtnYS - $nBtnHS) ; Left properties
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	$nFrmBkConf2		= GUICtrlCreateLabel("", $nBtnXS, $nBtnYS + $nBtnHS - 1, $nLS, 1) ; Top properties
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	$nFrmBkConf3		= GUICtrlCreateLabel("", $nBtnXS, $nYS, $nLS, 1) ; Bottom properties
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	$nFrmBkConf4		= GUICtrlCreateLabel("", $nLS + $nBtnXS - 1, $nBtnYS + $nBtnHS, 1, $nYS - $nBtnYS - $nBtnHS) ; Right properties
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	
	$nTIIP		= CreateODTab($hSchemesGUI, "IP settings", $nBtnXS, $nBtnYS, $nBtnLS, $nBtnHS, $arODBtnMain, -1, FALSE, -1, -1, 2)
	$nTIWiFi	= CreateODTab($hSchemesGUI, "WiFi", $nBtnXS + $nBtnLS + $nXS, $nBtnYS, GetScaled(58), $nBtnHS, $arODBtnMain, 7, FALSE, -1, -1, 2)
	
	$nLastItemConf = $nTIIP
	
	$nLblIPBk		= GUICtrlCreateLabel("", $nBtnXS + 1, $nBtnYS + $nBtnHS, $nLS - 2, $nYS - $nBtnYS - $nBtnHS) ; Back IP settings
	GUICtrlSetBkColor(-1, $nClrGUIBkConf)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nLblConf		= CreateCtrlLabel("IP Address:", 135, 116, 80, 18)
	GUICtrlSetBkColor(-1, $nClrGUIBkConf)
	$hIP			= GUICtrlCreateIPAddr(240, 113, 120, 21, $hSchemesGUI, $hGlobalFont)
	SetAddress($hIP, "192.168.40.65")

	$nBtnXS	= GetScaled(119)
	$nBtnYS	= GetScaled(85)
	$nBtnHS	= GetScaled(23)
	$nBtnLS	= GetScaled(110)
	$nXS	= GetScaled(6)
	$nRS	= GetScaled(243)
	$nYS	= GetScaled(133)
	
	$nLblBkWiFi		= GUICtrlCreateLabel("", $nBtnXS + 1, $nBtnYS + $nBtnHS, $nRS - 1, $nYS - $nBtnYS - $nBtnHS) ; WiFi back
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFi)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nFrmBkWiFi1	= GUICtrlCreateLabel("", $nBtnXS, $nBtnYS + $nBtnHS - 1, $nRS, 1) ; Top
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nFrmBkWiFi2	= GUICtrlCreateLabel("", $nBtnXS, $nBtnYS + $nBtnHS, 1, $nYS - $nBtnYS - $nBtnHS) ; Left
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nFrmBkWiFi3	= GUICtrlCreateLabel("", $nBtnXS, $nYS, $nRS + 1, 1) ; Bottom
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nFrmBkWiFi4	= GUICtrlCreateLabel("", $nRS + $nBtnXS, $nBtnYS + $nBtnHS - 1, 1, $nYS - $nBtnYS - $nBtnHS + 1) ; Right
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	GUICtrlSetState(-1, $GUI_DISABLE)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nTIWiFiAV		= CreateODTab($hSchemesGUI, "Available Networks", $nBtnXS, $nBtnYS, $nBtnLS, $nBtnHS, $arODBtnMain, -1, FALSE, -1, -1, 3)
	SetODBtnState($nTIWiFiAV, $GUI_HIDE, FALSE)
	$nTIWiFiPref	= CreateODTab($hSchemesGUI, "Preferred Networks", $nBtnXS + $nBtnLS + $nXS, $nBtnYS, $nBtnLS, $nBtnHS, $arODBtnMain, -1, FALSE, -1, -1, 3)
	SetODBtnState($nTIWiFiPref, $GUI_HIDE, FALSE)
	
	$nLastItemWiFi = $nTIWiFiAV
	
	$nLblWiFi		= CreateCtrlLabel("Use OS WiFi profile UI", 126, 115, 110, 16)
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFi)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nRadIPDHCP		= CreateCtrlRadio("Obtain IP automatically", 119, 85, 160, 21, $WS_GROUP, -1, $hSchemesGUI); $arODBtnMain, -1, FALSE, $nClrBtnChkTxt, $nClrBtnChkBk, -1, $nClrBtnChkGrad)
	GUICtrlSetBkColor(-1, $nClrGUIBkConf)
	$nBtnDhcpInfo	= CreateODBtn("?", 280, 85, 21, 21, $arODBtnMain, 28, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, "DHCP info")
	$nBtnDhcpRelease	= CreateODBtn("->", 300, 85, 21, 21, $arODBtnMain, 4, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, "Release")
	$nBtnDhcpRenew	= CreateODBtn("+", 320, 85, 21, 21, $arODBtnMain, 7, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, "Renew")
	$nBtnIPAltShow	= CreateODBtn("-", 340, 85, 21, 21, $arODBtnMain, 19, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, "Alternate configuration")
	;$nBtnIPAuto	= CreateODBtn("IP auto", 285, 113, 77, 21, $arODBtnMain, -1, FALSE, $nClrBtnUnchkTxt, $nClrBtnUnchkBk, -1, $nClrBtnUnchkGrad)
	
	$nBtnSchemeApply = CreateODBtn("Apply", 105, 156, 80, 20, $arODBtnMain, 4)
	$nBtnSchemeOK	= CreateODBtn("OK", 192, 156, 85, 20, $arODBtnMain, 2)
	$nBtnSchemeClose = CreateODBtn("Close", 284, 156, 85, 20, $arODBtnMain, 3)
	
	CreateCtrlLabel("Element:", 6, 210, 45, 18)
	$nComboElement	= CreateCtrlCombo("", 60, 207, 195, 100, BitOr($CBS_DROPDOWNLIST, $CBS_SORT, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	
	$nLblSchemeTxt	= CreateCtrlLabel("Text:", 261, 190, 40, 17)
	$nLblSchemeBk1	= CreateCtrlLabel("Back1:", 301, 190, 40, 17)
	$nLblSchemeBk2	= CreateCtrlLabel("Back2:", 343, 190, 40, 17)
	
	$nBtnSchemeTxt	= CreateODBtn("", 261, 207, 34, 20, $arODBtnMain, -1, FALSE, -1, -1, 4)
	$nBtnSchemeBk1	= CreateODBtn("", 302, 207, 34, 20, $arODBtnMain, -1, FALSE, -1, -1, 4)
	$nBtnSchemeBk2	= CreateODBtn("", 343, 207, 34, 20, $arODBtnMain, -1, FALSE, -1, -1, 4)
	
	ProfileRstClr()
	
	CreateCtrlLabel("Scheme:", 6, 236, 45, 18)
	$nComboScheme	= CreateCtrlCombo("", 60, 233, 195, 40)
	
	$nBtnSchemeRef	= CreateODBtn("Reload", 6, 262, 65, 22, $arODBtnMain, 7, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	GUICtrlSetTip(-1, "Reload scheme colors")
	$nBtnSchemeDef	= CreateODBtn("Set default", 78, 262, 95, 22, $arODBtnMain, 2, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	GUICtrlSetTip(-1, "Set selected scheme as default color scheme")
	$nBtnSchemeSave	= CreateODBtn("Save", 180, 262, 95, 22, $arODBtnMain, 4, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnSchemeDel	= CreateODBtn("Del", 282, 262, 95, 22, $arODBtnMain, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	
	; *** WiFi GUI ***
	$hWiFiGUI		= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	GUISetBkColor($nClrBkSub)
	CreateCtrlLabel("WiFi profiles are automatically added if a WiFi adapter exists", 6, 5, 375, 20)
	GUICtrlSetFont(-1, 8.5, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	
	$nLVWLPref		= CreateCtrlListView("SSID", 6, 25, 345, 124)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(315))	; SSID
	;GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, 60)	; Mode
	;GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 2, 70)	; Security
	
	$nBtnWiFiUp		= CreateODBtn("^", 357, 25, 20, 58, $arODBtnMain, 0, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	SetODBtnState($nBtnWiFiUp, $GUI_DISABLE, FALSE)
	$nBtnWiFiDown	= CreateODBtn("v", 357, 90, 20, 58, $arODBtnMain, 1, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	SetODBtnState($nBtnWiFiDown, $GUI_DISABLE, FALSE)
	
	Local $i, $sAuthData = "|"
	
	For $i = 0 To 8
		If $arAuthType[$i][0] <> "" Then
			If StringInStr($arAuthType[$i][2], "WPA") And Not StringInStr($arAuthType[$i][2], "PSK") Then ContinueLoop
			
			$sAuthData &= $arAuthType[$i][2] & "|"
		EndIf
	Next
	
	Local $sAuthDataDef = $arAuthType[0][2]
	
	CreateCtrlLabel("SSID:", 6, 158, 30, 20)
	$nInpSSID		= CreateCtrlInput("", 40, 155, 190, 20)
	
	CreateCtrlLabel("Type:", 248, 158, 30, 20)
	$nComboAuth		= CreateCtrlCombo("", 283, 155, 95, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, $sAuthData, $sAuthDataDef)
	
	CreateCtrlLabel("Key:", 6, 183, 30, 20)
	$nInpKey		= CreateCtrlInput("", 40, 180, 190, 20, BitOr($ES_AUTOHSCROLL, $ES_PASSWORD))
	$nChkKey		= CreateCtrlCheck("Show key", 40, 205, 120, 20, -1, -1, $hWiFiGUI)
	
	CreateCtrlLabel("Enc:", 248, 183, 30, 20)
	$nComboEnc		= CreateCtrlCombo("", 283, 180, 95, 40, $CBS_DROPDOWNLIST)
	
	GetAuthEnc(GUICtrlRead($nComboAuth))
	
	$nChkAuto		= CreateCtrlCheck("Auto connect", 6, 228, 95, 20, 0x1000)
	$nChkHidden		= CreateCtrlCheck("Connect nonbroadcasting", 105, 228, 162, 20, 0x1000)
	$nChkAdhoc		= CreateCtrlCheck("Adhoc network", 271, 228, 107, 20, 0x1000)
	
	$nBtnWiFiClear	= CreateODBtn("Clear", 6, 262, 65, 22, $arODBtnMain, 7, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnWiFiChg	= CreateODBtn("Change", 78, 262, 95, 22, $arODBtnMain, 9, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	SetODBtnState($nBtnWiFiChg, $GUI_DISABLE, FALSE)
	$nBtnWiFiAdd	= CreateODBtn("Add", 180, 262, 95, 22, $arODBtnMain, 5, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	$nBtnWiFiDel	= CreateODBtn("Del", 282, 262, 95, 22, $arODBtnMain, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	SetODBtnState($nBtnWiFiDel, $GUI_DISABLE, FALSE)
	
	; *** Preview GUI ***
	$hPrevGUI			= GUICreate("", $nR - $nX - 1, $nB - $nY - 1, $nX + 1, $nY + 1, BitOr($WS_CHILD, $WS_TABSTOP, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN), $WS_EX_CONTROLPARENT, $hPCG)
	GUISetBkColor($nClrBkSub)
	CreateCtrlLabel("The preview depends on the selected options and color scheme", 5, 5, 375, 20)
	GUICtrlSetFont(-1, $nGlobalFontSize, 600)
	;GUICtrlSetColor(-1, 0xC00000)
	
	$hPrevBkGUI			= CreateGUI("", 370, 257, 6, 25, BitOr($WS_BORDER, $WS_CHILD, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN), $WS_EX_CONTROLPARENT, $hPrevGUI)
	GUISetBkColor(0x3A6EA5)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hPrevBkGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	Local $LVS_ALIGNLEFT = 0x0800
	$nLVPrev			= CreateCtrlListView("", -2, -2, 374, 234)
	GUICtrlSetStyle(-1, BitOr($LVS_ICON, $LVS_ALIGNLEFT, $LVS_NOSCROLL, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN), 0)
	GUICtrlSetBkColor(-1, 0x3A6EA5)
	GUICtrlSetColor(-1, 0xFFFFFF)
	
	Local $LVS_EX_HEADERDRAGDROP = 0x00000010
	Local $LVS_EX_DOUBLEBUFFER = 0x00010000
	Local $LVS_EX_SNAPTOGRID = 0x00080000
	
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_FULLROWSELECT, $LVS_EX_FULLROWSELECT)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_SNAPTOGRID, $LVS_EX_SNAPTOGRID)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_HEADERDRAGDROP, $LVS_EX_HEADERDRAGDROP)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_DOUBLEBUFFER, $LVS_EX_DOUBLEBUFFER)

	Local $hILLV = ImageList_Create($nIconSizeBig, $nIconSizeBig, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	GUICtrlSendMsg(-1, $LVM_SETIMAGELIST, 0, $hILLV)
	
	AddILIcon($hILLV, 15, 16, "", "shell32.dll", FALSE)
	
	If $bIconLib Then
		AddILIcon($hILLV, 4, 4, "", $sIconLib, FALSE)
	Else
		AddILIcon($hILLV, 0, 0, "", @AutoItExe, FALSE)
	EndIf
	
	CreateAdvLVItem("Computer", $nLVPrev, "", 0, FALSE)
	CreateAdvLVItem("PEnetwork", $nLVPrev, "", 1, FALSE)
	If FileExists(@WindowsDir & "\Explorer.exe") Then
		AddILIcon($hILLV, 0, 1, "", @WindowsDir & "\Explorer.exe", FALSE)
		CreateAdvLVItem("Explorer", $nLVPrev, "", 2, FALSE)
	ElseIf FileExists(@SystemDir & "\cmd.exe") Then
		AddILIcon($hILLV, 0, 1, "", @WindowsDir & "\cmd.exe", FALSE)
		CreateAdvLVItem("CMD", $nLVPrev, "", 2, FALSE)
	EndIf
	
	Local $arPos = WinGetPos($hPrevBkGUI)
	GetScaledPos($arPos, 2)
	CreateCtrlLabel("", -1, $arPos[3] - 28, $arPos[2] + 1, GetScaled(30))
	GUICtrlSetBkColor(-1, GetBGRColor(GetSysColor($COLOR_BTNFACE)))
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nBtnPrevStart		= CreateCtrlButton("Start", 3, 233, 56, 21)
	SetWindowTheme(GUICtrlGetHandle($nBtnPrevStart), " ", " ")
	GUICtrlSetFont(-1, 8.5, 600)
	
	SetBtnImage($nBtnPrevStart, 52, -223)
	
	$nLblPrevTime		= CreateCtrlLabel(@Hour & ":" & @Min & "  ", 302, 233, 65, 22)
	GUICtrlSetStyle(-1, $SS_OWNERDRAW)
	
	$nIconTray			= GUICtrlCreateLabel("", GetScaled(307), GetScaled(236), $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, $SS_OWNERDRAW)
	
	$hPrevBlackGUI		= CreateGUI("", 370, 257, 6, 25, BitOr($WS_BORDER, $WS_CHILD, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN), $WS_EX_CONTROLPARENT, $hPrevGUI)
	GUISetBkColor(0x0)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hPrevBkGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	CreateCtrlLabel("Windows PE", 110, 120, 150, 40)
	GUICtrlSetColor(-1, 0xFFFFFF)
	GUICtrlSetFont(-1, 20, 400)
	
	GUISetState()
	
	GUISwitch($hPCG)
	
	$hLastConfGUI = $hGlobalGUI
	
	Local $Msg = 0
	Local $sFile = "", $sLine
	Local $arSection, $i, $nLen, $stText, $nCount
	Local $nState, $nCol, $nClr
	Local $nIdxE = -1
	Local $nID, $bBtnOK, $nResult
		
	ProfileLoadList($sProfFile)
	ProfileDisableControls()
	
	If FileExists($sProfFile) Then ProfileOpen($sProfFile, $sProfile)
	
	GUIRegisterMsg($WM_COMMAND, "WndProcEditor")
	GUIRegisterMsg($WM_NOTIFY, "WndProcEditor")
	GUIRegisterMsg($WM_PAINT, "WndProcEditor")
	GUIRegisterMsg($WM_VSCROLL, "WndProc")
	GUIRegisterMsg($WM_SETCURSOR, "WndProcEditor")
	GUIRegisterMsg($WM_MOUSEWHEEL, "WndProcEditor")
	
	If $bSaveWinPos Then SetWinPos($hPCG, $sGURegKey & "\Editor", GetScaled(535), GetScaled(420), 40)
	
	SetODBtnState($nBtnExit, $GUI_FOCUS, FALSE)
	
	GUISetState(@SW_SHOW, $hPCG)
	
	Do	
		While 1
			If $bPrevStartup Then
				If $bUseStartCount Then
					If $nStartCount < 1 Then
						$bUseStartCount = FALSE
						If $bFocusNo Then
							PostMessage($hPCG, $WM_COMMAND, $nBtnNo, GUICtrlGetHandle($nBtnNo))
						Else
							PostMessage($hPCG, $WM_COMMAND, $nBtnYes, GUICtrlGetHandle($nBtnYes))
						EndIf
					EndIf
				EndIf
			EndIf
			
			If $bPrevProfiles Then
				If $bUseProfileCount Then
					If $nProfileCount < 1 Then
						$bUseProfileCount = FALSE
						PostMessage($hPCG, $WM_COMMAND, $nBtnOK, GUICtrlGetHandle($nBtnOK))
					EndIf
				EndIf
			EndIf
			
			If $bPrevInstStarted Then
				If $nInstTimeCount < 1 Then
					$bPrevInstStarted = FALSE
					
					If $nStartMode > 0 Then
						GUICtrlDelete($nIconInst)
						GUICtrlDelete($nLblInstTitle)
						GUICtrlDelete($nLblInstLine)
						GUICtrlDelete($nLblStartTxt)
						GUICtrlDelete($nPrgrStart)
						GUICtrlDelete($nLblInst)
						InvalidateRect($hPrevBkGUI, 0, TRUE)
					EndIf
					
					If $bShowMainGUI Or $bShowTrayAct Or $bMinToTray Then
						ShowPrevPENM()
					Else
						StartPrevDemo()
					EndIf
				EndIf
			EndIf
			
			$arMsg = GUIGetMsg(1)
			$Msg = $arMsg[0]
			If $Msg = 0 Then ContinueLoop
			
			Switch $Msg
				Case $GUI_EVENT_CLOSE, $nBtnExit, $nMIExit
					Switch $arMsg[1]
						Case $hPCG
							ProfileSaveList()
							$sLine = GUICtrlRead($nComboProfiles)
							RegWrite($sGURegKey & "\Editor", "LastProfile", "REG_SZ", $sLine)
							If $bSaveWinPos Then SaveWinPos($hPCG, $sGURegKey & "\Editor")
							ExitLoop
							
						Case $hSubGUI
							If $hSubGUI <> 0 Then
								GUISetState(@SW_ENABLE, $hPCG)
								GUIDelete($hSubGUI)
								DelODBtnGrp($arODBtnSub)
								$hSubGUI = 0
								$nBtnSubOK = 0
								$nBtnSubCancel = 0
								
								If $nSubType = 0 Then
									$nBtnAddrUp = 0
									$nBtnAddrDown = 0
									$nBtnRename = 0
									$nBtnAdd = 0
									$nBtnDel = 0
									$nBtnCopy = 0
								EndIf
							EndIf
							
						Case $hAboutGUI
							GUISetState(@SW_ENABLE, $hPCG)
							GUISetState(@SW_HIDE, $hAboutGUI)						
					EndSwitch
					
				Case $GUI_EVENT_MINIMIZE
					If $hPSG <> 0 And $arMsg[1] = $hPSG Then GUISetState(@SW_RESTORE, $hPSG)				
				
				Case $nBtnProfFile, $nMIProfOpen
					If ProfileCheckChanges() <> 3 Then
						$sFile = FileOpenDialog("Select config file to open", $sProfPath, "Config files (*.ini)|Text files (*.*)", 8, "PENetwork.ini", $hPCG)
						If Not @Error Then
							
							If FileGetSize($sFile) = 0 Then
								Local $hFile = FileOpen($sFile, 34) ; Open as Unicode + Erase
								If $hFile <> -1 Then FileClose($hFile)
							EndIf
							
							ProfileOpen($sFile)
						EndIf
					EndIf
					
				Case $nBtnProfExt, $nMIProfOpenExt
					$sFile = GUICtrlRead($nInpProfFile)
					If FileExists($sFile) Then ShellExecute($sFile, "", "", "open")
				
				Case $nBtnProfClean
					If MsgBoxEx(36, "Clean list?", "Are you sure you want to clean the list of last open config files?", $hPCG) = 6 Then
						$sFile = GUICtrlRead($nInpProfFile)
						If $sFile <> "" And FileExists($sFile) Then
							GUICtrlSetData($nInpProfFile, "|" & $sFile, $sFile)
							GUICtrlSetTip($nInpProfFile, $sFile)
						Else
							GUICtrlSetData($nInpProfFile, "|")
							GUICtrlSetTip($nInpProfFile, "")
						EndIf
						
						RegDelete($sGURegKey & "\Editor\MRU")
					EndIf
				
				Case $nBtnProfNew, $nMIProfNew
					If ProfileCheckChanges() <> 3 Then
						$sFile = FileSaveDialog("Create new config file", "", "Config files (*.ini)", 16, "PENetwork.ini", $hPCG)
						If Not @Error Then
							Local $hFile = FileOpen($sFile, 34) ; Open as Unicode + Erase
							If $hFile <> -1 Then FileClose($hFile)
							
							ProfileOpen($sFile)
						EndIf
					EndIf
				
				Case $nBtnLoad, $nMILoad
					ProfileCheckChanges()
					If $bIniOK Then ProfileOpen($sPENMini)		
				
				Case $nBtnAdd
					ProfileAddProfile(GUICtrlRead($nInpProfile), FALSE)
					CheckListButton()
				
				Case $nBtnDel
					ProfileDelProfile(GUICtrlRead($nListAddr), TRUE)
					CheckListButton()
					
				Case $nBtnCopy
					ProfileCopyProfile(GUICtrlRead($nListAddr), TRUE)
					CheckListButton()
						
				Case $nBtnAddAdapter
					If $bIniOK And GUICtrlRead($nComboProfiles) <> "" Then _
						ProfileAddShowMenu($hPCG, $nBtnAddAdapter, $nDmyAddCon)
						
				Case $nBtnDelAdapter
					ProfileDelAdapter(GUICtrlRead($nComboProfiles), GUICtrlRead($nComboNA))
						
				Case $nAddNA1, $nAddNA2, $nAddNA3, $nAddNA4, $nAddNA5, $nAddNA6
					ProfileAddAdapter(GUICtrlRead($nComboProfiles), $Msg)
					
				Case $nBtnSave, $nMISave
					ProfileSave(TRUE)
					
				Case $nMISaveAs
					ProfileSaveAs()
				
				Case $nComboProfiles
					$sLine = GUICtrlRead($nComboProfiles)
					If $sLine <> "" Then
						SetODBtnState($nBtnProfDel, $GUI_ENABLE)
						SetODBtnState($nBtnProfCopy, $GUI_ENABLE)
					EndIf
					
					If $sLine <> $sCurProfile Then ProfileGetParams(GUICtrlRead($nComboProfiles))
					
				Case $nListAddr
					CheckListButton()
				
				Case $nBtnAddrUp
					MoveListData($nListAddr, TRUE)
					CheckListButton()
					
				Case $nBtnAddrDown
					MoveListData($nListAddr)
					CheckListButton()
					
				Case $nBtnCMDStartAdd
					ProfileCMDAdd($nLVCMDStart, GUICtrlRead($nInpCMDStart), _
						GUICtrlRead($nComboStartRun), GUICtrlRead($nComboStartWait), $nInpCMDStart)
					ChkListBtnCtrl($nLVCMDStart, $nBtnCMDStartUp, $nBtnCMDStartDown, TRUE, FALSE)
				
				Case $nBtnCMDStartEdit
					ProfileCMDEdit($nLVCMDStart, GUICtrlRead($nInpCMDStart), _
						GUICtrlRead($nComboStartRun), GUICtrlRead($nComboStartWait), $nInpCMDStart)
				
				Case $nBtnCMDStartDel
					ProfileCMDDel($nLVCMDStart)
					
				Case $nBtnCMDStartUp
					MoveListData($nLVCMDStart, TRUE, TRUE)
					ChkListBtnCtrl($nLVCMDStart, $nBtnCMDStartUp, $nBtnCMDStartDown, TRUE)
				
				Case $nBtnCMDStartDown
					MoveListData($nLVCMDStart, FALSE, TRUE)
					ChkListBtnCtrl($nLVCMDStart, $nBtnCMDStartUp, $nBtnCMDStartDown, TRUE)
				
				Case $nBtnCMDStartClear
					GUICtrlSetData($nInpCMDStart, "")
					GUICtrlSetData($nComboStartRun, "|Normal|Hidden|Minimized|Maximized", "Hidden")
					GUICtrlSetData($nComboStartWait, "|Wait|Nowait", "Wait")
	
				Case $nBtnCMDChangeAdd
					ProfileCMDAdd($nLVCMDChange, GUICtrlRead($nInpCMDChange), _
						GUICtrlRead($nComboChangeRun), GUICtrlRead($nComboChangeWait), $nInpCMDChange)
					ChkListBtnCtrl($nLVCMDChange, $nBtnCMDChangeUp, $nBtnCMDChangeDown, TRUE, FALSE)			
			
				Case $nBtnCMDStartEdit
					ProfileCMDEdit($nLVCMDChange, GUICtrlRead($nInpCMDChange), _
						GUICtrlRead($nComboChangeRun), GUICtrlRead($nComboChangeWait), $nInpCMDChange)
						
				Case $nBtnCMDChangeDel
					ProfileCMDDel($nLVCMDChange)
				
				Case $nBtnCMDChangeUp
					MoveListData($nLVCMDChange, TRUE, TRUE)
					ChkListBtnCtrl($nLVCMDChange, $nBtnCMDChangeUp, $nBtnCMDChangeDown, TRUE)
				
				Case $nBtnCMDChangeDown
					MoveListData($nLVCMDChange, FALSE, TRUE)
					ChkListBtnCtrl($nLVCMDChange, $nBtnCMDChangeUp, $nBtnCMDChangeDown, TRUE)
				
				Case $nBtnCMDChangeClear
					GUICtrlSetData($nInpCMDChange, "")
					GUICtrlSetData($nComboChangeRun, "|Normal|Hidden|Minimized|Maximized", "Hidden")
					GUICtrlSetData($nComboChangeWait, "|Wait|Nowait", "Wait")
					
				Case $nComboNA
					ProfileGetParams(GUICtrlRead($nComboProfiles), GUICtrlRead($nComboNA))
					
				Case $nBtnRename
					ProfileRenameProfile(GUICtrlRead($nListAddr), GUICtrlRead($nInpProfile))
					
				Case $nBtnAddUser
					ProfileAddShrUsr(GUICtrlRead($nComboShrUsr), GUICtrlRead($nInpShrPW))
				
				Case $nBtnDelUser
					ProfileDelShrUsr(GUICtrlRead($nComboShrUsr))
				
				Case $nComboShrUsr
					ProfileShowShrPW(GUICtrlRead($nComboShrUsr))
				
				Case $nBtnDrvAdd
					ProfileAddNetDrv(GUICtrlRead($nComboDrvPath), _
									GUICtrlRead($nInpDrvUsr), _
									GUICtrlRead($nInpDrvPW), _
									GUICtrlRead($nComboDrv))
				
				Case $nBtnDrvDel
					ProfileDelNetDrv(GUICtrlRead($nComboDrvPath))
					
				Case $nComboDrvPath
					ProfileShowDrvInfo(GUICtrlRead($nComboDrvPath))
				
				Case $nComboElement
					$nIdxE = -1
					$nCmbElementLast = -1
					
					For $i = 0 To 46
						If $arClr[$i][0] = GUICtrlRead($nComboElement) Then
							$nIdxE = $i
							ExitLoop
						EndIF
					Next
					
					If $nIdxE > -1 Then
						ProfileSetClr($nIdxE, 2)
						ProfileSetClr($nIdxE, 3)
						ProfileSetClr($nIdxE, 4)
					EndIf
					
				Case $nBtnSchemeTxt, $nBtnSchemeBk1, $nBtnSchemeBk2
					If $Msg = $nBtnSchemeTxt Then
						$nCol = 2
					ElseIf $Msg = $nBtnSchemeBk1 Then
						$nCol = 3
					Else
						$nCol = 4
					EndIf
					
					$nIdxE = -1
					For $i = 0 To 46
						If $arClr[$i][0] = GUICtrlRead($nComboElement) Then
							$nIdxE = $i
							ExitLoop
						EndIF
					Next
					
					If $nIdxE > -1 Then
						If $arClr[$nIdxE][5] Then
							$arClr[$nIdxE][$nCol] = ProfileClrDlg($arClr[$nIdxE][$nCol])
							SetODBtnData($Msg, "", -1, GetBGRColor($arClr[$nIdxE][$nCol]), TRUE)
						Else
							$arClr[$nIdxE][$nCol] = GetBGRColor(ProfileClrDlg(GetBGRColor($arClr[$nIdxE][$nCol])))
							SetODBtnData($Msg, "", -1, $arClr[$nIdxE][$nCol], TRUE)
						EndIf
						
						ArClr2Val()
						ProfileUpdClrIdx($nIdxE, $nCol)
						
						GUISetBkColor(-1, $hSchemesGUI)
					EndIf
					
					If $hPSG <> 0 And $bPrevStarted Then StartPrevDemo()
					
				Case $nBtnSchemeRef
					ProfileReadScheme(GUICtrlRead($nComboScheme))
					ProfileRstClr()
					
				Case $nBtnSchemeDef
					;ProfileSaveScheme(GUICtrlRead($nComboScheme), FALSE)
					$sLine = GUICtrlRead($nComboScheme)
					IniWrite($sPENMini, "Schemes", "Default", $sLine)
					If $sLine <> "" Then MsgBoxEx(64, $sInfo, "The color scheme """ & $sLine & """ was set as default scheme.")
					
				Case $nBtnSchemeSave
					ProfileSaveScheme(GUICtrlRead($nComboScheme))
					
				Case $nBtnSchemeDel
					ProfileDelScheme(GUICtrlRead($nComboScheme))
				
				Case $nComboScheme
					ProfileReadScheme(GUICtrlRead($nComboScheme))
					ProfileRstClr()
					If $hPSG <> 0 And $bPrevStarted Then StartPrevDemo()
				
				Case $nComboAuth
					GetAuthEnc(GUICtrlRead($nComboAuth))
		
				Case $nComboEnc
					SetEncState(GUICtrlRead($nComboAuth), GUICtrlRead($nComboEnc))
			
				Case $nBtnWiFiChg
					ProfileWiFiAdd(TRUE)
					
				Case $nBtnWiFiAdd
					ProfileWiFiAdd()
					
				Case $nBtnWiFiDel
					ProfileWiFiDel()
				
				Case $nBtnWiFiClear
					ProfileWiFiClear()
				
				Case $nBtnWiFiUp
					MoveListData($nLVWLPref, TRUE, TRUE)
					ChkListBtnCtrl($nLVWLPref, $nBtnWiFiUp, $nBtnWiFiDown, TRUE)
					$bWiFiChanged = TRUE
				
				Case $nBtnWiFiDown
					MoveListData($nLVWLPref, FALSE, TRUE)
					ChkListBtnCtrl($nLVWLPref, $nBtnWiFiUp, $nBtnWiFiDown, TRUE)
					$bWiFiChanged = TRUE
				
				Case $nTIGlobal
					If $hLastConfGUI <> $hGlobalGUI Then SwitchConfGUI($hGlobalGUI)
					
				Case $nTIDesc
					If $hLastConfGUI <> $hDescGUI Then SwitchConfGUI($hDescGUI)
					
				Case $nTIAdapter
					If $hLastConfGUI <> $hConfGUI Then SwitchConfGUI($hConfGUI)
					
				Case $nTINetIdent
					If $hLastConfGUI <> $hIdentGUI Then SwitchConfGUI($hIdentGUI)
					
				Case $nTINetShares
					If $hLastConfGUI <> $hSharesGUI Then SwitchConfGUI($hSharesGUI)
					
				Case $nTINetDrives
					If $hLastConfGUI <> $hDrivesGUI Then SwitchConfGUI($hDrivesGUI)
				
				Case $nTIColorSchemes
					If $hLastConfGUI <> $hSchemesGUI Then SwitchConfGUI($hSchemesGUI)
					
				Case $nTIWireless
					If $hLastConfGUI <> $hWiFiGUI Then SwitchConfGUI($hWiFiGUI)
					
				Case $nTICMDStartup
					If $hLastConfGUI <> $hCMDStartGUI Then SwitchConfGUI($hCMDStartGUI)
					
				Case $nTICMDChange
					If $hLastConfGUI <> $hCMDChangeGUI Then SwitchConfGUI($hCMDChangeGUI)
					
				Case $nTIPreview
					If $hLastConfGUI <> $hPrevGUI Then
						SwitchConfGUI($hPrevGUI)
						If $bIniOk Then
							GUISetState(@SW_HIDE, $hPrevBlackGUI)
							GUISetState(@SW_SHOW, $hPrevBkGUI)
						Else
							GUISetState(@SW_HIDE, $hPrevBkGUI)
							GUISetState(@SW_SHOW, $hPrevBlackGUI)
						EndIf
					EndIf
					
				Case $nTIConf
					ProfileSetSchemeElement($Msg, 14)
				
				Case $nTIIdent
					ProfileSetSchemeElement($Msg, 13)
					
				Case $nTIIP
					ProfileSetSchemeElement($Msg, 17)
					SetODBtnState($nTIWiFiAV, $GUI_HIDE, FALSE)
					SetODBtnState($nTIWiFiPref, $GUI_HIDE, FALSE)
					GUICtrlSetState($nFrmBkWiFi1, $GUI_HIDE)
					GUICtrlSetState($nFrmBkWiFi2, $GUI_HIDE)
					GUICtrlSetState($nFrmBkWiFi3, $GUI_HIDE)
					GUICtrlSetState($nFrmBkWiFi4, $GUI_HIDE)
					GUICtrlSetState($nLblBkWiFi, $GUI_HIDE)
					GUICtrlSetState($nLblWiFi, $GUI_HIDE)
					GUICtrlSetState($nLblConf, $GUI_SHOW)
					SetCtrlState($hIP, @SW_SHOW)
					GUICtrlSetState($nRadIPDHCP, $GUI_SHOW)
					GUICtrlSetState($nBtnDhcpInfo, $GUI_SHOW)
					GUICtrlSetState($nBtnDhcpRelease, $GUI_SHOW)
					GUICtrlSetState($nBtnDhcpRenew, $GUI_SHOW)
					GUICtrlSetState($nBtnIPAltShow, $GUI_SHOW)
					
				Case $nTIWiFi
					ProfileSetSchemeElement($Msg, 16)
					GUICtrlSetState($nLblConf, $GUI_HIDE)
					GUICtrlSetState($nRadIPDHCP, $GUI_HIDE)
					GUICtrlSetState($nBtnDhcpInfo, $GUI_HIDE)
					GUICtrlSetState($nBtnDhcpRelease, $GUI_HIDE)
					GUICtrlSetState($nBtnDhcpRenew, $GUI_HIDE)
					GUICtrlSetState($nBtnIPAltShow, $GUI_HIDE)
					SetCtrlState($hIP, @SW_HIDE)
					SetODBtnState($nTIWiFiAV, $GUI_SHOW, FALSE)
					SetODBtnState($nTIWiFiPref, $GUI_SHOW, FALSE)
					GUICtrlSetState($nFrmBkWiFi1, $GUI_SHOW)
					GUICtrlSetState($nFrmBkWiFi2, $GUI_SHOW)
					GUICtrlSetState($nFrmBkWiFi3, $GUI_SHOW)
					GUICtrlSetState($nFrmBkWiFi4, $GUI_SHOW)
					GUICtrlSetState($nLblBkWiFi, $GUI_SHOW)
					GUICtrlSetState($nLblWiFi, $GUI_SHOW)
					
				Case $nTIWiFiAV
					ProfileSetSchemeElement($Msg, 19)
				
				Case $nTIWiFiPref
					ProfileSetSchemeElement($Msg, 18)
						
				Case $nInpProfFile
					$sFile = GUICtrlRead($nInpProfFile)
					If FileExists($sFile) Then
						ProfileOpen($sFile)
						If $bIniOk Then
							GUISetState(@SW_HIDE, $hPrevBlackGUI)
							GUISetState(@SW_SHOW, $hPrevBkGUI)
						Else
							GUISetState(@SW_HIDE, $hPrevBkGUI)
							GUISetState(@SW_SHOW, $hPrevBlackGUI)
						EndIf
					EndIf
						
				;Case $nBtnIPMode
				;	ProfileSetSchemeElement($Msg, 4)
				
				Case $nBtnDhcpInfo, $nBtnDhcpRelease, $nBtnDhcpRenew, $nBtnIPAltShow
					ProfileSetSchemeElement($Msg, 6)
					
				;Case $nBtnIPAuto
				;	ProfileSetSchemeElement($Msg, 5)
				
				Case $nBtnSchemeApply, $nBtnSchemeOK, $nBtnSchemeClose
					ProfileSetSchemeElement($Msg, 10)
				
				Case $nLblStateMain
					ProfileSetSchemeElement($Msg, 0)
					
				Case $nLblStateProgress
					ProfileSetSchemeElement($Msg, 1)
					
				Case $nLblDefault
					ProfileSetSchemeElement($Msg, 26)
				
				Case $nLblConf
					ProfileSetSchemeElement($Msg, 27)
					
				Case $nLblSrvStart
					ProfileSetSchemeElement($Msg, 2)
				
				Case $nLblSrvStop
					ProfileSetSchemeElement($Msg, 3)
					
				Case $nLblWiFi
					ProfileSetSchemeElement($Msg, 28)
						
				Case $nChkKey
					Local $sKey = GUICtrlRead($nInpKey)
					If BitAnd(GUICtrlRead($nChkKey), $GUI_CHECKED) Then
						GUICtrlSendMsg($nInpKey, $EM_SETPASSWORDCHAR, 0, 0)
						GUICtrlSetData($nInpKey, $sKey)
					Else
						GUICtrlSendMsg($nInpKey, $EM_SETPASSWORDCHAR, 0x25CF, 0)
						GUICtrlSetData($nInpKey, $sKey)
					EndIf
					
				Case $nChkShrPW
					Local $sPW = GUICtrlRead($nInpShrPW)
					If BitAnd(GUICtrlRead($nChkShrPW), $GUI_CHECKED) Then
						GUICtrlSendMsg($nInpShrPW, $EM_SETPASSWORDCHAR, 0, 0)
						GUICtrlSetData($nInpShrPW, $sPW)
					Else
						GUICtrlSendMsg($nInpShrPW, $EM_SETPASSWORDCHAR, 0x25CF, 0)
						GUICtrlSetData($nInpShrPW, $sPW)
					EndIf
					
				Case $nChkDrvPW
					Local $sPW = GUICtrlRead($nInpDrvPW)
					If BitAnd(GUICtrlRead($nChkDrvPW), $GUI_CHECKED) Then
						GUICtrlSendMsg($nInpDrvPW, $EM_SETPASSWORDCHAR, 0, 0)
						GUICtrlSetData($nInpDrvPW, $sPW)
					Else
						GUICtrlSendMsg($nInpDrvPW, $EM_SETPASSWORDCHAR, 0x25CF, 0)
						GUICtrlSetData($nInpDrvPW, $sPW)
					EndIf
				
				Case $nBtnPrevStart, $nBtnPENMCancel
					StartPrevDemo()
					
				Case $nBtnYes, $nBtnNo
					If $Msg = $nBtnYes Then
						$bBtnOK = TRUE
					Else
						$bBtnOK = FALSE
					EndIf
					
					KillTimer($hPSG, $nTimerID)
					DelODBtnGrp($arODBtnSub)
					GUIDelete($hPSG)
					
					$hPSG = 0
					$nBtnYes = 0
					$nBtnNo = 0
					
					If $bBtnOK Then
						If $bUseProfiles And $bUseProfileSelect Then
							ShowPrevProfSel()
						Else
							ShowPrevInstall()
						EndIf
					Else
						$bPrevStarted = FALSE
						GUICtrlSetData($nBtnPrevStart, "Start")
						SetBtnImage($nBtnPrevStart, 52, -223)
						InvalidateRect(GUICtrlGetHandle($nIconTray), 0, TRUE)
					EndIf
					$bPrevStartup = FALSE
					
				Case $nBtnOK, $nBtnCancel
					KillTimer($hPSG, $nTimerID)
					DelODBtnGrp($arODBtnSub)
					GUIDelete($hPSG)
					
					$hPSG = 0
					$nBtnOK = 0
					$nBtnCancel = 0
					$nListProfiles = 0
					$bPrevProfiles = FALSE
					
					ShowPrevInstall()
				
				Case $nListProfiles
					KillTimer($hPSG, $nTimerID)
					$bUseProfileCount = FALSE
					$bPrevProfiles = FALSE
					SetODBtnData($nProfileCountCtrl, $sProfileCountText)
					GUICtrlSetData($nEditInfo, ReadProfileDesc($sPENMini, GUICtrlRead($nListProfiles), "Desc.Line"))
						
				Case $nBtnProfManage
					ShowProfGUI()
				
				Case $nBtnProfAdd
					ShowProfGUI(1)
				
				Case $nBtnProfCopy	
					ProfileCopyProfile(GUICtrlRead($nComboProfiles))
				
				Case $nBtnProfDel
					ProfileDelProfile(GUICtrlRead($nComboProfiles))
						
				Case $nBtnSubOK, $nBtnSubCancel
					$sLine = ""
					If $Msg = $nBtnSubOK Then
						$bBtnOK = TRUE
						If $nSubType = 1 Then $sLine = GUICtrlRead($nInpProfile)
					Else
						$bBtnOK = FALSE
					EndIf
								
					If $bBtnOK Then				
						Switch $nSubType
							Case 0 ; Manage profiles
								; Rewrite profile list
								$sLine = ""
								$nCount = GUICtrlSendMsg($nListAddr, $LB_GETCOUNT, 0, 0)
								
								For $i = 0 To $nCount - 1
									$nLen = GUICtrlSendMsg($nListAddr, $LB_GETTEXTLEN, $i, 0)
									If $nLen > 0 Then
										$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
										
										If GUICtrlSendMsg($nListAddr, $LB_GETTEXT, $i, DllStructGetPtr($stText)) > 0 Then
											$sLine = $sLine & DllStructGetData($stText, 1) & "=" & @LF
										EndIf
									EndIf									
								Next

								IniWriteSection($sPENMini, "NetProfiles", $sLine)
								
								$sLine = GUICtrlRead($nComboProfiles)
								GUICtrlSetData($nComboProfiles, "|")
								GUICtrlSetData($nComboDefProf, "||")
								ProfileGetProfiles()
								If $sComboProf <> "" Then GUICtrlSetData($nComboDefProf, $sComboProf, $sComboProf)
								If $sLine <> "" Then GUICtrlSetData($nComboProfiles, $sLine, $sLine)

							Case 1 ; Add profile
								ProfileAddProfile($sLine)
						EndSwitch
					EndIf
					
					GUISetState(@SW_ENABLE, $hPCG)
					DelODBtnGrp($arODBtnSub)
					GUIDelete($hSubGUI)
					
					$hSubGUI = 0
					$nBtnSubOK = 0
					$nBtnSubCancel = 0
					$nBtnAddrUp = 0
					$nBtnAddrDown = 0
					$nBtnRename = 0
					$nBtnAdd = 0
					$nBtnDel = 0
					$nBtnCopy = 0
					
				Case $nMIAbout
					ShowAboutGUI()
					
				Case $nBtnAboutOK
					GUISetState(@SW_ENABLE, $hPCG)
					GUISetState(@SW_HIDE, $hAboutGUI)
						
				Case $nMIPrefs
					ShowPrefsGUI()
					
				Case $nBtnPrefsOK, $nBtnPrefsCancel
					If $Msg = $nBtnPrefsOK Then
						If BitAnd(GUICtrlRead($nChkOpenLastFile), $GUI_CHECKED) Then
							RegWrite($sGURegKey & "\Editor", "OpenLastFile", "REG_DWORD", 0x1)
							$bOpenLastFile = TRUE
						Else
							RegWrite($sGURegKey & "\Editor", "OpenLastFile", "REG_DWORD", 0x0)
							$bOpenLastFile = FALSE
						EndIf
						
						If BitAnd(GUICtrlRead($nChkOpenLastProfile), $GUI_CHECKED) Then
							RegWrite($sGURegKey & "\Editor", "OpenLastProfile", "REG_DWORD", 0x1)
							$bOpenLastProfile = TRUE
						Else
							RegWrite($sGURegKey & "\Editor", "OpenLastProfile", "REG_DWORD", 0x0)
							$bOpenLastProfile = FALSE
						EndIf
						
						If BitAnd(GUICtrlRead($nChkSaveWinPos), $GUI_CHECKED) Then
							RegWrite($sGURegKey & "\Editor", "SaveWinPos", "REG_DWORD", 0x1)
							$bSaveWinPos = TRUE
						Else
							RegWrite($sGURegKey & "\Editor", "SaveWinPos", "REG_DWORD", 0x0)
							$bSaveWinPos = FALSE
						EndIf
						
						If BitAnd(GUICtrlRead($nChkUseOSFont), $GUI_CHECKED) Then
							RegWrite($sGURegKey & "\Editor", "UseOSFont", "REG_DWORD", 0x1)
							$bUseOSFont = TRUE
						Else
							RegWrite($sGURegKey & "\Editor", "UseOSFont", "REG_DWORD", 0x0)
							$bUseOSFont = FALSE
						EndIf
					Else
						If $bOpenLastFile = TRUE Then
							GUICtrlSetState($nChkOpenLastFile, $GUI_CHECKED)
						Else
							GUICtrlSetState($nChkOpenLastFile, $GUI_UNCHECKED)
						EndIf
						
						If $bOpenLastProfile = TRUE Then
							GUICtrlSetState($nChkOpenLastProfile, $GUI_CHECKED)
						Else
							GUICtrlSetState($nChkOpenLastProfile, $GUI_UNCHECKED)
						EndIf
						
						If $bSaveWinPos = TRUE Then
							GUICtrlSetState($nChkSaveWinPos, $GUI_CHECKED)
						Else
							GUICtrlSetState($nChkSaveWinPos, $GUI_UNCHECKED)
						EndIf
						
						If $bUseOSFont = TRUE Then
							GUICtrlSetState($nChkUseOSFont, $GUI_CHECKED)
						Else
							GUICtrlSetState($nChkUseOSFont, $GUI_UNCHECKED)
						EndIf
					EndIf
					
					GUISetState(@SW_ENABLE, $hPCG)
					GUISetState(@SW_HIDE, $hPrefsGUI)
					
				Case $nLblAboutAuthor
					GUICtrlSetFont($nLblAboutAuthor, $nGlobalFontSize, 400, 0)
					ShellExecute($sUrlHome)
			
				Case $nLblAboutAI3
					GUICtrlSetFont($nLblAboutAI3, $nGlobalFontSize, 400, 0)
					ShellExecute($sUrlAI3)
					
				Case $nRadioOSFont
					GUICtrlSetState($nInpFont, $GUI_DISABLE)
				
				Case $nRadioFont
					GUICtrlSetState($nInpFont, $GUI_ENABLE)
					
			EndSwitch
		WEnd
		
		$nResult = ProfileCheckChanges()
	Until $nResult = 0 Or $nResult < 3
EndFunc


;**********************************************************************
; Editor message procedure
;**********************************************************************
Func WndProcEditor($hWnd, $Msg, $wParam, $lParam)
	Local $hCtrl, $nCode, $nID, $sLine
	
	Switch $Msg					
		Case $WM_SETCURSOR
			For $i = 1 To $ODBUTTONS[0][0]
				If $ODBUTTONS[$i][9] = $wParam Then
					SetCursor($hCursorHand)
					Return TRUE
				EndIf
			Next
			
			If $wParam = $hLblAboutAI3 Then
				SetCursor($hCursorHand)
				If $bLblAboutAI3 = FALSE Then
					$bLblAboutAI3 = TRUE
					GUICtrlSetFont($nLblAboutAI3, $nGlobalFontSize, 400, 4)
				EndIf
				Return TRUE		
			Else
				If $bLblAboutAI3 Then GUICtrlSetFont($nLblAboutAI3, $nGlobalFontSize, 400, 0)
				$bLblAboutAI3 = FALSE
			EndIf
			
			If $wParam = $hLblAboutAuthor Then
				SetCursor($hCursorHand)
				If $bLblAboutAuthor = FALSE Then
					$bLblAboutAuthor = TRUE
					GUICtrlSetFont($nLblAboutAuthor, $nGlobalFontSize, 400, 4)
				EndIf
				Return TRUE		
			Else
				If $bLblAboutAuthor Then GUICtrlSetFont($nLblAboutAuthor, $nGlobalFontSize, 400, 0)
				$bLblAboutAuthor = FALSE
			EndIf
			
			If $hWnd = $wParam Then
				SetCursor($hCursorArrow)
				Return TRUE
			EndIf
			
			Return FALSE
			
		Case $WM_MOUSEWHEEL
			If $hWnd = $hPCG Then
				; Workaround for older OS'<Win10
				If $hLastConfGUI = $hGlobalGUI Then
					; Only wheel if mouse is in other gui client area
					Local $stPoint = DllStructCreate("int;int")
					GetCursorPos(DllStructGetPtr($stPoint))
					Local $stRect = DllStructCreate("long;long;long;long")
					GetWindowRect($hGlobalGUI, DllStructGetPtr($stRect))
					If DllStructGetData($stPoint, 1) >= DllStructGetData($stRect, 1) And _
						DllStructGetData($stPoint, 1) <= DllStructGetData($stRect, 3) And _
						DllStructGetData($stPoint, 2) >= DllStructGetData($stRect, 2) And _
						DllStructGetData($stPoint, 2) <= DllStructGetData($stRect, 4) Then
						Local $nDist = BitShift($wParam, 16)
						If $nDist > 0 Then
							For $i = 1 To $nScrollLines
								SendMessage($hGlobalGUI, $WM_VSCROLL, $SB_LINEUP, 0)
							Next
						Else
							For $i = 1 To $nScrollLines
								SendMessage($hGlobalGUI, $WM_VSCROLL, $SB_LINEDOWN, 0)
							Next
						EndIf
					EndIf
					$stPoint = 0
					$stRect = 0
				EndIf
			EndIf
			
		Case $WM_COMMAND
			$hCtrl = $lParam
			$nCode = BitShift($wParam, 16)
    		$nID = BitAnd($wParam, 0x0000FFFF)
    		
			If $nID = 1 And $nCode = 0 Then
    			Local $hFocus = GetFocus()
				If $hFocus <> 0 Then
					Local $nDlgID = GetDlgCtrlID($hFocus)
					If $nDlgID <> 0 Then PostMessage($hWnd, $WM_COMMAND, BitAnd($nDlgID, 0x0000FFFF), $hFocus)
				EndIf
				Return 0
			EndIf
			
			If $nCode = $EN_CHANGE Then
				Switch $nID
					Case $nInpIP, $nInpSM, $nInpDG, $nInpDNS, $nInpWINS
						Local $sText = GUICtrlRead($nID)
						If $sText <> "" Then						
							If IsValidAddress(GUICtrlRead($nID)) Then
								GUICtrlSetColor($nID, 0x0)
							Else
								GUICtrlSetColor($nID, $nClrChkWrong)								
							EndIf
						EndIf
						
					Case $nInpMAC
						Local $sText = GUICtrlRead($nID)
						If $sText <> "" Then
							If StringRegExp($sText, $sMACChkPattern) Then
								GUICtrlSetColor($nID, 0x0)
							Else
								GUICtrlSetColor($nID, $nClrChkWrong)
							EndIf	
						EndIf
				EndSwitch
			ElseIf $nCode = $EN_UPDATE Then
				Switch $nID
					Case $nInpPCName
						Local $sChkChr = """C/C\C[C]C:C|C<C>C=C;C,"
    					Local $arChkCr = StringSplit($sChkChr, "C")
    					
    					If IsArray($arChkCr) Then
    						Local $bInpFalse = FALSE
    						  						
    						For $i = 1 To $arChkCr[0]
    							If StringInStr(GUICtrlRead($nID), $arChkCr[$i]) Then
    								$bInpFalse = TRUE
    								GUICtrlSetData($nID, StringReplace(GUICtrlRead($nID), $arChkCr[$i], ""))
    								ExitLoop
    							EndIf
    						Next
    						
    						GUICtrlSetData($nID, StringReplace(GUICtrlRead($nID), " ", ""))
    					EndIf
				EndSwitch
			EndIf

		Case $WM_NOTIFY
			Local $sNMHDR = "hwnd;uint_ptr;int"
			Local $stNMHDR = DllStructCreate($sNMHDR, $lParam)
			
			$hCtrl	= DllStructGetData($stNMHDR, 1)
			$nID	= DllStructGetData($stNMHDR, 2)
			$nCode	= DllStructGetData($stNMHDR, 3)
			
			Switch $hWnd
				Case $hCMDStartGUI, $hCMDChangeGUI, $hWiFiGUI, $hPrevBkGUI
					Switch $nCode
						Case $LVN_BEGINDRAG
							Return 0
							
						Case $LVN_ITEMCHANGED
							Local $nUp = 0, $nDown = 0
							Switch $nID
								Case $nLVCMDStart
									$nUp	= $nBtnCMDStartUp
									$nDown	= $nBtnCMDStartDown
								Case $nLVCMDChange
									$nUp	= $nBtnCMDChangeUp
									$nDown	= $nBtnCMDChangeDown
								Case $nLVWLPref
									$nUp	= $nBtnWiFiUp
									$nDown	= $nBtnWiFiDown
									Local $nCurSel = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
									If $nCurSel > -1 Then ProfileWiFiGetParams($nCurSel)
							EndSwitch							
							ChkListBtnCtrl($nID, $nUp, $nDown, TRUE)
						
						Case $NM_DBLCLK
							If $nID = $nLVPrev Then
								Local $stLVIA = DllStructCreate("hwnd;uint_ptr;int;int;int;uint;uint;uint;long[2];long_ptr;uint", $lParam)								
								Local $stPoint = DllStructCreate("long;long")    				
    							GetCursorPos(DllStructGetPtr($stPoint))
								ScreenToClient($hCtrl, DllStructGetPtr($stPoint))								
								Local $stLVHI = DllStructCreate("long[2];uint;int;int;int")
								DllStructSetData($stLVHI, 1, DllStructGetData($stPoint, 1), 1)
								DllStructSetData($stLVHI, 1, DllStructGetData($stPoint, 2), 2)
								
								Local $nItem = GUICtrlSendMsg($nLVPrev, $LVM_HITTEST, 0, DllStructGetPtr($stLVHI))
								If $nItem = 0 Then MsgBoxEx(64, $sInfo, "This is just a preview window, not more, not less.", $hPCG)
								If $nItem = 1 And $bPrevStarted = FALSE Then StartPrevDemo()							
							EndIf
							
						Case $NM_CLICK
							If $nID > 0 Then
								Switch $nID
									Case $nLVWLPref
										Local $nCurSel = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
										If $nCurSel > -1 Then
											ProfileWiFiGetParams($nCurSel)
											If BitAnd(GetODBtnState($nBtnWiFiChg), $GUI_DISABLE) Then SetODBtnState($nBtnWiFiChg, $GUI_ENABLE)
											If BitAnd(GetODBtnState($nBtnWiFiDel), $GUI_DISABLE) Then SetODBtnState($nBtnWiFiDel, $GUI_ENABLE)
										Else
											If BitAnd(GetODBtnState($nBtnWiFiChg), $GUI_ENABLE) Then SetODBtnState($nBtnWiFiChg, $GUI_DISABLE)
											If BitAnd(GetODBtnState($nBtnWiFiDel), $GUI_ENABLE) Then SetODBtnState($nBtnWiFiDel, $GUI_DISABLE)
										EndIf
											
									Case $nLVCMDStart, $nLVCMDChange
										Local $nCurSel = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
										If $nCurSel > -1 Then
											Local $sSep		= "@@CMD@@"
											Local $sText	= GetLVText($nID, $nCurSel, $sSep, 3)
											Local $nInp		= $nInpCMDStart
											Local $nRun		= $nComboStartRun
											Local $nWait	= $nComboStartWait
											
											If $nID = $nLVCMDChange Then
												$nInp	= $nInpCMDChange
												$nRun	= $nComboChangeRun
												$nWait	= $nComboChangeWait
												If BitAnd(GetODBtnState($nBtnCMDChangeChg), $GUI_DISABLE) Then SetODBtnState($nBtnCMDChangeChg, $GUI_ENABLE)
												If BitAnd(GetODBtnState($nBtnCMDChangeDel), $GUI_DISABLE) Then SetODBtnState($nBtnCMDChangeDel, $GUI_ENABLE)
											Else
												If BitAnd(GetODBtnState($nBtnCMDStartEdit), $GUI_DISABLE) Then SetODBtnState($nBtnCMDStartEdit, $GUI_ENABLE)
												If BitAnd(GetODBtnState($nBtnCMDStartDel), $GUI_DISABLE) Then SetODBtnState($nBtnCMDStartDel, $GUI_ENABLE)																							
											EndIf
											
											If $sText <> "" Then
												Local $arText = StringSplit($sText, $sSep, 1)
												If $arText[0] = 3 Then
													GUICtrlSetData($nInp, $arText[1])
													GUICtrlSetData($nRun, $arText[2])
													If $arText[3] = "Yes" Then
														$arText[3] = "Wait"
													Else
														$arText[3] = "NoWait"
													EndIf
													
													GUICtrlSetData($nWait, $arText[3])
												EndIf
											EndIf		
										Else
											If $nID = $nLVCMDChange Then
												If BitAnd(GetODBtnState($nBtnCMDChangeChg), $GUI_ENABLE) Then SetODBtnState($nBtnCMDChangeChg, $GUI_DISABLE)
												If BitAnd(GetODBtnState($nBtnCMDChangeDel), $GUI_ENABLE) Then SetODBtnState($nBtnCMDChangeDel, $GUI_DISABLE)
											Else
												If BitAnd(GetODBtnState($nBtnCMDStartEdit), $GUI_ENABLE) Then SetODBtnState($nBtnCMDStartEdit, $GUI_DISABLE)
												If BitAnd(GetODBtnState($nBtnCMDStartDel), $GUI_ENABLE) Then SetODBtnState($nBtnCMDStartDel, $GUI_DISABLE)																							
											EndIf
											
										EndIf
								EndSwitch
							EndIf
					EndSwitch
			EndSwitch
			
		Case $WM_PAINT
			If $hWnd = $hPSG And $hPSG <> 0 Then PostMessage($hPSG, $WM_NCACTIVATE, TRUE, 0)			
			Return $GUI_RUNDEFMSG
	EndSwitch
EndFunc


;**********************************************************************
; Profile functions
;**********************************************************************
Func ProfileOpen($sFile, $sProfile = "")
	$bIniOK = FALSE
	
	If $sFile = "" Then Return
	
	$sPENMini = $sFile
	If Not FileExists($sFile) Then FileWrite($sFile, "")
	GUICtrlSetData($nInpProfFile, $sFile, $sFile)
	GUICtrlSetTip($nInpProfFile, $sFile)
	
	$bIniOK = TRUE
	
	ProfileSaveList()

	GUICtrlSetData($nComboProfiles, "|")
	GUICtrlSetData($nComboDefProf, "||")
	
	$sComboProf = IniRead($sPENMini, $sGSection, "ProfileDefault", "")

	ProfileClearSettings()
	
	ProfileDisableControls()
	
	GUICtrlSetState($nComboProfiles, $GUI_ENABLE)
	SetODBtnState($nBtnProfManage, $GUI_ENABLE)
	SetODBtnState($nBtnProfAdd, $GUI_ENABLE)	
	
	ProfileGetProfiles()
	ProfileGetSchemes()
		
	If IniRead($sPENMini, $sGSection, "AutoStart", "Yes") = "No" Then
		GUICtrlSetState($nChkStartPrompt, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkStartPrompt, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "FocusNo", "No") = "Yes" Then
		GUICtrlSetState($nChkFocusNo, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkFocusNo, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "UseStartCountdown", "No") = "Yes" Then
		GUICtrlSetState($nChkStartCount, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkStartCount, $GUI_UNCHECKED)
	EndIf
	
	GUICtrlSetData($nInpStartCount, IniRead($sPENMini, $sGSection, "StartCountdown", "10"))
	
	Local $nStartMode = Number(IniRead($sPENMini, $sGSection, "StartMode", "1"))
	Local $sStartMode = "1 - Center"

	Switch $nStartMode
		Case 0
			$sStartMode = "0 - Hidden"
		Case 1
			$sStartMode = "1 - Center"
		Case 2
			$sStartMode = "2 - TopLeft"
		Case 3
			$sStartMode = "3 - TopRight"
		Case 4
			$sStartMode = "4 - BottomLeft"
		Case 5
			$sStartMode = "5 - BottomRight"
		Case 6
			$sStartMode = "6 - Depends on systray position"
	EndSwitch
	
	GUICtrlSetData($nComboStartMode, $sStartModes, $sStartMode)
	
	If IniRead($sPENMini, $sGSection, "UseProfiles", "No") = "Yes" Then
		GUICtrlSetState($nChkProfUse, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkProfUse, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "UseProfileSelect", "Yes") = "No" Then
		GUICtrlSetState($nChkProf, $GUI_UNCHECKED)
	Else
		GUICtrlSetState($nChkProf, $GUI_CHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "UseProfileCountdown", "No") = "Yes" Then
		GUICtrlSetState($nChkCount, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkCount, $GUI_UNCHECKED)
	EndIf
	
	GUICtrlSetData($nInpCount, IniRead($sPENMini, $sGSection, "ProfileCountdown", "5"))
	
	If IniRead($sPENMini, $sGSection, "Debug", "No") = "Yes" Then
		GUICtrlSetState($nChkDebug, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkDebug, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "EnableAutoIP", "No") = "Yes" Then
		GUICtrlSetState($nChkAutoIP, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkAutoIP, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "ForceScanOnStartup", "No") = "Yes" Then
		GUICtrlSetState($nChkForceScan, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkForceScan, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "ShowTrayActivity", "No") = "Yes" Then
		GUICtrlSetState($nChkShowAct, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkShowAct, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "ShowMain", "No") = "Yes" Then
		GUICtrlSetState($nRadioStartToTray, $GUI_UNCHECKED)
		GUICtrlSetState($nRadioCloseMain, $GUI_UNCHECKED)
		GUICtrlSetState($nRadioShowMain, $GUI_CHECKED)
	Else
		If IniRead($sPENMini, $sGSection, "StartToTray", "No") = "Yes" Then
			GUICtrlSetState($nRadioCloseMain, $GUI_UNCHECKED)
			GUICtrlSetState($nRadioShowMain, $GUI_UNCHECKED)
			GUICtrlSetState($nRadioStartToTray, $GUI_CHECKED)
		Else
			GUICtrlSetState($nRadioShowMain, $GUI_UNCHECKED)
			GUICtrlSetState($nRadioStartToTray, $GUI_UNCHECKED)
			GUICtrlSetState($nRadioCloseMain, $GUI_CHECKED)
		EndIf	
	EndIf

	If IniRead($sPENMini, $sGSection, "UseOSFont", "Yes") = "No" Then
		GUICtrlSetState($nRadioOSFont, $GUI_UNCHECKED)
		GUICtrlSetState($nRadioFont, $GUI_CHECKED)
		GUICtrlSetState($nInpFont, $GUI_ENABLE)
	Else
		GUICtrlSetState($nRadioFont, $GUI_UNCHECKED)
		GUICtrlSetState($nRadioOSFont, $GUI_CHECKED)
		GUICtrlSetState($nInpFont, $GUI_DISABLE)
	EndIf
	
	GUICtrlSetData($nInpFont, IniRead($sPENMini, $sGSection, "GlobalFont", ""))
	
	If IniRead($sPENMini, $sGSection, "UseIniIcons", "No") = "Yes" Then
		GUICtrlSetState($nChkIcons, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkIcons, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "WaitConnect", "Yes") = "No" Then
		GUICtrlSetState($nChkWait, $GUI_UNCHECKED)
	Else
		GUICtrlSetState($nChkWait, $GUI_CHECKED)
	EndIf
	
	GUICtrlSetData($nInpWait, IniRead($sPENMini, $sGSection, "WaitConnectTime", $nWaitConnectTime))
	
	If IniRead($sPENMini, $sGSection, "TrayLimitInfo", "No") = "Yes" Then
		GUICtrlSetState($nChkTrayLimitInfo, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkTrayLimitInfo, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "TrayAdaptWiFi", "No") = "Yes" Then
		GUICtrlSetState($nChkTrayAdaptWiFi, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkTrayAdaptWiFi, $GUI_UNCHECKED)
	EndIf
	
	Local $nResult = Int(IniRead($sPENMini, $sGSection, "TrayWiFiHeight", "0"))
	If $nResult > 0 Then
		GUICtrlSetState($nChkTrayWiFiHeight, $GUI_CHECKED)
		GUICtrlSetData($nInpWiFiHeight, $nResult)
	Else
		GUICtrlSetState($nChkTrayWiFiHeight, $GUI_UNCHECKED)
		GUICtrlSetData($nInpWiFiHeight, 0)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "TrayShowMAC", "No") = "Yes" Then
		GUICtrlSetState($nChkTrayShowMAC, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkTrayShowMAC, $GUI_UNCHECKED)
	EndIf
	
	If IniRead($sPENMini, $sGSection, "TrayShowIPv6", "No") = "Yes" Then
		GUICtrlSetState($nChkTrayShowIPv6, $GUI_CHECKED)
	Else
		GUICtrlSetState($nChkTrayShowIPv6, $GUI_UNCHECKED)
	EndIf
	
	
	$sCurProfile = $sProfile
	Local $bFound = FALSE
	
	If $sProfile <> "" Then
		Local $i
		Local $arNetProfiles = IniReadSection($sPENMini, "NetProfiles")
		For $i = 1 To $arNetProfiles[0][0]
			If $arNetProfiles[$i][0] = $sProfile Then
				SetODBtnState($nBtnProfDel, $GUI_ENABLE)
				SetODBtnState($nBtnProfCopy, $GUI_ENABLE)
				ProfileGetParams($sProfile)
				GUICtrlSetData($nComboProfiles, $sProfile, $sProfile)
				$bFound = TRUE
				ExitLoop
			EndIf
		Next		
	EndIf
	
	If Not $bFound Then $sCurProfile = ""
	
	GUICtrlSetState($nMIProfOpenExt, $GUI_ENABLE)
	GUICtrlSetState($nMILoad, $GUI_ENABLE)
	GUICtrlSetState($nMISave, $GUI_ENABLE)
	GUICtrlSetState($nMISaveAs, $GUI_ENABLE)
EndFunc


Func ProfileGetProfiles($bFromMain = TRUE)
	Local $arNetProfiles = IniReadSection($sPENMini, "NetProfiles")
	If @Error Then Return
	
	If $arNetProfiles[0][0] = 0 Then Return
	
	Local $i
	
	For $i = 1 To $arNetProfiles[0][0]
		If $bFromMain Then
			GUICtrlSetData($nComboProfiles, $arNetProfiles[$i][0])
			GUICtrlSetData($nComboDefProf, $arNetProfiles[$i][0], $sComboProf)
		Else
			GUICtrlSendMsg($nListAddr, $LB_INSERTSTRING, -1, $arNetProfiles[$i][0])
		EndIf
	Next
EndFunc


Func ProfileGetSchemes()
	Local $i = 1, $sLine, $sSchemes = "|Default (built-in)|Classic (built-in)"
	
	Local $sDefault = IniRead($sPENMini, "Schemes", "Default", "")
	If $sDefault = "" Then $sDefault = "Default (built-in)"
	
	While 1
		$sLine = IniRead($sPENMini, "Schemes", "Scheme" & $i, "IniReadError")
		If $sLine = "IniReadError" Then ExitLoop
		
		$sSchemes = $sSchemes & "|" & $sLine
		
		$i += 1
	WEnd
		
	GUICtrlSetData($nComboScheme, $sSchemes, $sDefault)

	ProfileReadScheme($sDefault)
	ProfileRstClr()
EndFunc


Func ProfileReadScheme($sScheme, $bUpdate = TRUE)
	If $sScheme = "Default (built-in)" Then
		GetSchemeDefault()
	ElseIf $sScheme = "Classic (built-in)" Then
		GetSchemeClassic()
	Else
		ReadScheme($sScheme)
	EndIf
	
	If $bUpdate Then ProfileUpdClr()

	FillArClr()
EndFunc


Func ProfileSaveScheme($sScheme, $bMsg = TRUE)
	If $sScheme = "" Or $sScheme = "Default (built-in)" Or $sScheme = "Classic (built-in)" Then Return

	ProfileSaveSE($sScheme, "ClrStateGreen", $arClr[0][2])
	ProfileSaveSE($sScheme, "ClrStateRed", $arClr[1][2])
	ProfileSaveSE($sScheme, "ClrSvcStart", $arClr[2][3])
	ProfileSaveSE($sScheme, "ClrSvcStop", $arClr[3][3])
	ProfileSaveSE($sScheme, "ClrBtnChkTxt", $arClr[4][2])
	ProfileSaveSE($sScheme, "ClrBtnChkBk", $arClr[4][3])
	ProfileSaveSE($sScheme, "ClrBtnChkGrad", $arClr[4][4])
	ProfileSaveSE($sScheme, "ClrBtnUnchkTxt", $arClr[5][2])
	ProfileSaveSE($sScheme, "ClrBtnUnchkBk", $arClr[5][3])
	ProfileSaveSE($sScheme, "ClrBtnUnchkGrad", $arClr[5][4])
	ProfileSaveSE($sScheme, "ClrBtnDHCPTxt", $arClr[6][2])
	ProfileSaveSE($sScheme, "ClrBtnDHCPBk", $arClr[6][3])
	ProfileSaveSE($sScheme, "ClrBtnDHCPGrad", $arClr[6][4])
	ProfileSaveSE($sScheme, "ClrBtnTxtDisabled", $arClr[7][2], TRUE)
	ProfileSaveSE($sScheme, "ClrBtnBkActive", $arClr[8][2])
	ProfileSaveSE($sScheme, "ClrBtnFocus", $arClr[9][2], TRUE)
	ProfileSaveSE($sScheme, "ClrBtnNormalTxt", $arClr[10][2], TRUE)
	ProfileSaveSE($sScheme, "ClrBtnNormalBk", $arClr[10][3], TRUE)
	ProfileSaveSE($sScheme, "ClrBtnNormalGrad", $arClr[10][4], TRUE)
	ProfileSaveSE($sScheme, "ClrBtnFrame", $arClr[11][2], TRUE)
	ProfileSaveSE($sScheme, "ClrWiFiConnect", $arClr[12][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTITxt", $arClr[13][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTIBk", $arClr[13][3], TRUE)
	ProfileSaveSE($sScheme, "ClrTIGrad", $arClr[13][4], TRUE)
	ProfileSaveSE($sScheme, "ClrTISelTxt", $arClr[14][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTISelBk", $arClr[14][3], TRUE)
	ProfileSaveSE($sScheme, "ClrTISelGrad", $arClr[14][4], TRUE)
	ProfileSaveSE($sScheme, "ClrTIFocus", $arClr[15][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTIConfTxt", $arClr[16][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTIConfBk", $arClr[16][3], TRUE)
	ProfileSaveSE($sScheme, "ClrTIConfGrad", $arClr[16][4], TRUE)
	ProfileSaveSE($sScheme, "ClrTIConfSelTxt", $arClr[17][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTIConfSelBk", $arClr[17][3], TRUE)
	ProfileSaveSE($sScheme, "ClrTIConfSelGrad", $arClr[17][4], TRUE)
	ProfileSaveSE($sScheme, "ClrTIWiFiTxt", $arClr[18][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTIWiFiBk", $arClr[18][3], TRUE)
	ProfileSaveSE($sScheme, "ClrTIWiFiGrad", $arClr[18][4], TRUE)
	ProfileSaveSE($sScheme, "ClrTIWiFiSelTxt", $arClr[19][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTIWiFiSelBk", $arClr[19][3], TRUE)
	ProfileSaveSE($sScheme, "ClrTIWiFiSelGrad", $arClr[19][4], TRUE)
	ProfileSaveSE($sScheme, "ClrGUIBkMain", $arClr[20][3])
	ProfileSaveSE($sScheme, "ClrGUIBk", $arClr[21][3])
	ProfileSaveSE($sScheme, "ClrGUIBkSub", $arClr[22][3])
	ProfileSaveSE($sScheme, "ClrGUIBkConf", $arClr[23][3])
	ProfileSaveSE($sScheme, "ClrGUIBkWiFi", $arClr[24][3])
	ProfileSaveSE($sScheme, "ClrGUIBkAuth", $arClr[25][3])
	ProfileSaveSE($sScheme, "ClrLblNormal", $arClr[26][2])
	ProfileSaveSE($sScheme, "ClrLblConf", $arClr[27][2])
	ProfileSaveSE($sScheme, "ClrLblWiFi", $arClr[28][2])
	ProfileSaveSE($sScheme, "ClrLVWiFiTxt", $arClr[29][2])
	ProfileSaveSE($sScheme, "ClrLVWiFiBk", $arClr[29][3])
	ProfileSaveSE($sScheme, "ClrLVSharesTxt", $arClr[30][2])
	ProfileSaveSE($sScheme, "ClrLVSharesBk", $arClr[30][3])
	ProfileSaveSE($sScheme, "ClrLVNetDrvTxt", $arClr[31][2])
	ProfileSaveSE($sScheme, "ClrLVNetDrvBk", $arClr[31][3])
	ProfileSaveSE($sScheme, "ClrLVPingTxt", $arClr[32][2])
	ProfileSaveSE($sScheme, "ClrLVPingBk", $arClr[32][3])
	ProfileSaveSE($sScheme, "ClrLProfileTxt", $arClr[33][2])
	ProfileSaveSE($sScheme, "ClrLProfileBk", $arClr[33][3])
	ProfileSaveSE($sScheme, "ClrLExtTxt", $arClr[34][2])
	ProfileSaveSE($sScheme, "ClrLExtBk", $arClr[34][3])
	ProfileSaveSE($sScheme, "ClrGUIBkFrame", $arClr[35][2])
	ProfileSaveSE($sScheme, "ClrGUIBkConfFrame", $arClr[36][2])
	ProfileSaveSE($sScheme, "ClrGUIBkWiFiFrame", $arClr[37][2])
	ProfileSaveSE($sScheme, "ClrBtnFrameDisabled", $arClr[38][2])
	ProfileSaveSE($sScheme, "ClrTrayBk", $arClr[39][3])
	ProfileSaveSE($sScheme, "ClrTrayTxt", $arClr[39][2])
	ProfileSaveSE($sScheme, "ClrTrayTrans", $arClr[40][2])
	ProfileSaveSE($sScheme, "ClrTraySelBk", $arClr[41][3])
	ProfileSaveSE($sScheme, "ClrTraySelTxt", $arClr[41][2])
	ProfileSaveSE($sScheme, "ClrTrayConnect", $arClr[42][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTrayBtnFocus", $arClr[43][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTrayBtnTxt", $arClr[44][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTrayBtnBk", $arClr[44][3], TRUE)
	ProfileSaveSE($sScheme, "ClrTrayBtnGrad", $arClr[44][4], TRUE)
	ProfileSaveSE($sScheme, "ClrTrayBtnFrame", $arClr[45][2], TRUE)
	ProfileSaveSE($sScheme, "ClrTrayTxtGray", $arClr[46][2])
		
	Local $i = 1, $bFound = FALSE, $sLine
	
	While 1
		$sLine = IniRead($sPENMini, "Schemes", "Scheme" & $i, "IniReadError")
		If $sLine = "IniReadError" Then ExitLoop
		
		If $sLine = $sScheme Then $bFound = TRUE
		
		$i += 1
	WEnd
	
	If Not $bFound Then
		GUICtrlSetData($nComboScheme, $sScheme)
		IniWrite($sPENMini, "Schemes", "Scheme" & $i, $sScheme)
	EndIf
	
	If $bMsg Then MsgBoxEx(64, $sInfo, "The color scheme """ & $sScheme & """ was saved.", $hPCG)
EndFunc


Func ProfileSaveSE($sScheme, $sEntry, $sVal, $bBGR = FALSE)
	If $sVal < 0 Then
		IniWrite($sPENMini, $sScheme, $sEntry, $sVal)
	Else
		If $bBGR Then
			IniWrite($sPENMini, $sScheme, $sEntry, "0x" & Hex(GetBGRColor($sVal), 6))
		Else
			IniWrite($sPENMini, $sScheme, $sEntry, "0x" & Hex($sVal, 6))
		EndIf
	EndIf
EndFunc


Func ProfileDelScheme($sScheme)
	If $sScheme = "" Or $sScheme = "Default (built-in)" Or $sScheme = "Classic (built-in)" Then Return

	If MsgBoxEx(36, "Delete color scheme?", "Are you sure to delete the color scheme """ & $sScheme & """ ?", $hPCG) = 6 Then
		Local $i = 1, $c = 0, $sLine, $sSchemes = "", $arSplit, $sDef = ""
		
		While 1
			$sLine = IniRead($sPENMini, "Schemes", "Scheme" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			
			If $sLine <> $sScheme Then $sSchemes = $sSchemes & "|" & $sLine
			
			$i += 1
		WEnd
		
		$sDef = IniRead($sPENMini, "Schemes", "Default", "")
		
		IniDelete($sPENMini, $sScheme)
		IniDelete($sPENMini, "Schemes")
		
		If $sDef <> $sScheme Then IniWrite($sPENMini, "Schemes", "Default", $sDef) 
		
		$arSplit = StringSplit($sSchemes, "|")
		For $i = 1 To $arSplit[0]
			If $arSplit[$i] <> "" Then
				$c += 1
				IniWrite($sPENMini, "Schemes", "Scheme" & $c, $arSplit[$i])
			EndIf
		Next
		
		
		ProfileGetSchemes()
		
		MsgBoxEx(64, $sInfo, "The color scheme """ & $sScheme & """ was deleted.", $hPCG)
	EndIf
EndFunc


Func ProfileUpdClr()
	Local $bUpdBtn = FALSE
	If BitAnd(GUICtrlGetState($nLblConf), $GUI_SHOW) Then $bUpdBtn = TRUE
	
	SetODBtnData($nBtnDhcpInfo, "", $nClrBtnDhcpTxt, $nClrBtnDhcpBk, $bUpdBtn, $nClrBtnDhcpGrad)
	
	GUICtrlSetBkColor($nFrmBkMain1, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nFrmBkMain2, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nFrmBkMain3, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nFrmBkMain4, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nFrmBkMain5, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nFrmBkMain6, $nClrGUIBkFrame)
	
	GUICtrlSetBkColor($nFrmBkConf1, $nClrGUIBkConfFrame)
	GUICtrlSetBkColor($nFrmBkConf2, $nClrGUIBkConfFrame)
	GUICtrlSetBkColor($nFrmBkConf3, $nClrGUIBkConfFrame)
	GUICtrlSetBkColor($nFrmBkConf4, $nClrGUIBkConfFrame)
			
	GUICtrlSetBkColor($nLblBkMain1, $nClrGUIBkMain)
	GUICtrlSetBkColor($nLblBkMain2, $nClrGUIBkMain)

	GUICtrlSetBkColor($nLblStateMain, $nClrGUIBkMain)
	GUICtrlSetColor($nLblStateMain, $nClrStateGreen)
	
	GUICtrlSetBkColor($nLblStateProgress, $nClrGUIBkMain)
	GUICtrlSetColor($nLblStateProgress, $nClrStateRed)
	
	GUICtrlSetBkColor($nLblConfBk1, $nClrGUIBk)
	
	GUICtrlSetBkColor($nLblIPBk, $nClrGUIBkConf)

	GUICtrlSetColor($nLblConf, $nClrLblConf)
	GUICtrlSetBkColor($nLblConf, $nClrGUIBkConf)
	
	GUICtrlSetBkColor($nFrmBkWiFi1, $nClrGUIBkWiFiFrame)
	GUICtrlSetBkColor($nFrmBkWiFi2, $nClrGUIBkWiFiFrame)
	GUICtrlSetBkColor($nFrmBkWiFi3, $nClrGUIBkWiFiFrame)
	GUICtrlSetBkColor($nFrmBkWiFi4, $nClrGUIBkWiFiFrame)
	
	GUICtrlSetBkColor($nLblBkWiFi, $nClrGUIBkWiFi)
	GUICtrlSetColor($nLblWiFi, $nClrLblWiFi)
	GUICtrlSetBkColor($nLblWiFi, $nClrGUIBkWiFi)
	
	GUICtrlSetColor($nLblDefault, $nClrLblNormal)
	GUICtrlSetBkColor($nLblDefault, $nClrGUIBk)
	
	GUICtrlSetBkColor($nLblSrvStart, $nClrSvcStart)
	GUICtrlSetBkColor($nLblSrvStop, $nClrSvcStop)

	InvalidateRect($hSchemesGUI, 0, FALSE)
EndFunc


Func ProfileUpdClrIdx($nIdx = -1, $nCol = 0)
	If $nIdx = -1 Then Return
	
	Switch $nIdx
		Case 0
			GUICtrlSetColor($nLblStateMain, $nClrStateGreen)		
		Case 1
			GUICtrlSetColor($nLblStateProgress, $nClrStateRed)			
		Case 2
			GUICtrlSetBkColor($nLblSrvStart, $nClrSvcStart)			
		Case 3
			GUICtrlSetBkColor($nLblSrvStop, $nClrSvcStop)			
		;Case 4
		;	SetODBtnData($nBtnIPMode, "", $nClrBtnChkTxt, $nClrBtnChkBk, TRUE, $nClrBtnChkGrad)
		;Case 5
		;	SetODBtnData($nBtnIPAuto, "", $nClrBtnUnchkTxt, $nClrBtnUnchkBk, TRUE, $nClrBtnUnchkGrad)
		Case 6
			SetODBtnData($nBtnDHCPInfo, "", $nClrBtnDHCPTxt, $nClrBtnDHCPBk, TRUE, $nClrBtnDHCPGrad)
		Case 20
			GUICtrlSetBkColor($nLblBkMain1, $nClrGUIBkMain)
			GUICtrlSetBkColor($nLblBkMain2, $nClrGUIBkMain)
			GUICtrlSetBkColor($nLblStateMain, $nClrGUIBkMain)
			GUICtrlSetBkColor($nLblStateProgress, $nClrGUIBkMain)
		Case 21
			GUICtrlSetBkColor($nLblConfBk1, $nClrGUIBk)
			GUICtrlSetBkColor($nLblDefault, $nClrGUIBk)
		Case 23
			GUICtrlSetBkColor($nLblIPBk, $nClrGUIBkConf)
			GUICtrlSetBkColor($nLblConf, $nClrGUIBkConf)
		Case 24
			GUICtrlSetBkColor($nLblBkWiFi, $nClrGUIBkWiFi)
			GUICtrlSetBkColor($nLblWiFi, $nClrGUIBkWiFi)
		Case 26
			GUICtrlSetColor($nLblDefault, $nClrLblNormal)
		Case 27
			GUICtrlSetColor($nLblConf, $nClrLblConf)
		Case 28
			GUICtrlSetColor($nLblWiFi, $nClrLblWiFi)
		Case 35
			GUICtrlSetBkColor($nFrmBkMain1, $nClrGUIBkFrame)
			GUICtrlSetBkColor($nFrmBkMain2, $nClrGUIBkFrame)
			GUICtrlSetBkColor($nFrmBkMain3, $nClrGUIBkFrame)
			GUICtrlSetBkColor($nFrmBkMain4, $nClrGUIBkFrame)
			GUICtrlSetBkColor($nFrmBkMain5, $nClrGUIBkFrame)
			GUICtrlSetBkColor($nFrmBkMain6, $nClrGUIBkFrame)
		Case 36
			GUICtrlSetBkColor($nFrmBkConf1, $nClrGUIBkConfFrame)
			GUICtrlSetBkColor($nFrmBkConf2, $nClrGUIBkConfFrame)
			GUICtrlSetBkColor($nFrmBkConf3, $nClrGUIBkConfFrame)
			GUICtrlSetBkColor($nFrmBkConf4, $nClrGUIBkConfFrame)
		Case 37
			GUICtrlSetBkColor($nFrmBkWiFi1, $nClrGUIBkWiFiFrame)
			GUICtrlSetBkColor($nFrmBkWiFi2, $nClrGUIBkWiFiFrame)
			GUICtrlSetBkColor($nFrmBkWiFi3, $nClrGUIBkWiFiFrame)
			GUICtrlSetBkColor($nFrmBkWiFi4, $nClrGUIBkWiFiFrame)
	EndSwitch
EndFunc


Func ProfileSetClr($nIdx, $nCol)
	Local $nID, $nLbl
	
	If $nCol = 2 Then
		$nID = $nBtnSchemeTxt
		$nLbl= $nLblSchemeTxt
	ElseIf $nCol = 3 Then
		$nID = $nBtnSchemeBk1
		$nLbl= $nLblSchemeBk1
	Else
		$nID = $nBtnSchemeBk2
		$nLbl= $nLblSchemeBk2
	EndIf
	
	If $arClr[$nIdx][$nCol] = -4 Then
		GUICtrlSetState($nLblSchemeTxt, $GUI_HIDE)
		SetODBtnState($nBtnSchemeTxt, $GUI_HIDE, FALSE)
		GUICtrlSetState($nLblSchemeBk1, $GUI_HIDE)
		SetODBtnState($nBtnSchemeBk1, $GUI_HIDE, FALSE)
		GUICtrlSetState($nLblSchemeBk2, $GUI_HIDE)
		SetODBtnState($nBtnSchemeBk2, $GUI_HIDE, FALSE)
	Else
		GUICtrlSetState($nLblSchemeTxt, $GUI_SHOW)
		SetODBtnState($nBtnSchemeTxt, $GUI_SHOW, FALSE)
		GUICtrlSetState($nLblSchemeBk1, $GUI_SHOW)
		SetODBtnState($nBtnSchemeBk1, $GUI_SHOW, FALSE)
		GUICtrlSetState($nLblSchemeBk2, $GUI_SHOW)
		SetODBtnState($nBtnSchemeBk2, $GUI_SHOW, FALSE)
		
		If $arClr[$nIdx][$nCol] = -3 Then
			GUICtrlSetState($nLbl, $GUI_DISABLE)
			SetODBtnState($nID, $GUI_DISABLE, FALSE)
			SetODBtnData($nID, "", -1, GetBGRColor(GetSysColor($COLOR_BTNFACE)))
		Else
			GUICtrlSetState($nLbl, $GUI_ENABLE)
			SetODBtnState($nID, $GUI_ENABLE, FALSE)
			If $arClr[$nIdx][$nCol] = -1 Then
				SetODBtnData($nID, "", -1, GetBGRColor(GetSysColor($COLOR_BTNFACE)))
			ElseIf $arClr[$nIdx][5] Then
				SetODBtnData($nID, "", -1, GetBGRColor($arClr[$nIdx][$nCol]))
			Else
				SetODBtnData($nID, "", -1, $arClr[$nIdx][$nCol])
			EndIf
		EndIf
	EndIf
EndFunc


Func ProfileRstClr()
	Local $i, $sClrElement = ""	
	For $i = 0 To 46
		$sClrElement = $sClrElement & "|" & $arClr[$i][0]
	Next
	
	$nCmbElementLast = -1
	
	GUICtrlSetData($nComboElement, $sClrElement)
	
	SetODBtnState($nBtnSchemeTxt, BitOr($GUI_DISABLE, $GUI_SHOW), FALSE)
	SetODBtnData($nBtnSchemeTxt, "", -1, GetBGRColor(GetSysColor($COLOR_BTNFACE)))
	SetODBtnState($nBtnSchemeBk1, BitOr($GUI_DISABLE, $GUI_SHOW), FALSE)
	SetODBtnData($nBtnSchemeBk1, "", -1, GetBGRColor(GetSysColor($COLOR_BTNFACE)))
	SetODBtnState($nBtnSchemeBk2, BitOr($GUI_DISABLE, $GUI_SHOW), FALSE)
	SetODBtnData($nBtnSchemeBk2, "", -1, GetBGRColor(GetSysColor($COLOR_BTNFACE)))
	
	GUICtrlSetState($nLblSchemeTxt, $GUI_SHOW)
	GUICtrlSetState($nLblSchemeBk1, $GUI_SHOW)
	GUICtrlSetState($nLblSchemeBk2, $GUI_SHOW)
EndFunc


Func FillArClr()
	$arClr[0][2]		= $nClrStateGreen
	$arClr[1][2]		= $nClrStateRed
	$arClr[2][3]		= $nClrSvcStart
	$arClr[3][3]		= $nClrSvcStop
	$arClr[4][2]		= $nClrBtnChkTxt
	$arClr[4][3]		= $nClrBtnChkBk
	$arClr[4][4]		= $nClrBtnChkGrad
	$arClr[5][2]		= $nClrBtnUnchkTxt
	$arClr[5][3]		= $nClrBtnUnchkBk
	$arClr[5][4]		= $nClrBtnUnchkGrad
	$arClr[6][2]		= $nClrBtnDHCPTxt
	$arClr[6][3]		= $nClrBtnDHCPBk
	$arClr[6][4]		= $nClrBtnDHCPGrad
	$arClr[7][2]		= $nClrBtnTxtDisabled
	$arClr[8][2]		= $nClrBtnBkActive
	$arClr[9][2]		= $nClrBtnFocus
	$arClr[10][2]		= $nClrBtnNormalTxt
	$arClr[10][3]		= $nClrBtnNormalBk
	$arClr[10][4]		= $nClrBtnNormalGrad
	$arClr[11][2]		= $nClrBtnFrame
	$arClr[12][2]		= $nClrWiFiConnect
	$arClr[13][2]		= $nClrTITxt
	$arClr[13][3]		= $nClrTIBk
	$arClr[13][4]		= $nClrTIGrad
	$arClr[14][2]		= $nClrTISelTxt
	$arClr[14][3]		= $nClrTISelBk
	$arClr[14][4]		= $nClrTISelGrad
	$arClr[15][2]		= $nClrTIFocus
	$arClr[16][2]		= $nClrTIConfTxt
	$arClr[16][3]		= $nClrTIConfBk
	$arClr[16][4]		= $nClrTIConfGrad
	$arClr[17][2]		= $nClrTIConfSelTxt
	$arClr[17][3]		= $nClrTIConfSelBk
	$arClr[17][4]		= $nClrTIConfSelGrad
	$arClr[18][2]		= $nClrTIWiFiTxt
	$arClr[18][3]		= $nClrTIWiFiBk
	$arClr[18][4]		= $nClrTIWiFiGrad
	$arClr[19][2]		= $nClrTIWiFiSelTxt
	$arClr[19][3]		= $nClrTIWiFiSelBk
	$arClr[19][4]		= $nClrTIWiFiSelGrad
	$arClr[20][3]		= $nClrGUIBkMain
	$arClr[21][3]		= $nClrGUIBk
	$arClr[22][3]		= $nClrGUIBkSub
	$arClr[23][3]		= $nClrGUIBkConf
	$arClr[24][3]		= $nClrGUIBkWiFi
	$arClr[25][3]		= $nClrGUIBkAuth
	$arClr[26][2]		= $nClrLblNormal
	$arClr[27][2]		= $nClrLblConf
	$arClr[28][2]		= $nClrLblWiFi
	$arClr[29][2]		= $nClrLVWiFiTxt
	$arClr[29][3]		= $nClrLVWiFiBk
	$arClr[30][2]		= $nClrLVSharesTxt
	$arClr[30][3]		= $nClrLVSharesBk
	$arClr[31][2]		= $nClrLVDrivesTxt
	$arClr[31][3]		= $nClrLVDrivesBk
	$arClr[32][2]		= $nClrLVPingTxt
	$arClr[32][3]		= $nClrLVPingBk
	$arClr[33][2]		= $nClrLProfileTxt
	$arClr[33][3]		= $nClrLProfileBk
	$arClr[34][2]		= $nClrLExtTxt
	$arClr[34][3]		= $nClrLExtBk
	$arClr[35][2]		= $nClrGUIBkFrame
	$arClr[36][2]		= $nClrGUIBkConfFrame
	$arClr[37][2]		= $nClrGUIBkWiFiFrame
	$arClr[38][2]		= $nClrBtnFrameDisabled
	$arClr[39][3]		= $nClrTrayBk
	$arClr[39][2]		= $nClrTrayTxt
	$arClr[40][2]		= $nClrTrayTrans
	$arClr[41][3]		= $nClrTraySelBk
	$arClr[41][2]		= $nClrTraySelTxt
	$arClr[42][2]		= $nClrTrayConnect
	$arClr[43][2]		= $nClrTrayBtnFocus
	$arClr[44][2]		= $nClrTrayBtnTxt
	$arClr[44][3]		= $nClrTrayBtnBk
	$arClr[44][4]		= $nClrTrayBtnGrad
	$arClr[45][2]		= $nClrTrayBtnFrame
	$arClr[46][2]		= $nClrTrayTxtGray
EndFunc


Func ArClr2Val()
	$nClrStateGreen		= $arClr[0][2]
	$nClrStateRed		= $arClr[1][2]
	$nClrSvcStart		= $arClr[2][3]
	$nClrSvcStop		= $arClr[3][3]
	$nClrBtnChkTxt		= $arClr[4][2]
	$nClrBtnChkBk		= $arClr[4][3]
	$nClrBtnChkGrad		= $arClr[4][4]
	$nClrBtnUnchkTxt	= $arClr[5][2]
	$nClrBtnUnchkBk		= $arClr[5][3]
	$nClrBtnUnchkGrad	= $arClr[5][4]
	$nClrBtnDHCPTxt		= $arClr[6][2]
	$nClrBtnDHCPBk		= $arClr[6][3]
	$nClrBtnDHCPGrad	= $arClr[6][4]
	$nClrBtnTxtDisabled	= $arClr[7][2]
	$nClrBtnBkActive	= $arClr[8][2]
	$nClrBtnFocus		= $arClr[9][2]
	$nClrBtnNormalTxt	= $arClr[10][2]
	$nClrBtnNormalBk	= $arClr[10][3]
	$nClrBtnNormalGrad	= $arClr[10][4]
	$nClrBtnFrame		= $arClr[11][2]
	$nClrWiFiConnect	= $arClr[12][2]
	$nClrTITxt			= $arClr[13][2]
	$nClrTIBk			= $arClr[13][3]
	$nClrTIGrad			= $arClr[13][4]
	$nClrTISelTxt		= $arClr[14][2]
	$nClrTISelBk		= $arClr[14][3]
	$nClrTISelGrad		= $arClr[14][4]
	$nClrTIFocus		= $arClr[15][2]
	$nClrTIConfTxt		= $arClr[16][2]
	$nClrTIConfBk		= $arClr[16][3]
	$nClrTIConfGrad		= $arClr[16][4]
	$nClrTIConfSelTxt	= $arClr[17][2]
	$nClrTIConfSelBk	= $arClr[17][3]
	$nClrTIConfSelGrad	= $arClr[17][4]
	$nClrTIWiFiTxt		= $arClr[18][2]
	$nClrTIWiFiBk		= $arClr[18][3]
	$nClrTIWiFiGrad		= $arClr[18][4]
	$nClrTIWiFiSelTxt	= $arClr[19][2]
	$nClrTIWiFiSelBk	= $arClr[19][3]
	$nClrTIWiFiSelGrad	= $arClr[19][4]
	$nClrGUIBkMain		= $arClr[20][3]
	$nClrGUIBk			= $arClr[21][3]
	$nClrGUIBkSub		= $arClr[22][3]
	$nClrGUIBkConf		= $arClr[23][3]
	$nClrGUIBkWiFi		= $arClr[24][3]
	$nClrGUIBkAuth		= $arClr[25][3]
	$nClrLblNormal		= $arClr[26][2]
	$nClrLblConf		= $arClr[27][2]
	$nClrLblWiFi		= $arClr[28][2]
	$nClrLVWiFiTxt		= $arClr[29][2]
	$nClrLVWiFiBk		= $arClr[29][3]
	$nClrLVSharesTxt	= $arClr[30][2]
	$nClrLVSharesBk		= $arClr[30][3]
	$nClrLVDrivesTxt	= $arClr[31][2]
	$nClrLVDrivesBk		= $arClr[31][3]
	$nClrLVPingTxt		= $arClr[32][2]
	$nClrLVPingBk		= $arClr[32][3]
	$nClrLProfileTxt	= $arClr[33][2]
	$nClrLProfileBk		= $arClr[33][3]
	$nClrLExtTxt		= $arClr[34][2]
	$nClrLExtBk			= $arClr[34][3]
	$nClrGUIBkFrame		= $arClr[35][2]
	$nClrGUIBkConfFrame	= $arClr[36][2]
	$nClrGUIBkWiFiFrame	= $arClr[37][2]
	$nClrBtnFrameDisabled = $arClr[38][2]
	$nClrTrayBk			= $arClr[39][3]
	$nClrTrayTxt		= $arClr[39][2]
	$nClrTrayTrans		= $arClr[40][2]
	$nClrTraySelBk		= $arClr[41][3]
	$nClrTraySelTxt		= $arClr[41][2]
	$nClrTrayConnect	= $arClr[42][2]
	$nClrTrayBtnFocus	= $arClr[43][2]
	$nClrTrayBtnTxt		= $arClr[44][2]
	$nClrTrayBtnBk		= $arClr[44][3]
	$nClrTrayBtnGrad	= $arClr[44][4]
	$nClrTrayBtnFrame	= $arClr[45][2]
	$nClrTrayTxtGray	= $arClr[46][2]
EndFunc


Func ProfileClrDlg($nInitClr = 0)
	Local $stClr = DllStructCreate("dword[16]")
	Local $stCC = DllStructCreate("dword;hwnd;hwnd;dword;ptr;dword;dword;ptr;ptr")
	DllStructSetData($stCC, 1, DllStructGetSize($stCC))
	DllStructSetData($stCC, 2, $hPCG)
	DllStructSetData($stCC, 3, 0)
	DllStructSetData($stCC, 4, $nInitClr)
	DllStructSetData($stCC, 5, DllStructGetPtr($stClr))
	DllStructSetData($stCC, 6, BitOr(0x1, 0x2)) ; CC_RGBINIT + CC_FULLOPEN
	DllStructSetData($stCC, 8, 0)
	DllStructSetData($stCC, 9, 0)
	
	DllCall("comdlg32.dll", "int", "ChooseColor", _
									"long_ptr", DllStructGetPtr($stCC))
													
	Return DllStructGetData($stCC, 4)
EndFunc


Func ProfileSetSchemeElement($nID, $nIdx)
	If $nID <> $nCmbElementLast And $nIdx > -1 Then
		GUICtrlSetData($nComboElement, $arClr[$nIdx][0])
	
		ProfileSetClr($nIdx, 2)
		ProfileSetClr($nIdx, 3)
		ProfileSetClr($nIdx, 4)
		
		$nCmbElementLast = $nID
	EndIf
EndFunc


Func ProfileClearSettings()
	;GUICtrlSetData($nInpProfile, "")
	GUICtrlSetData($nEditDesc, "")
	GUICtrlSetData($nInpPCName, "")
	GUICtrlSetData($nInpPCWG, "")
	GUICtrlSetData($nInpPCDNS, "")
	GUICtrlSetData($nInpNetPath, "")
	GUICtrlSetData($nComboNA, "|")
	GUICtrlSetState($nChkShrAuto, $GUI_INDETERMINATE)
	GUICtrlSetState($nChkShrAll, $GUI_INDETERMINATE)
	GUICtrlSetData($nComboShrUsr, "|")
	GUICtrlSetData($nInpShrPW, "")
	
	GUICtrlSetData($nComboDrvPath, "|")
	GUICtrlSetData($nInpDrvUsr, "")
	GUICtrlSetData($nInpDrvPW, "")
	;GUICtrlSetData($nComboDrv, $sNewLetters, "")
	GUICtrlSetData($nLblDrvLetter, "")
	
	GUICtrlSendMsg($nLVCMDStart, $LVM_DELETEALLITEMS, 0, 0)
	GUICtrlSetData($nInpCMDStart, "")
	
	GUICtrlSendMsg($nLVCMDChange, $LVM_DELETEALLITEMS, 0, 0)
	GUICtrlSetData($nInpCMDChange, "")
	
	GUICtrlSendMsg($nLVWLPref, $LVM_DELETEALLITEMS, 0, 0)
	
	GUICtrlSetState($nChkKey, $GUI_UNCHECKED)
	GUICtrlSendMsg($nInpKey, $EM_SETPASSWORDCHAR, 0x25CF, 0)
	GUICtrlSetState($nChkShrPW, $GUI_UNCHECKED)
	GUICtrlSendMsg($nInpShrPW, $EM_SETPASSWORDCHAR, 0x25CF, 0)
	GUICtrlSetState($nChkDrvPW, $GUI_UNCHECKED)
	GUICtrlSendMsg($nInpDrvPW, $EM_SETPASSWORDCHAR, 0x25CF, 0)
	
	ProfileWiFiClear()
	ProfileClearInputs()
EndFunc


Func ProfileClearInputs()
	GUICtrlSetData($nInpIP, "")
	GUICtrlSetData($nInpSM, "")
	GUICtrlSetData($nInpDG, "")
	GUICtrlSetData($nInpDNS, "")		
	GUICtrlSetData($nInpWINS, "")
	GUICtrlSetData($nInpMAC, "")
	GUICtrlSetData($nInpFilter, "")
EndFunc


Func ProfileDisableControls()
	SetODBtnState($nBtnProfDel, $GUI_DISABLE)
	SetODBtnState($nBtnProfCopy, $GUI_DISABLE)
	GUICtrlSetState($nEditDesc, $GUI_DISABLE)
	GUICtrlSetState($nInpPCName, $GUI_DISABLE)
	GUICtrlSetState($nInpPCWG, $GUI_DISABLE)
	GUICtrlSetState($nInpPCDNS, $GUI_DISABLE)
	GUICtrlSetState($nComboNA, $GUI_DISABLE)
	GUICtrlSetState($nBtnAddAdapter, $GUI_DISABLE)
	GUICtrlSetState($nBtnDelAdapter, $GUI_DISABLE)
	GUICtrlSetState($nInpIP, $GUI_DISABLE)
	GUICtrlSetState($nInpSM, $GUI_DISABLE)
	GUICtrlSetState($nInpDG, $GUI_DISABLE)
	GUICtrlSetState($nInpDNS, $GUI_DISABLE)
	GUICtrlSetState($nInpWINS, $GUI_DISABLE)
	GUICtrlSetState($nInpMAC, $GUI_DISABLE)
	GUICtrlSetState($nInpFilter, $GUI_DISABLE)
	GUICtrlSetState($nChkShrAuto, $GUI_DISABLE)
	GUICtrlSetState($nChkShrAll, $GUI_DISABLE)
	SetODBtnState($nBtnAddUser, $GUI_DISABLE)
	SetODBtnState($nBtnDelUser, $GUI_DISABLE)
	GUICtrlSetState($nChkShrPW, $GUI_DISABLE)
	GUICtrlSetState($nComboShrUsr, $GUI_DISABLE)
	GUICtrlSetState($nInpShrPW, $GUI_DISABLE)
	GUICtrlSetState($nInpNetPath, $GUI_DISABLE)
	GUICtrlSetState($nComboDrvPath, $GUI_DISABLE)
	GUICtrlSetState($nInpDrvUsr, $GUI_DISABLE)
	GUICtrlSetState($nInpDrvPW, $GUI_DISABLE)
	GUICtrlSetState($nComboDrv, $GUI_DISABLE)
	SetODBtnState($nBtnDrvAdd, $GUI_DISABLE)
	SetODBtnState($nBtnDrvDel, $GUI_DISABLE)
	GUICtrlSetState($nChkDrvPW, $GUI_DISABLE)
	GUICtrlSetState($nInpCMDStart, $GUI_DISABLE)
	GUICtrlSetState($nInpCMDChange, $GUI_DISABLE)	
	GUICtrlSetState($nInpSSID, $GUI_DISABLE)
	GUICtrlSetState($nInpKey, $GUI_DISABLE)
	GUICtrlSetState($nChkKey, $GUI_DISABLE)
	GUICtrlSetState($nComboAuth, $GUI_DISABLE)
	GUICtrlSetState($nComboEnc, $GUI_DISABLE)
	SetODBtnState($nBtnWiFiClear, $GUI_DISABLE)
	SetODBtnState($nBtnWiFiAdd, $GUI_DISABLE)
	GUICtrlSetState($nChkAuto, $GUI_DISABLE)
	GUICtrlSetState($nChkHidden, $GUI_DISABLE)
	GUICtrlSetState($nChkAdhoc, $GUI_DISABLE)
	SetODBtnState($nBtnCMDStartUp, $GUI_DISABLE)
	SetODBtnState($nBtnCMDStartDown, $GUI_DISABLE)
	GUICtrlSetState($nComboStartRun, $GUI_DISABLE)
	GUICtrlSetState($nComboStartWait, $GUI_DISABLE)
	SetODBtnState($nBtnCMDStartClear, $GUI_DISABLE)
	SetODBtnState($nBtnCMDStartEdit, $GUI_DISABLE)
	SetODBtnState($nBtnCMDStartAdd, $GUI_DISABLE)
	SetODBtnState($nBtnCMDStartDel, $GUI_DISABLE)
	SetODBtnState($nBtnCMDChangeUp, $GUI_DISABLE)
	SetODBtnState($nBtnCMDChangeDown, $GUI_DISABLE)
	GUICtrlSetState($nComboChangeRun, $GUI_DISABLE)
	GUICtrlSetState($nComboChangeWait, $GUI_DISABLE)
	SetODBtnState($nBtnCMDChangeClear, $GUI_DISABLE)
	SetODBtnState($nBtnCmdChangeChg, $GUI_DISABLE)
	SetODBtnState($nBtnCMDChangeAdd, $GUI_DISABLE)
	SetODBtnState($nBtnCMDChangeDel, $GUI_DISABLE)
	
EndFunc


Func ProfileGetSection($sProfile)
	Local $sSection = ""
	Local $arNetProfiles = IniReadSection($sPENMini, "NetProfiles")
	
	If @Error Then
		IniWriteSection(@ScriptDir & "\PENetwork.ini", "NetProfiles", "")
		Return ""
	EndIf
	
	Local $i
	
	For $i = 1 To $arNetProfiles[0][0]
		If $arNetProfiles[$i][0] = $sProfile Then
			$sSection = $arNetProfiles[$i][1]
			Return $sSection
		EndIf
	Next
	
	Return $sSection
EndFunc


Func ProfileAddSection($sProfile)
	Local $sSection = ""
	Local $arNetProfiles = IniReadSection($sPENMini, "NetProfiles")
	
	If @Error Then
		IniWriteSection(@ScriptDir & "\PENetwork.ini", "NetProfiles", "")
	Else
		Local $i
		For $i = 1 To $arNetProfiles[0][0]
			If $arNetProfiles[$i][0] = $sProfile Then
				$sSection = $arNetProfiles[$i][1]
				Return $sSection
			EndIf
		Next
	EndIf
	
	Return $sSection
EndFunc


Func ProfileCheckChanges()
	Local $nMsgRes = 0, $nResult = 0
	
	If $bAdapterAdded Or _
	$bUserChanged Or _
	$bDriveChanged Or _
	$bWiFiChanged Then
		$nMsgRes = MsgBoxEx(35, "Save changes now?", "Your current changes were not saved." & @LF & _
					"Do you want to save them now?", $hPCG)
		If $nMsgRes = 6 Then
			ProfileSave()
			$nResult = 1
		Else
			If $nMsgRes = 2 Then Return 3
			
			$bUserChanged	= FALSE
			$bDriveChanged	= FALSE
			$bWiFiChanged	= FALSE
			
			$nResult = 2
		EndIf
		
		$bAdapterAdded = FALSE
	EndIf
	
	Return $nResult
EndFunc


Func ProfileGetParams($sProfile, $sAdapter = "")
	If ProfileCheckChanges() = 3 Then Return
		
	$sCurProfile = $sProfile
	
	Local $i, $nMode, $nID, $sLine, $sDesc = "", $sShrUsrLst = "|", $sNetDrvLst = "|"
	Local $arProfile = IniReadSection($sPENMini, $sProfile)
	If @Error Then
		ProfileClearSettings()
		Return
	EndIf
	
	If $sAdapter = "" Then	
		ProfileClearSettings()
		
		GUICtrlSetState($nEditDesc, $GUI_ENABLE)
		GUICtrlSetState($nInpPCName, $GUI_ENABLE)
		GUICtrlSetState($nInpPCWG, $GUI_ENABLE)
		GUICtrlSetState($nInpPCDNS, $GUI_ENABLE)
		GUICtrlSetState($nComboNA, $GUI_ENABLE)
		GUICtrlSetState($nBtnAddAdapter, $GUI_ENABLE)
		GUICtrlSetState($nBtnDelAdapter, $GUI_ENABLE)
		GUICtrlSetState($nInpIP, $GUI_ENABLE)
		GUICtrlSetState($nInpSM, $GUI_ENABLE)
		GUICtrlSetState($nInpDG, $GUI_ENABLE)
		GUICtrlSetState($nInpDNS, $GUI_ENABLE)
		GUICtrlSetState($nInpWINS, $GUI_ENABLE)
		GUICtrlSetState($nInpMAC, $GUI_ENABLE)
		GUICtrlSetState($nInpFilter, $GUI_ENABLE)
		GUICtrlSetState($nChkShrAuto, $GUI_ENABLE)
		GUICtrlSetState($nChkShrAll, $GUI_ENABLE)
		SetODBtnState($nBtnAddUser, $GUI_ENABLE)
		SetODBtnState($nBtnDelUser, $GUI_ENABLE)
		GUICtrlSetState($nChkShrPW, $GUI_ENABLE)
		GUICtrlSetState($nComboShrUsr, $GUI_ENABLE)
		GUICtrlSetState($nInpShrPW, $GUI_ENABLE)
		GUICtrlSetState($nInpNetPath, $GUI_ENABLE)
		GUICtrlSetState($nComboDrvPath, $GUI_ENABLE)
		GUICtrlSetState($nInpDrvUsr, $GUI_ENABLE)
		GUICtrlSetState($nInpDrvPW, $GUI_ENABLE)
		GUICtrlSetState($nComboDrv, $GUI_ENABLE)
		SetODBtnState($nBtnDrvAdd, $GUI_ENABLE)
		SetODBtnState($nBtnDrvDel, $GUI_ENABLE)
		GUICtrlSetState($nChkDrvPW, $GUI_ENABLE)
		GUICtrlSetState($nInpCMDStart, $GUI_ENABLE)
		GUICtrlSetState($nInpCMDChange, $GUI_ENABLE)
		GUICtrlSetState($nInpSSID, $GUI_ENABLE)
		GUICtrlSetState($nInpKey, $GUI_ENABLE)
		GUICtrlSetState($nChkKey, $GUI_ENABLE)
		GUICtrlSetState($nComboAuth, $GUI_ENABLE)
		GUICtrlSetState($nComboEnc, $GUI_ENABLE)
		SetODBtnState($nBtnWiFiClear, $GUI_ENABLE)
		SetODBtnState($nBtnWiFiAdd, $GUI_ENABLE)
		GUICtrlSetState($nChkAuto, $GUI_ENABLE)
		GUICtrlSetState($nChkHidden, $GUI_ENABLE)
		GUICtrlSetState($nChkAdhoc, $GUI_ENABLE)
		GUICtrlSetState($nComboStartRun, $GUI_ENABLE)
		GUICtrlSetState($nComboStartWait, $GUI_ENABLE)
		SetODBtnState($nBtnCMDStartClear, $GUI_ENABLE)
		SetODBtnState($nBtnCMDStartAdd, $GUI_ENABLE)
		GUICtrlSetState($nComboChangeRun, $GUI_ENABLE)
		GUICtrlSetState($nComboChangeWait, $GUI_ENABLE)
		SetODBtnState($nBtnCMDChangeClear, $GUI_ENABLE)
		SetODBtnState($nBtnCMDChangeAdd, $GUI_ENABLE)
		
		$i = 1
		While 1
			$sLine = IniRead($sPENMini, $sProfile, "Desc.Line" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			
			$sDesc &= $sLine & @CRLF
			
			$i += 1
		WEnd
		
		; 15.03.2008 - only write to inifile on profile saving
		; Description compatibility mode
		If $sDesc = "" Then
			$sLine = IniRead($sPENMini, $sProfile, "Desc", "IniReadError")
			If $sLine <> "IniReadError" Then $sDesc = StringReplace($sLine, "@LF", @CRLF)
		EndIf
		
		If StringRight($sDesc, 2) = @CRLF Then $sDesc = StringTrimRight($sDesc, 2)
		
		GUICtrlSetData($nEditDesc, $sDesc)
		;GUICtrlSetData($nEditDesc, StringReplace(IniRead($sPENMini, $sProfile, $sProfile & ".Desc", ""), "@LF", @CRLF))
		GUICtrlSetData($nInpPCName, IniRead($sPENMini, $sProfile, "ComputerName", ""))
		GUICtrlSetData($nInpPCWG, IniRead($sPENMini, $sProfile, "WorkGroup", ""))
		GUICtrlSetData($nInpPCDNS, IniRead($sPENMini, $sProfile, "DNSSuffix", ""))		
		GUICtrlSetData($nInpNetPath, IniRead($sPENMini, $sProfile, "NetPath", ""))
		
		Local $sStartSharing	= IniRead($sPENMini, $sProfile, "StartSharing", "")
		Local $sShareAll		= IniRead($sPENMini, $sProfile, "ShareAll", "")
		
		If $sStartSharing = "Yes" Then
			GUICtrlSetState($nChkShrAuto, $GUI_CHECKED)
		ElseIf $sStartSharing = "No" Then
			GUICtrlSetState($nChkShrAuto, $GUI_UNCHECKED)
		Else
			GUICtrlSetState($nChkShrAuto, $GUI_INDETERMINATE)
		EndIf
		
		If $sShareAll = "Yes" Then
			GUICtrlSetState($nChkShrAll, $GUI_CHECKED)
		ElseIf $sShareAll = "No" Then
			GUICtrlSetState($nChkShrAll, $GUI_UNCHECKED)
		Else
			GUICtrlSetState($nChkShrAll, $GUI_INDETERMINATE)
		EndIf
	
		; Get sharing accounts
		$arShrUsr[0][0] = 0
		
		$i = 1
		While 1
			$sLine = IniRead($sPENMini, $sProfile, "Share.User" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			$sLine = ProfileGetDText($sLine)
			
			$arShrUsr[0][0] += 1
			$arShrUsr[$arShrUsr[0][0]][0] = $sLine
			$arShrUsr[$arShrUsr[0][0]][1] = ProfileGetDText(IniRead($sPENMini, $sProfile, "Share.Pass" & $i, ""))
			
			$sShrUsrLst &= $sLine & "|"
			$i += 1			
		WEnd
		
		If $sShrUsrLst <> "" Then GUICtrlSetData($nComboShrUsr, $sShrUsrLst)
		
		GUICtrlSetData($nInpShrPW, "")
		
		; Get net drives
		$arNetDrv[0][0] = 0
		
		$i = 1
		While 1
			$sLine = IniRead($sPENMini, $sProfile, "NetDrv.Path" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			
			$arNetDrv[0][0] += 1
			$arNetDrv[$arNetDrv[0][0]][0] = $sLine
			$arNetDrv[$arNetDrv[0][0]][1] = ProfileGetDText(IniRead($sPENMini, $sProfile, "NetDrv.User" & $i, ""))
			$arNetDrv[$arNetDrv[0][0]][2] = ProfileGetDText(IniRead($sPENMini, $sProfile, "NetDrv.Pass" & $i, ""))
			$arNetDrv[$arNetDrv[0][0]][3] = IniRead($sPENMini, $sProfile, "NetDrv.Letter" & $i, "")
			
			$sNetDrvLst &= $sLine & "|"
			$i += 1			
		WEnd

		If $sNetDrvLst <> "" Then GUICtrlSetData($nComboDrvPath, $sNetDrvLst)
		
		ProfileUpdNetLetters()
		
		GUICtrlSetData($nInpDrvUsr, "")
		GUICtrlSetData($nInpDrvPW, "")
		GUICtrlSetData($nLblDrvLetter, "")		
		GUICtrlSetData($nComboDrv, $sNewLetters, "")
		
		; Load CMD's - after starting network
		$i = 1
		Local $sCMD, $sStart, $sWait
		While 1
			$sCMD	= IniRead($sPENMini, $sProfile, "CMDStart.CMD" & $i, "IniReadError")
			If $sCMD = "IniReadError" Then ExitLoop
			
			$sStart	= IniRead($sPENMini, $sProfile, "CMDStart.Start" & $i, "Normal")
			$sWait	= IniRead($sPENMini, $sProfile, "CMDStart.Wait" & $i, "Yes")
			
			ProfileCMDAdd($nLVCMDStart, $sCMD, $sStart, $sWait)
			
			$i += 1
		WEnd
		
		; Load CMD's - after changing IP settings
		$i = 1
		Local $sCMD, $sStart, $sWait
		While 1
			$sCMD	= IniRead($sPENMini, $sProfile, "CMDChange.CMD" & $i, "IniReadError")
			If $sCMD = "IniReadError" Then ExitLoop
			
			$sStart	= IniRead($sPENMini, $sProfile, "CMDChange.Start" & $i, "Normal")
			$sWait	= IniRead($sPENMini, $sProfile, "CMDChange.Wait" & $i, "Yes")
			
			ProfileCMDAdd($nLVCMDChange, $sCMD, $sStart, $sWait)
			
			$i += 1
		WEnd
		
		; Load WiFi profiles
		$i = 1
		Local $sWiFiSSID, $sWiFiKey, $sWiFiAuth, $sWiFiEnc, $sWiFiAuto, $sWiFiHidden, $sWiFiAdhoc
		GUICtrlSendMsg($nLVWLPref, $LVM_DELETEALLITEMS, 0, 0)
		$arWiFiPref[0][0] = 0
		
		While 1
			$sWiFiSSID	= IniRead($sPENMini, $sProfile, "WiFiProfile.SSID" & $i, "IniReadError")
			If $sWiFiSSID = "IniReadError" Then ExitLoop
			
			$sWiFiKey	= ProfileGetDText(IniRead($sPENMini, $sProfile, "WiFiProfile.Key" & $i, ""))
			$sWiFiAuth	= IniRead($sPENMini, $sProfile, "WiFiProfile.Auth" & $i, "none")
			$sWiFiEnc	= IniRead($sPENMini, $sProfile, "WiFiProfile.Enc" & $i, "none")
			$sWiFiAuto	= IniRead($sPENMini, $sProfile, "WiFiProfile.Auto" & $i, "No")
			$sWiFiHidden= IniRead($sPENMini, $sProfile, "WiFiProfile.Hidden" & $i, "No")
			$sWiFiAdhoc	= IniRead($sPENMini, $sProfile, "WiFiProfile.Adhoc" & $i, "No")
			
			$arWiFiPref[0][0] += 1
			$arWiFiPref[$arWiFiPref[0][0]][0] = $sWiFiSSID
			$arWiFiPref[$arWiFiPref[0][0]][1] = $sWiFiKey
			$arWiFiPref[$arWiFiPref[0][0]][2] = $sWiFiAuth
			$arWiFiPref[$arWiFiPref[0][0]][3] = $sWiFiEnc
			$arWiFiPref[$arWiFiPref[0][0]][4] = $sWiFiAuto
			$arWiFiPref[$arWiFiPref[0][0]][5] = $sWiFiHidden
			$arWiFiPref[$arWiFiPref[0][0]][6] = $sWiFiAdhoc
			
			CreateAdvLVItem($sWiFiSSID, $nLVWLPref, "|", -1, FALSE)
			
			$i += 1
		WEnd
	Else
		ProfileClearInputs()
	EndIf
	
	If $sAdapter = "" Then
		GUICtrlSetData($nComboNA, "|")
		
		Local $nAdapter = 0, $nAdapterLast = 0
		Local $sText = "", $sDefault = ""
			
		For $i = 1 To $arProfile[0][0]
			If StringInStr($arProfile[$i][0], "NetAdapter") Then
				$sText = StringLeft($arProfile[$i][0], 11)
				
				If Not ProfileIsAdapterInList($sText) Then
					$nAdapter = Number(StringRight($sText, 1))
					If $nAdapterLast > $nAdapter Or $nAdapterLast = 0 Then
						$sDefault = $sText
						$nAdapterLast = $nAdapter
					EndIf
					GUICtrlSetData($nComboNA, $sText)
				EndIf
			EndIf
		Next
		
		If $sDefault <> "" Then
			GUICtrlSetData($nComboNA, $sDefault)
			$sCurAdapter = $sDefault
		EndIf
	Else
		$sCurAdapter = $sAdapter
	EndIf
	
	ProfileReadAdapter($sProfile, $sCurAdapter)
EndFunc


Func ProfileGetDText($sTextE)
	If $sTextE = "" Then Return ""
	
	Local $i, $k, $c = 0, $sText = ""
	
	For $i = 1 To StringLen($sTextE) Step 2
		$c += 1
		$k = Dec(StringMid($sTextE, $i, 2))
		
		If ($k + $c) > 256 Then
			$sText &= Chr($c - (256 - $k))
		Else
			$sText &= Chr($k + $c)
		EndIf
	Next
	
	Return $sText
EndFunc


Func ProfileGetEText($sTextD)
	If $sTextD = "" Then Return ""
	
	Local $i, $sText = ""

	For $i = 1 To StringLen($sTextD)
		$sText &= Hex(Asc(StringMid($sTextD, $i, 1)) - $i, 2)	
	Next
	
	Return $sText
EndFunc


Func ProfileReadAdapter($sSection, $sAdapter)
	Local $i
	
	Local $sIP		= IniRead($sPENMini, $sSection, $sAdapter & ".IP", "")
	Local $sSM		= IniRead($sPENMini, $sSection, $sAdapter & ".SM", "")
	Local $sDG		= IniRead($sPENMini, $sSection, $sAdapter & ".DG", "")
	Local $sDNS		= IniRead($sPENMini, $sSection, $sAdapter & ".DNS", "")
	Local $sWINS	= IniRead($sPENMini, $sSection, $sAdapter & ".WINS", "")
	Local $sMAC		= IniRead($sPENMini, $sSection, $sAdapter & ".MAC", "")
	Local $sFilter	= IniRead($sPENMini, $sSection, $sAdapter & ".Filter", "")
	
	If $sIP = "" Or StringInStr($sIP, "0.0.0.0") Then
		GUICtrlSetData($nInpIP, "")
		GUICtrlSetData($nInpSM, "")
	Else
		GUICtrlSetData($nInpIP, $sIP)
		GUICtrlSetData($nInpSM, $sSM)
	EndIf
	
	If $sDG = "" Or StringInStr($sDG, "0.0.0.0") Then
		GUICtrlSetData($nInpDG, "")
	Else
		GUICtrlSetData($nInpDG, $sDG)
	EndIf
	
	If $sDNS = "" Then
		GUICtrlSetData($nInpDNS, "")
	Else
		GUICtrlSetData($nInpDNS, $sDNS)
	EndIf
	
	If $sWINS = "" Then
		GUICtrlSetData($nInpWINS, "")
	Else
		GUICtrlSetData($nInpWINS, $sWINS)
	EndIf
	
	If $sMAC = "" Then
		GUICtrlSetData($nInpMAC, "")
	Else
		GUICtrlSetData($nInpMAC, $sMAC)
	EndIf
	
	If $sFilter = "" Then
		GUICtrlSetData($nInpFilter, "")
	Else
		GUICtrlSetData($nInpFilter, $sFilter)
	EndIf
EndFunc


Func ProfileAddProfile($sProfile, $bFromMain = TRUE)
	If Not $bIniOK Then Return
	ProfileCheckChanges()
	
	If $sProfile = "" Then
		MsgBoxEx(48, $sInfo, "Please enter a profile name first!", $hSubGUI)
		Return
	EndIf
	
	If ProfileIsProfileInList($sProfile, $bFromMain) Then
		MsgBoxEx(48, $sInfo, "The profile """ & $sProfile & """already exists!", $hSubGUI)
		Return
	EndIf
	
	If Not $bFromMain Then
		Local $stText = DllStructCreate("wchar[" & (StringLen($sProfile) + 1) & "]")
		DllStructSetData($stText, 1, $sProfile)
		
		GUICtrlSendMsg($nListAddr, $LB_INSERTSTRING, -1, DllStructGetPtr($stText))
		GUICtrlSendMsg($nListAddr, $LB_SELECTSTRING, -1, $sProfile)
		GUICtrlSetData($nInpProfile, "")
	EndIf
	
	GUICtrlSetData($nComboProfiles, $sProfile, $sProfile)	
	GUICtrlSetData($nComboDefProf, $sProfile)
	
	$sCurProfile = $sProfile
	$sCurAdapter = ""
	
	SetODBtnState($nBtnProfDel, $GUI_ENABLE)
	SetODBtnState($nBtnProfCopy, $GUI_ENABLE)
	
	IniWrite($sPENMini, $sProfile, "Computername", "")
	IniWrite($sPENMini, $sProfile, "Workgroup", "")
	IniWrite($sPENMini, "NetProfiles", $sProfile, "")
					
	ProfileGetParams($sProfile)
EndFunc


Func ProfileRenameProfile($sProfile, $sNewname)
	If Not $bIniOK Or $sProfile = "" Then Return
	If $sNewname = "" Then
		MsgBoxEx(48, $sInfo, "Please enter a new profile name first!", $hSubGUI)
		Return
	EndIf

	If ProfileIsProfileInList($sNewname) Then
		MsgBoxEx(48, $sInfo, "The profile """ & $sNewname & """ already exists!", $hSubGUI)
		Return
	EndIf

	Local $i, $sCurSel
	Local $arSection = IniReadSection($sPENMini, "NetProfiles")
	If @Error Then Return
	
	For $i = 1 To $arSection[0][0]
		If $arSection[$i][0] = $sProfile Then
			$arSection[$i][0] = $sNewname
			IniDelete($sPENMini, "NetProfiles", $sProfile)
			IniWriteSection($sPENMini, "NetProfiles", $arSection)
			IniRenameSection($sPENMini, $sProfile, $sNewname)
    
			ProfileChangeProfileList($sNewname, $sProfile)
			GUICtrlSetData($nInpProfile, "")
			
			ExitLoop
		EndIf
	Next
	
	; Update available profiles combo in main GUI
	$sCurSel = GUICtrlRead($nComboProfiles)		
	GUICtrlSetData($nComboProfiles, "|")
	ProfileGetProfiles()
	GUICtrlSetData($nComboProfiles, $sCurSel, $sCurSel)
EndFunc


Func ProfileChangeProfileList($sProfile, $sOldProfile, $bChange = TRUE)
	If $sProfile = "" Then Return
	
	Local $nCurSel = GUICtrlSendMsg($nListAddr, $LB_GETCURSEL, 0, 0)
	
	If $nCurSel <> -1 Then
		GUICtrlSendMsg($nListAddr, $LB_DELETESTRING, $nCurSel, 0)
		
		Local $nCount = GUICtrlSendMsg($nComboDefProf, $CB_GETCOUNT, 0, 0)
		Local $stText, $i, $nLen, $sString
	
		For $i = 0 To $nCount - 1
			$nLen = GUICtrlSendMsg($nComboDefProf, $CB_GETLBTEXTLEN, $i, 0)
			If $nLen > 0 Then
				$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			
				If GUICtrlSendMsg($nComboDefProf, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then
					$sString = DllStructGetData($stText, 1)
					If $sString == $sOldProfile Then
						GUICtrlSendMsg($nComboDefProf, $CB_DELETESTRING, $i, 0)
						ExitLoop
					EndIf
				EndIf
			EndIf
		Next
	
		If $bChange Then
			GUICtrlSendMsg($nListAddr, $LB_INSERTSTRING, $nCurSel, $sProfile)
			GUICtrlSendMsg($nListAddr, $LB_SETCURSEL, $nCurSel, 0)
			
			If IniRead($sPENMini, $sGSection, "ProfileDefault", "") = $sOldProfile Then
				IniWrite($sPENMini, $sGSection, "ProfileDefault", $sProfile)
				GUICtrlSetData($nComboDefProf, $sProfile, $sProfile)
			Else
				GUICtrlSetData($nComboDefProf, $sProfile)
			EndIf
		EndIf
		
	EndIf
EndFunc


Func ProfileDelProfile($sProfile, $bFromSub = FALSE)
	If Not $bIniOK Or $sProfile = "" Then Return

	If $bFromSub Then
		If MsgBoxEx(36, "Delete profile?", _
		"Are you sure you want to delete the profile """ & $sProfile & """ and all of it's settings?", $hSubGUI) = 7 Then Return
	Else
		If MsgBoxEx(36, "Delete profile?", _
		"Are you sure you want to delete the profile """ & $sProfile & """ and all of it's settings?", $hPCG) = 7 Then Return
	EndIf
	
	IniDelete($sPENMini, "NetProfiles", $sProfile)
	IniDelete($sPENMini, $sProfile)
	
	If IniRead($sPENMini, $sGSection, "ProfileDefault", "") = $sProfile Then _
		IniWrite($sPENMini, $sGSection, "ProfileDefault", "")
	
	Local $sTmpProfile = GUICtrlRead($nComboProfiles)
	
	If $bFromSub Then
		ProfileChangeProfileList($sProfile, "", FALSE)
		If $sProfile = $sTmpProfile Then
			$sCurProfile = ""
			ProfileOpen($sPENMini)
		Else
			GUICtrlSetData($nComboProfiles, "|")
			ProfileGetProfiles()
			If $sTmpProfile <> "" Then GUICtrlSetData($nComboProfiles, $sTmpProfile, $sTmpProfile)
		EndIf
	Else
		$sCurProfile = ""
		ProfileOpen($sPENMini)
	EndIf
EndFunc


Func ProfileCopyProfile($sProfile, $bFromSub = FALSE, $sNewProfile = "")
	If Not $bIniOK Or $sProfile = "" Then Return

	Local $arProfile	= IniReadSection($sPENMini, $sProfile)
	Local $arSections	= IniReadSectionNames($sPENMini)
	Local $i, $c = 1, $bFound = FALSE
	
	If $bFromSub Or $sNewProfile = "" Then $sNewProfile = "Copy of " & $sProfile	
	
	While 1
		For $i = 1 To $arSections[0]
			If $arSections[$i] = $sNewProfile Then
				$bFound = TRUE
				ExitLoop
			EndIf	
		Next
		
		If $bFound Then
			$c += 1
			$sNewProfile = "Copy (" & $c & ") of " & $sProfile
			$bFound = FALSE
		Else
			ExitLoop
		EndIf
	WEnd		
			
	IniWriteSection($sPENMini, $sNewProfile, $arProfile)
	IniWrite($sPENMini, "NetProfiles", $sNewProfile, "")
	
	If $bFromSub Then
		Local $stText = DllStructCreate("wchar[" & (StringLen($sNewProfile) + 1) & "]")
		DllStructSetData($stText, 1, $sNewProfile)					
		GUICtrlSendMsg($nListAddr, $LB_INSERTSTRING, -1, DllStructGetPtr($stText))
	EndIf
	
	Local $sTmpProfile = GUICtrlRead($nComboProfiles)
	GUICtrlSetData($nComboProfiles, "|")
	ProfileGetProfiles()
	If $sTmpProfile <> "" Then GUICtrlSetData($nComboProfiles, $sTmpProfile, $sTmpProfile)
EndFunc


Func ProfileIsProfileInList($sProfile, $bFromMain = TRUE)
	Local $bResult = FALSE
	Local $i, $nCount, $stText, $nLen
	
	If $bFromMain Then
		$nCount = GUICtrlSendMsg($nComboProfiles, $CB_GETCOUNT, 0, 0)
		If $nCount = 0 Then Return FALSE
		
		For $i = 0 To $nCount - 1
			$nLen = GUICtrlSendMsg($nComboProfiles, $CB_GETLBTEXTLEN, $i, 0)
			If $nLen > 0 Then
				$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
				
				If GUICtrlSendMsg($nComboProfiles, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then	
					If DllStructGetData($stText, 1) = $sProfile Then
						$bResult = TRUE
						ExitLoop
					EndIf
				EndIf
			EndIf		
		Next
	Else
		$nCount = GUICtrlSendMsg($nListAddr, $LB_GETCOUNT, 0, 0)
		If $nCount = 0 Then Return FALSE
		
		For $i = 0 To $nCount - 1
			$nLen = GUICtrlSendMsg($nListAddr, $LB_GETTEXTLEN, $i, 0)
			If $nLen > 0 Then
				$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
				
				If GUICtrlSendMsg($nListAddr, $LB_GETTEXT, $i, DllStructGetPtr($stText)) > 0 Then
					If DllStructGetData($stText, 1) = $sProfile Then
						$bResult = TRUE
						ExitLoop
					EndIf
				EndIf
			EndIf		
		Next
	EndIf
	
	Return $bResult
EndFunc


Func ProfileCMDAdd($nLV, $sCMD, $sStart, $sWait, $nInp = 0, $nL = -1)
	;If Not $bIniOK Then Return
	
	$bProfileCMDAdded = FALSE
	
	If $sCMD = "" Then
		MsgBoxEx(48, $sInfo, "Please enter a cmdline first!", $hPCG)
		Return
	EndIf
	
	If $sWait = "Wait" Then
		$sWait = "Yes"
	ElseIf $sWait <> "Yes" Then
		$sWait = "No"
	EndIf
	
	Local $sSep = "@@CMD@@"
	CreateAdvLVItem($sCMD & $sSep & $sStart & $sSep & $sWait, $nLV, $sSep, -1, FALSE, $nL)
	
	If $nInp > 0 Then GUICtrlSetData($nInp, "")
		
	$bProfileCMDAdded = TRUE
EndFunc


Func ProfileCMDEdit($nLV, $sCMD, $sStart, $sWait, $nInp)
	Local $nCurSel = GUICtrlSendMsg($nLV, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	If $nCurSel = -1 Or $sCMD = "" Then Return
	
	If $sCMD <> "" Then
		GUICtrlSendMsg($nLV, $LVM_DELETEITEM, $nCurSel, 0)
		ProfileCMDAdd($nLV, $sCMD, $sStart, $sWait, $nInp, $nCurSel)
	EndIf
EndFunc


Func ProfileCMDDel($nLV)
	Local $nCurSel = GUICtrlSendMsg($nLV, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	If $nCurSel = -1 Then Return
	
	GUICtrlSendMsg($nLV, $LVM_DELETEITEM, $nCurSel, 0)
EndFunc


Func ProfileIsAdapterInList($sAdapter)
	Local $bResult = FALSE
	Local $nCount = GUICtrlSendMsg($nComboNA, $CB_GETCOUNT, 0, 0)
	If $nCount = 0 Then Return FALSE
	
	Local $stText, $i, $nLen
	
	For $i = 0 To $nCount - 1
		$nLen = GUICtrlSendMsg($nComboNA, $CB_GETLBTEXTLEN, $i, 0)
		If $nLen > 0 Then
			$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			
			If GUICtrlSendMsg($nComboNA, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then	
				If DllStructGetData($stText, 1) = $sAdapter Then
					$bResult = TRUE
					ExitLoop
				EndIf
			EndIf
		EndIf		
	Next
	
	Return $bResult
EndFunc


Func ProfileDeleteAdapterFromList($sAdapter)
	Local $nCount = GUICtrlSendMsg($nComboNA, $CB_GETCOUNT, 0, 0)
	If $nCount = 0 Or $sAdapter = "" Then Return
	
	Local $stText, $i, $nLen
	
	For $i = 0 To $nCount - 1
		$nLen = GUICtrlSendMsg($nComboNA, $CB_GETLBTEXTLEN, $i, 0)
		If $nLen > 0 Then
			$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			
			If GUICtrlSendMsg($nComboNA, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then	
				If DllStructGetData($stText, 1) = $sAdapter Then
					GUICtrlSendMsg($nComboNA, $CB_DELETESTRING, $i, 0)
					ExitLoop
				EndIf
			EndIf
		EndIf		
	Next	
EndFunc


Func ProfileAddAdapter($sProfile, $nAdapter)
	Local $sAdapter = GUICtrlRead($nAdapter, 1)
	
	If ProfileIsAdapterInList($sAdapter) Then
		MsgBoxEx(48, $sInfo, """" & $sAdapter & """ already exists in this profile!", $hPCG)
		Return
	EndIf
	
	If ProfileCheckChanges() = 2 Then ProfileDeleteAdapterFromList($sAdapter)
	
	$bAdapterAdded = FALSE
		
	ProfileClearInputs()
	
	GUICtrlSetData($nComboNA, $sAdapter, $sAdapter)
	
	$sCurAdapter = $sAdapter
	$bAdapterAdded = TRUE
EndFunc


Func ProfileDelAdapter($sProfile, $sAdapter)
	If Not $bIniOK Or $sProfile = "" Or $sAdapter = "" Then Return
	
	If MsgBoxEx(36, "Delete network adapter?", "Are you sure you want to delete """ & $sAdapter & """ ?", $hPCG) = 7 Then Return
	
	IniDelete($sPENMini, $sProfile, $sAdapter & ".UseDHCP")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".IP")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".SM")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".DG")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".DNS")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".WINS")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".MAC")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".Filter")
	
	Local $nAdapter = Number(StringRight($sAdapter, 1))
	
	Local $i
	For $i = $nAdapter + 1 To 6
		If IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".UseDHCP", "IniReadError") = "IniReadError" Then ExitLoop
		
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".UseDHCP", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".UseDHCP", ""))
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".IP", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".IP", ""))
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".SM", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".SM", ""))
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".DG", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".DG", ""))
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".DNS", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".DNS", ""))
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".WINS", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".WINS", ""))
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".MAC", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".MAC", ""))
		IniWrite($sPENMini, $sProfile, "NetAdapter" & ($i - 1) & ".Filter", IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".Filter", ""))	
	Next

	$i -= 1
		
	If IniRead($sPENMini, $sProfile, "NetAdapter" & $i & ".UseDHCP", "IniReadError") <> "IniReadError" Then 
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".UseDHCP")
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".IP")
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".SM")
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".DG")
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".DNS")
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".WINS")
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".MAC")
		IniDelete($sPENMini, $sProfile, "NetAdapter" & $i & ".Filter")
	EndIf
	
	ProfileOpen($sPENMini)
EndFunc


Func ProfileAddShowMenu($hWnd, $nID, $nContextID)
	Local $hMenu	= GUICtrlGetHandle($nContextID)
	Local $arPos	= ControlGetPos($hWnd, "", $nID)
	Local $stPoint	= DllStructCreate("int;int")
	DllStructSetData($stPoint, 1, $arPos[0])
	DllStructSetData($stPoint, 2, $arPos[1] + $arPos[3])
	
	ClientToScreen($hWnd, DllStructGetPtr($stPoint))
	TrackPopupMenuEx($hMenu, 0, DllStructGetData($stPoint, 1), DllStructGetData($stPoint, 2), $hWnd, 0)
EndFunc


Func ProfileSaveAdapter($sProfile, $sAdapter)
	If Not $bIniOK Or $sProfile = "" Or $sAdapter = "" Then Return
	
	IniWrite($sPENMini, "NetProfiles", $sProfile, "")
	
	Local $bUseDHCP	= 0
	Local $sIP		= GUICtrlRead($nInpIP)
	Local $sSM		= GUICtrlRead($nInpSM)
	Local $sDG		= GUICtrlRead($nInpDG)
	Local $sDNS		= GUICtrlRead($nInpDNS)
	Local $sWINS	= GUICtrlRead($nInpWINS)
	Local $sMAC		= GUICtrlRead($nInpMAC)
	Local $sFilter	= GUICtrlRead($nInpFilter)
	
	If $sIP = "" Then $bUseDHCP = 1
	IniDelete($sPENMini, $sProfile, $sAdapter & ".UseDHCP")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".IP")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".SM")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".DG")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".DNS")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".WINS")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".MAC")
	IniDelete($sPENMini, $sProfile, $sAdapter & ".Filter")
	
	IniWrite($sPENMini, $sProfile, $sAdapter & ".UseDHCP", $bUseDHCP)
	IniWrite($sPENMini, $sProfile, $sAdapter & ".IP", $sIP)
	IniWrite($sPENMini, $sProfile, $sAdapter & ".SM", $sSM)
	IniWrite($sPENMini, $sProfile, $sAdapter & ".DG", $sDG)
	IniWrite($sPENMini, $sProfile, $sAdapter & ".DNS", $sDNS)
	IniWrite($sPENMini, $sProfile, $sAdapter & ".WINS", $sWINS)
	IniWrite($sPENMini, $sProfile, $sAdapter & ".MAC", $sMAC)
	IniWrite($sPENMini, $sProfile, $sAdapter & ".Filter", $sFilter)
EndFunc


Func ProfileGetComboString($nCtrl, $sSearch, ByRef $sList, $bDiff = FALSE)
	Local $nCount = GUICtrlSendMsg($nCtrl, $CB_GETCOUNT, 0, 0)
	Local $stText, $i, $nLen, $sString, $bFound = FALSE
	
	For $i = 0 To $nCount - 1
		$nLen = GUICtrlSendMsg($nCtrl, $CB_GETLBTEXTLEN, $i, 0)
		If $nLen > 0 Then
			$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			
			If GUICtrlSendMsg($nCtrl, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then	
				$sString = DllStructGetData($stText, 1)
				If $bDiff Then
					If $sString <> $sSearch Then $sList &= $sString & "|"
				Else
					If $sString = $sSearch Then $bFound = TRUE				
					$sList &= $sString & "|"
				EndIf
			EndIf
		EndIf
	Next
	
	Return $bFound
EndFunc


Func ProfileAddShrUsr($sUser, $sPass)
	If Not $bIniOK Then Return
	
	$bUserChanged = FALSE
	
	If $sUser = "" Then Return
	
	Local $i, $sList = "|", $bFound = FALSE
	
	If Not ProfileGetComboString($nComboShrUsr, $sUser, $sList) Then
		For $i = 1 To $arShrUsr[0][0]
			If $arShrUsr[$i][0] = "" Then
				$bFound = TRUE
				$nCount = $i
				ExitLoop
			EndIf
		Next
		
		If $bFound Then
			$i = $nCount
		Else
			$arShrUsr[0][0] += 1
			$i = $arShrUsr[0][0]
		EndIf
		
		$arShrUsr[$i][0] = $sUser
		$arShrUsr[$i][1] = $sPass
		
		$sList &= $sUser
	Else
		For $i = 1 To $arShrUsr[0][0]
			If $arShrUsr[$i][0] = $sUser Then
				$arShrUsr[$i][1] = $sPass
				ExitLoop
			EndIf
		Next	
	EndIf

	$bUserChanged = TRUE
	
	GUICtrlSetData($nComboShrUsr, $sList)
	GUICtrlSetData($nInpShrPW, "")
EndFunc


Func ProfileDelShrUsr($sUser)
	If Not $bIniOK Then Return
		
	$bUserChanged = FALSE
	
	If $sUser = "" Then Return
	
	Local $i, $bFound = FALSE, $sList = "|"
	
	For $i = 1 To $arShrUsr[0][0]
		If $arShrUsr[$i][0] = $sUser Then
			$arShrUsr[$i][0] = ""
			$arShrUsr[$i][1] = ""
			
			ExitLoop
		EndIf	
	Next
	
	ProfileGetComboString($nComboShrUsr, $sUser, $sList, TRUE)

	$bUserChanged = TRUE
	
	GUICtrlSetData($nComboShrUsr, $sList)
	GUICtrlSetData($nInpShrPW, "")
EndFunc


Func ProfileShowShrPW($sUser)
	If $sUser = "" Then Return
	
	Local $i, $bFound = FALSE
	
	For $i = 1 To $arShrUsr[0][0]
		If $arShrUsr[$i][0] = $sUser Then
			$bFound = TRUE			
			ExitLoop
		EndIf	
	Next
	
	If $bFound Then GUICtrlSetData($nInpShrPW, $arShrUsr[$i][1])
EndFunc


Func ProfileAddNetDrv($sPath, $sUser, $sPass, $sLetter)
	If Not $bIniOK Or $sPath = "" Then Return
	
	Local $i, $sList = "|", $bFound = FALSE
		
	If Not ProfileGetComboString($nComboDrvPath, $sPath, $sList) Then
		For $i = 1 To $arNetDrv[0][0]
			If $arNetDrv[$i][0] = "" Then
				$bFound = TRUE
				$nCount = $i
				ExitLoop
			EndIf
		Next
		
		If $bFound Then
			$i = $nCount
		Else
			$arNetDrv[0][0] += 1
			$i = $arNetDrv[0][0]
		EndIf
		
		$arNetDrv[$i][0] = $sPath
		$arNetDrv[$i][1] = $sUser
		$arNetDrv[$i][2] = $sPass
		$arNetDrv[$i][3] = $sLetter
				
		$sList &= $sPath
	Else
		For $i = 1 To $arNetDrv[0][0]
			If $arNetDrv[$i][0] = $sPath Then
				$arNetDrv[$i][1] = $sUser
				$arNetDrv[$i][2] = $sPass
				$arNetDrv[$i][3] = $sLetter
				ExitLoop
			EndIf
		Next
	EndIf

	$bDriveChanged = TRUE
	
	ProfileUpdNetLetters()
	
	GUICtrlSetData($nComboDrvPath, $sList)
	GUICtrlSetData($nInpDrvUsr, "")
	GUICtrlSetData($nInpDrvPW, "")
	GUICtrlSetData($nComboDrv, $sNewLetters, "")
	GUICtrlSetData($nLblDrvLetter, "")
EndFunc


Func ProfileDelNetDrv($sPath)
	If Not $bIniOK Or $sPath = "" Then Return
	
	Local $i, $sList = "|"
	
	For $i = 1 To $arNetDrv[0][0]
		If $arNetDrv[$i][0] = $sPath Then
			$arNetDrv[$i][0] = ""
			$arNetDrv[$i][1] = ""
			$arNetDrv[$i][2] = ""
			$arNetDrv[$i][3] = ""
			
			ExitLoop
		EndIf
	Next
	
	ProfileGetComboString($nComboDrvPath, $sPath, $sList, TRUE)
	ProfileUpdNetLetters()
		
	$bDriveChanged = TRUE
	
	GUICtrlSetData($nComboDrvPath, $sList)
	GUICtrlSetData($nInpDrvUsr, "")
	GUICtrlSetData($nInpDrvPW, "")
	GUICtrlSetData($nComboDrv, $sNewLetters, "")
	GUICtrlSetData($nLblDrvLetter, "")
EndFunc


Func ProfileUpdNetLetters()
	Local $sLetters = "", $i, $k, $bFound
	
	Local $arSplit = StringSplit($sDrvLetters, "|")
	If IsArray($arSplit) Then
		For $i = 1 To $arSplit[0]
			If $arSplit[$i] <> "" And $arSplit[$i] <> "*" Then
				$bFound = FALSE
				
				For $k = 1 To $arNetDrv[0][0]
					If $arNetDrv[$k][0] <> "" And $arNetDrv[$k][3] <> "*" Then
						If StringInStr($arSplit[$i], $arNetDrv[$k][3]) Then
							$bFound = TRUE
							ExitLoop
						EndIf
					EndIf				
				Next
				
				If Not $bFound Then $sLetters &= $arSplit[$i] & "|"
			EndIf
		Next
		
		$sLetters = "|*||" & $sLetters
	Else
		$sLetters = $sNewLetters
	EndIf
	
	$sNewLetters = $sLetters
EndFunc


Func ProfileShowDrvInfo($sPath)
	If $sPath = "" Then Return
	
	Local $i, $bFound = FALSE, $sDef = ""
	
	For $i = 1 To $arNetDrv[0][0]
		If $arNetDrv[$i][0] = $sPath Then
			$bFound = TRUE			
			ExitLoop
		EndIf	
	Next
	
	If $bFound Then
		GUICtrlSetData($nInpDrvUsr, $arNetDrv[$i][1])
		GUICtrlSetData($nInpDrvPW, $arNetDrv[$i][2])
		GUICtrlSetData($nLblDrvLetter, $arNetDrv[$i][3])
	EndIf
EndFunc


Func ProfileSavePosition()
	Local $nCount = GUICtrlSendMsg($nComboProfiles, $CB_GETCOUNT, 0, 0)
	If $nCount = 0 Then Return
	
	Local $arProfiles[$nCount]
	Local $stText, $sString, $i, $nLen
	
	For $i = 0 To $nCount - 1
		$nLen = GUICtrlSendMsg($nComboProfiles, $CB_GETLBTEXTLEN, $i, 0)
		If $nLen > 0 Then
			$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			
			If GUICtrlSendMsg($nComboProfiles, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then
				$sString = DllStructGetData($stText, 1)
				$arProfiles[$i] = $sString
				IniDelete($sPENMini, "NetProfiles", $arProfiles[$i])
			EndIf
		EndIf
	Next
	
	For $i = 0 To $nCount - 1
		IniWrite($sPENMini, "NetProfiles", $arProfiles[$i], "")
	Next	
EndFunc


Func ProfileSaveAs()
	Local $sSource	= GUICtrlRead($nInpProfFile)
	If $sSource = "" Then Return
	
	Local $stDrive	= DllStructCreate("wchar[" & $MAX_PATH & "]")
	Local $stFolder	= DllStructCreate("wchar[" & $MAX_PATH & "]")
	Local $stFile	= DllStructCreate("wchar[" & $MAX_PATH & "]")
	Local $stExt	= DllStructCreate("wchar[" & $MAX_PATH & "]")
	
	_wsplitpath($sSource, DllStructGetPtr($stDrive), DllStructGetPtr($stFolder), DllStructGetPtr($stFile), DllStructGetPtr($stExt))
	
	Local $sFolder	= DllStructGetData($stDrive, 1) & DllStructGetData($stFolder, 1)
	Local $sFile	= DllStructGetData($stFile, 1) & DllStructGetData($stExt, 1)
	Local $sTarget	= FileSaveDialog("Save config as file", $sFolder, "Config files (*.ini)|Text files (*.txt)", 16, $sFile, $hPCG)
	
	If $sTarget <> "" Then
		If $sTarget = ($sFolder & $sFile) Then
			ProfileSave(FALSE)
		Else
			If FileCopy($sSource, $sTarget, 1) Then
				$sPENMini = $sTarget
				ProfileSave(FALSE)
			EndIf
		EndIf
	
		GUICtrlSetData($nInpProfFile, $sTarget, $sTarget)
		ProfileSaveList() ; By a crash the list is saved before
	EndIf
EndFunc


Func ProfileSave($bMsg = FALSE)
	If Not $bIniOK Then Return
	
	If BitAnd(GUICtrlRead($nChkStartPrompt), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "AutoStart", "No")
	Else
		IniWrite($sPENMini, $sGSection, "AutoStart", "Yes")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkFocusNo), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "FocusNo", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "FocusNo", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkStartCount), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "UseStartCountdown", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "UseStartCountdown", "No")
	EndIf
	
	IniWrite($sPENMini, $sGSection, "StartCountdown", GUICtrlRead($nInpStartCount))
	IniWrite($sPENMini, $sGSection, "StartMode", StringLeft(GUICtrlRead($nComboStartMode), 1))
	
	If BitAnd(GUICtrlRead($nChkProfUse), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "UseProfiles", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "UseProfiles", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkProf), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "UseProfileSelect", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "UseProfileSelect", "No")
	EndIf
		
	If BitAnd(GUICtrlRead($nChkCount), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "UseProfileCountdown", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "UseProfileCountdown", "No")
	EndIf
		
	IniWrite($sPENMini, $sGSection, "ProfileCountdown", GUICtrlRead($nInpCount))
	IniWrite($sPENMini, $sGSection, "ProfileDefault", GUICtrlRead($nComboDefProf))
	
	If BitAnd(GUICtrlRead($nChkDebug), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "Debug", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "Debug", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkAutoIP), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "EnableAutoIP", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "EnableAutoIP", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkForceScan), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "ForceScanOnStartup", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "ForceScanOnStartup", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkShowAct), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "ShowTrayActivity", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "ShowTrayActivity", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nRadioShowMain), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "ShowMain", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "ShowMain", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nRadioStartToTray), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "StartToTray", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "StartToTray", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nRadioCloseMain), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "ShowMain", "No")
		IniWrite($sPENMini, $sGSection, "StartToTray", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nRadioOSFont), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "UseOSFont", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "UseOSFont", "No")
		IniWrite($sPENMini, $sGSection, "GlobalFont", GUICtrlRead($nInpFont))
	EndIf
	
	If BitAnd(GUICtrlRead($nChkIcons), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "UseIniIcons", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "UseIniIcons", "No")
	EndIf

	If BitAnd(GUICtrlRead($nChkWait), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "WaitConnect", "Yes")
		IniWrite($sPENMini, $sGSection, "WaitConnectTime", GUICtrlRead($nInpWait))
	Else
		IniWrite($sPENMini, $sGSection, "WaitConnect", "No")
	EndIf
	
	GUICtrlSetData($nInpWait, IniRead($sPENMini, $sGSection, "WaitConnectTime", $nWaitConnectTime))
	
	If BitAnd(GUICtrlRead($nChkTrayLimitInfo), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "TrayLimitInfo", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "TrayLimitInfo", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkTrayAdaptWiFi), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "TrayAdaptWiFi", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "TrayAdaptWiFi", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkTrayWiFiHeight), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "TrayWiFiHeight", GUICtrlRead($nInpWiFiHeight))
	Else
		IniWrite($sPENMini, $sGSection, "TrayWiFiHeight", "0")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkTrayShowMAC), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "TrayShowMAC", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "TrayShowMAC", "No")
	EndIf
	
	If BitAnd(GUICtrlRead($nChkTrayShowIPv6), $GUI_CHECKED) Then
		IniWrite($sPENMini, $sGSection, "TrayShowIPv6", "Yes")
	Else
		IniWrite($sPENMini, $sGSection, "TrayShowIPv6", "No")
	EndIf
	
	ProfileSavePosition()
		
	If $sCurProfile <> "" And GUICtrlRead($nComboProfiles) <> "" Then
		
		ProfileSaveAdapter($sCurProfile, $sCurAdapter)
		
		Local $i = 1, $c = 0, $sLine
				
		If GUICtrlRead($nInpPCName) <> "" Then
			IniWrite($sPENMini, $sCurProfile, "Computername", GUICtrlRead($nInpPCName))
		Else
			IniDelete($sPENMini, $sCurProfile, "Computername")
		EndIf
		
		If GUICtrlRead($nInpPCWG) <> "" Then
			IniWrite($sPENMini, $sCurProfile, "Workgroup", GUICtrlRead($nInpPCWG))
		Else
			IniDelete($sPENMini, $sCurProfile, "Workgroup")
		EndIf
		
		If GUICtrlRead($nInpPCDNS) <> "" Then
			IniWrite($sPENMini, $sCurProfile, "DNSSuffix", GUICtrlRead($nInpPCDNS))
		Else
			IniDelete($sPENMini, $sCurProfile, "DNSSuffix")
		EndIf
		
		; Save sharing settings
		IniDelete($sPENMini, $sCurProfile, "StartSharing")
		If BitAnd(GUICtrlRead($nChkShrAuto), $GUI_CHECKED) Then
			IniWrite($sPENMini, $sCurProfile, "StartSharing", "Yes")
		ElseIf BitAnd(GUICtrlRead($nChkShrAuto), $GUI_UNCHECKED) Then
			IniWrite($sPENMini, $sCurProfile, "StartSharing", "No")
		Else
			IniWrite($sPENMini, $sCurProfile, "StartSharing", "")
		EndIf
		
		IniDelete($sPENMini, $sCurProfile, "ShareAll")
		If BitAnd(GUICtrlRead($nChkShrAll), $GUI_CHECKED) Then
			IniWrite($sPENMini, $sCurProfile, "ShareAll", "Yes")
		ElseIf BitAnd(GUICtrlRead($nChkShrAll), $GUI_UNCHECKED) Then
			IniWrite($sPENMini, $sCurProfile, "ShareAll", "No")
		Else
			IniWrite($sPENMini, $sCurProfile, "ShareAll", "")
		EndIf
		
		$i = 1
		$c = 0
		
		While 1
			$sLine = IniRead($sPENMini, $sCurProfile, "Share.User" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			$i += 1
			$c += 1		
		WEnd
		
		For $i = 1 To $c
			IniDelete($sPENMini, $sCurProfile, "Share.User" & $i)
			IniDelete($sPENMini, $sCurProfile, "Share.Pass" & $i)
		Next
		
		$c = 0
		
		For $i = 1 To $arShrUsr[0][0]
			If $arShrUsr[$i][0] <> "" Then
				$c += 1
				IniWrite($sPENMini, $sCurProfile, "Share.User" & $c, ProfileGetEText($arShrUsr[$i][0]))
				IniWrite($sPENMini, $sCurProfile, "Share.Pass" & $c, ProfileGetEText($arShrUsr[$i][1]))
			EndIf
		Next
		
		; Save network drives
		IniDelete($sPENMini, $sCurProfile, "NetPath")
		IniWrite($sPENMini, $sCurProfile, "NetPath", GUICtrlRead($nInpNetPath))
		
		$i = 1
		$c = 0
		
		While 1
			$sLine = IniRead($sPENMini, $sCurProfile, "NetDrv.Path" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			$i += 1
			$c += 1		
		WEnd
		
		For $i = 1 To $c
			IniDelete($sPENMini, $sCurProfile, "NetDrv.Path" & $i)
			IniDelete($sPENMini, $sCurProfile, "NetDrv.User" & $i)
			IniDelete($sPENMini, $sCurProfile, "NetDrv.Pass" & $i)
			IniDelete($sPENMini, $sCurProfile, "NetDrv.Letter" & $i)
		Next
		
		$c = 0
		
		For $i = 1 To $arNetDrv[0][0]
			If $arNetDrv[$i][0] <> "" Then
				$c += 1
				IniWrite($sPENMini, $sCurProfile, "NetDrv.Path" & $c, $arNetDrv[$i][0])
				IniWrite($sPENMini, $sCurProfile, "NetDrv.User" & $c, ProfileGetEText($arNetDrv[$i][1]))
				IniWrite($sPENMini, $sCurProfile, "NetDrv.Pass" & $c, ProfileGetEText($arNetDrv[$i][2]))
				IniWrite($sPENMini, $sCurProfile, "NetDrv.Letter" & $c, $arNetDrv[$i][3])
			EndIf
		Next
		
		; Save description
		$i = 1
		$c = 0
		
		While 1
			$sLine = IniRead($sPENMini, $sCurProfile, "Desc.Line" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			$i += 1
			$c += 1		
		WEnd
		
		For $i = 1 To $c
			IniDelete($sPENMini, $sCurProfile, "Desc.Line" & $i)
		Next
		
		; Delete old description
		IniDelete($sPENMini, $sCurProfile, "Desc")
		
		;IniWrite($sPENMini, $sCurProfile, "Desc", StringReplace(GUICtrlRead($nEditDesc), @CRLF, "@LF"))
		
		Local $sDesc = StringReplace(GUICtrlRead($nEditDesc), @CRLF, "@LF")
		Local $arDesc = StringSplit($sDesc, "@LF", 1)
		If IsArray($arDesc) Then
			For $i = 1 To $arDesc[0]
				IniWrite($sPENMini, $sCurProfile, "Desc.Line" & $i, $arDesc[$i])
			Next
		EndIf
		
		; Save CMD's
		$i = 1
		$c = 0
		
		While 1
			$sLine = IniRead($sPENMini, $sCurProfile, "CMDStart.CMD" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			$i += 1
			$c += 1		
		WEnd
		
		For $i = 1 To $c
			IniDelete($sPENMini, $sCurProfile, "CMDStart.CMD" & $i)
			IniDelete($sPENMini, $sCurProfile, "CMDStart.Start" & $i)
			IniDelete($sPENMini, $sCurProfile, "CMDStart.Wait" & $i)
		Next
		
		$c = GUICtrlSendMsg($nLVCMDStart, $LVM_GETITEMCOUNT, 0, 0)
		If $c > 0 Then
			Local $sSep = "@@CMD@@", $sText, $arText
			For $i = 1 To $c
				$sText = GetLVText($nLVCMDStart, $i - 1, $sSep, 3)
				If $sText <> "" Then
					$arText = StringSplit($sText, $sSep, 1)
					If $arText[0] = 3 Then
						IniWrite($sPENMini, $sCurProfile, "CMDStart.CMD" & $i, $arText[1])
						IniWrite($sPENMini, $sCurProfile, "CMDStart.Start" & $i, $arText[2])
						IniWrite($sPENMini, $sCurProfile, "CMDStart.Wait" & $i, $arText[3])
					EndIf
				EndIf
			Next
		EndIf
		
		$i = 1
		$c = 0
		
		While 1
			$sLine = IniRead($sPENMini, $sCurProfile, "CMDChange.CMD" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			$i += 1
			$c += 1		
		WEnd
		
		For $i = 1 To $c
			IniDelete($sPENMini, $sCurProfile, "CMDChange.CMD" & $i)
			IniDelete($sPENMini, $sCurProfile, "CMDChange.Start" & $i)
			IniDelete($sPENMini, $sCurProfile, "CMDChange.Wait" & $i)
		Next
		
		Local $sSep = "@@CMD@@", $sText, $arText
		
		$c = GUICtrlSendMsg($nLVCMDChange, $LVM_GETITEMCOUNT, 0, 0)
		If $c > 0 Then
			For $i = 1 To $c
				$sText = GetLVText($nLVCMDChange, $i - 1, $sSep, 3)
				If $sText <> "" Then
					$arText = StringSplit($sText, $sSep, 1)
					If $arText[0] = 3 Then
						IniWrite($sPENMini, $sCurProfile, "CMDChange.CMD" & $i, $arText[1])
						IniWrite($sPENMini, $sCurProfile, "CMDChange.Start" & $i, $arText[2])
						IniWrite($sPENMini, $sCurProfile, "CMDChange.Wait" & $i, $arText[3])
					EndIf
				EndIf
			Next
		EndIf
		
		; Save WiFi profiles
		$i = 1
		$c = 0
		
		While 1
			$sLine = IniRead($sPENMini, $sCurProfile, "WiFiProfile.SSID" & $i, "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			$i += 1
			$c += 1		
		WEnd
		
		For $i = 1 To $c
			IniDelete($sPENMini, $sCurProfile, "WiFiProfile.SSID" & $i)
			IniDelete($sPENMini, $sCurProfile, "WiFiProfile.Key" & $i)
			IniDelete($sPENMini, $sCurProfile, "WiFiProfile.Auth" & $i)
			IniDelete($sPENMini, $sCurProfile, "WiFiProfile.Enc" & $i)
			IniDelete($sPENMini, $sCurProfile, "WiFiProfile.Auto" & $i)
			IniDelete($sPENMini, $sCurProfile, "WiFiProfile.Hidden" & $i)
			IniDelete($sPENMini, $sCurProfile, "WiFiProfile.Adhoc" & $i)
		Next
		
		$c = GUICtrlSendMsg($nLVWLPref, $LVM_GETITEMCOUNT, 0, 0)
		If $c > 0 Then
			Local $k
			$sSep = "|"
			
			For $i = 1 To $c
				$sText = GetLVText($nLVWLPref, $i - 1, "|", 1)
				For $k = 1 To $arWiFiPref[0][0]
					If $sText == $arWiFiPref[$k][0] Then
						IniWrite($sPENMini, $sCurProfile, "WiFiProfile.SSID" & $i, $arWiFiPref[$k][0])
						IniWrite($sPENMini, $sCurProfile, "WiFiProfile.Key" & $i, ProfileGetEText($arWiFiPref[$k][1]))
						IniWrite($sPENMini, $sCurProfile, "WiFiProfile.Auth" & $i, $arWiFiPref[$k][2])
						IniWrite($sPENMini, $sCurProfile, "WiFiProfile.Enc" & $i, $arWiFiPref[$k][3])
						IniWrite($sPENMini, $sCurProfile, "WiFiProfile.Auto" & $i, $arWiFiPref[$k][4])
						IniWrite($sPENMini, $sCurProfile, "WiFiProfile.Hidden" & $i, $arWiFiPref[$k][5])
						IniWrite($sPENMini, $sCurProfile, "WiFiProfile.Adhoc" & $i, $arWiFiPref[$k][6])
					EndIf
				Next
			Next
		EndIf
				
		$bAdapterAdded	= FALSE
		$bUserChanged	= FALSE
		$bDriveChanged	= FALSE
		$bWiFiChanged	= FALSE
		
		If $bMsg Then MsgBoxEx(64, $sInfo, "The profile """ & $sCurProfile & """ was saved.", $hPCG)
	EndIf
	
	If $bMsg And $sCurProfile = "" Then MsgBoxEx(64, $sInfo, "Global settings were saved.", $hPCG)
EndFunc


Func ProfileWiFiAdd($bChange = FALSE)
	Local $sSSID	= GUICtrlRead($nInpSSID)
	If $sSSID = "" Then Return
	
	Local $sKey		= GUICtrlRead($nInpKey)
	Local $sAuth	= GUICtrlRead($nComboAuth)
	Local $sEnc		= GUICtrlRead($nComboEnc)
	
	;GetAuthEnc(GUICtrlRead($nComboAuth))
	
	Local $bAuto	= FALSE
	Local $bHidden	= FALSE
	Local $bAdhoc	= FALSE
	
	If BitAnd(GUICtrlRead($nChkAuto), $GUI_CHECKED) Then $bAuto = TRUE
	If BitAnd(GUICtrlRead($nChkHidden), $GUI_CHECKED) Then $bHidden = TRUE
	If BitAnd(GUICtrlRead($nChkAdhoc), $GUI_CHECKED) Then $bAdhoc = TRUE
	
	Local $i, $bFound = FALSE, $nIdx = 0
	
	If $bChange Then		
		For $i = 1 To $arWiFiPref[0][0]
			If $sSSID == $arWiFiPref[$i][0] Then
				$nIdx = $i
				$bFound = TRUE
				ExitLoop			
			EndIf		
		Next
	EndIf
	
	If Not $bFound Then
		$arWiFiPref[0][0] += 1
		$nIdx = $arWiFiPref[0][0]
	EndIf
	
	$arWiFiPref[$nIdx][0] = $sSSID
	$arWiFiPref[$nIdx][1] = $sKey
	$arWiFiPref[$nIdx][2] = $sAuth
	$arWiFiPref[$nIdx][3] = $sEnc
	If $bAuto Then
		$arWiFiPref[$nIdx][4] = "Yes"
	Else
		$arWiFiPref[$nIdx][4] = "No"
	EndIf
	If $bHidden Then
		$arWiFiPref[$nIdx][5] = "Yes"
	Else
		$arWiFiPref[$nIdx][5] = "No"
	EndIf
	If $bAdhoc Then
		$arWiFiPref[$nIdx][6] = "Yes"
	Else
		$arWiFiPref[$nIdx][6] = "No"
	EndIf
	
	If Not $bChange Then CreateAdvLVItem($sSSID, $nLVWLPref, "|", -1, FALSE)
	
	$bWiFiChanged = TRUE
EndFunc


Func ProfileWiFiGetParams($nIdx)
	Local $sProfile = GUICtrlRead($nComboProfiles)
	If $sProfile = "" Then Return
	
	If $nIdx = $nWiFiIdxLast Then Return
	$nWiFiIdxLast = $nIdx
	
	Local $sText = GetLVText($nLVWLPref, $nIdx, "|", 1)
	GUICtrlSetData($nInpSSID, $sText)

	Local $i = 1, $sWiFiSSID, $sWiFiKey, $sWiFiAuth, $sWiFiEnc, $sWiFiAuto, $sWiFiHidden, $sWiFiAdhoc
	While 1
		$sWiFiSSID	= IniRead($sPENMini, $sProfile, "WiFiProfile.SSID" & $i, "IniReadError")
		If $sWiFiSSID = "IniReadError" Then ExitLoop
		If $sWiFiSSID == $sText Then
			$sWiFiKey	= ProfileGetDText(IniRead($sPENMini, $sProfile, "WiFiProfile.Key" & $i, ""))
			$sWiFiAuth	= IniRead($sPENMini, $sProfile, "WiFiProfile.Auth" & $i, "none")
			$sWiFiEnc	= IniRead($sPENMini, $sProfile, "WiFiProfile.Enc" & $i, "")
			$sWiFiAuto	= IniRead($sPENMini, $sProfile, "WiFiProfile.Auto" & $i, "No")
			$sWiFiHidden= IniRead($sPENMini, $sProfile, "WiFiProfile.Hidden" & $i, "No")
			$sWiFiAdhoc	= IniRead($sPENMini, $sProfile, "WiFiProfile.Adhoc" & $i, "No")
			
			GUICtrlSetData($nInpKey, $sWiFiKey)
			GUICtrlSetData($nComboAuth, $sWiFiAuth)
			GetAuthEnc(GUICtrlRead($nComboAuth))
			GUICtrlSetData($nComboEnc, $sWiFiEnc)
			
			If $sWiFiAuto = "Yes" Then
				GUICtrlSetState($nChkAuto, $GUI_CHECKED)
			Else
				GUICtrlSetState($nChkAuto, $GUI_UNCHECKED)
			EndIf
			If $sWiFiHidden = "Yes" Then
				GUICtrlSetState($nChkHidden, $GUI_CHECKED)
			Else
				GUICtrlSetState($nChkHidden, $GUI_UNCHECKED)
			EndIf
			If $sWiFiAdhoc = "Yes" Then
				GUICtrlSetState($nChkAdhoc, $GUI_CHECKED)
			Else
				GUICtrlSetState($nChkAdhoc, $GUI_UNCHECKED)
			EndIf
			ExitLoop
		EndIf
		
		$i += 1
	WEnd
EndFunc


Func ProfileWiFiDel()
	Local $nCurSel = GUICtrlSendMsg($nLVWLPref, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	If $nCurSel > -1 Then
		Local $sSSID = GetLVText($nLVWLPref, $nCurSel, "|", 1)
		If $sSSID = "" Then Return
		
		Local $i
		
		For $i = 1 To $arWiFiPref[0][0]
			If $sSSID == $arWiFiPref[$i][0] Then
				$arWiFiPref[$i][0] = ""
				$arWiFiPref[$i][1] = ""
				$arWiFiPref[$i][2] = ""
				$arWiFiPref[$i][3] = ""
				$arWiFiPref[$i][4] = ""
				$arWiFiPref[$i][5] = ""
				$arWiFiPref[$i][6] = ""
				
				GUICtrlSendMsg($nLVWLPref, $LVM_DELETEITEM, $nCurSel, 0)
				$bWiFiChanged = TRUE
				
				ExitLoop
			EndIf
		Next
	EndIf	
EndFunc


Func ProfileWiFiClear()
	Local $i, $sAuthData = "|"
	
	GUICtrlSetData($nInpSSID, "")
	GUICtrlSetData($nInpKey, "")
	
	For $i = 0 To 8
		If $arAuthType[$i][0] <> "" Then
			If StringInStr($arAuthType[$i][2], "WPA") And Not StringInStr($arAuthType[$i][2], "PSK") Then ContinueLoop
			
			$sAuthData &= $arAuthType[$i][2] & "|"
		EndIf
	Next
	
	Local $sAuthDataDef = $arAuthType[0][2]
	GUICtrlSetData($nComboAuth, $sAuthData, $sAuthDataDef)
	GetAuthEnc(GUICtrlRead($nComboAuth))
	
	GUICtrlSetState($nChkAuto, $GUI_UNCHECKED)
	GUICtrlSetState($nChkHidden, $GUI_UNCHECKED)
	GUICtrlSetState($nChkAdhoc, $GUI_UNCHECKED)
	
	SetODBtnState($nBtnWiFiChg, $GUI_DISABLE)
	SetODBtnState($nBtnWiFiDel, $GUI_DISABLE)
	
	$nWiFiIdxLast = -1
EndFunc


Func ProfileSaveList()
	Local $sKey = "Software\PENetwork\Editor\MRU"
	Local $stString = DllStructCreate("wchar[" & (StringLen($sKey) + 1) & "]")
	DllStructSetData($stString, 1, $sKey)
	
	Local $stMRUI = DllStructCreate($sMRUINFO)
	DllStructSetData($stMRUI, 1, DllStructGetSize($stMRUI))
	DllStructSetData($stMRUI, 2, 26) ; Max. 26 entries
	DllStructSetData($stMRUI, 3, 0)
	DllStructSetData($stMRUI, 4, $HKEY_CURRENT_USER)
	DllStructSetData($stMRUI, 5, DllStructGetPtr($stString))
	DllStructSetData($stMRUI, 6, 0)
	
	Local $hMRU = CreateMRUListW(DllStructGetPtr($stMRUI))
	
	If $hMRU <> 0 Then
		Local $nCount = GUICtrlSendMsg($nInpProfFile, $CB_GETCOUNT, 0, 0)
		Local $stText, $i, $nLen
	
		For $i = $nCount - 1 To 0 Step -1
			$nLen = GUICtrlSendMsg($nInpProfFile, $CB_GETLBTEXTLEN, $i, 0)
			If $nLen > 0 Then
				$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			
				If GUICtrlSendMsg($nInpProfFile, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then _
					AddMRUStringW($hMRU, DllStructGetPtr($stText))
			EndIf		
		Next
		
		FreeMRUList($hMRU)
	EndIf
	
	Local $sLast = GUICtrlRead($nInpProfFile)
	If $sLast <> "" Then RegWrite($sGURegKey & "\Editor", "LastFile", "REG_SZ", $sLast)
EndFunc


Func ProfileLoadList($sDefault)
	Local $i, $sData = "|"
	Local $sKey = "Software\PENetwork\Editor\MRU"
	Local $stString = DllStructCreate("wchar[" & (StringLen($sKey) + 1) & "]")
	DllStructSetData($stString, 1, $sKey)
	
	Local $stMRUI = DllStructCreate($sMRUINFO)
	DllStructSetData($stMRUI, 1, DllStructGetSize($stMRUI))
	DllStructSetData($stMRUI, 2, 26)
	DllStructSetData($stMRUI, 3, 0)
	DllStructSetData($stMRUI, 4, $HKEY_CURRENT_USER)
	DllStructSetData($stMRUI, 5, DllStructGetPtr($stString))
	DllStructSetData($stMRUI, 6, 0)
	
	Local $hMRU = CreateMRUListW(DllStructGetPtr($stMRUI))
	
	If $hMRU <> 0 Then
		Local $nCount = EnumMRUListW($hMRU, -1, 0, 0)
		
		For $i = 0 To $nCount - 1
			$stString = DllStructCreate("wchar[" & $MAX_PATH & "]")
			If EnumMRUListW($hMRU, $i, DllStructGetPtr($stString), $MAX_PATH) <> -1 Then _
				$sData = $sData & DllStructGetData($stString, 1) & "|"
		Next

		FreeMRUList($hMRU)
	EndIf
	
	If $sDefault <> "" Then
		GUICtrlSetData($nInpProfFile, $sData, $sDefault)
	Else
		GUICtrlSetData($nInpProfFile, $sData)
	EndIf
EndFunc


;**********************************************************************
; Add file (and profile) to last known list for editor
;**********************************************************************
Func ProfileAddToList($sFile, $sProfile = "")
	If $sFile = "" Then Return
	
	Local $i, $sData = ""
	Local $sKey = "Software\PENetwork\Editor\MRU"
	Local $stString = DllStructCreate("wchar[" & (StringLen($sKey) + 1) & "]")
	DllStructSetData($stString, 1, $sKey)
	
	Local $stMRUI = DllStructCreate($sMRUINFO)
	DllStructSetData($stMRUI, 1, DllStructGetSize($stMRUI))
	DllStructSetData($stMRUI, 2, 26)
	DllStructSetData($stMRUI, 3, 0)
	DllStructSetData($stMRUI, 4, $HKEY_CURRENT_USER)
	DllStructSetData($stMRUI, 5, DllStructGetPtr($stString))
	DllStructSetData($stMRUI, 6, 0)
	
	Local $hMRU = CreateMRUListW(DllStructGetPtr($stMRUI))
	
	If $hMRU <> 0 Then
		Local $stText = DllStructCreate("wchar[" & StringLen($sFile) + 1 & "]")
		Local $bFound = FALSE
		
		Local $nCount = EnumMRUListW($hMRU, -1, 0, 0)
		
		For $i = 0 To $nCount - 1
			$stString = DllStructCreate("wchar[" & $MAX_PATH & "]")
			If EnumMRUListW($hMRU, $i, DllStructGetPtr($stString), $MAX_PATH) <> -1 Then
				If DllStructGetData($stString, 1) = $sFile Then
					$bFound = TRUE
					ExitLoop
				EndIf
			EndIf
		Next
		
		If Not $bFound Then AddMRUStringW($hMRU, DllStructGetPtr($stText))
		FreeMRUList($hMRU)
		
		RegWrite($sGURegKey & "\Editor", "LastFile", "REG_SZ", $sFile)
		If $sProfile <> "" Then RegWrite($sGURegKey & "\Editor", "LastProfile", "REG_SZ", $sProfile)
	EndIf
EndFunc


;**********************************************************************
; Checks if the given address is a dot4 network address
;**********************************************************************
Func IsValidAddress($sAddr)
	Local $bIPWrong, $c, $i, $nIP, $arIP
	Local $bIsIP = FALSE
	Local $arIPS = StringSplit($sAddr, ",")
	
	If IsArray($arIPS) Then
		$bIPWrong = FALSE
			
		For $c = 1 To $arIPS[0]
			$bIsIP= FALSE
			
			$arIP = StringSplit($arIPS[$c], ".")
			If IsArray($arIP) Then
				If $arIP[0] = 4 Then
					For $i = 1 To $arIP[0]
						$nIP = Number($arIP[$i])
						If Not ($nIP <= 255 And ($nIP > 0 Or $arIP[$i] = "0") And StringIsDigit($arIP[$i])) Then
							$bIPWrong = TRUE
							ExitLoop
						EndIf
					Next
					
					If Not $bIPWrong Then $bIsIP = TRUE
				EndIf
			EndIf
			
			If $bIPWrong Then ExitLoop
		Next
	EndIf
	
	Return $bIsIP
EndFunc


;**********************************************************************
; Show profile manager
;**********************************************************************
Func ShowProfGUI($nType = 0)
	GUISetState(@SW_DISABLE, $hPCG)
	
	Local $arPos	= WinGetPos($hPCG)
	Local $sTitle	= ""
	Local $nW, $nH
	
	$nSubType = $nType
	
	Switch $nType
		Case 0 ; Manager
			$sTitle	= "Manage profiles"
			$nW		= 300
			$nH		= 260
		Case 1 ; Add
			$sTitle = "Add new profile"
			$nW		= 260
			$nH		= 83
	EndSwitch

	GetScaledPos($arPos, 2)
	$hSubGUI		= CreateGUI($sTitle, $nW, $nH, $arPos[0] + 150, $arPos[1] + 114, BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
									BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hPCG)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	;GUISetBkColor($nClrGUIBk)
	
	If $bIconLib Then
		GUISetIcon($sIconLib, -4)
	Else
		SetWindowIcon($hSubGUI, @AutoItExe, 161)
	EndIf
	
	Switch $nType
		Case 0
			CreateCtrlLabel("Network Profile List:", 5, 6, $nW - 10, 20)
			GUICtrlSetFont(-1, 8.5, 600)
			
			$nListAddr			= CreateCtrlList("", 5, 25, 260, 140)
			GUICtrlSetStyle(-1, BitOr($WS_BORDER, $WS_VSCROLL))
		
			$nBtnAddrUp			= CreateODBtn("^", 270, 25, 25, 65, $arODBtnSub, 0, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			SetODBtnState($nBtnAddrUp, $GUI_DISABLE, FALSE)
			
			$nBtnAddrDown		= CreateODBtn("v", 270, 98, 25, 60, $arODBtnSub, 1, TRUE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			SetODBtnState($nBtnAddrDown, $GUI_DISABLE, FALSE)
			
			$nInpProfile		= CreateCtrlInput("", 5, 165, 260, 20)
			
			$nBtnRename			= CreateODBtn("Rename", 5, 190, 75, 22, $arODBtnSub, 9, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			$nBtnAdd			= CreateODBtn("Add", 85, 190, 65, 22, $arODBtnSub, 5, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			$nBtnDel			= CreateODBtn("Del", 155, 190, 65, 22, $arODBtnSub, 6, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			$nBtnCopy			= CreateODBtn("Copy", 225, 190, 70, 22, $arODBtnSub, 4, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			GUICtrlSetTip(-1, "Copy selected profile settings to new one")
			
			CreateCtrlLabel("", 0, 220, $nW, 2, $SS_SUNKEN)
			
			$nBtnSubOK		= CreateODBtn("&OK", Round(($nW - 100) / 2), $nH - 25 - 6, 100, 25, $arODBtnSub, -1, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			
			ProfileGetProfiles(FALSE)
		
		Case 1
			CreateCtrlLabel("Please enter a name for the new profile to add:", 5, 6, $nW - 10, 20)
			$nInpProfile = CreateCtrlInput("", 5, 25, $nW - 10, 20)
			
			$nBtnSubOK		= CreateODBtn("&OK", 5, $nH - 25 - 6, Round($nW / 2) - 8, 25, $arODBtnSub, 2, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
			$nBtnSubCancel	= CreateODBtn("&Cancel", Round($nW / 2) + 3, $nH - 25 - 6, Round($nW / 2) - 8, 25, $arODBtnSub, 3, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
	EndSwitch
	
	GUISetState()
EndFunc


;**********************************************************************
; Show About GUI
;**********************************************************************
Func ShowAboutGUI()
	GUISetState(@SW_DISABLE, $hPCG)
	
	Local $arPos	= WinGetPos($hPCG)
	Local $nW		= 280
	Local $nH		= 160
	
	If $hAboutGUI = 0 Then
		GetScaledPos($arPos, 2)
		
		Local $sTitle	= "About PENM Editor"
		
		$hAboutGUI		= CreateGUI($sTitle, $nW, $nH, $arPos[0] + Round(($arPos[2] - $nW) / 2), $arPos[1] + Round(($arPos[3] - $nH - 18) / 2), BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
										BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hPCG)
		GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
		
		If $bIconLib Then
			GUISetIcon($sIconLib, -5)
		Else
			GUISetIcon(@AutoItExe, 182)
		EndIf
							
		$nBtnAboutOK	= CreateODBtn("&OK", Round(($nW - 100) / 2), $nH - 25 - 6, 100, 25, $arODBtnSub, -1, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
		
		CreateCtrlIcon(@AutoItExe, 0, 5, 5, $nIconSizeBig, $nIconSizeBig)
		GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
		SetIconFrom(-1, 0, -4, "", FALSE)
		
		CreateCtrlLabel("PE Network Manager " & $sVersion & " - configuration/profile editor", 45, 7, 230, 40)
		GUICtrlSetFont(-1, 10, 600, 0, $sGlobalFont)
			
		CreateCtrlLabel("", 0, 73, $nW + 1, 2, $SS_SUNKEN)
		CreateCtrlLabel("", 0, 120, $nW + 1, 2, $SS_SUNKEN)
		
		$nW = GetTextSize($hAboutGUI, "2018 Holger Kotsch")		
		$nLblAboutAuthor	= CreateCtrlLabel("2018 Holger Kotsch", 45, 45, GetScaled($nW, 2), 18)
		;GUICtrlSetCursor(-1, 0)
		GUICtrlSetTip(-1, $sUrlHome)
		$hLblAboutAuthor = GUICtrlGethandle($nLblAboutAuthor)
		
		$nW = GetTextSize($hAboutGUI, $sLblAboutAI3)
		
		$nLblAboutAI3	= CreateCtrlLabel($sLblAboutAI3, 230 - GetScaled($nW, 2), 90, GetScaled($nW, 2), 20, $SS_RIGHT)
		;GUICtrlSetCursor(-1, 0)
		GUICtrlSetTip(-1, $sUrlAI3)
		$hLblAboutAI3 = GUICtrlGethandle($nLblAboutAI3)
		
		CreateCtrlIcon(@AutoItExe, 0, 245, 80, $nIconSizeBig, $nIconSizeBig)
		GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
		SetIconFrom(-1, 180, -3, "", FALSE)
	Else
		$nW = GetScaled($nW)
		$nH = GetScaled($nH)
		
		WinMove($hAboutGUI, "", $arPos[0] + Round(($arPos[2] - $nW) / 2), $arPos[1] + Round(($arPos[3] - $nH - GetScaled(18)) / 2))
	EndIf
	
	GUISetState(@SW_SHOW, $hAboutGUI)
EndFunc


;**********************************************************************
; Show Pref GUI
;**********************************************************************
Func ShowPrefsGUI()
	GUISetState(@SW_DISABLE, $hPCG)
	
	Local $arPos	= WinGetPos($hPCG)
	Local $nW		= 360
	Local $nH		= 160
			
	If $hPrefsGUI = 0 Then
		GetScaledPos($arPos, 2)
	
		Local $sTitle	= "Preferences"
	
		$hPrefsGUI		= CreateGUI($sTitle, $nW, $nH, $arPos[0] + Round(($arPos[2] - $nW) / 2), $arPos[1] + Round(($arPos[3] - $nH - 18) / 2), BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
										BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hPCG)						
		GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
					
		If $bIconLib Then
			GUISetIcon($sIconLib, -7)
		Else
			GUISetIcon(@AutoItExe, 183)
		EndIf
		
		CreateCtrlIcon("shell32.dll", -1, 5, 6, $nIconSizeSmall, $nIconSizeSmall)
		SetIconFrom(-1, 230, -60)

		$nChkOpenLastFile = CreateCtrlCheck("Automatically open last config file on startup", 25, 5, 330, 20, -1, -1, $hPrefsGUI)
		If $bOpenLastFile Then GUICtrlSetState(-1, $GUI_CHECKED)
		
		CreateCtrlIcon("shell32.dll", -1, 22, 26, $nIconSizeSmall, $nIconSizeSmall)
		SetIconFrom(-1, 227, -57)

		$nChkOpenLastProfile = CreateCtrlCheck("Load last profile on file open", 43, 25, 315, 20, -1, -1, $hPrefsGUI)
		If $bOpenLastProfile Then GUICtrlSetState(-1, $GUI_CHECKED)
		
		CreateCtrlIcon("shell32.dll", -1, 5, 46, $nIconSizeSmall, $nIconSizeSmall)
		SetIconFrom(-1, 242, -72)
		
		$nChkSaveWinPos	= CreateCtrlCheck("Save current position of editor window", 25, 45, 330, 20, -1, -1, $hPrefsGUI)
		If $bSaveWinPos Then GUICtrlSetState(-1, $GUI_CHECKED)
		
		CreateCtrlIcon("shell32.dll", -1, 5, 66, $nIconSizeSmall, $nIconSizeSmall)
		SetIconFrom(-1, 184, -8)
		
		$nChkUseOSFont = CreateCtrlCheck("Use OS default font for GUI (Restart of GUI is required)", 25, 65, 330, 20, -1, -1, $hPrefsGUI)
		If $bUseOSFont Then GUICtrlSetState(-1, $GUI_CHECKED)
			
		CreateCtrlLabel("", 0, $nH - 25 - 6 - 9, $nW, 2, $SS_SUNKEN)
				
		$nBtnPrefsOK	= CreateODBtn("&OK", Round($nW / 2) - 100 - 3, $nH - 25 - 6, 100, 25, $arODBtnSub, -1, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
		$nBtnPrefsCancel= CreateODBtn("&Cancel", Round($nW / 2) + 3, $nH - 25 - 6, 100, 25, $arODBtnSub, -1, FALSE, -1, $nClrBtnBk, 4, $nClrBtnGrad)
		SetODBtnState($nBtnPrefsCancel, $GUI_FOCUS)
	Else
		SetODBtnState($nBtnPrefsCancel, $GUI_FOCUS)
		
		$nW = GetScaled($nW)
		$nH = GetScaled($nH)
		
		WinMove($hPrefsGUI, "", $arPos[0] + Round(($arPos[2] - $nW) / 2), $arPos[1] + Round(($arPos[3] - $nH - GetScaled(18)) / 2))
	EndIf
	
	GUISetState(@SW_SHOW, $hPrefsGUI)
EndFunc


;**********************************************************************
; Set an image for a button
;**********************************************************************
Func SetBtnImage($nCtrl, $nLib, $nExe)
	Local $stIcon = DllStructCreate("hwnd")
	If $bIconLib Then
		ExtractIconExW($sIconLib, $nLib, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, $nExe, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	
	GUICtrlSendMsg($nCtrl, 0x00F7, 1, DllStructGetData($stIcon, 1))
	DestroyIcon(DllStructGetData($stIcon, 1))
EndFunc


;**********************************************************************
; Get the options for preview
;**********************************************************************
Func GetPrevOptions()
	If BitAnd(GUICtrlRead($nChkStartPrompt), $GUI_CHECKED) Then
		$bAutoStart = FALSE
	Else
		$bAutoStart = TRUE
	EndIf
	If BitAnd(GUICtrlRead($nChkFocusNo), $GUI_CHECKED) Then
		$bFocusNo = TRUE
	Else
		$bFocusNo = FALSE
	EndIf
	If BitAnd(GUICtrlRead($nChkStartCount), $GUI_CHECKED) Then
		$bUseStartCount = TRUE
		$nStartCount = GUICtrlRead($nInpStartCount)
	Else
		$bUseStartCount = FALSE
	EndIf
	If BitAnd(GUICtrlRead($nChkProfUse), $GUI_CHECKED) Then
		$bUseProfiles = TRUE
		$sProfileDefault = GUICtrlRead($nComboDefProf)
	Else
		$bUseProfiles = FALSE
	EndIf
	If BitAnd(GUICtrlRead($nChkProf), $GUI_CHECKED) Then
		$bUseProfileSelect = TRUE
	Else
		$bUseProfileSelect = FALSE
	EndIf
	If BitAnd(GUICtrlRead($nChkCount), $GUI_CHECKED) Then
		$bUseProfileCount = TRUE
		$nProfileCount = GUICtrlRead($nInpCount)
	Else
		$bUseProfileCount = FALSE
	EndIf
	If BitAnd(GUICtrlRead($nRadioShowMain), $GUI_CHECKED) Then
		$bShowMainGUI = TRUE
	Else
		$bShowMainGUI = FALSE
	EndIf
	If BitAnd(GUICtrlRead($nChkShowAct), $GUI_CHECKED) Then
		$bShowTrayAct = TRUE
	Else
		$bShowTrayAct = FALSE
	EndIf
	If BitAnd(GUICtrlRead($nRadioStartToTray), $GUI_CHECKED) Then
		$bMinToTray = TRUE
	Else
		$bMinToTray = FALSE
	EndIf
	
	$nStartMode = Number(StringLeft(GUICtrlRead($nComboStartMode), 1))
EndFunc


;**********************************************************************
; Start/Stop the preview demo
;**********************************************************************
Func StartPrevDemo()
	If $bPrevStarted Then
		$bPrevStarted = FALSE
		
		If $hPSG <> 0 Then
			KillTimer($hPSG, $nTimerID)
			DelODBtnGrp($arODBtnSub)
			GUIDelete($hPSG)
			$hPSG = 0
		EndIf
		
		GUICtrlSetData($nBtnPrevStart, "Start")
		SetBtnImage($nBtnPrevStart, 52, -223)
		
		If $bPrevStartup Then
			$nBtnYes = 0
			$nBtnNo = 0
		EndIf
		
		If $bPrevProfiles Then
			$nListProfiles = 0
			$nBtnOK = 0
			$nBtnCancel = 0
		EndIf
			
		If $bPrevInstStarted And $nStartMode > 0 Then
			GUICtrlDelete($nIconInst)
			GUICtrlDelete($nLblInstTitle)
			GUICtrlDelete($nLblInstLine)
			GUICtrlDelete($nLblStartTxt)
			GUICtrlDelete($nPrgrStart)
			GUICtrlDelete($nLblInst)
			InvalidateRect($hPrevBkGUI, 0, TRUE)			
		EndIf
		
		If $bPrevPENMStarted Then
			$nTIPrevConf = 0
			$nTIPrevIdent = 0
			$nTIPrevSharing = 0
			$nTIPrevDrives = 0
			$nTIPrevProfiles = 0
			$nTIPrevOther = 0
			$nTIPrevAbout = 0
			$nLastItemPrev = 0
			$nBtnPENMApply = 0
			$nBtnPENMOK = 0
			$nBtnPENMCancel = 0
		EndIf
		
		$bPrevStartup = FALSE
		$bPrevProfiles = FALSE
		$bPrevInstStarted = FALSE
		$bPrevPENMStarted = FALSE
				
		InvalidateRect(GUICtrlGetHandle($nIconTray), 0, TRUE)		
	Else
		$bPrevStarted = TRUE
		
		GUICtrlSetData($nBtnPrevStart, "Stop")
		SetBtnImage($nBtnPrevStart, 53, -224)
		GetPrevOptions()

		If $bAutoStart Then
			If $bUseProfiles And $bUseProfileSelect Then
				ShowPrevProfSel()
			Else
				ShowPrevInstall()
			EndIf
		Else
			ShowPrevStartup()
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Show the preview startup
;**********************************************************************
Func ShowPrevStartup()
	Local $nResult = 6, $nGUIWidth = 160, $nGUIHeight = 60, $nWidth = 170, $nBtnWidth = 90, $nBtnHeight = 20
	If $bFocusNo Then $nResult = 7
	
	SetODBtnSize(0, 0, $sNetStartNet, $nWidth, 20, FALSE, FALSE)
	
	$nGUIWidth = $nWidth + 30
	If $nGUIWidth < (2 * $nBtnWidth + 15) Then
		$nGUIWidth = 2 * $nBtnWidth + 15
	Else
		$nBtnWidth = Round(($nGUIWidth - 15) / 2)
	EndIf
	
	$nGUIWidth += 3
	
	$hPSG		= CreateGUI($sMainTitle, $nGUIWidth, $nGUIHeight, -1, -1, _
							BitOr($WS_CHILD, $DS_MODALFRAME, $WS_CAPTION, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN), _
							$WS_EX_CONTROLPARENT, $hPrevBkGUI)
	SetWindowTheme($hPSG, " ", " ")
	GUISetFont(7, 400, 0, $sGlobalFont)
	SendMessage($hPSG, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkSub)
	
	CreateCtrlIcon("user32.dll", -3, 5, 3, GetScaled($nIconSizeSmall, 2), GetScaled($nIconSizeSmall, 2))
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $WS_GROUP))
	
	CreateCtrlLabel($sNetStartNet, 25, 6, $nWidth, 20)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	$nBtnYes	= CreateODBtn($sBtnYes, 4, $nGUIHeight - $nBtnHeight - 6, $nBtnWidth, $nBtnHeight, $arODBtnSub, 2)
	$nBtnNo		= CreateODBtn($sBtnNo, $nGUIWidth - $nBtnWidth - 5, $nGUIHeight - $nBtnHeight - 6, $nBtnWidth, $nBtnHeight, $arODBtnSub, 3)
	
	If $bFocusNo Then
		SetODBtnState($nBtnNo, $GUI_DEFBUTTON, FALSE)
		SetODBtnState($nBtnNo, $GUI_FOCUS)
	Else
		SetODBtnState($nBtnYes, $GUI_DEFBUTTON, FALSE)
		SetODBtnState($nBtnYes, $GUI_FOCUS)
	EndIf
	
	Local $arPos = WinGetPos($hPSG)
	SetWindowPos($hPSG, 0, GetScaled(90), GetScaled(65), $arPos[2], $arPos[3], 0)
	PostMessage($hPSG, $WM_NCACTIVATE, TRUE, 0)
	GUISetState()	
	
	GUIRegisterMsg($WM_TIMER, "PreStartWndProc")
	
	If $bUseStartCount Then
		SetTimer($hPSG, $nTimerID, 1000, 0)
		
		If $bFocusNo Then
			SetODBtnData($nBtnNo, $sBtnNo & " " & $sProfIn & " " & $nStartCount & " " & $sProfSec & ".")
		Else
			SetODBtnData($nBtnYes, $sBtnYes & " " & $sProfIn & " " & $nStartCount & " " & $sProfSec & ".")
		EndIf
	EndIf
	
	$bPrevStartup = TRUE
EndFunc


;**********************************************************************
; Show the preview profiles selection
;**********************************************************************
Func ShowPrevProfSel()
	Local $i, $sProfiles = "", $sLine, $nLen, $stText
	
	For $i = 0 To GUICtrlSendMsg($nComboProfiles, $CB_GETCOUNT, 0, 0) - 1
		$nLen = GUICtrlSendMsg($nComboProfiles, $CB_GETLBTEXTLEN, $i, 0)
		If $nLen > 0 Then
			$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			If GUICtrlSendMsg($nComboProfiles, $CB_GETLBTEXT, $i, DllStructGetPtr($stText)) > 0 Then
				$sProfiles = $sProfiles & DllStructGetData($stText, 1) & "|"
			EndIf
		EndIf
	Next
	
	Local $sListProfile = $sProfileDefault
	
	$hPSG		= CreateGUI($sPreTitle & " Network Manager " & $sProfSelTitle, 200, 200, 80, 3, _
							BitOr($WS_CHILD, $DS_MODALFRAME, $WS_CAPTION, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN), _
							$WS_EX_CONTROLPARENT, $hPrevBkGUI)
	SetWindowTheme($hPSG, " ", " ")
	GUISetFont(7, 400, 0, $sGlobalFont)	
	SendMessage($hPSG, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkSub)
	
	If $bIconLib Then
		CreateCtrlIcon($sIconLib, -4, 5, 3, $nIconSizeSmall, $nIconSizeSmall)
	Else
		CreateCtrlIcon(@AutoItExe, 161, 5, 3, $nIconSizeSmall, $nIconSizeSmall)
	EndIf
	
	CreateCtrlLabel($sLblProfSelect & ":", 30, 6, 165, 14)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	$nListProfiles		= CreateCtrlList("", 5, 28, 190, 60, BitOr($WS_BORDER, $WS_VSCROLL))
	GUICtrlSetData(-1, $sProfiles, $sListProfile)
	
	CreateCtrlLabel($sLblProfDesc & ":", 5, 88, 190, 10)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	$nEditInfo			= CreateCtrlEdit("", 5, 100, 190, 65, BitOr($WS_VSCROLL, $ES_AUTOVSCROLL, $ES_READONLY))

	$nBtnOK				= CreateODBtn($sBtnOK, 5, 175, 92, 20, $arODBtnSub, 2)
	$nBtnCancel			= CreateODBtn($sBtnCancel, 102, 175, 92, 20, $arODBtnSub, 3)
	
	If $sListProfile <> "" Then GUICtrlSetData($nEditInfo, ReadProfileDesc($sPENMini, $sListProfile, "Desc.Line"))

	$nProfileCountCtrl = $nBtnOK
	If $sProfileDefault = "" Then
		$sProfileCountText = $sBtnCancel
		$nProfileCountCtrl = $nBtnCancel
	Else
		$sProfileCountText = $sBtnOK
	EndIf	
	
	SetODBtnState($nProfileCountCtrl, $GUI_DEFBUTTON)
	SetODBtnState($nProfileCountCtrl, $GUI_FOCUS)
	
	Local $arPos = WinGetPos($hPSG)
	
	SetWindowPos($hPSG, 0, 0, 0, 0, 0, BitOr($SWP_NOSIZE, $SWP_NOMOVE))
	PostMessage($hPSG, $WM_NCACTIVATE, TRUE, 0)
	GUISetState()
	
	GUIRegisterMsg($WM_TIMER, "PreWndProc")
		
	If $bUseProfileCount Then
		SetTimer($hPSG, $nTimerID, 1000, 0)
		SetODBtnData($nProfileCountCtrl, $sProfileCountText & " " & $sProfIn & " " & $nProfileCount & " " & $sProfSec & ".")
	EndIf
	
	$bPrevProfiles = TRUE
EndFunc


;**********************************************************************
; Show the preview installation process
;**********************************************************************
Func ShowPrevInstall()

	If $nStartMode > 0 Then
		; StartMode: 0 - Hidden / 1 - Center / 2 - TopLeft / 3 - TopRight / 4 - BottomLeft / 5 - BottomRight / 6 - Depends on systray position
		Local $nX		= -1
		Local $nY		= -1
		Local $nW		= GetScaled(200)
		Local $nH		= GetScaled(75)
		Local $nBkClr	= $nClrGUIBkSub
		If $nBkClr = -1 Then $nBkClr = GetBGRColor(GetSysColor($COLOR_BTNFACE))
		Local $nTxtClr	= $nClrLblNormal
		If $nTxtClr = -1 Then $nTxtClr = GetSysColor($COLOR_BTNTEXT)
		
		Local $nWType	= BitOr($WS_CHILD, $WS_CAPTION, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN)
		Local $nWExType	= $WS_EX_TOOLWINDOW + $WS_EX_CONTROLPARENT ;BitOr($WS_EX_TOPMOST, $WS_EX_TOOLWINDOW)
		Local $arPos	= WinGetPos($hPrevBkGUI)
		GetScaledPos($arPos, 2)
		
		Switch $nStartMode
			Case 1
				$nX = Round(($arPos[2] - $nW) / 2)
				$nY = Round(($arPos[3] - $nH) / 2) - 18
			Case 2
				$nX = 0
				$nY = 0
			Case 3
				$nX = $arPos[2] - $nW - 2
				$nY = 0
			Case 4
				$nX = 0
				$nY = $arPos[3] - $nH - 30
			Case 5, 6
				$nX = $arPos[2] - $nW - 2
				$nY = $arPos[3] - $nH - 30
		EndSwitch
		
		GUISwitch($hPrevBkGUI)
		
		$nIconInst		= CreateCtrlLabel("", $nX + 5, $nY + 3, $nIconSizeSmall, $nIconSizeSmall, -1, -1, 1)
		GUICtrlSetStyle(-1, $SS_OWNERDRAW) 
		
		$nLblInstTitle	= CreateCtrlLabel($sMainTitle, $nX + 26, $nY + 2, $nW - 32, 18, $SS_CENTERIMAGE)
		GUICtrlSetBkColor(-1, $nBkClr)
		GUICtrlSetColor(-1, $nTxtClr)
		GUICtrlSetFont(-1, 8, 600)
		
		$nLblInstLine	= CreateCtrlLabel("", $nX + 2, $nY + 22, $nW - 4, 2, $SS_SUNKEN)
		
		$nLblStartTxt	= CreateCtrlLabel($sLblStartNet, $nX + 5, $nY + 27, $nW - 10, 34, $SS_LEFTNOWORDWRAP)
		GUICtrlSetBkColor(-1, $nBkClr)
		GUICtrlSetColor(-1, $nTxtClr)
		GUICtrlSetFont(-1, 7)
		
		$nPrgrStart		= CreateCtrlProg($nX + 5, $nY + 61, $nW - 10, 10, $PBS_SMOOTH)
		
		$nLblInst		= CreateCtrlLabel("", $nX, $nY, $nW, $nH, $WS_BORDER + $WS_DISABLED + $WS_CLIPSIBLINGS)
		GUICtrlSetBkColor(-1, $nBkClr)
				
		SetWindowPos(GUICtrlGetHandle($nLVPrev), GUICtrlGetHandle($nLblInst), 0, 0, 0, 0, BitOr($SWP_NOSIZE, $SWP_NOMOVE))
				
		InvalidateRect($hPrevBkGUI, 0, TRUE)
	EndIf
	
	$bPrevInstStarted = TRUE
	
	$nInstTime = 100
	$nInstTimeCount = $nInstTime
		
	GUIRegisterMsg($WM_TIMER, "PreInstProc")
		
	SetTimer($hPrevBkGUI, $nTimerID, 50, 0)
EndFunc


;**********************************************************************
; Show the preview profiles selection
;**********************************************************************
Func ShowPrevPENM()
	Local $i, $sProfiles = "", $sLine, $nLen, $stText
	
	$hPSG		= CreateGUI($sMainTitle, 305, 200, 55, 3, _
							BitOr($WS_CHILD, $WS_SYSMENU, $WS_CAPTION, $WS_GROUP, $WS_CLIPSIBLINGS, $WS_CLIPCHILDREN), _
							$WS_EX_CONTROLPARENT, $hPrevBkGUI)
	SetWindowTheme($hPSG, " ", " ")
	GUISetFont(7, 400, 0, $sGlobalFont)	
	SendMessage($hPSG, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkMain)
	
	If $bIconLib Then
		GUISetIcon($sIconLib, -4)
	Else
		SetWindowIcon($hPSG, @AutoItExe, 161)
	EndIf
	
	Local $nBtnX	= 0
	Local $nBtnY	= 0
	Local $nBtnH	= GetScaled(18)
	Local $nBtnL	= GetScaled(95)
	Local $nR		= GetScaled(304)
	Local $nY		= GetScaled(157)
		
	GUICtrlCreateLabel("", $nBtnL, 0, $nR - $nBtnL, 1) ; Top Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	GUICtrlCreateLabel("", $nBtnL - 1, 0, 1, $nY) ; Left Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	GUICtrlCreateLabel("", $nR, 0, 1, $nY) ; Right Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	
	If $hPrevFont = 0 Then CreateGlobalFont(0, 7, 400, 0, $sGlobalFont, $hPrevFont)
	
	$nTIPrevConf	= CreateODTab($hPSG, $sTIConfig, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, 0, FALSE, -1, -1, 6, -1)
	$nBtnY += $nBtnH - 1
	$nTIPrevIdent	= CreateODTab($hPSG, $sTIIdent, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, 1, FALSE, -1, -1, 6, -1)
	$nBtnY += $nBtnH - 1
	$nTIPrevSharing	= CreateODTab($hPSG, $sTISharing, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, 2, FALSE, -1, -1, 6, -1)
	$nBtnY += $nBtnH - 1
	$nTIPrevDrives	= CreateODTab($hPSG, $sTIDrives, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, 3, FALSE, -1, -1, 6, -1)
	$nBtnY += $nBtnH - 1
	$nTIPrevProfiles= CreateODTab($hPSG, $sTIProfiles, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, 4, FALSE, -1, -1, 6, -1)
	$nBtnY += $nBtnH - 1
	$nTIPrevOther	= CreateODTab($hPSG, $sTIOther, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, 5, FALSE, -1, -1, 6, -1)
	$nBtnY += $nBtnH - 1
	$nTIPrevAbout	= CreateODTab($hPSG, $sTIAbout, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, 6, FALSE, -1, -1, 6, -1)
	$nBtnY += $nBtnH - 1
	$nTISize		= CreateODTab($hPSG, ">", $nBtnL - GetScaled(22), $nBtnY, GetScaled(22), GetScaled(14), $arODBtnSub, 23, TRUE)
	
	$nLastItemPrev = $nTIPrevConf	
	
	GUICtrlCreateLabel("", $nBtnL, 1, $nR - $nBtnL - 1, GetScaled(49))
	GUICtrlSetBkColor(-1, $nClrGUIBk)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	CreateODBtn(">", 100, 5, 18, 18, $arODBtnSub, 7, TRUE)
	
	CreateCtrlCombo("", 123, 5, 176, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, "NetDev PRO/1000 MB", "NetDev PRO/1000 MB")
	GUICtrlSetTip(-1, "LAN connection" & @LF & "NetDev PRO/1000 MB")
	
	CreateCtrlLabel($sLblAdapterState & ":", 125, 30, 25, 14)
	GUICtrlSetBkColor(-1, $nClrGUIBk)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	$nIconPrev = GUICtrlCreateLabel("", GetScaled(151), GetScaled(30), $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, $SS_OWNERDRAW + $SS_NOTIFY)
	GUICtrlSetTip(-1, $sTTCon)
	
	CreateCtrlLabel($sLblAdapterSpeed & ":", 175, 30, 30, 14)
	GUICtrlSetBkColor(-1, $nClrGUIBk)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	CreateODBtn("100 " & $sAdapterSpeed, 206, 28, 50, 16, $arODBtnSub)
	CreateODBtn($sLblAdapterMAC & ":", 259, 28, 40, 16, $arODBtnSub)
	
	GUICtrlCreateLabel("", $nBtnL, GetScaled(49) + 1, $nR - $nBtnL - 1, $nY - GetScaled(49))
	GUICtrlSetBkColor(-1, $nClrGUIBkConf)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	GUICtrlCreateLabel("", $nBtnL - 1, $nY, $nR - $nBtnL + 2, 1) ; Bottom Main
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	
	;GUICtrlCreateLabel("", $nBtnL, GetScaled(54), 200, GetScaled(3), $SS_SUNKEN)
	
	;CreateODBtn($sBtnIPDHCP, 100, 55, 199, 15, $arODBtnSub, -1, FALSE, $nClrBtnChkTxt, $nClrBtnChkBk, 7, $nClrBtnChkGrad)
	CreateCtrlRadio("Obtain IP automatically", 100, 57, 130, 15, $WS_GROUP, -1, $hPSG)
	GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nBtnX = GetScaled(100)
	$nBtnY = GetScaled(55)
	$nBtnH = GetScaled(15)
	$nBtnL = GetScaled(130)
	
	;CreateODBtn($sBtnDHCPInfo, $nBtnX, $nBtnY, $nBtnL, $nBtnH, $arODBtnSub, -1, FALSE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, 8, $nClrBtnDhcpGrad, FALSE)
	$nBtnX += $nBtnL
	CreateODBtn("?", $nBtnX, $nBtnY, 18, 18, $arODBtnSub, 28, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, 8, $nClrBtnDhcpGrad, FALSE)
	$nBtnX += 17
	CreateODBtn("+", $nBtnX, $nBtnY, 18, 18, $arODBtnSub, 4, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, 8, $nClrBtnDhcpGrad, FALSE)
	$nBtnX += 17
	CreateODBtn("-", $nBtnX, $nBtnY, 18, 18, $arODBtnSub, 7, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, 8, $nClrBtnDhcpGrad, FALSE)
	$nBtnX += 17
	CreateODBtn("-", $nBtnX, $nBtnY, 18, 18, $arODBtnSub, 19, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, 8, $nClrBtnDhcpGrad, FALSE)
	
	CreateCtrlRadio("Use the following static IP address:", 100, 73, 170, 15, -1, -1, $hPSG)
	CreateCtrlRadio("Obtain DNS automatically", 100, 91, 170, 15, $WS_GROUP, -1, $hPSG)
	GUICtrlSetState(-1, $GUI_CHECKED)
	CreateCtrlRadio("Use the following static DNS address:", 100, 105, 170, 15, -1, -1, $hPSG)
	CreateCtrlRadio("Obtain WINS automatically", 100, 121, 170, 15, $WS_GROUP, -1, $hPSG)
	GUICtrlSetState(-1, $GUI_CHECKED)
	CreateCtrlRadio("Use the following static WINS address:", 100, 135, 170, 15, -1, -1, $hPSG)
	
	$nBtnPENMApply		= CreateODBtn($sBtnApply, 95, 163, 66, 18, $arODBtnSub, 4)		
	$nBtnPENMOK			= CreateODBtn($sBtnOK, 165, 163, 66, 18, $arODBtnSub, 2)
	$nBtnPENMCancel		= CreateODBtn($sBtnCancel, 235, 163, 66, 18, $arODBtnSub, 3)

	SetODBtnState($nBtnPENMCancel, $GUI_DEFBUTTON)
	SetODBtnState($nBtnPENMCancel, $GUI_FOCUS)
	
	CreateCtrlLabel("", 0, 185, $nR + 1, 3, $SS_SUNKEN)
	CreateCtrlLabel($sStateReady, 2, 188, 297, 11)
	GUICtrlSetColor(-1, $nClrStateGreen)
	
	If $bShowMainGUI Then
		Local $arPos = WinGetPos($hPSG)
		SetWindowPos($hPSG, 0, 0, 0, 0, 0, BitOr($SWP_NOSIZE, $SWP_NOMOVE))
		PostMessage($hPSG, $WM_NCACTIVATE, TRUE, 0)
		GUISetState()
	EndIf
	
	$bPrevPENMStarted = TRUE
	
	InvalidateRect(GUICtrlGetHandle($nIconTray), 0, TRUE)
EndFunc


;**********************************************************************
; Delete selfcreated IP address controls before leaving
;**********************************************************************
Func CleanIPCtrls()
	DestroyWindow($hIP)
	DestroyWindow($hSM)
	DestroyWindow($hDG)
	DestroyWindow($hDNS)
	DestroyWindow($hWINS)
	DestroyWindow($hAltIP)
	DestroyWindow($hAltSM)
	DestroyWindow($hAltDG)
	DestroyWindow($hAltDNS1)
	DestroyWindow($hAltWINS1)
	DestroyWindow($hAltDNS2)
	DestroyWindow($hAltWINS2)
	
	If $hAddr1 <> 0 Then DestroyWindow($hAddr1)
	If $hAddr2 <> 0 Then DestroyWindow($hAddr2)
EndFunc


;**********************************************************************
; GUI window process
;**********************************************************************
Func WndProc($hWnd, $Msg, $wParam, $lParam)
	Local $nCode, $hCtrl, $nID, $nResult, $i
	
	Switch $Msg
		Case $WM_ACTIVATE
			If $hWnd = $hTrayWiFiGUI And $wParam = 0 And $bTrayWndConnect = FALSE Then
				SetTimer($hTrayMsgWnd, $nTrayTimerID, $nTrayTimerTimeOut, 0)
				Return 0
			EndIf
			
		Case $WM_SETCURSOR
			If $hCursorCurrent = $hCursorWait Then
				SetCursor($hCursorWait)
				Return TRUE ; Long time action is in progress
			EndIf
			
			For $i = 1 To $ODBUTTONS[0][0]
				If $ODBUTTONS[$i][9] = $wParam Then
					SetCursor($hCursorHand)
					Return TRUE
				EndIf
			Next
			
			If $wParam = $hLblAboutAI3 Then
				SetCursor($hCursorHand)
				If $bLblAboutAI3 = FALSE Then
					$bLblAboutAI3 = TRUE
					GUICtrlSetFont($nLblAboutAI3, $nGlobalFontSize, 400, 4)
				EndIf
				Return TRUE
			Else
				If $bLblAboutAI3 Then GUICtrlSetFont($nLblAboutAI3, $nGlobalFontSize, 400, 0)
				$bLblAboutAI3 = FALSE
			EndIf
			
			If $wParam = $hLblAboutAuthor Then
				SetCursor($hCursorHand)
				If $bLblAboutAuthor = FALSE Then
					$bLblAboutAuthor = TRUE
					GUICtrlSetFont($nLblAboutAuthor, $nGlobalFontSize, 400, 4)
				EndIf
				Return TRUE		
			Else
				If $bLblAboutAuthor Then GUICtrlSetFont($nLblAboutAuthor, $nGlobalFontSize, 400, 0)
				$bLblAboutAuthor = FALSE
			EndIf
			
			If $hWnd = $wParam Then
				SetCursor($hCursorCurrent)
				Return TRUE
			EndIf
			
			Return FALSE
				
		Case $WM_VSCROLL
			If $lParam <> 0 Then Return $GUI_RUNDEFMSG
			Local $i = -1, $hWndScroll = $hWnd
			Switch $hWnd
				Case $hOtherGUI
					$i = 0
				Case $hTrayGUI, $hTraySubGUI
					If $bTraySBVisible Then
						$i = 1
						$hWndScroll = $hTraySubGUI
					EndIf
				Case $hGlobalGUI
					$i = 2
			EndSwitch
			
			If $i > -1 Then
				$nCode = BitAnd($wParam, 0x0000FFFF)
				Local $nNewPos = 0
				
				Switch $nCode
					Case $SB_TOP, $SB_LINEUP
						$nNewPos = $arScrollInfo[$i][0] - 15
					Case $SB_BOTTOM, $SB_LINEDOWN
						$nNewPos = $arScrollInfo[$i][0] + 15
					Case $SB_PAGEUP
						$nNewPos = $arScrollInfo[$i][0] - 40
					Case $SB_PAGEDOWN
						$nNewPos = $arScrollInfo[$i][0] + 40
					Case $SB_THUMBPOSITION, $SB_THUMBTRACK
						$nNewPos = BitShift($wParam, 16)
					Case Else
						$nNewPos = $arScrollInfo[$i][0]
				EndSwitch
				
				If $nNewPos < 0 Then $nNewPos = 0
				If $nNewPos > ($arScrollInfo[$i][1] + 1) Then $nNewPos = $arScrollInfo[$i][1] + 1
				
				Local $nDelta = $nNewPos - $arScrollInfo[$i][0]
				
				$arScrollInfo[$i][0] = $nNewPos
				
				ScrollWindow($hWndScroll, 0, -$nDelta, 0, 0)
				UpdateWindow($hWndScroll)
				
				Local $stSI = DllStructCreate($sSCROLLINFO)
				DllStructSetData($stSI, 1, DllStructGetSize($stSI))				
				DllStructSetData($stSI, 2, $SIF_POS)
				DllStructSetData($stSI, 6, $arScrollInfo[$i][0])
				SetScrollInfo($hWndScroll, $SB_VERT, DllStructGetPtr($stSI), TRUE)
				$stSI = 0
				
				Return 0
			EndIf
			
		Case $WM_MOUSEWHEEL
			If $hWnd = $hMainGUI Then
				; Workaround for older OS'<Win10
				If $hLastGUI = $hOtherGUI Then
					; Only wheel if mouse is in other gui client area
					Local $stPoint = DllStructCreate("int;int")
					GetCursorPos(DllStructGetPtr($stPoint))
					Local $stRect = DllStructCreate("long;long;long;long")
					GetWindowRect($hOtherGUI, DllStructGetPtr($stRect))
					If DllStructGetData($stPoint, 1) >= DllStructGetData($stRect, 1) And _
						DllStructGetData($stPoint, 1) <= DllStructGetData($stRect, 3) And _
						DllStructGetData($stPoint, 2) >= DllStructGetData($stRect, 2) And _
						DllStructGetData($stPoint, 2) <= DllStructGetData($stRect, 4) Then
						Local $nDist = BitShift($wParam, 16)
						If $nDist > 0 Then
							For $i = 1 To $nScrollLines
								SendMessage($hOtherGUI, $WM_VSCROLL, $SB_LINEUP, 0)
							Next
						Else
							For $i = 1 To $nScrollLines
								SendMessage($hOtherGUI, $WM_VSCROLL, $SB_LINEDOWN, 0)
							Next
						EndIf
					EndIf
					$stPoint = 0
					$stRect = 0
				EndIf
			ElseIf (($hWnd = $hTrayGUI Or $hWnd = $hTraySubGUI) And $bTraySBVisible) Then
				Local $nDist = BitShift($wParam, 16)
				If $nDist > 0 Then
					For $i = 1 To $nScrollLines
						SendMessage($hTraySubGUI, $WM_VSCROLL, $SB_LINEUP, 0)
					Next
				Else
					For $i = 1 To $nScrollLines
						SendMessage($hTraySubGUI, $WM_VSCROLL, $SB_LINEDOWN, 0)
					Next
				EndIf
			EndIf			
			
		Case 0x7FFF ; send by 2nd instance
			Debug("IN: Detected message from another instance - own PID: " & @AutoItPID)
			If BitAnd($wParam, 0xFFFFFFFF) = @AutoItPID Then
				ShowWindow($hMainGUI, @SW_RESTORE)
				GUISetState(@SW_SHOW, $hMainGUI)
				If $bShowTrayAct = FALSE And $bShowTrayAlways = FALSE Then TrayIconSetState(2)
				If Not $bShowTrayAlways Then $bInTray = FALSE
				Return 0
			EndIf
			
		Case $nTaskbarCreatedMsg
			If $bInTray Or $bShowTrayAct Or $bShowTrayAlways Then
				TrayIconSetState(2)
				TrayIconSetState()
				If $bShowTrayAct Then SetTrayIcon($nLastTrayState)
			EndIf
			
		Case $TRAYMSGID
			Switch $lParam
				Case $WM_MOUSEMOVE
					GetCursorPos(DllStructGetPtr($stTrayPnt))
					
					If DllStructGetData($stTrayPnt, 1) <> $arMousePos[0] Or _
						DllStructGetData($stTrayPnt, 2) <> $arMousePos[1] Then
						If $bTrayTrackMouse And $hTrayGUI = 0 And $bTrayWndWiFi = FALSE And $bTrayTimerStop = FALSE Then
							KillTimer($hTrayMsgWnd, $nTrayTimerIDInit)
							SetTimer($hTrayMsgWnd, $nTrayTimerIDInit, $nTrayTimerTimeOut, 0)
						EndIf
						
						$arMousePos[0] = DllStructGetData($stTrayPnt, 1)
						$arMousePos[1] = DllStructGetData($stTrayPnt, 2)
						
						Return 0							
					EndIf
					
				Case $WM_LBUTTONUP
					If $arWLANList[0] = 0 Then Return 0
					If $bTrayWndCreating = FALSE Then
						$bTrayWndCreating = TRUE
						KillTimer($hTrayMsgWnd, $nTrayTimerIDInit)
						KillTimer($hTrayMsgWnd, $nTrayTimerID)
						KillTimer($hTrayWiFiGUI, $nTrayTimerIDEnum)

						If $hTrayGUI <> 0 Then DeleteTrayInfo()
						
						If $bTrayWndWiFi Then
							GUISetState(@SW_HIDE, $hTrayWiFiGUI)
							$bTrayWndWiFi = FALSE
							SetTimer($hTrayMsgWnd, $nTrayTimerID, $nTrayTimerTimeOut, 0)
						Else
							ShowTrayWiFi()
							SetTimer($hTrayWiFiGUI, $nTrayTimerIDEnum, $nTrayTimerTimeOutEnum, 0)
							$bTrayWndWiFi = TRUE
							$bTrayTimerStop = TRUE
						EndIf
						
						$bTrayWndCreating = FALSE
					EndIf
					
					Return 0

				Case $WM_LBUTTONDBLCLK
						$bTrayWndCreating = TRUE						
						KillTimer($hTrayMsgWnd, $nTrayTimerID)
						KillTimer($hTrayMsgWnd, $nTrayTimerIDInit)
						
						If $hTrayGUI <> 0 Then DeleteTrayInfo()

						If $bTrayWndWiFi Then
							GUISetState(@SW_HIDE, $hTrayWifiGUI)
							KillTimer($hTrayWiFiGUI, $nTrayTimerIDEnum)
						EndIf
						
						If $bShowTrayAct = FALSE And $bShowTrayAlways = FALSE Then TrayIconSetState(2)
						If Not $bShowTrayAlways Then $bInTray = FALSE
						ShowWindow($hMainGUI, @SW_RESTORE)
						GUISetState(@SW_SHOW, $hMainGUI)
						SetForegroundWindow($hMainGUI)
						SetTimer($hTrayMsgWnd, $nTrayTimerID, $nTrayTimerTimeOut, 0)
						$bTrayWndCreating = FALSE
						Return 0
					
				Case $WM_RBUTTONUP
					If $hTrayMenu <> 0 Then
						$bTrayTrackMouse = FALSE
						
						KillTimer($hTrayMsgWnd, $nTrayTimerIDInit)
						KillTimer($hTrayMsgWnd, $nTrayTimerID)
											
						If $hTrayGUI <> 0 Then DeleteTrayInfo()
			
						If $bTrayWndWiFi Then
							GUISetState(@SW_HIDE, $hTrayWifiGUI)
							KillTimer($hTrayWiFiGUI, $nTrayTimerIDEnum)
						EndIf
						
						Local $stPoint = DllStructCreate("int;int")
						GetCursorPos(DllStructGetPtr($stPoint))
						SetForegroundWindow($hWnd)
						
						TrackPopupMenuEx($hTrayMenu, 0, DllStructGetData($stPoint, 1), DllStructGetData($stPoint, 2), $hWnd, 0)
						PostMessage($hWnd, 0, 0, 0)
					EndIf
			EndSwitch
			
		Case $WM_MENUSELECT
			If $hWnd = $hTrayMsgWnd And BitShift($wParam, 16) = -1 And $lParam = 0 Then $bTrayTrackMouse = TRUE
		
		Case $WM_CONTEXTMENU
			If $wParam = $hTVDrvNet Then
				Local $nY = BitShift($lParam, 16)
	    		Local $nX = BitAnd($lParam, 0x0000FFFF)
	    		Local $stPoint = DllStructCreate("int;int")
	    		DllStructSetData($stPoint, 1, $nX)
	    		DllStructSetData($stPoint, 2, $nY)
	    		
	    		ScreenToClient($hTVDrvNet, DllStructGetPtr($stPoint))
				
				Local $stTVHT = DllStructCreate("long;long;uint;hwnd")
	    		DllStructSetData($stTVHT, 1, DllStructGetData($stPoint, 1))
	    		DllStructSetData($stTVHT, 2, DllStructGetData($stPoint, 2))
				
	    		Local $hItem = GUICtrlSendMsg($nTVDrvNet, $TVM_HITTEST, 0, DllStructGetPtr($stTVHT))
	    		If $hItem <> 0 And BitAnd(DllStructGetData($stTVHT, 3), $TVHT_ONITEM) Then
	    			Local $nImage = GetTVIImage($nTVDrvNet, $hItem)
	    			If $nImage = 2 Or $nImage = 3 Then
	    				GUICtrlSendMsg($nTVDrvNet, $TVM_SELECTITEM, $TVGN_CARET, $hItem)
	    				
	    				ClientToScreen($hTVDrvNet, DllStructGetPtr($stPoint))
	    				
						Local $hMenu = GUICtrlGetHandle($nConMenuNetDrv)
						If $hMenu <> 0 Then TrackPopupMenuEx($hMenu, 0, DllStructGetData($stPoint, 1), DllStructGetData($stPoint, 2), $hDrivesGUI, 0)
					EndIf
				EndIf
			EndIf
				
		Case $WM_NOTIFY
			Local $stPoint
			Local $sNMHDR = "hwnd;uint_ptr;int"
			Local $stNMHDR = DllStructCreate($sNMHDR, $lParam)
			
			$hCtrl	= DllStructGetData($stNMHDR, 1)
			$nID	= DllStructGetData($stNMHDR, 2)
			$nCode	= DllStructGetData($stNMHDR, 3)
			
			If $nCode = $NM_RCLICK Then
				If $nID = $nLVDrives Or $nID = $nLVShares Then
					$stPoint = DllStructCreate("int;int")
    				
    				GetCursorPos(DllStructGetPtr($stPoint))
					ScreenToClient($hCtrl, DllStructGetPtr($stPoint))
					
					Local $hMenu = 0
    				Local $stLVHT = DllStructCreate("int;int;uint;int;int")
    				DllStructSetData($stLVHT, 1, DllStructGetData($stPoint, 1))
    				DllStructSetData($stLVHT, 2, DllStructGetData($stPoint, 2))
    				
    				ClientToScreen($hCtrl, DllStructGetPtr($stPoint))
    				
					If GUICtrlSendMsg($nID, $LVM_SUBITEMHITTEST, 0, DllStructGetPtr($stLVHT)) > -1 Then
						If $nID = $nLVShares Then
							$hMenu = GUICtrlGetHandle($nConMenuShr)
						ElseIf $nID = $nLVDrives Then
							$hMenu = GUICtrlGetHandle($nConMenuDrv)
						EndIf
					EndIf
										
					If $hMenu <> 0 Then TrackPopupMenuEx($hMenu, 0, DllStructGetData($stPoint, 1), DllStructGetData($stPoint, 2), $hWnd, 0)
				ElseIf $nID = $nLVWLAvailTray Then
					$stPoint = DllStructCreate("int;int")
    				
    				GetCursorPos(DllStructGetPtr($stPoint))
					ScreenToClient($hCtrl, DllStructGetPtr($stPoint))
					
					Local $hMenu = 0
    				Local $stLVHT = DllStructCreate("int;int;uint;int;int")
    				DllStructSetData($stLVHT, 1, DllStructGetData($stPoint, 1))
    				DllStructSetData($stLVHT, 2, DllStructGetData($stPoint, 2))
    				
    				ClientToScreen($hCtrl, DllStructGetPtr($stPoint))
    				
					Local $nItem = GUICtrlSendMsg($nID, $LVM_SUBITEMHITTEST, 0, DllStructGetPtr($stLVHT))
					If $nItem > -1 Then
						Local $sSSID = GetLVIText($nID, $nItem, 1)
						If BitAnd($arWLAVNList[$nItem][5], 128) And Not $bIsVista Then $sSSID &= "-adhoc"
						
						Local $stVersion	= DllStructCreate("dword")
						Local $stHandle		= DllStructCreate("dword")
						DllStructSetData($stHandle, 1, 0)
						
						If WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle)) = $ERROR_SUCCESS Then
							Local $hWlan 	= DllStructGetData($stHandle, 1)							
							Local $i = IsWLANI(GUICtrlRead($nComboNATray))
							If $i > 0 Then
								Local $stGUID	= DllStructCreate($sGUID)
								CreateGUIDFromString($stGUID, $arWLANList[$i])
								
								Local $stPtr = DllStructCreate("ptr")
								Local $stProfile	= DllStructCreate("wchar[260]")
								DllStructSetData($stProfile, 1, $sSSID)
								If WlanGetProfile($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stProfile), 0, DllStructGetPtr($stPtr), 0, 0) = $ERROR_SUCCESS Then
									$hMenu = GUICtrlGetHandle($nConMenuWiFi)
									If $hMenu <> 0 Then TrackPopupMenuEx($hMenu, 0, DllStructGetData($stPoint, 1), DllStructGetData($stPoint, 2), $hWnd, 0)				
									WlanFreeMemory(DllStructGetData($stPtr, 1))
									;sCurSelPref = $sSSID
								EndIf
							EndIf
							WlanCloseHandle($hWlan, 0)
						EndIf
					EndIf			
				EndIf
			ElseIf $nCode = $NM_DBLCLK Then
				Switch $nID
					Case $nLVWLAvail
						Local $nLVCur = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
						If $nLVCur > -1 Then
							If GetLVIImage($nID, $nLVCur, 0) <> 18 Then ; Only try to connect to 'connectable' networks						
								GUICtrlSetData($nLblState, $sLblWiFiCon)
								GUICtrlSetColor($nLblState, $nClrStateRed)
								;SetGUICursor($hCursorWait, $hMainGUI)
								
								$nResult = ConnectWlan(GUICtrlRead($nComboNA))
								If $nResult <> -9999 Then
									If $nResult = $ERROR_SUCCESS Then
										Sleep(3000)
										EnumWlanAvailNetworks(GUICtrlRead($nComboNA))
									EndIf
									
									;SetGUICursor($hCursorArrow, $hMainGUI)
									GUICtrlSetColor($nLblState, $nClrStateGreen)
									GUICtrlSetData($nLblState, $sStateReady)
									
									Return 0
								EndIf
							EndIf
						EndIf
					Case $nLVWLPref
						EditWlanProfile(GUICtrlRead($nComboNA))
						Return 0
					Case $nLVShares, $nLVDrives
						BrowseDrive($nID)
						Return 0
					
					Case $nLVWLAvailTray
						Local $nLVCur = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
						If $nLVCur > -1 Then
							If BitAnd(GetLVIText($nID, $nLVCur, 0), 512) Then ; Only try to connect to 'connectable' networks	
								GUICtrlSetData($nLblState, $sLblWiFiCon)
								GUICtrlSetColor($nLblState, $nClrStateRed)
								;SetGUICursor($hCursorWait, $hMainGUI)
								
								$bTrayWndConnect = TRUE
								$nResult = ConnectWlan(GUICtrlRead($nComboNATray), TRUE, $nLVWLAvailTray, 1)
								If $nResult <> -9999 Then
									$bTrayWndConnect = FALSE
									
									;SetGUICursor($hCursorArrow, $hMainGUI)
									GUICtrlSetColor($nLblState, $nClrStateGreen)
									GUICtrlSetData($nLblState, $sStateReady)
									
									Return 0
								EndIf
							EndIf
						EndIf
				EndSwitch
			EndIF			
			
			If $nCode = $NM_CUSTOMDRAW And $nID <> 0 Then
				Switch $nID
					Case $nLVWLAvail, $nLVWLAvailTray
						Local $stNMLVCUSTOMDRAW = DllStructCreate("hwnd;uint_ptr;uint_ptr;dword;ulong_ptr;long[4];ulong_ptr;uint;long_ptr;dword;dword;int;" & _
																	"dword;dword;int;int;int;int;long[4];uint", $lParam)
						Local $nDrawStage		= DllStructGetData($stNMLVCUSTOMDRAW, 4)
						Local $nItem			= DllStructGetData($stNMLVCUSTOMDRAW, 7)
						
						If $nItem = $nCurConItem Or ($nItem <> $nCurConItem And $nDrawStage = $CDDS_PREPAINT) Then
							Local $hDC = DllStructGetData($stNMLVCUSTOMDRAW, 5)
							
							Switch $nDrawStage
								Case $CDDS_PREPAINT
									Return $CDRF_NOTIFYITEMDRAW
									
								Case $CDDS_ITEMPREPAINT
									DllStructSetData($stNMLVCUSTOMDRAW, 10, $nClrWiFiConnect) ; Text color
									;DllStructSetData($stNMLVCUSTOMDRAW, 11, 0xD0F0F0) ; Background color
									If $nID = $nLVWLAvail Then
										SelectObject($hDC, $hGlobalBoldFont)
									Else
										SelectObject($hDC, $hWiFiBigBoldFont)
									EndIf
									Return $CDRF_NEWFONT
							EndSwitch
						EndIf
						
					Case $nChkScan, $nChkPing, $nChkTrace, $nChkReverse, $nChkIcons, $nChkDebug, $nChkStartTray, $nChkMinTray, $nChkEndTray, _
							$nChkShowAct, $nChkShowTip, $nChkShowOnlyCon, $nChkLastPos, $nChkLastPage, $nChkUseWMI, $nChkShrAll, $nChkWLEditUI, _
							$nChkKey, $nChkAuto, $nChkHidden, $nChkAdhoc, $nChkConnKey, $nRadioOSFont, $nRadioFont, $nRadIPDHCP, $nRadIPStatic, _
							$nRadIPNone, $nChkDGMode, $nRadDNSDHCP, $nRadDNSStatic, $nRadWINSDHCP, $nRadWINSStatic, $nRadIPPrivate, $nRadIPUser, _
							$nChkWait, $nChkConnAuto, $nChkShowAlways, $nChkTrayLimitInfo, $nChkTrayAdaptWiFi, $nChkTrayShowMAC, $nChkTrayShowIPv6
						Local $stNMCUSTOMDRAW = DllStructCreate("hwnd;uint_ptr;uint_ptr;dword;ulong_ptr;long[4];long_ptr;uint;long_ptr", $lParam)						
						Local $hDC = DllStructGetData($stNMCUSTOMDRAW, 5)
					
						Local $nLen = GetWindowTextLength($hCtrl)		
						Local $stText = DllStructCreate("wchar[" & ($nLen + 1) & "]")
						GetWindowTextW($hCtrl, DllStructGetPtr($stText), $nLen + 1)
						
						Local $nColor = $nClrLblNormal
						Local $uFlags	= BitOr($DT_NOCLIP, $DT_VCENTER, $DT_SINGLELINE)
						
						Switch $nID
							Case $nChkWLEditUI
								$nColor = $nClrLblWiFi
								$uFlags = BitOr($DT_NOCLIP, $DT_VCENTER, $DT_WORDBREAK)
							Case $nChkKey, $nChkAuto, $nChkHidden, $nChkAdhoc, $nChkConnKey, $nChkConnAuto
								$nColor = $nClrLblWiFi
						EndSwitch
						
						If BitAnd(DllStructGetData($stNMCUSTOMDRAW, 8), $CDIS_DISABLED) Then $nColor = GetSysColor($COLOR_GRAYTEXT)
						
						If DllStructGetData($stNMCUSTOMDRAW, 4) = $CDDS_PREPAINT Then					
							SetTextColor($hDC, $nColor)
							
							Local $stRect	= DllStructCreate("int;int;int;int")
							DllStructSetData($stRect, 1, DllStructGetData($stNMCUSTOMDRAW, 6, 1) + GetScaled(16))
							DllStructSetData($stRect, 2, DllStructGetData($stNMCUSTOMDRAW, 6, 2))
							DllStructSetData($stRect, 3, DllStructGetData($stNMCUSTOMDRAW, 6, 3))
							DllStructSetData($stRect, 4, DllStructGetData($stNMCUSTOMDRAW, 6, 4))
							
							DrawTextW($hDC, DllStructGetPtr($stText), $nLen, DllStructGetPtr($stRect), $uFlags)
							
							$stText = 0
							Return $CDRF_SKIPDEFAULT
						EndIf
				EndSwitch
			EndIf
			
			Switch $hWnd
				Case $hMainGUI
					Switch $nCode
						Case $LVN_BEGINDRAG
							Return 0
					EndSwitch
					
				Case $hSubGUI, $hSharesGUI, $hDrivesGUI, $hConfWiFiGUI, $hWiFiAvailGUI, $hWiFiPrefGUI, $hIdentGUI, $hTrayWiFiGUI
					Switch $nCode
						Case $LVN_BEGINDRAG
							Return 0
						
						Case $LVN_HOTTRACK
							If $hWnd = $hWiFiAvailGUI Or $hWnd = $hTrayWiFiGUI Then
								Local $stLVHT = DllStructCreate("int;int;uint;int;int")
			    				$stPoint = DllStructCreate("int;int")
			    				
			    				GetCursorPos(DllStructGetPtr($stPoint))
								ScreenToClient($hCtrl, DllStructGetPtr($stPoint))
								
			    				DllStructSetData($stLVHT, 1, DllStructGetData($stPoint, 1))
			    				DllStructSetData($stLVHT, 2, DllStructGetData($stPoint, 2))
			    				
			    				ClientToScreen($hCtrl, DllStructGetPtr($stPoint))
			    				
								Local $nItem = GUICtrlSendMsg($nID, $LVM_SUBITEMHITTEST, 0, DllStructGetPtr($stLVHT))
								Local $nCol = DllStructGetData($stLVHT, 5)
								
								If $nID = $nLVWLAvail Or $nID = $nLVWLAvailTray Then
									If $nItem <> $nCurItem Or $nCurCol <> $nCol Then
										$nCurItem	= $nItem
										$nCurCol	= $nCol
										
										If $nItem >= 0 Then
											If $hLVTT <> 0 Then
												DestroyWindow($hLVTT)
											EndIf
											
											Local $i, $s, $sText
											Local $sProfileConnected	= ""
											Local $sSSIDConnected		= ""
											Local $sMAC					= ""
											Local $bAdhoc				= FALSE
											Local $nSignal				= 0
													
											If $nID = $nLVWLAvailTray And $nCol > -1 Then
												Local $sStrCon = ""
												Local $sTitle = ""
												$sText = GetLVIText($nID, $nItem, 1)
												
												If GetWlanCurCon(GUICtrlRead($nComboNATray), $sProfileConnected, $sSSIDConnected, $sMAC, $bAdhoc, $nSignal) Then
													If $sText == $sProfileConnected Then $sStrCon = "MAC: " & $sMAC
												EndIf
												
												For $i = 1 To $arWLAVNList[0][0]
													;consolewrite("sText:" & $sText & ";" & $arWLAVNList[$i][1] & ";" & $arWLAVNList[$i][2] & ";" & $arWLAVNList[$i][6] & ";" & $arWLAVNList[$i][7] & @LF)
												
													If ($arWLAVNList[$i][1] = $sText) Or _
														($arWLAVNList[$i][6] <> $arWLAVNList[$i][1] And $arWLAVNList[$i][6] = $sText) Or _
														($arWLAVNList[$i][2] <> $arWLAVNList[$i][1] And $arWLAVNList[$i][2] = $sText) Or _
														($arWLAVNList[$i][6] <> $arWLAVNList[$i][7] And $arWLAVNList[$i][7] = $sText) Then
														$nItem = $i
														ExitLoop
													EndIf
												Next
												
												Switch $arWLAVNList[$nItem][4]
													Case "N"
														$s = "802.11n"													
													Case "G"
														$s = "802.11g"
													Case "B"
														$s = "802.11b"
													Case "A"
														$s = "802.11a"
													Case "AC"
														$s = "802.11ac"
													Case "AD"
														$s = "802.11ad"
													Case "AX"
														$s = "802.11ax"
													Case Else
														$s = $sWiFiUnknown
												EndSwitch
												
												$sText = "SSID: " & $arWLAVNList[$nItem][6]
												
												If $sStrCon <> "" Then
													$sTitle = $sWiFiBalConTo
													$sText = $sText & @CRLF & $sStrCon
												EndIf
												
												$sText &= @CRLF & $sWiFiBalSignal & ": " & $arWLAVNList[$nItem][0] & @CRLF & $sWiFiBalSec & ": " & $arWLAVNList[$nItem][3] & _
													@CRLF & $sWiFiBalRadio & ": " & $s
												CreateBalloonTip($hCtrl, $sText, $sTitle)
											Else
												Local $nImage = GetLVIImage($nID, $nItem, $nCol)
												
												If $nCol = 1 Or $nCol = 4 Then
													$sText = GetLVIText($nID, $nItem, $nCol)
															
													If $nCol = 1 Then
														If GetWlanCurCon(GUICtrlRead($nComboNA), $sProfileConnected, $sSSIDConnected, $sMAC, $bAdhoc, $nSignal) Then
															If $sText == $sProfileConnected Then
																Local $sStrCon = "ESSID: " & @Tab & $sSSIDConnected & @CRLF & "MAC: " & @Tab & $sMAC
																CreateBalloonTip($hCtrl, $sStrCon, $sWiFiBalConTo, 1)
															EndIf
														EndIf
													Else
														Switch $sText
															Case "N"
																CreateBalloonTip($hCtrl, "802.11n")
															Case "G"
																CreateBalloonTip($hCtrl, "802.11g")
															Case "B"
																CreateBalloonTip($hCtrl, "802.11b")
															Case "A"
																CreateBalloonTip($hCtrl, "802.11a")
															Case "AC"
																CreateBalloonTip($hCtrl, "802.11ac")
															Case Else
																CreateBalloonTip($hCtrl, $sWiFiUnknown)
														EndSwitch
													EndIf
												Else
													$sText = GetLVIText($nID, $nItem, 1) ; SSID
													
													Switch $nCol
														Case 2
															If $nImage = 5 Then
																CreateBalloonTip($hCtrl, $sWiFiBalNetSec)
															ElseIf $nImage = 6 Then
																CreateBalloonTip($hCtrl, $sWiFiBalNetNonSec)
															EndIf
													
														Case 3
															Switch $nImage
																Case 7, 8
																	CreateBalloonTip($hCtrl, $sWiFiBalNetInfra)
																
																Case 9, 10
																	CreateBalloonTip($hCtrl, $sWiFiBalNetAdhoc)														
															EndSwitch
														
														Case 5
															If $nImage = 11 Then CreateBalloonTip($hCtrl, $sWiFiBalNetPref)													
													EndSwitch
												EndIf
											EndIf
										ElseIf $hLVTT <> 0 Then
											DestroyWindow($hLVTT)
											
											$nCurItem	= -1
											$nCurCol	= -1
										EndIf
									EndIf
								EndIf
							EndIf
							
						Case $LVN_ITEMCHANGED, $NM_CLICK
							Local $nLVCur
							If $nID = $nLVShares Then
								$nLVCur = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
								If $nLVCur > -1 And $nLVCur <> $nLVShrLast And $nCode = $LVN_ITEMCHANGED Then
									If BitAnd(GetODBtnState($nBtnShrDel), $GUI_DISABLE) Then SetODBtnState($nBtnShrDel, $GUI_ENABLE)
								ElseIf $nLVCur = -1 And $nLVShrLast = -1 And $nCode = $NM_CLICK Then
									If BitAnd(GetODBtnState($nBtnShrDel), $GUI_ENABLE) Then SetODBtnState($nBtnShrDel, $GUI_DISABLE)
								EndIf
								$nLVShrLast = $nLVCur
							ElseIf $nID = $nLVDrives Then
								$nLVCur = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
								If $nLVCur > -1 And $nLVCur <> $nLVDrvLast And $nCode = $LVN_ITEMCHANGED Then
									If BitAnd(GetODBtnState($nBtnDrvDel), $GUI_DISABLE) Then SetODBtnState($nBtnDrvDel, $GUI_ENABLE)
								ElseIf $nLVCur = -1 And $nLVDrvLast = -1 And $nCode = $NM_CLICK Then
									If BitAnd(GetODBtnState($nBtnDrvDel), $GUI_ENABLE) Then SetODBtnState($nBtnDrvDel, $GUI_DISABLE)
								EndIf
								$nLVDrvLast = $nLVCur
							ElseIf $nID = $nLVWLAvail Then
								$nLVCur = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
								If $nLVCur > -1 And $nLVCur <> $nLVWALast And $nCode = $LVN_ITEMCHANGED Then
									If GetLVIImage($nID, $nLVCur, 0) = 18 Then
										If BitAnd(GetODBtnState($nBtnWLCon), $GUI_ENABLE) Then SetODBtnState($nBtnWLCon, $GUI_DISABLE)
									Else
										If BitAnd(GetODBtnState($nBtnWLCon), $GUI_DISABLE) Then SetODBtnState($nBtnWLCon, $GUI_ENABLE)
									EndIf
								ElseIf $nLVCur = -1 And $nLVWALast = -1 And $nCode = $NM_CLICK Then
									If BitAnd(GetODBtnState($nBtnWLCon), $GUI_ENABLE) Then SetODBtnState($nBtnWLCon, $GUI_DISABLE)
								EndIf
								$nLVWALast = $nLVCur
							ElseIf $nID = $nLVWLPref Then
								$nLVCur = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
								If $nLVCur > -1 And $nLVCur <> $nLVWLast And $nCode = $LVN_ITEMCHANGED Then
									If BitAnd(GetODBtnState($nBtnWLDel), $GUI_DISABLE) Then SetODBtnState($nBtnWLDel, $GUI_ENABLE)
									If BitAnd(GetODBtnState($nBtnWLEdit), $GUI_DISABLE) Then SetODBtnState($nBtnWLEdit, $GUI_ENABLE)
									If BitAnd(GetODBtnState($nBtnWLExport), $GUI_DISABLE) Then SetODBtnState($nBtnWLExport, $GUI_ENABLE)
								ElseIf $nLVCur = -1 And $nLVWLast = -1 And $nCode = $NM_CLICK Then
									If BitAnd(GetODBtnState($nBtnWLDel), $GUI_ENABLE) Then SetODBtnState($nBtnWLDel, $GUI_DISABLE)
									If BitAnd(GetODBtnState($nBtnWLEdit), $GUI_ENABLE) Then SetODBtnState($nBtnWLEdit, $GUI_DISABLE)
									If BitAnd(GetODBtnState($nBtnWLExport), $GUI_ENABLE) Then SetODBtnState($nBtnWLExport, $GUI_DISABLE)
								EndIf
								$nLVWLast = $nLVCur
								
								If $bIsVista Then
									ChkListBtnCtrl($nLVWLPref, $nBtnWLUp, $nBtnWLDown, TRUE, FALSE)
								Else
									ChkWiFiPrefListBtnCtrlXP()								
								EndIf
							ElseIf $nID = $nLVWLAvailTray Then
								$nLVCur = GUICtrlSendMsg($nID, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
								$sText = GUICtrlRead($nBtnWLConTray)
								If $nLVCur > -1 And $nCode = $LVN_ITEMCHANGED Then
									Local $nBitType = Number(GetLVIText($nID, $nLVCur, 0))
																									
									If BitAnd($nBitType, 512) Then
										SetODBtnState($nBtnWLConTray, $GUI_ENABLE, FALSE)
									Else
										SetODBtnState($nBtnWLConTray, $GUI_DISABLE, FALSE)
									EndIf
									
									If BitAnd($nBitType, 256) Then
										If $sText <> $sBtnWiFiDisconnect Then SetODBtnData($nBtnWLConTray, $sBtnWiFiDisconnect, FALSE)
									Else
										If BitAnd($nBitType, 512) Then
											SetODBtnState($nBtnWLConTray, $GUI_ENABLE, FALSE)
										Else
											SetODBtnState($nBtnWLConTray, $GUI_DISABLE, FALSE)
										EndIf
										
										If $sText <> $sBtnConnect Then SetODBtnData($nBtnWLConTray, $sBtnConnect, FALSE)
									EndIf
								ElseIf $nLVCur = -1 And $nLVWALastTray = -1 And $nCode = $NM_CLICK Then
									SetODBtnState($nBtnWLConTray, $GUI_DISABLE, FALSE)
									If $sText <> $sBtnWiFiDisconnect Then SetODBtnData($nBtnWLConTray, $sBtnWiFiDisconnect, FALSE)
								EndIf
								$nLVWALastTray = $nLVCur
							EndIf
					EndSwitch
			EndSwitch
			
			If $nCode = $IPN_FIELDCHANGED Then
				Local $stNMIP = DllStructCreate("dword;uint;int;int;int", $lParam)
				CheckAddress($hCtrl, DllStructGetData($stNMIP, 4), DllStructGetData($stNMIP, 5))
			EndIf
			
			If $nID = $nTVDrvNet Then
				Local $sText	= ""
				Local $nState	= 0
				Local $nChilds	= 0
				Local $stPNMTV	= DllStructCreate($sNMHDR & ";uint_ptr;" & $sTVI & ";" & $sTVI & ";long;long", $lParam)
				Local $hItem	= DllStructGetData($stPNMTV, 16)
				
				If $hItem <> 0 Then
					Switch $nCode
						Case $TVN_ITEMEXPANDINGA, $TVN_ITEMEXPANDINGW
							Local $hChild = GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_CHILD, $hItem)
							If GetTVItem($nTVDrvNet, $hItem, $sText, $nState, $nChilds) Then							
								If DllStructGetData($stPNMTV, 4) = $TVE_EXPAND And $hChild = 0 Then
									GUICtrlSetColor($nLblState, $nClrStateRed)
									GUICtrlSetData($nLblState, $sLblNetResSearch)
									SetGUICursor($hCursorWait, $hMainGUI)
									If GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem) = 0 Then
										If Not IsServiceRunning("browser") Then StartSvc("browser")
									EndIf
									EnumNetItems($sText, $hItem, $hItem)
									SetGUICursor($hCursorArrow, $hMainGUI)
									GUICtrlSetData($nLblState, $sStateReady)
									GUICtrlSetColor($nLblState, $nClrStateGreen)
								EndIf
							EndIf

						Case $TVN_SELCHANGEDA, $TVN_SELCHANGEDW
							GetTVITree($nTVDrvNet, $hItem, $sText)
							GUICtrlSetData($nComboDrvPath, $sText, $sText)

							Local $nImage = GetTVIImage($nTVDrvNet, $hItem)
							
							If $nImage = 0 Then
								SetODBtnState($nBtnDrvNetDel, $GUI_ENABLE)
								GUICtrlSetData($nEditDrvDesc, "")
							Else
								Local $hParent = GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem)
								If $hParent = 0 Then
									SetODBtnState($nBtnDrvNetDel, $GUI_ENABLE)
								Else
									SetODBtnState($nBtnDrvNetDel, $GUI_DISABLE)
								EndIf
								
								If $nImage = 1 Then
									GetTVItem($nTVDrvNet, $hItem, $sText, $nState, $nChilds)
									TCPStartUp()
									Local $sIP = TCPNameToIP($sText)
									TCPShutDown()
									
									GUICtrlSetData($nEditDrvDesc, "IP: " & $sIP)
								Else
									GUICtrlSetData($nEditDrvDesc, "")
								EndIf
							EndIf

						Case $TVN_ITEMEXPANDEDA, $TVN_ITEMEXPANDEDW
							If GetTVItem($nTVDrvNet, $hItem, $sText, $nState, $nChilds) Then
								If Not BitAnd($nState, $TVIS_EXPANDED) Then
									Local $hParent = GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem)
									Local $hPrev = GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_PREVIOUS, $hItem)
									Local $hSel = GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_CARET, 0)
									
									If $hPrev = 0 Then $hPrev = $TVI_FIRST
									
									Local $bSel = FALSE
									If $hSel = $hItem Then $bSel = TRUE
									Local $nImage = GetTVIImage($nTVDrvNet, $hItem)
									
									If GUICtrlSendMsg($nTVDrvNet, $TVM_DELETEITEM, 0, $hItem) Then
										$hItem = CreateAdvTVItem($sText, $nTVDrvNet, $hParent, $hPrev, $nImage, TRUE)
										If $hItem <> 0 And $bSel Then GUICtrlSendMsg($nTVDrvNet, $TVM_SELECTITEM, $TVGN_CARET, $hItem)
									EndIf
								EndIf
							EndIf
					EndSwitch
				EndIf
			EndIf
			
		Case $WM_SYSCOMMAND
			If $hWnd = $hMainGUI And ($wParam = $SC_MINIMIZE Or $wParam = $SC_CLOSE) Then $bLoopPing = FALSE
			
		Case $WM_COMMAND
			$hCtrl	= $lParam
			$nCode	= BitShift($wParam, 16)
    		$nID	= BitAnd($wParam, 0x0000FFFF)
    		
    		If $nID = 0 And $nCode = 0 Then $bLoopPing = FALSE
    		
    		If $nID = 1 And $nCode = 0 Then
    			Local $hFocus = GetFocus()
				If $hFocus <> 0 Then
					Local $nDlgID = GetDlgCtrlID($hFocus)
					If $nDlgID <> 0 Then
						$nLastOD = $nDlgID
						$nLastPr = 0

						GUICtrlSendMsg($nDlgID, $BM_SETSTATE, TRUE, 0)
						PostMessage($hWnd, $WM_COMMAND, BitAnd($nDlgID, 0x0000FFFF), $hFocus)
					EndIf
				EndIf
				
				Return 0
			Else
				If $nCode = 0 Then
					If $nID = $nLastOD And $nID = $nLastBtn Then
						$nLastPr += 1
						
						If $nLastPr = 2 Then
							$nLastPr = 0
							$nLastOD = 0
							Return 0
						EndIf
					EndIf
				Else
					$nLastPr = 0
					$nLastOD = 0
				EndIf
				
				$nLastBtn = $nID
			EndIf

			If $arSpeedItems[0][0] > 0 Then
    			For $i = 1 To $arSpeedItems[0][0]
    				If $nID = $arSpeedItems[$i][0] Then
	    				SetExtVal(GUICtrlRead($nComboNA), $arSpeedItems[0][1], $arSpeedItems[$i][1])
	    				If GUICtrlRead($nListExtProp) = $arSpeedItems[0][1] Then _
	    					GetExtVal(GUICtrlRead($nComboNA), $arSpeedItems[0][1], $arSpeedItems[$i][1])
	    				
	    				Local $k	    					
	    				For $k = 1 To $arSpeedItems[0][0]
							GUICtrlSetState($arSpeedItems[$k][0], $GUI_UNCHECKED)
						Next
							
						GUICtrlSetState($nID, $GUI_CHECKED)	
	    				
    					Return 0
    				EndIf
    			Next
    		EndIf
    		
    		Local $nTMPIP = 0
    		Local $nTmpSM = 0
    			
    		If $hCtrl = $hIP And $nCode = $EN_KILLFOCUS Then
    			If GetAddress($hIP, $nTMPIP) = 4 Then
    				If GetAddress($hSM, $nTmpSM) = 0 Then SetAddress($hSM, GetSubnetMask($nTMPIP))
    			EndIf
    		EndIf
    		
    		If $hCtrl = $hAddr1 And $nCode = $EN_KILLFOCUS And $hAddr2 <> 0 Then
    			If GetAddress($hAddr1, $nTMPIP) = 4 Then
    				If GetAddress($hAddr2, $nTmpSM) = 0 Then SetAddress($hAddr2, GetSubnetMask($nTMPIP))
    			EndIf
    		EndIf
    		
    		Switch $hCtrl
    			Case $hCbEditPing
    				If $nCode = 0 Then
	   					If $bLoopPing = TRUE Then
	   						$bLoopPing = FALSE
	   					Else
	   						PingAddress()
	   					EndIf
	   				ElseIf $nCode = $EN_CHANGE Then
	   					$bLoopPing = FALSE
	   				EndIf
	   				
	   			Case $hComboLastPage
    				If $nCode = $CBN_SELCHANGE Then
    					Local $nIdx = SendMessage($hComboLastPage, $CB_GETCURSEL, 0, 0)
    					If $nIdx > -1 Then
    						If $nIdx = 0 Then
    							$bOpenLastPage = TRUE
    							RegWrite($sGURegKey, "OpenLastPage", "REG_DWORD", 1)
    						Else
    							$bOpenLastPage = FALSE
    							RegWrite($sGURegKey, "OpenLastPage", "REG_DWORD", 0)
    							RegWrite($sGURegKey, "LastPage", "REG_DWORD", $nIdx)
    						EndIf
    					EndIf
    				EndIf
    				
    			Case $hCbEditDrvPath
					If $nCode = 0 Then SendMessage($hDrivesGUI, $WM_NEXTDLGCTL, 0, FALSE)
    		EndSwitch
    		   			
    		Switch $nID
    			Case $nInpPCName, $nInpPCWG
    				If $nCode = $EN_UPDATE Then
    					; Not allowed characters: " / \ [ ] : | < > + = ; , ?
    					Local $sChkChr = """C/C\C[C]C:C|C<C>C+C=C;C,C?"
    					Local $arChkCr = StringSplit($sChkChr, "C")
    					
    					;If $nID = $nInpPCWG Then GUICtrlSetData($nID, StringUpper(GUICtrlRead($nID)))
    					
    					If IsArray($arChkCr) Then
    						Local $bInpFalse = FALSE
    						
    						For $i = 1 To $arChkCr[0]
    							If StringInStr(GUICtrlRead($nID), $arChkCr[$i]) Then
    								$bInpFalse = TRUE
    								GUICtrlSetData($nID, StringReplace(GUICtrlRead($nID), $arChkCr[$i], ""))
    								ExitLoop
    							EndIf
    						Next
    						
    						GUICtrlSetData($nID, StringReplace(GUICtrlRead($nID), " ", ""))
    						If $bInpFalse Then
    							ToolTip($sTTCharsNoAllow & ":" & @LF & _
    													""" / \ [ ] : | < > + = ; , ?")
    							Sleep(2000)
    							ToolTip("")
    						Else
    							ToolTip("")
    						EndIf
    					EndIf
    				ElseIf $nCode = $EN_MAXTEXT Then
    					Local $nMaxText = $MAX_COMPUTERNAME_LENGTH
    					
    					ToolTip($nMaxText & " " & $sTTCharsMax & "!")
    					Sleep(2000)
    					ToolTip("")    				
    				EndIf
    			
    			Case $nBtnPing, $nBtnTrace, $nBtnApply, $nBtnOK, $nBtnCancel
    				If $nCode = $BN_CLICKED And $bLoopPing = TRUE Then
    					$bLoopPing = FALSE
    					If $nID = $nBtnPing Or $nBtnTrace Then Return 0
    				EndIf
   				
   				Case $nComboPing
   					If $nCode = $CBN_DROPDOWN Then EnumPingList()
   					
   				Case $nComboDrv
   					If $nCode = $CBN_DROPDOWN Then EnumDriveLetters()
   				
   				Case $nComboDrvPath
   					If $nCode = $CBN_DROPDOWN Then EnumLastUsedPath()
   					
   				Case $nComboShrUsr
   					If $nCode = $CBN_DROPDOWN Then UpdateShareUsrCombo()
   					
   				Case $nComboLang
   					If $nCode = $CBN_DROPDOWN Then EnumLanguages()

   				Case $nInpKey
   					If $nCode = $EN_SETFOCUS And GUICtrlRead($nInpKey) = $sHiddenInput Then GUICtrlSetData($nInpKey, "")

   				Case $nInpShrPW
   					If $nCode = $EN_SETFOCUS And GUICtrlRead($nInpShrPW) = $sHiddenInput Then GUICtrlSetData($nInpShrPW, "")
   				
   				Case $nInpExtVal
   					If $nCode = $EN_UPDATE Then
   						SetExtVal(GUICtrlRead($nComboNA), GUICtrlRead($nListExtProp), GUICtrlRead($nComboExtVal))
   						
   						If GUICtrlRead($nInpExtVal) = "" Then
   							If Not BitAnd(GUICtrlRead($nRadioExtNotSet), $GUI_CHECKED) Then
   								GUICtrlSetState($nRadioExtSet, $GUI_UNCHECKED)
   								GUICtrlSetState($nRadioExtNotSet, $GUI_CHECKED)   								
   							EndIf
   						Else
   							If Not BitAnd(GUICtrlRead($nRadioExtSet), $GUI_CHECKED) Then
   								GUICtrlSetState($nRadioExtNotSet, $GUI_UNCHECKED)
   								GUICtrlSetState($nRadioExtSet, $GUI_CHECKED)
   							EndIf
   						EndIf
   					EndIf
   					
   				Case $nListProf
   					If $nCode = $LBN_SELCHANGE Then
   						If GUICtrlRead($nListProf) <> "" Then
   							SetODBtnState($nBtnProfApply, $GUI_ENABLE)
   						Else
   							SetODBtnState($nBtnProfApply, $GUI_DISABLE)
   						EndIf
   					EndIf
   				
		   		Case $nTIExit
					Exit
				
				Case $nTIShoAct
					CheckTrayIcon($nTIShoAct)
					Return 0
					
				Case $nTIShoGUI
					ShowWindow($hMainGUI, @SW_RESTORE)
					GUISetState(@SW_SHOW, $hMainGUI)
					SetForegroundWindow($hMainGUI)					
					If $bShowTrayAct = FALSE And $bShowTrayAlways = FALSE Then TrayIconSetState(2)
					If Not $bShowTrayAlways Then $bInTray = FALSE			
					Return 0
					
				Case $nInpNewMAC
					If $nCode = $EN_CHANGE Then
						Local $sText = GUICtrlRead($nID)
						If $sText <> "" Then
							If StringRegExp($sText, $sMACChkPattern) Then
								GUICtrlSetColor($nID, 0x0)
							Else
								GUICtrlSetColor($nID, $nClrChkWrong)
							EndIf
						EndIf
					EndIf
					
				Case $nInpConnKey
					If $nCode = 0 Then
						; ENTER pressed
						PostMessage($hWiFiConnGUI, $WM_COMMAND, $nBtnConnOK, GUICtrlGetHandle($nBtnConnOK))
					EndIf
					
				Case $nInpDrvUsr, $nInpDrvPW
					If $nCode = 0 Then SendMessage($hDrivesGUI, $WM_NEXTDLGCTL, 0, FALSE)
					
				Case $nComboNA
					Switch $nCode
						Case $CBN_DROPDOWN
							$bComboNADrop = TRUE
						Case $CBN_CLOSEUP, $CBN_SELENDOK, $CBN_SELENDCANCEL
							$bComboNADrop = FALSE
					EndSwitch
					
				Case $nComboNATray
					Switch $nCode
						Case $CBN_DROPDOWN
							$bComboNATrayDrop = TRUE
						Case $CBN_CLOSEUP, $CBN_SELENDOK, $CBN_SELENDCANCEL
							$bComboNATrayDrop = FALSE
					EndSwitch
   			EndSwitch
   			
   		Case $WM_TIMER
   			Switch $hWnd
   				Case $hMainGUI
   					If $wParam = $nTimerID Then
   						Local $nState = CheckAdapterActivity()
   						If $nState <> $nLastTrayState Then SetTrayIcon($nState)
   						$nLastTrayState = $nState
					EndIf

				Case $hTrayMsgWnd
					Local $hShellTrayWnd = WinGetHandle("[CLASS:Shell_TrayWnd]")
					Local $hTrayNotifyWnd = FindWindowExW($hShellTrayWnd, 0, "TrayNotifyWnd", "")
					Local $hTrayNotifyIconWnd = WinGetHandle("[CLASS:NotifyIconOverflowWindow]")
					
					KillTimer($hWnd, $nTrayTimerIDInit)
					KillTimer($hWnd, $nTrayTimerID)

					If $hTrayNotifyWnd <> 0 Then
						Local $arPos = MouseGetPos()
						Local $arTrayPos = WinGetPos($hTrayNotifyWnd)
						Local $nNotifyX = -1
						Local $nNotifyY = -1
						Local $nNotifyW = -1
						Local $nNotifyH = -1
						Local $bNotifyIconVisable = IsWindowVisible($hTrayNotifyIconWnd)
						
						If $hTrayNotifyIconWnd <> 0 Then
							Local $arNotifyPos = WinGetPos($hTrayNotifyIconWnd)
							$nNotifyX = $arNotifyPos[0]
							$nNotifyY = $arNotifyPos[1]
							$nNotifyW = $arNotifyPos[2]
							$nNotifyH = $arNotifyPos[3]
						EndIf
						
						If $bTrayWndWiFi Then
							Local $arGUI= WinGetPos($hTrayWiFiGUI)
						Else
							Local $arGUI= WinGetPos($hTrayGUI)
						EndIf
						
						If ($arPos[0] = DllStructGetData($stTrayPnt, 1) And _
							$arPos[1] = DllStructGetData($stTrayPnt, 2) And _
							(($arPos[0] >= $arTrayPos[0] And _
							($arPos[0] <= $arTrayPos[0] + $arTrayPos[2]) And _
							$arPos[1] >= $arTrayPos[1] And _
							($arPos[1] <= $arTrayPos[1] + $arTrayPos[3])) Or _
							($bNotifyIconVisable = TRUE And _
							$arPos[0] >= $nNotifyX And _
							$arPos[0] <= ($nNotifyX + $nNotifyW) And _
							$arPos[1] >= $nNotifyY And _
							$arPos[1] <= ($nNotifyY + $nNotifyH)))) Or _
							(IsArray($arGUI) And _
							$arPos[0] >= $arGUI[0] And _
							$arPos[0] <= $arGUI[0] + $arGUI[2] And _
							$arPos[1] >= $arGUI[1] And _
							$arPos[1] <= $arGUI[1] + $arGUI[3]) Then							
							If $wParam = $nTrayTimerIDInit And _
								$hTrayGUI = 0 And _
								$bTrayWndWiFi = FALSE And _
								$bShowTrayTip = FALSE Then ShowTrayInfo()
							SetTimer($hTrayMsgWnd, $wParam, $nTrayTimerTimeOut, 0)
						Else
							If $wParam = $nTrayTimerIDInit Then
								If $hTrayGUI <> 0 Then DeleteTrayInfo()
							ElseIf $wParam = $nTrayTimerID Then
								If $bTrayWndConnect = FALSE Then
									GUISetState(@SW_HIDE, $hTrayWifiGUI)
									KillTimer($hTrayWiFiGUI, $nTrayTimerIDEnum)
									$bTrayWndWiFi = FALSE
									$bTrayTimerStop = FALSE
								EndIf
							EndIf
						EndIf
					EndIf
				
				Case $hTrayWiFiGUI
					If $bComboNATrayDrop = FALSE Then
						KillTimer($hWnd, $nTrayTimerIDEnum)
						UpdateTrayGUI(GUICtrlRead($nComboNATray))
						SetTimer($hTrayWiFiGUI, $nTrayTimerIDEnum, $nTrayTimerTimeOutEnum, 0)
					EndIf
					
			EndSwitch
			
   		Case $WM_DRAWITEM
   			Local $stDrawItem = DllStructCreate("uint;uint;uint;uint;uint;hwnd;hwnd;int[4];dword", $lParam)
   			Local Const $ODT_LISTBOX = 2
			Local Const $ODT_BUTTON = 4
			Local Const $ODT_STATIC = 5
			Local Const $ODT_LISTVIEW = 102
				
			Local $nType = DllStructGetData($stDrawItem, 1)
			If $nType = $ODT_LISTVIEW Then
				$nID			= DllStructGetData($stDrawItem, 2)
				Local $nIdx		= DllStructGetData($stDrawItem, 3)
				Local $nState	= DllStructGetData($stDrawItem, 5)
				$hCtrl			= DllStructGetData($stDrawItem, 6)
				Local $hDC		= DllStructGetData($stDrawItem, 7)
				Local $nL		= DllStructGetData($stDrawItem, 8, 1)
				Local $nT		= DllStructGetData($stDrawItem, 8, 2)
				Local $nR		= DllStructGetData($stDrawItem, 8, 3)
				Local $nB		= DllStructGetData($stDrawItem, 8, 4)
				
				DrawLVItem($hWnd, $nID, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nIdx, $nState)
				
				Return TRUE
			
			ElseIf $nType = $ODT_STATIC Then
				Local $hDC = DllStructGetData($stDrawItem, 7)
				$nID = DllStructGetData($stDrawItem, 2)
				
				Switch $nID
					Case $nIconInst
						If $bIconLib Then
							DrawStatic($hDC, $sIconLib, -4, GetBGRColor($nClrGUIBkSub))
						Else
							DrawStatic($hDC, @AutoItExe, 0, GetBGRColor($nClrGUIBkSub))
						EndIf
					
					Case $nIconPrev
						If $bIconLib Then
							DrawStatic($hDC, $sIconLib, -18, GetBGRColor($nClrGUIBk))
						Else
							DrawStatic($hDC, @AutoItExe, -178, GetBGRColor($nClrGUIBk))
						EndIf
						
					Case $nIconTray
						If $bPrevPENMStarted Then
							If $bShowTrayAct Or $bMinToTray Or $bShowTrayAlways Then
								If $bShowTrayAct Then
									If $bIconLib Then
										DrawStatic($hDC, $sIconLib, -18)
									Else
										DrawStatic($hDC, @AutoItExe, -178)
									EndIf
								Else
									If $bIconLib Then
										DrawStatic($hDC, $sIconLib, -4)
									Else
										DrawStatic($hDC, @AutoItExe, 0)
									EndIf
								EndIf
							EndIf 
						Else
							DrawStatic($hDC, "")
						EndIf
					
					Case $nLblPrevTime
						DrawStatic($hDC, @Hour & ":" & @Min, 0, -1, FALSE, 65, 21)
				EndSwitch
				
			ElseIf $nType = $ODT_BUTTON Then
				$nID			= DllStructGetData($stDrawItem, 2)
				Local $nState	= DllStructGetData($stDrawItem, 5)
				$hCtrl			= DllStructGetData($stDrawItem, 6)
				Local $hDC		= DllStructGetData($stDrawItem, 7)
				Local $nL		= DllStructGetData($stDrawItem, 8, 1)
				Local $nT		= DllStructGetData($stDrawItem, 8, 2)
				Local $nR		= DllStructGetData($stDrawItem, 8, 3)
				Local $nB		= DllStructGetData($stDrawItem, 8, 4)
				
				Local $nIdx		= GetODBtnIdx($nID)
				If $nIdx = 0 Then Return $GUI_RUNDEFMSG
				
				#cs
				#define ODS_SELECTED    0x0001
				#define ODS_GRAYED      0x0002
				#define ODS_DISABLED    0x0004
				#define ODS_CHECKED     0x0008
				#define ODS_FOCUS       0x0010
				#ce
				
				Local $sText	= $ODBUTTONS[$nIdx][1]
				Local $bIcon	= $ODBUTTONS[$nIdx][2]
				Local $nTxtClr	= $ODBUTTONS[$nIdx][3]
				Local $nBkClr	= $ODBUTTONS[$nIdx][4]
				Local $nIconIdx	= $ODBUTTONS[$nIdx][5]
				Local $nMode	= $ODBUTTONS[$nIdx][7]
				Local $nGradClr	= $ODBUTTONS[$nIdx][8]
				
				If BitAnd($nState, 0x0010) Then $nCurFocus = $nID
				
				If $nMode = 1 Then
					If $bPaint Then
						If $nLastItemGUI = $nID And _
							($nCurFocus < $nTIConf Or _
							$nCurFocus > $nTIAbout Or _
							$nID = $nCurFocus Or _
							$nState = 0) Then
							$nState = 0x0001
						EndIf
						
						DrawTabItem($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nIconIdx, 1)
						
						If BitAnd($nState, 0x0001) Then
							If $nLastItemGUI <> $nID Then
								SetODBtnState($nLastItemGUI, $GUI_HIDE, FALSE)
								SetODBtnState($nLastItemGUI, $GUI_SHOW)
								PostMessage($hWnd, $WM_COMMAND, 0, $hCtrl)
							EndIf
							$nLastItemGUI = $nID
						EndIf
					EndIf
				ElseIf $nMode = 2 Then
					If $bPaint Then
						If $nLastItemConf = $nID And _
							($nCurFocus < $nTIIP Or _
							$nCurFocus > $nTIFirewall Or _
							$nID = $nCurFocus Or _
							$nState = 0) Then
							$nState = 0x0001
						EndIf
						
						DrawTabItem($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nIconIdx, 2)
						
						If BitAnd($nState, 0x0001) Then
							If $nLastItemConf <> $nID Then
								SetODBtnState($nLastItemConf, $GUI_HIDE, FALSE)
								SetODBtnState($nLastItemConf, $GUI_SHOW)
								PostMessage($hWnd, $WM_COMMAND, 0, $hCtrl)
							EndIf
							
							$nLastItemConf = $nID
						EndIf						
					EndIf
				ElseIf $nMode = 3 Then
					If $bPaint Then
						If $nLastItemWiFi = $nID And _
							($nCurFocus < $nTIWiFiAV Or _
							$nCurFocus > $nTIWiFiSrv Or _
							$nID = $nCurFocus Or _
							$nState = 0) Then
							$nState = 0x0001
						EndIf
						
						DrawTabItem($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nIconIdx, 3)
						
						If BitAnd($nState, 0x0001) Then
							If $nLastItemWiFi <> $nID Then
								SetODBtnState($nLastItemWiFi, $GUI_HIDE, FALSE)
								SetODBtnState($nLastItemWiFi, $GUI_SHOW)
								PostMessage($hWnd, $WM_COMMAND, 0, $hCtrl)
							EndIf
							$nLastItemWiFi = $nID
						EndIf
					EndIf
				ElseIf $nMode = 5 Then
					If $bPaint Then
						If $nLastItemEditor = $nID And _
							($nCurFocus < $nTIGlobal Or _
							$nCurFocus > $nTIPreview Or _
							$nID = $nCurFocus Or _
							$nState = 0) Then
							$nState = 0x0001
						EndIf
						
						DrawTabItem($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nIconIdx, 5)
						
						If BitAnd($nState, 0x0001) Then
							If $nLastItemEditor <> $nID Then
								SetODBtnState($nLastItemEditor, $GUI_HIDE, FALSE)
								SetODBtnState($nLastItemEditor, $GUI_SHOW)
								PostMessage($hWnd, $WM_COMMAND, 0, $hCtrl)
							EndIf
							$nLastItemEditor = $nID
						EndIf
					EndIf
				ElseIf $nMode = 6 Then
					If $bPaint Then
						If $nLastItemPrev = $nID And _
							($nCurFocus < $nTIPrevConf And _
							$nCurFocus > $nTIPrevAbout Or _
							$nID = $nCurFocus Or _
							$nState = 0) Then
							$nState = 0x0001
						EndIf
						
						If BitAnd($nState, 0x0001) Then
							If $nLastItemPrev <> $nID Then
								SetODBtnState($nLastItemPrev, $GUI_HIDE, FALSE)
								SetODBtnState($nLastItemPrev, $GUI_SHOW)
							EndIf
							
							$nLastItemPrev = $nID
						EndIf
						
						DrawTabItem($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nIconIdx, 1)
						
					EndIf
				ElseIf $bPaint Then
					Switch $nID
						Case $nBtnDhcpInfo, $nBtnDhcpRelease, $nBtnDhcpRenew, $nBtnIPAltShow, $nBtnIPAltHide
							DrawButton($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nTxtClr, $nBkClr, $nGradClr, $bIcon, $nIconIdx, 2, $nID)
						Case Else	
							Switch $nMode
								Case 9
									DrawButton($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nTxtClr, $nBkClr, $nGradClr, $bIcon, $nIconIdx, 9, $nID)
								Case 8
									DrawButton($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nTxtClr, $nBkClr, $nGradClr, $bIcon, $nIconIdx, 2, $nID)
								Case 7
									DrawButton($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nTxtClr, $nBkClr, $nGradClr, $bIcon, $nIconIdx, 1, $nID)
								Case 4
									DrawButton($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nTxtClr, $nBkClr, $nGradClr, $bIcon, $nIconIdx, 4, $nID)
								Case Else
									DrawButton($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nTxtClr, $nBkClr, $nGradClr, $bIcon, $nIconIdx, 3, $nID)
							EndSwitch
					EndSwitch
				EndIf

				Return 1
			EndIf
		
			
		Case $WM_INITMENUPOPUP
			If $wParam = GUICtrlGetHandle($nMenuSpeed) Then
				If $arSpeedItems[0][0] > 0 Then
					Local $k = GetExtIdx($arSpeedItems[0][1])
					If $k = 0 Then Return $GUI_RUNDEFMSG
					
					Local $sSub = $arExtVal[$k][0]
					Local $sVal = ""
					
					For $i = 1 To $arExtVal[0][0]						
						If $arExtVal[$i][0] = $sSub Then
							$sVal = $arExtVal[$i][2]
							ExitLoop
						EndIf					
					Next
					
					If $sVal <> "" Then
						For $i = 1 To $arSpeedItems[0][0]
							GUICtrlSetState($arSpeedItems[$i][0], $GUI_UNCHECKED)
							If $sVal = $arSpeedItems[$i][2] Then GUICtrlSetState($arSpeedItems[$i][0], $GUI_CHECKED)
						Next
						
						Return 0
					EndIf
				EndIf			
			EndIf
			
		Case $WM_CTLCOLORSTATIC
			Local $hDC = $wParam
			$hCtrl = $lParam
			
			Switch $hCtrl
				Case $hLblMac, $hEditProfDesc, $hEditDrvDesc, $hInpPCName, $hInpPCWG, $hInpPCDNS, _
					$hAddrPing, $hLimPing, $hInpProfFile, $hInpTime, $hInpCurMAC, $hInpTrace, _
					$hCbEditShrUsr, $hCbEditCMDIPChg, $hCbEditPing, $hCbEditDrvPath
					SetTextColor($hDC, $nClrLblNormal)
					SetBkMode($hDC, 1)
					Return $hBrushGUI
				Case $hComboShrUsr, $hInpShrPW
					SetBkMode($hDC, 1)
					Return $hBrushGUI
				Case $hEditShrAdmin
					SetTextColor($hDC, GetBGRColor($nClrStateRed))
					SetBkMode($hDC, 1)
					Return $hBrushGUI
				Case $hInpProfile, $hInpSSID, $hInpKey, $hInpConnSSID
					SetTextColor($hDC, $nClrLblWiFi)
					SetBkMode($hDC, 1)
					Return $hBrushWiFiGUI
				Case Else
					For $i = 1 To $arStatic[0]
						If $arStatic[$i] = $hCtrl Then
							SetBkMode($hDC, 1)
							Return $hBrushTrayGUI
						EndIf
					Next
			EndSwitch
	EndSwitch
EndFunc


;**********************************************************************
; Updates a client area
;**********************************************************************
Func InvalidateClientRect($hWnd, $nID)
	Local $stRect = DllStructCreate("long;long;long;long")
		
	Local $hCtrl = GetDlgItem($hWnd, $nID)
	GetWindowRect($hCtrl, DllStructGetPtr($stRect))
	
	Local $stPoint = DllStructCreate("long;long")
	DllStructSetData($stPoint, 1, DllStructGetData($stRect, 1))
	DllStructSetData($stPoint, 2, DllStructGetData($stRect, 2))
	ScreenToClient($hWnd, DllStructGetPtr($stPoint))
	DllStructSetData($stRect, 1, DllStructGetData($stPoint, 1))
	DllStructSetData($stRect, 2, DllStructGetData($stPoint, 2))
	
	DllStructSetData($stPoint, 1, DllStructGetData($stRect, 3))
	DllStructSetData($stPoint, 2, DllStructGetData($stRect, 4))
	ScreenToClient($hWnd, DllStructGetPtr($stPoint))
	DllStructSetData($stRect, 3, DllStructGetData($stPoint, 1))
	DllStructSetData($stRect, 4, DllStructGetData($stPoint, 2))
	
	InvalidateRect($hWnd, DllStructGetPtr($stRect), TRUE)	
EndFunc


;**********************************************************************
; Draw static icon
;**********************************************************************
Func DrawStatic($hDC, $sIconFile, $nIconID = 0, $nBkClr = -1, $bIcon = TRUE, $nW = 0, $nH = 0)
	Local $hBrush
	If $nBkClr = -1 Then
		$hBrush = GetSysColorBrush($COLOR_BTNFACE)
	Else
		$hBrush = CreateSolidBrush($nBkClr)
	EndIf
	
	Local $hOldBrush	= SelectObject($hDC, $hBrush)
	Local $stIcon		= DllStructCreate("hwnd")
	Local $stRect		= DllStructCreate("int;int;int;int")
	DllStructSetData($stRect, 1, 0)
	DllStructSetData($stRect, 2, 0)
			
	If $sIconFile <> "" Then
		If $bIcon Then
			If ExtractIconExW($sIconFile, $nIconID, 0, DllStructGetPtr($stIcon), 1) > 0 Then
				DrawIconEx($hDC, 0, 0, DllStructGetData($stIcon, 1), $nIconSizeSmall, $nIconSizeSmall, 1, $hBrush, 0x0003) ; DI_NORMAL		
				DestroyIcon(DllStructGetData($stIcon, 1))
			EndIf
		Else
			DllStructSetData($stRect, 3, GetScaled($nW))
			DllStructSetData($stRect, 4, GetScaled($nH))
			FillRect($hDC, DllStructGetPtr($stRect), $hBrush)
			DrawEdge($hDC, DllStructGetPtr($stRect), BitOr(0x0002, 0x0008), 0x400F) ; BDR_SUNKEN, BF_FLAT|BF_RECT
			
			Local $nOldBkClr = SetBkColor($hDC, GetSysColor($COLOR_BTNFACE))
			DllStructSetData($stRect, 3, GetScaled($nW - 8))
			
			Local $stText = DllStructCreate("wchar[" & StringLen($sIconFile) + 1 & "]")
			DllStructSetData($stText, 1, $sIconFile)
			
			Local $uFlags = BitOr($DT_NOCLIP, $DT_RIGHT, $DT_VCENTER, $DT_SINGLELINE)
			DrawTextW($hDC, DllStructGetPtr($stText), StringLen($sIconFile), DllStructGetPtr($stRect), $uFlags)
			
			SetBkColor($hDC, $nOldBkClr)
		EndIf
	Else
		DllStructSetData($stRect, 3, $nIconSizeSmall)
		DllStructSetData($stRect, 4, $nIconSizeSmall)	
		FillRect($hDC, DllStructGetPtr($stRect), $hBrush)
	EndIf
	
	SelectObject($hDC, $hOldBrush)
	DeleteObject($hBrush)	
EndFunc


;**********************************************************************
; Draw button
;**********************************************************************
Func DrawButton($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nTxtClr, $nBkClr, $nGradClr, $bIcon, $nIconIdx, $nDraw = 3, $nID = -1)
	Local $bMoveItem			= TRUE
	
	Local $stRect = DllStructCreate("int;int;int;int")
	DllStructSetData($stRect, 1, $nL)
	DllStructSetData($stRect, 2, $nT)
	DllStructSetData($stRect, 3, $nR)
	DllStructSetData($stRect, 4, $nB)
    
    ; Color selection
    If $nDraw = 3 Then
		$nTxtClr	= $nClrBtnNormalTxt
		$nBkClr		= $nClrBtnNormalBk
		$nGradClr	= $nClrBtnNormalGrad
	EndIf
	
	If $nDraw = 9 Then
		$nTxtClr	= $nClrTrayBtnTxt
		$nBkClr		= $nClrTrayBtnBk
		$nGradClr	= $nClrTrayBtnGrad
	EndIf
	
	Local $nOldClr
	If BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED) Then
		Local $nClrTxtDis = $nClrBtnTxtDisabled
		If $nDraw = 9 Then $nClrTxtDis = $nClrTrayBtnTxt
		$nOldClr = SetTextColor($hDC, $nClrTxtDis)
	Else
		If $nTxtClr = -1 Then
			$nOldClr = SetTextColor($hDC, GetSysColor($COLOR_BTNTEXT))
		Else
			$nOldClr = SetTextColor($hDC, $nTxtClr)
		EndIf
	EndIf
	
	Local $hBrush, $nClrBk, $nClrGrad
	
	If BitAnd($nState, $ODS_DISABLED) And $nBkClr <> -1 Then $nBkClr = ReduceClr($nBkClr, 0.95)
	If BitAnd($nState, $ODS_DISABLED) And $nGradClr <> -1 And $nBkClr <> -1 Then $nGradClr = ReduceClr($nGradClr, 0.95)
		
	If BitAnd($nState, $ODS_SELECTED) And $nGradClr <> -1 Then ; And $nDraw <> 4 Then
		Local $nTemp = $nBkClr
		$nBkClr = $nGradClr
		$nGradClr = $nTemp
	EndIf
	
	If $nBkClr <> $nGradClr And $nGradClr <> -1 Then $bMoveItem = FALSE
	
	If $nBkClr = -1 Then
		$hBrush		= GetSysColorBrush($COLOR_BTNFACE)
		$nClrBk		= GetSysColor($COLOR_BTNFACE)
		$nClrGrad	= $nBkClr
	Else
		$hBrush		= CreateSolidBrush($nBkClr)
		$nClrBk 	= $nBkClr
		If $nGradClr = -1 Then
			$nClrGrad = $nClrBk
		Else
			$nClrGrad	= $nGradClr
		EndIf
	EndIf
	
	; Draw back frame
	Local $nOldBkClr = SetBkColor($hDC, $nClrBk)
	Local $hOldBrush = SelectObject($hDC, $hBrush)
		
	If $nClrBk = -1 Or $nClrBk = $nClrGrad Or $nClrGrad = -1 Or ($nDraw = 4 And $nClrGrad = -1) Then
		FillRect($hDC, DllStructGetPtr($stRect), $hBrush)
	ElseIf $nClrBk <> $nClrGrad Then
		If ($sText = "v" Or $sText = "^") And $hPCG <> 0 Then			
			FillGradientRect($hDC, $stRect, $nClrBk, $nClrGrad, FALSE)
		Else
			FillGradientRect($hDC, $stRect, $nClrBk, $nClrGrad, TRUE)
		EndIf
	EndIf
	
	SelectObject($hDC, $hOldBrush)
	DeleteObject($hBrush)
	
	; Draw back rect
	Local $nClrFrame = $nClrBtnFrame
	If $nDraw = 9 Then
		$nClrFrame = $nClrTrayBtnFrame
	ElseIf $nDraw = 4 Then
		If BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED) Then
			$nClrFrame = 0x4D4D4D
		Else
			$nClrFrame = 0x0
		EndIf
	ElseIf BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED) Then 
		$nClrFrame = $nClrBtnFrameDisabled
	EndIf
	
	If $nID = $nTISize Then
		$hBrush = CreateSolidBrush(GetBGRColor($nClrGUIBkFrame))
	Else
		$hBrush = CreateSolidBrush($nClrFrame)
	EndIf
	
	If $nID = $nTISize Or $nClrFrame <> -1 Then FrameRect($hDC, DllStructGetPtr($stRect), $hBrush)
	
	; Draw white active rect
	If Not (BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED)) And _
			$nClrBtnBkActive <> -1 And $nDraw <> 4 Or ($nDraw = 4 And $nClrGrad = -1) Then
		DeleteObject($hBrush)
		If $nDraw = 9 Then
			$hBrush = CreateSolidBrush($nClrTrayBtnFrame)
		ElseIf $nDraw = 4 Then
			$hBrush = CreateSolidBrush(0xFFFFFF)
		Else
			$hBrush = CreateSolidBrush($nClrBtnBkActive)
		EndIf
		
		If BitAnd($nState, $ODS_FOCUS) Then
			InflateRect(DllStructGetPtr($stRect), -2, -2)
		Else	
			InflateRect(DllStructGetPtr($stRect), -1, -1)
		EndIf
		
		$hOldBrush = SelectObject($hDC, $hBrush)
		
		FrameRect($hDC, DllStructGetPtr($stRect), $hBrush)
		
		If BitAnd($nState, $ODS_FOCUS) Then    
			InflateRect(DllStructGetPtr($stRect), +2, +2)
		Else
			InflateRect(DllStructGetPtr($stRect), +1, +1)
		EndIf
	EndIf
	
	SelectObjecT($hDC, $hOldBrush)
	DeleteObject($hBrush)
	
	; Draw focus rect
	If BitAnd($nState, $ODS_FOCUS) Then
		If $nDraw = 4 Then
			$hBrush = CreateSolidBrush(0x90FF)
		ElseIf $nDraw = 9 Then
			$hBrush = CreateSolidBrush($nClrTrayBtnFocus)
		Else
			$hBrush = CreateSolidBrush($nClrBtnFocus)
		EndIf
		$hOldBrush = SelectObjecT($hDC, $hBrush)
		InflateRect(DllStructGetPtr($stRect), -1, -1)
		FrameRect($hDC, DllStructGetPtr($stRect), $hBrush)
		InflateRect(DllStructGetPtr($stRect), +1, +1)
		SelectObjecT($hDC, $hOldBrush)
		DeleteObject($hBrush)
	EndIf
	
	; Draw icon
	Local $nMode = SetBkMode($hDC, 1)
	Local $nX, $nY
	
	If $sText = "..." Then
		If BitAnd($nState, $ODS_DISABLED) And $nDraw <> 4 Then
			$bIcon = TRUE
			$sText = ""
		Else
			$nIconIdx = -1
		EndIf
	EndIf
	
	If $bIcon Or $nIconIdx > -1 Then
		If $bIcon Then
			$nX = Round((DllStructGetData($stRect, 3) - $nIconSizeSmall) / 2); + 1
		Else
			$nX = Round((GetScaled(26) - $nIconSizeSmall) / 2)
		EndIf
		
		$nY = (DllStructGetData($stRect, 4) - $nIconSizeSmall) / 2
		
		If BitAnd($nState, $ODS_SELECTED) And $bMoveItem Then
			$nX += 1
			$nY += 1
		EndIf
		
		If BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED) Then
			ImageList_Draw($hILBtn, $nIconIdx, $hDC, $nX, $nY, 5)
		Else
			ImageList_Draw($hILBtn, $nIconIdx,	$hDC, $nX, $nY, 1)
		EndIf
	EndIf
	
	; Draw text
	If $sText <> "" And Not $bIcon Then
		If $nIconIdx > -1 Then DllStructSetData($stRect, 1, DllStructGetData($stRect, 1) + GetScaled(26) - GetScaled(5))
	
		Local $stText = DllStructCreate("wchar[" & StringLen($sText) + 1 & "]")
		DllStructSetData($stText, 1, $sText)
	
		Local $uFlags = BitOr($DT_NOCLIP, $DT_CENTER, $DT_VCENTER, $DT_SINGLELINE, $DT_END_ELLIPSIS, $DT_MODIFYSTRING)
		
		If BitAnd($nState, $ODS_SELECTED) And $bMoveItem Then
			DllStructSetData($stRect, 1, DllStructGetData($stRect, 1) + 2)
			DllStructSetData($stRect, 2, DllStructGetData($stRect, 2) + 2)
		EndIf
		
		If $hWnd = $hPSG And $hPSG <> 0 And $bPrevStarted Then
			Local $hOldFont = SelectObject($hDC, $hPrevFont)
		Else
			Local $hOldFont = SelectObject($hDC, $hGlobalFont)
		EndIf
		
		DrawTextW($hDC, DllStructGetPtr($stText), StringLen($sText), DllStructGetPtr($stRect), $uFlags)
		SelectObject($hDC, $hOldFont)
	EndIf
	
	; Cleanup
	SetTextColor($hDC, $nOldClr)
	SetBkColor($hDC, $nOldBkClr)
    SetBkMode($hDC, $nMode)
    
    Return 1
EndFunc


;**********************************************************************
; Draw tab item
;**********************************************************************
Func DrawTabItem($hWnd, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nState, $sText, $nIconIdx, $nDraw)	
	Local $stRect = DllStructCreate("int;int;int;int")
    
	DllStructSetData($stRect, 1, $nL)
    DllStructSetData($stRect, 2, $nT)
    DllStructSetData($stRect, 3, $nR)
    DllStructSetData($stRect, 4, $nB)
    
   ;If BitAnd($nState, $ODS_FOCUS) Or BitAnd($nState, $ODS_SELECTED) Then
	If BitAnd($nState, $ODS_SELECTED) Then
    	If $nDraw = 2 Or $nDraw = 3 Then
    		;DllStructSetData($stRect, 2, DllStructGetData($stRect, 2) + 1)
    		DllStructSetData($stRect, 4, DllStructGetData($stRect, 4) + 1)
    	Else
    		DllStructSetData($stRect, 3, DllStructGetData($stRect, 3) + 1)
    	EndIf
    EndIf
    
    ; Just for testing
    ;If $nDraw = 1 And BitAnd($nState, $ODS_SELECTED) Then SelectObject($hDC, $hGlobalBoldFont)
    
     ; Color selection
    Local $nOldClr
    Local $nTIClrTxt, $nTIClrBk, $nTIClrGrad
	
	Switch $nDraw
		Case 1
    		If BitAnd($nState, $ODS_SELECTED) Then
    			$nTIClrTxt	= $nClrTISelTxt
				$nTIClrBk	= $nClrTISelBk
				$nTIClrGrad	= $nClrTISelGrad
			Else
				$nTIClrTxt	= $nClrTITxt
				$nTIClrBk	= $nClrTIBk
				$nTIClrGrad	= $nClrTIGrad
			EndIf		
		
		Case 2
			If BitAnd($nState, $ODS_SELECTED) Then
				$nTIClrTxt	= $nClrTIConfSelTxt
				$nTIClrBk	= $nClrTIConfSelBk
				$nTIClrGrad	= $nClrTIConfSelGrad
			Else
				$nTIClrTxt	= $nClrTIConfTxt
				$nTIClrBk	= $nClrTIConfBk
				$nTIClrGrad	= $nClrTIConfGrad
			EndIf
		
		Case 5
			If BitAnd($nState, $ODS_SELECTED) Then
				$nTIClrTxt	= 0x0 ;$nClrTISelTxt
				$nTIClrBk	= GetBGRColor($nClrBkSub) ;$nClrTISelBk
				$nTIClrGrad	= GetBGRColor($nClrBkSub) ;$nClrTISelGrad
			Else
				$nTIClrTxt	= 0x0 ;$nClrTITxt
				$nTIClrBk	= 0xDAD8D6 ;$nClrTIBk
				$nTIClrGrad	= 0x8D8A89 ;$nClrTIGrad
			EndIf		
		Case Else
			If BitAnd($nState, $ODS_SELECTED) Then
				$nTIClrTxt	= $nClrTIWiFiSelTxt
				$nTIClrBk	= $nClrTIWiFiSelBk
				$nTIClrGrad	= $nClrTIWiFiSelGrad
			Else
				$nTIClrTxt	= $nClrTIWiFiTxt
				$nTIClrBk	= $nClrTIWiFiBk
				$nTIClrGrad	= $nClrTIWiFiGrad
			EndIf
	EndSwitch
		
    If BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED) Then
    	$nOldClr = SetTextColor($hDC, $nClrBtnTxtDisabled)
    Else
    	If $nTIClrTxt = -1 Then
			$nOldClr = SetTextColor($hDC, GetSysColor($COLOR_BTNTEXT))
		Else
			$nOldClr = SetTextColor($hDC, $nTIClrTxt)
		EndIf
	EndIf	
	
	Local $hBrush
	
	If BitAnd($nState, $ODS_SELECTED) Then
		If $nTIClrBk = -1 Then
			$hBrush		= GetSysColorBrush($COLOR_BTNFACE)
			$nTIClrBk	= GetSysColor($COLOR_BTNFACE)
			$nTIClrGrad	= $nTIClrBk
		Else
			$hBrush		= CreateSolidBrush($nTIClrBk)
		EndIf
	ElseIf $nTIClrBk = -1 Then
		$hBrush			= GetSysColorBrush($COLOR_BTNFACE)
		$nTIClrBk		= GetSysColor($COLOR_BTNFACE)
	Else
		$hBrush = CreateSolidBrush($nTIClrBk)
	EndIf
	
	; Draw back frame
	Local $nOldBkClr = SetBkColor($hDC, $nTIClrBk)
	Local $hOldBrush = SelectObject($hDC, $hBrush)

	;InflateRect(DllStructGetPtr($stRect), -1, -1)
	If $nTIClrBk = -1 Or $nTIClrBk = $nTIClrGrad Or $nTIClrGrad = -1 Then
		FillRect($hDC, DllStructGetPtr($stRect), $hBrush)
	ElseIf $nTIClrBk <> $nTIClrGrad Then
		FillGradientRect($hDC, $stRect, $nTIClrBk, $nTIClrGrad, TRUE)
	EndIf
	;InflateRect(DllStructGetPtr($stRect), +1, +1)
	DeleteObject($hBrush)	

	; Draw back rect
	If BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED) Then
		$hBrush = CreateSolidBrush($nClrBtnTxtDisabled)
	Else
		If $nDraw = 1 Then
			$hBrush = CreateSolidBrush(GetBGRColor($nClrGUIBkFrame))
		ElseIf $nDraw = 2 Then
			$hBrush = CreateSolidBrush(GetBGRColor($nClrGUIBkConfFrame))
		ElseIf $nDraw = 5 Then
			$hBrush = CreateSolidBrush(0x0)
		Else
			$hBrush = CreateSolidBrush(GetBGRColor($nClrGUIBkWiFiFrame))
		EndIf
	EndIf
	FrameRect($hDC, DllStructGetPtr($stRect), $hBrush)

	; Draw focus rect
	If BitAnd($nState, $ODS_FOCUS) And Not BitAnd($nState, $ODS_SELECTED) Then    
		InflateRect(DllStructGetPtr($stRect), -1, -1)
		DeleteObject($hBrush)	
		If $nDraw = 5 Then
			$hBrush = CreateSolidBrush(0x90FF)
		Else
			$hBrush = CreateSolidBrush($nClrTIFocus)
		EndIf
		FrameRect($hDC, DllStructGetPtr($stRect), $hBrush)
		InflateRect(DllStructGetPtr($stRect), +1, +1)
	EndIf
	
	If ($nDraw = 2 Or $nDraw = 3) And BitAnd($nState, $ODS_SELECTED) Then DllStructSetData($stRect, 4, DllStructGetData($stRect, 4) - 1)
	
	; Draw icon
	Local $nMode = SetBkMode($hDC, 1)
	Local $nX, $nY
	
	If $nIconIdx > -1 Then
		$nX = Round((GetScaled(26) - $nIconSizeSmall) / 2)
		$nY = Round((DllStructGetData($stRect, 4) - $nIconSizeSmall) / 2)
		
		If BitAnd($nState, $ODS_GRAYED) Or BitAnd($nState, $ODS_DISABLED) Then
			ImageList_Draw($hILBtn2, $nIconIdx, $hDC, $nX, $nY, 5)
		Else
			ImageList_Draw($hILBtn2, $nIconIdx,	$hDC, $nX, $nY, 1)
		EndIf
	EndIf
	
	; Draw text
	If $nIconIdx > -1 Then
		DllStructSetData($stRect, 1, DllStructGetData($stRect, 1) + GetScaled(26))
	Else
		DllStructSetData($stRect, 1, DllStructGetData($stRect, 1) + GetScaled(6))
	EndIf	
	
	Local $stText = DllStructCreate("wchar[" & StringLen($sText) + 1 & "]")
	DllStructSetData($stText, 1, $sText)

	Local $uFlags = BitOr($DT_NOCLIP, $DT_VCENTER, $DT_SINGLELINE)
	
	If $hWnd = $hPSG And $hPSG <> 0 And $bPrevStarted Then
		Local $hOldFont = SelectObject($hDC, $hPrevFont)
	Else
		Local $hOldFont = SelectObject($hDC, $hGlobalFont)
	EndIf
	DrawTextW($hDC, DllStructGetPtr($stText), StringLen($sText), DllStructGetPtr($stRect), $uFlags)
	
	; Cleanup
	SelectObject($hDC, $hOldFont)
	SelectObject($hDC, $hOldBrush)
	DeleteObject($hBrush)
	SetTextColor($hDC, $nOldClr)
	SetBkColor($hDC, $nOldBkClr)
    SetBkMode($hDC, $nMode)
    
    Return 1
EndFunc


;********************************************************************
; Draw ownerdrawn listview item
;********************************************************************
Func DrawLVItem($hWnd, $nCtrl, $hCtrl, $hDC, $nL, $nT, $nR, $nB, $nIdx, $nState)
	Local $nSignal		= 0
	Local $nSecure		= 0
	Local $nType		= 0
	Local $sText		= GetLVIText($nCtrl, $nIdx, 1)
	Local $nBitType		= Number(GetLVIText($nCtrl, $nIdx, 0)); (1=0%, 2=20%, 4=40%, 8=60%, 16=80%, 32=100%, 64=secured, 128=adhoc, 256=connected, 512=connectable, 1024/2048=authenticating, 4096=preferred)
	Local $hBrush		= 0
    Local $hOldBrush	= 0
	Local $nMode		= SetBkMode($hDC, 1)
	Local $stRect		= DllStructCreate("int;int;int;int")
    DllStructSetData($stRect, 1, $nL)
    DllStructSetData($stRect, 2, $nT)
    DllStructSetData($stRect, 3, $nR)
    DllStructSetData($stRect, 4, $nB)
	
	; Draw back rect
	If BitAnd($nState, $ODS_SELECTED) Then
		$hBrush = CreateSolidBrush(GetBGRColor($nClrTraySelBk))
		$hOldBrush = SelectObject($hDC, $hBrush)
		FillRect($hDC, DllStructGetPtr($stRect), $hBrush)
	Else
		$hBrush = CreateSolidBrush(GetBGRColor($nClrTrayBk))
		$hOldBrush = SelectObject($hDC, $hBrush)
		FillRect($hDC, DllStructGetPtr($stRect), $hBrush)
	EndIf
		
	SelectObject($hDC, $hOldBrush)
	DeleteObject($hBrush)
	
	; Draw focus rect
	If BitAnd($nState, $ODS_FOCUS) Then
		$hBrush = CreateSolidBrush(GetBGRColor($nClrTraySelBk))
		$hOldBrush = SelectObjecT($hDC, $hBrush)
		FrameRect($hDC, DllStructGetPtr($stRect), $hBrush)
		SelectObjecT($hDC, $hOldBrush)
		DeleteObject($hBrush)
	EndIf
	
	$nL -= GetScaled(2)
	
	If BitAnd($nBitType, 1) Then ImageList_Draw($hILLVWLATray, 2, $hDC, $nL, $nT, 1)
	If BitAnd($nBitType, 2) Then ImageList_Draw($hILLVWLATray, 3, $hDC, $nL, $nT, 1)
	If BitAnd($nBitType, 4) Then ImageList_Draw($hILLVWLATray, 4, $hDC, $nL, $nT, 1)
	If BitAnd($nBitType, 8) Then ImageList_Draw($hILLVWLATray, 5, $hDC, $nL, $nT, 1)
	If BitAnd($nBitType, 16) Then ImageList_Draw($hILLVWLATray, 6, $hDC, $nL, $nT, 1)
	If BitAnd($nBitType, 32) Then ImageList_Draw($hILLVWLATray, 7, $hDC, $nL, $nT, 1)
	If BitAnd($nBitType, 64) Then ImageList_Draw($hILLVWLATray, 8, $hDC, $nL + GetScaled(16), $nT, 1)
	If BitAnd($nBitType, 128) Then ImageList_Draw($hILLVWLATray, 9, $hDC, $nL + GetScaled(16), $nT, 1)
		
	If BitAnd($nBitType, 512) Then
		If BitAnd($nBitType, 4096) Then ImageList_Draw($hILLVWLATray, 10, $hDC, $nL, $nT, 1)
	Else
		ImageList_Draw($hILLVWLATray, 11, $hDC, $nL, $nT, 1)
	EndIf

	$nL += GetScaled(2)
	
	Local $stText
	Local $nBound
	Local $uFlags = 0
	Local $nStripWidth = 0
	Local $sConnText = ""
	
	If BitAnd($nBitType, 256) Then $sConnText = $sWiFiConnected & " "
	If BitAnd($nBitType, 1024) Then $sConnText = $sWiFiConnecting & " "
		
	Local $hOldFont = 0
	
	If BitAnd($nState, $ODS_SELECTED) Then
		SetTextColor($hDC, $nClrTraySelTxt)
	Else
		If BitAnd($nBitType, 256) Then
			SetTextColor($hDC, $nClrTrayConnect)
		Else
			SetTextColor($hDC, $nClrTrayTxt)
		EndIf
	EndIf
	
	$stText = DllStructCreate("wchar[" & (StringLen($sText) + 1) & "]")
	DllStructSetData($stText, 1, $sText)
	DllStructSetData($stRect, 1, $nL + GetScaled(40))
	
	If BitAnd($nBitType, 256) Or BitAnd($nBitType, 1024) Then
		$uFlags = BitOr($DT_NOCLIP, $DT_SINGLELINE, $DT_VCENTER, $DT_CALCRECT)
		Local $stRectCalc = DllStructCreate("int;int;int;int")
		DllStructSetData($stRectCalc, 1, 0)
		DllStructSetData($stRectCalc, 2, 0)
		DllStructSetData($stRectCalc, 3, 0)
		DllStructSetData($stRectCalc, 4, 0)			
		
		$hOldFont = SelectObject($hDC, $hGlobalBoldFont)
		
		Local $stCalcText = DllStructCreate("wchar[" & (StringLen($sConnText) + 1) & "]")
		DllStructSetData($stCalcText, 1, $sConnText)
		DrawTextW($hDC, DllStructGetPtr($stCalcText), StringLen($sConnText), DllStructGetPtr($stRectCalc), $uFlags)
		$nBound = DllStructGetData($stRectCalc, 3)
		SelectObject($hDC, $hOldFont)
		
		$stRectCalc = 0
		$stCalcText = 0
		
		DllStructSetData($stRect, 3, $nR - $nBound - 2)
		$hOldFont = SelectObject($hDC, $hWiFiBigBoldFont)
	Else
		$hOldFont = SelectObject($hDC, $hWiFiBigFont)
	EndIf
	
	$uFlags = BitOr($DT_NOCLIP, $DT_SINGLELINE, $DT_VCENTER, $DT_END_ELLIPSIS)
	
	; Draw SSID
	DrawTextW($hDC, DllStructGetPtr($stText), StringLen($sText), DllStructGetPtr($stRect), $uFlags)
	
	If BitAnd($nBitType, 2048) Then
		If BitAnd($nState, $ODS_SELECTED) Then
			SetTextColor($hDC, GetBGRColor($nClrTraySelBk))
		Else
			SetTextColor($hDC, GetBGRColor($nClrTrayBk))
		EndIf
	Else
		If BitAnd($nState, $ODS_SELECTED) Then
			SetTextColor($hDC, GetBGRColor($nClrTraySelTxt))
		Else			
			If BitAnd($nBitType, 256) Or BitAnd($nBitType, 1024) Then
				SetTextColor($hDC, $nClrTrayTxt)
			Else
				SetTextColor($hDC, $nClrTrayTxtGray)
			EndIf
		EndIf
	EndIf

	; Draw connected/connecting state
	If BitAnd($nBitType, 256) Or BitAnd($nBitType, 1024) Then
		DllStructSetData($stRect, 3, $nR)
		$hOldFont = SelectObject($hDC, $hGlobalBoldFont)
		$stText = DllStructCreate("wchar[" & (StringLen($sConnText) + 1) & "]")
		DllStructSetData($stText, 1, $sConnText)
		DllStructSetData($stRect, 1, $nR - $nBound)
		$uFlags = BitOr($DT_NOCLIP, $DT_SINGLELINE, $DT_VCENTER, $DT_RIGHT)
		DrawTextW($hDC, DllStructGetPtr($stText), StringLen($sConnText), DllStructGetPtr($stRect), $uFlags)
	EndIf
	
	; Cleanup
	SelectObject($hDC, $hOldFont)    
	If $hBrush <> 0 Then DeleteObject($hBrush)
	SetBkMode($hDC, $nMode)
    
    Return TRUE
EndFunc


;********************************************************************
; Fill background rect with gradient colors
;********************************************************************
Func FillGradientRect($hDC, $stRect, $nClr1, $nClr2, $bVert = FALSE)
	Local $stVert = DllStructCreate("long;long;ushort;ushort;ushort;ushort;" & _
									"long;long;ushort;ushort;ushort;ushort")
									
	DllStructSetData($stVert, 1, DllStructGetData($stRect, 1))
	DllStructSetData($stVert, 2, DllStructGetData($stRect, 2))
	DllStructSetData($stVert, 3, BitShift(ColorGetClr($nClr1, 3), -8))
	DllStructSetData($stVert, 4, BitShift(ColorGetClr($nClr1, 2), -8))
	DllStructSetData($stVert, 5, BitShift(ColorGetClr($nClr1, 1), -8))
	DllStructSetData($stVert, 6, 0)
	
	DllStructSetData($stVert, 7, DllStructGetData($stRect, 3))
	DllStructSetData($stVert, 8, DllStructGetData($stRect, 4))
	DllStructSetData($stVert, 9, BitShift(ColorGetClr($nClr2, 3), -8))
	DllStructSetData($stVert, 10, BitShift(ColorGetClr($nClr2, 2), -8))
	DllStructSetData($stVert, 11, BitShift(ColorGetClr($nClr2, 1), -8))
	DllStructSetData($stVert, 12, 0)
	
	Local $stGradRect = DllStructCreate("ulong;ulong")
	DllStructSetData($stGradRect, 1, 0)
	DllStructSetData($stGradRect, 2, 1)
	
	If $bVert Then
		GradientFill($hDC, DllStructGetPtr($stVert), 2, DllStructGetPtr($stGradRect), 1, 1)
	Else
		GradientFill($hDC, DllStructGetPtr($stVert), 2, DllStructGetPtr($stGradRect), 1, 0)
	EndIf
EndFunc


Func GradientFill($hDC, $pVert, $nNumVert, $pRect, $nNumRect, $nFillMode)
	Local $nResult = DllCall($hMsimg32, "int", "GradientFill", _
													"hwnd", $hDC, _
													"ptr", $pVert, _
													"ulong", $nNumVert, _
													"ptr", $pRect, _
													"ulong", $nNumRect, _
													"ulong", $nFillMode)
	Return $nResult[0]
EndFunc


;********************************************************************
; Get color part
;********************************************************************
Func ColorGetClr($nColor, $nMode)
	Local $nClr = $nColor
	
	;If $bUseRGBColors Then $nClr = GetBGRColor($nColor)
	
	Switch $nMode
		Case 1
			$nClr = BitShift($nClr, 16)
		Case 2
			$nClr = BitShift(BitAnd($nClr, 0xFF00), 8)
		Case 3
			$nClr = BitAnd($nClr, 0xFF)
	EndSwitch
	
	Return $nClr
EndFunc


;**********************************************************************
; Get BGR value from RGB color
;**********************************************************************
Func GetBGRColor($nColor)
	Return BitOr(BitShift(BitAnd($nColor, 0xFF), -16), BitAnd($nColor, 0xFF00), BitShift($nColor, 16))
EndFunc


;**********************************************************************
; Reduce color to x perc
;**********************************************************************
Func ReduceClr($nColor, $nPerc)
	Return BitOr(BitShift(ColorGetClr($nColor, 1) * $nPerc, -16), BitShift(ColorGetClr($nColor, 2) * $nPerc, -8), ColorGetClr($nColor, 3) * $nPerc)
EndFunc


;**********************************************************************
; Check schemes
;**********************************************************************
Func CheckSchemes($bRead = TRUE)
	Debug("IN: CheckSchemes")
	If Not FileExists($sPENMIni) Then
		$sCurScheme = $sLblDefault
		
		If $hBrushGUI <> 0 Then DeleteObject($hBrushGUI)
		$hBrushGUI = CreateSolidBrush(GetBGRColor($nClrGUIBk))
	
		If $hBrushWiFiGUI <> 0 Then DeleteObject($hBrushWiFiGUI)
		$hBrushWiFiGUI = CreateSolidBrush(GetBGRColor($nClrGUIBkWiFi))

		If $hBrushTrayGUI <> 0 Then DeleteObject($hBrushTrayGUI)
		$hBrushTrayGUI = CreateSolidBrush(GetBGRColor($nClrTrayBk))
		
		Return
	EndIf
	
	Local $sRegScheme = RegRead($sGURegKey, "Scheme")
	
	If $sRegScheme = "" Then $sRegScheme = RegRead($sGRegKey, "Scheme")
	
	If $sRegScheme = "" Then $sRegScheme = IniRead($sPENMini, "Schemes", "Default", "")
	
	If $sRegScheme = "" Or $sRegScheme = $sLblDefault Or RegRead($sGURegKey, "SchemeDefault") = 1 Then
		$sCurScheme = $sLblDefault
	ElseIf RegRead($sGURegKey, "SchemeClassic") = 1 Then
		$sCurScheme = $sLblClassic
	Else
		$sCurScheme = $sRegScheme
	EndIf

	Local $i = 1, $sLine
	Local $sSchemes = "|" & $sLblDefault & "|" & $sLblClassic
	Local $bSchemeFound = FALSE
	If $sRegScheme = $sLblDefault Or $sRegScheme = $sLblClassic Then $bSchemeFound = TRUE
	
	While 1
		$sLine = IniRead($sPENMIni, "Schemes", "Scheme" & $i, "IniReadError")
		If $sLine = "IniReadError" Then ExitLoop
		
		$sSchemes = $sSchemes & "|" & $sLine
		
		If $sLine = $sRegScheme Then $bSchemeFound = TRUE
		
		$i += 1
	WEnd
	
	$sAllSchemes = $sSchemes
	
	If Not $bSchemeFound Then
		$sCurScheme = $sLblDefault
		RegWrite($sGURegKey, "Scheme", "REG_SZ", $sCurScheme)
	EndIf
	
	If $bRead Then ReadScheme($sCurScheme)
	
	If $hBrushGUI = 0 Then $hBrushGUI = CreateSolidBrush(GetBGRColor($nClrGUIBk))
	If $hBrushWiFiGUI = 0 Then $hBrushWiFiGUI = CreateSolidBrush(GetBGRColor($nClrGUIBkWiFi))
	If $hBrushTrayGUI = 0 Then $hBrushTrayGUI = CreateSolidBrush(GetBGRColor($nClrTrayBk))
	
EndFunc


;**********************************************************************
; Read color scheme from ini
;**********************************************************************
Func ReadScheme($sScheme)
	If $sScheme = $sLblClassic Then
		GetSchemeClassic()
	Else
		GetSchemeDefault()
	EndIf
	
	GetSEClr($sScheme, "ClrStateGreen", $nClrStateGreen, FALSE)
	GetSEClr($sScheme, "ClrStateRed", $nClrStateRed, FALSE)
	GetSEClr($sScheme, "ClrSvcStart", $nClrSvcStart, FALSE)
	GetSEClr($sScheme, "ClrSvcStop", $nClrSvcStop, FALSE)
	GetSEClr($sScheme, "ClrBtnChkTxt", $nClrBtnChkTxt, FALSE)
	GetSEClr($sScheme, "ClrBtnChkBk", $nClrBtnChkBk, FALSE)
	GetSEClr($sScheme, "ClrBtnChkGrad", $nClrBtnChkGrad, FALSE)
	GetSEClr($sScheme, "ClrBtnUnchkTxt", $nClrBtnUnchkTxt, FALSE)
	GetSEClr($sScheme, "ClrBtnUnchkBk", $nClrBtnUnchkBk, FALSE)
	GetSEClr($sScheme, "ClrBtnUnchkGrad", $nClrBtnUnchkGrad, FALSE)
	GetSEClr($sScheme, "ClrBtnDhcpTxt", $nClrBtnDhcpTxt, FALSE)
	GetSEClr($sScheme, "ClrBtnDhcpBk", $nClrBtnDhcpBk, FALSE)
	GetSEClr($sScheme, "ClrBtnDhcpGrad", $nClrBtnDhcpGrad, FALSE)
	GetSEClr($sScheme, "ClrBtnTxtDisabled", $nClrBtnTxtDisabled)
	GetSEClr($sScheme, "ClrBtnBkActive", $nClrBtnBkActive)
	GetSEClr($sScheme, "ClrBtnFocus", $nClrBtnFocus)
	GetSEClr($sScheme, "ClrBtnNormalTxt", $nClrBtnNormalTxt)
	GetSEClr($sScheme, "ClrBtnNormalBk", $nClrBtnNormalBk)
	GetSEClr($sScheme, "ClrBtnNormalGrad", $nClrBtnNormalGrad)
	GetSEClr($sScheme, "ClrBtnFrame", $nClrBtnFrame)
	If GetSEClr($sScheme, "ClrBtnFrameDisabled", $nClrBtnFrameDisabled) = FALSE And _
		$sScheme <> $sLblDefault Then $nClrBtnFrameDisabled = $nClrBtnFrame
	GetSEClr($sScheme, "ClrWiFiConnect", $nClrWiFiConnect)
	GetSEClr($sScheme, "ClrTITxt", $nClrTITxt)
	GetSEClr($sScheme, "ClrTIBk", $nClrTIBk)
	GetSEClr($sScheme, "ClrTIGrad", $nClrTIGrad)
	GetSEClr($sScheme, "ClrTISelTxt", $nClrTISelTxt)
	GetSEClr($sScheme, "ClrTISelBk", $nClrTISelBk)
	GetSEClr($sScheme, "ClrTISelGrad", $nClrTISelGrad)
	GetSEClr($sScheme, "ClrTIFocus", $nClrTIFocus)
	GetSEClr($sScheme, "ClrTIConfTxt", $nClrTIConfTxt)
	GetSEClr($sScheme, "ClrTIConfBk", $nClrTIConfBk)
	GetSEClr($sScheme, "ClrTIConfGrad", $nClrTIConfGrad)
	GetSEClr($sScheme, "ClrTIConfSelTxt", $nClrTIConfSelTxt)
	GetSEClr($sScheme, "ClrTIConfSelBk", $nClrTIConfSelBk)
	GetSEClr($sScheme, "ClrTIConfSelGrad", $nClrTIConfSelGrad)
	GetSEClr($sScheme, "ClrTIWiFiTxt", $nClrTIWiFiTxt)
	GetSEClr($sScheme, "ClrTIWiFiBk", $nClrTIWiFiBk)
	GetSEClr($sScheme, "ClrTIWiFiGrad", $nClrTIWiFiGrad)
	GetSEClr($sScheme, "ClrTIWiFiSelTxt", $nClrTIWiFiSelTxt)
	GetSEClr($sScheme, "ClrTIWiFiSelBk", $nClrTIWiFiSelBk)
	GetSEClr($sScheme, "ClrTIWiFiSelGrad", $nClrTIWiFiSelGrad)
	GetSEClr($sScheme, "ClrGUIBkMain", $nClrGUIBkMain, FALSE)
	GetSEClr($sScheme, "ClrGUIBk", $nClrGUIBk, FALSE)
	GetSEClr($sScheme, "ClrGUIBkSub", $nClrGUIBkSub, FALSE)
	GetSEClr($sScheme, "ClrGUIBkConf", $nClrGUIBkConf, FALSE)
	GetSEClr($sScheme, "ClrGUIBkWiFi", $nClrGUIBkWiFi, FALSE)
	GetSEClr($sScheme, "ClrGUIBkAuth", $nClrGUIBkAuth, FALSE)
	GetSEClr($sScheme, "ClrLblNormal", $nClrLblNormal, FALSE)
	GetSEClr($sScheme, "ClrLblConf", $nClrLblConf, FALSE)
	GetSEClr($sScheme, "ClrLblWiFi", $nClrLblWiFi, FALSE)
	GetSEClr($sScheme, "ClrLVWiFiBk", $nClrLVWiFiBk, FALSE)
	GetSEClr($sScheme, "ClrLVWiFiTxt", $nClrLVWiFiTxt, FALSE)
	GetSEClr($sScheme, "ClrLVSharesBk", $nClrLVSharesBk, FALSE)
	GetSEClr($sScheme, "ClrLVSharesTxt", $nClrLVSharesTxt, FALSE)
	GetSEClr($sScheme, "ClrLVDrivesBk", $nClrLVDrivesBk, FALSE)
	GetSEClr($sScheme, "ClrLVDrivesTxt", $nClrLVDrivesTxt, FALSE)
	GetSEClr($sScheme, "ClrLVPingBk", $nClrLVPingBk, FALSE)
	GetSEClr($sScheme, "ClrLVPingTxt", $nClrLVPingTxt, FALSE)
	GetSEClr($sScheme, "ClrLProfileBk", $nClrLProfileBk, FALSE)
	GetSEClr($sScheme, "ClrLProfileTxt", $nClrLProfileTxt, FALSE)
	GetSEClr($sScheme, "ClrLExtBk", $nClrLExtBk, FALSE)
	GetSEClr($sScheme, "ClrLExtTxt", $nClrLExtTxt, FALSE)
	GetSEClr($sScheme, "ClrGUIBkFrame", $nClrGUIBkFrame, FALSE)
	GetSEClr($sScheme, "ClrGUIBkConfFrame", $nClrGUIBkConfFrame, FALSE)
	GetSEClr($sScheme, "ClrGUIBkWiFiFrame", $nClrGUIBkWiFiFrame, FALSE)
	GetSEClr($sScheme, "ClrTrayBk", $nClrTrayBk, FALSE)
	GetSEClr($sScheme, "ClrTrayTxt", $nClrTrayTxt, FALSE)
	GetSEClr($sScheme, "ClrTrayTrans", $nClrTrayTrans, FALSE)
	GetSEClr($sScheme, "ClrTraySelBk", $nClrTraySelBk, FALSE)
	GetSEClr($sScheme, "ClrTraySelTxt", $nClrTraySelTxt, FALSE)
	GetSEClr($sScheme, "ClrTrayConnect", $nClrTrayConnect)
	GetSEClr($sScheme, "ClrTrayBtnFocus", $nClrTrayBtnFocus)
	GetSEClr($sScheme, "ClrTrayBtnTxt", $nClrTrayBtnTxt)
	GetSEClr($sScheme, "ClrTrayBtnBk", $nClrTrayBtnBk)
	GetSEClr($sScheme, "ClrTrayBtnGrad", $nClrTrayBtnGrad)
	GetSEClr($sScheme, "ClrTrayBtnFrame", $nClrTrayBtnFrame)
	GetSEClr($sScheme, "ClrTrayTxtGray", $nClrTrayTxtGray)
	
	If $hBrushGUI <> 0 Then DeleteObject($hBrushGUI)
	$hBrushGUI = CreateSolidBrush(GetBGRColor($nClrGUIBk))
	
	If $hBrushWiFiGUI <> 0 Then DeleteObject($hBrushWiFiGUI)
	$hBrushWiFiGUI = CreateSolidBrush(GetBGRColor($nClrGUIBkWiFi))

	If $hBrushTrayGUI <> 0 Then DeleteObject($hBrushTrayGUI)
	$hBrushTrayGUI = CreateSolidBrush(GetBGRColor($nClrTrayBk))
	
	$sIconLib = IniRead($sPENMIni, $sScheme, "IconLib", "")
	If $sIconLib = "" Then $sIconLib = @ScriptDir & "\PENetwork.icl"
	If Not FileExists($sIconLib) Then $sIconLib = @ScriptDir & "\" & $sIconLib
	If FileExists($sIconLib) Then
		$bIconLib = TRUE
	Else
		$bIconLib = FALSE
	EndIf
EndFunc


;**********************************************************************
; Get scheme entry color
;**********************************************************************
Func GetSEClr($sScheme, $sEntry, ByRef $nRet, $bBGR = TRUE)
	Local $nVal = -1
	
	Local $sVal = IniRead($sPENMIni, $sScheme, $sEntry, "")
	
	If $sVal <> "" Then
		$nRet = Number($sVal)
		If $bBGR Then $nRet = GetBGRColor($nRet)
		
		Return TRUE
	EndIf
	
	Return FALSE
EndFunc


;**********************************************************************
; Scans for available language files
;**********************************************************************
Func CheckLanguage()
	Local $sLocale = RegRead("HKCU\Control Panel\International", "Locale")
	If $sLocale = "" Then
		$sLocale = RegRead($sCCS & "\Control\Nls\Language", "default")
		If $sLocale = "" Then Return
	EndIf
	
	Local $sFile, $hSearch, $sLangStr, $sLangCode, $sLang = ""
	Local $sRegLang = RegRead($sGURegKey, "LangCode")
	If $sRegLang = "" Then $sRegLang = RegRead($sGRegKey, "LangCode")
	
	$hSearch = FileFindFirstFile(@ScriptDir & "\*.lng")
	If $hSearch = -1 Then Return
	
	While 1
		$sFile = FileFindNextFile($hSearch)
		If @Error Then ExitLoop
    	
		$sLangCode	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "LangCode", "")
		$sLangStr	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "Language", "")
		
		If $sLangStr <> "" And $sLangCode <> "" And ((Dec($sLocale) = Dec($sLangCode)) Or ($sRegLang <> "" And $sLangCode = $sRegLang)) Then
			$sCurLang		= $sLangStr
			$sCurLangFile	= @ScriptDir & "\" & $sFile
			$sCurLangAuthor	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "Author", "")
			$sCurLangVer	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "Version", "")
			
			If $sRegLang = "" Or ($sRegLang <> "" And $sLangCode = $sRegLang) Then ExitLoop
		EndIf
	WEnd
	
	FileClose($hSearch)
EndFunc


;**********************************************************************
; Enum available language files
;**********************************************************************
Func EnumLanguages()
	Local $sLang = "|", $sFile, $hSearch, $sLangStr = ""
	
	$hSearch = FileFindFirstFile(@ScriptDir & "\*.lng")
	If $hSearch = -1 Then Return
	
	While 1
		$sFile = FileFindNextFile($hSearch) 
		If @Error Then ExitLoop
    	
		$sLangStr = IniRead(@ScriptDir & "\" & $sFile, $sGSection, "Language", "")
		If $sLangStr <> "" Then $sLang = $sLang & $sLangStr & "|"
		
	WEnd
	
	FileClose($hSearch)
	
	GUICtrlSetData($nComboLang, $sLang, $sCurLang)
EndFunc


;**********************************************************************
; Read details from language file
;**********************************************************************
Func GetLangInfos($sLang)
	Local $sFile, $hSearch, $sLangStr = "", $sLangCode = ""
	
	If $sLang = "" Then Return
	
	$hSearch = FileFindFirstFile(@ScriptDir & "\*.lng")
	If $hSearch = -1 Then Return
	
	$sCurLangFile = ""
	
	While 1
		$sFile = FileFindNextFile($hSearch) 
		If @Error Then ExitLoop
    	
		$sLangStr	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "Language", "")
		$sLangCode	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "LangCode", "")
		
		If $sLangStr <> "" And $sLangStr = $sLang Then
			$sCurLangFile	= @ScriptDir & "\" & $sFile
			$sCurLangAuthor	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "Author", "")
			$sCurLangVer	= IniRead(@ScriptDir & "\" & $sFile, $sGSection, "Version", "")
			
			GUICtrlSetTip($nComboLang, $sLblLangAuthor & ": " & $sCurLangAuthor & @LF & _
							$sLblLangVersion & ": " & $sCurLangVer)
			ExitLoop
		EndIf		
	WEnd

	FileClose($hSearch)
	
	If $sCurLangFile <> "" Then
		RegWrite($sGURegKey, "LangCode", "REG_SZ", $sLangCode)
		ApplyLanguage()
	EndIf
EndFunc


;**********************************************************************
; Change GUI size depend on small or big tabs
;**********************************************************************
Func ApplyGUIChange()
	Debug("IN: ApplyGUIChange")

	Local $arPos = WinGetPos($hMainGUI)
	If Not IsArray($arPos) Then	Return
	
	Local $nSizeSmall	= GetScaled(26)
	Local $nSizeNormal	= GetScaled(130)
	Local $nX
	Local $nS = GetScaled(26)
	Local $nY = 0
	Local $nR = GetScaled(104)
	Local $nW = GetScaled(541)
	
	If $bTabSmall Then
		$bPaint = FALSE
		
		WinMove($hMainGUI, "", $arPos[0] - $nSizeNormal + $nSizeSmall, $arPos[1], $arPos[2] + $nSizeNormal - $nSizeSmall)
		WinMove($hConfGUI, "", $nSizeNormal, 1)
		WinMove($hIdentGUI, "", $nSizeNormal, 1)
		WinMove($hSharesGUI, "", $nSizeNormal, 1)
		WinMove($hDrivesGUI, "", $nSizeNormal, 1)
		WinMove($hProfilesGUI, "", $nSizeNormal, 1)
		WinMove($hOtherGUI, "", $nSizeNormal, 1)
		WinMove($hAboutGUI, "", $nSizeNormal, 1)			
		
		GUICtrlSetPos($nTIConf, 0, $nY, $nSizeNormal)
		ControlMove($hMainGUI, "", $nTIConf, 0, $nY, $nSizeNormal)
		$nY += $nS - 1
	
		If Not BitAnd($nGUIDisable, 1) Then
			GUICtrlSetPos($nTIIdent, 0, $nY, $nSizeNormal)
			ControlMove($hMainGUI, "", $nTIIdent, 0, $nY, $nSizeNormal)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 2) Then
			GUICtrlSetPos($nTISharing, 0, $nY, $nSizeNormal)
			ControlMove($hMainGUI, "", $nTISharing, 0, $nY, $nSizeNormal)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 4) Then
			GUICtrlSetPos($nTIDrives, 0, $nY, $nSizeNormal)
			ControlMove($hMainGUI, "", $nTIDrives, 0, $nY, $nSizeNormal)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 8) Then
			GUICtrlSetPos($nTIProfiles, 0, $nY, $nSizeNormal)
			ControlMove($hMainGUI, "", $nTIProfiles, 0, $nY, $nSizeNormal)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 16) Then
			GUICtrlSetPos($nTIOther, 0, $nY, $nSizeNormal)
			ControlMove($hMainGUI, "", $nTIOther, 0, $nY, $nSizeNormal)
			$nY += $nS - 1
		EndIf
		
		GUICtrlSetPos($nTIAbout, 0, $nY, $nSizeNormal)
		ControlMove($hMainGUI, "", $nTIAbout, 0, $nY, $nSizeNormal)
		$nY += $nS - 1
		
		If Not BitAnd($nGUIDisable, 512) Then
			SetODBtnIcon($nTISize, 23, FALSE)
			GUICtrlSetPos($nTISize, $nSizeNormal - GetScaled(26), $nY, GetScaled(26))
			ControlMove($hMainGUI, "", $nTISize, $nSizeNormal - GetScaled(26), $nY, GetScaled(26))
		EndIf
		
		GUICtrlSetTip($nTIConf, "")
		GUICtrlSetTip($nTIIdent, "")
		GUICtrlSetTip($nTISharing, "")
		GUICtrlSetTip($nTIDrives, "")
		GUICtrlSetTip($nTIProfiles, "")
		GUICtrlSetTip($nTIOther, "")
		GUICtrlSetTip($nTIAbout, "")
		
		$bPaint = TRUE
		InvalidateRect($hMainGUI, 0, FALSE)
						
		$bTabSmall = FALSE
	Else
		$bPaint = FALSE
		
		WinMove($hMainGUI, "", $arPos[0] + $nSizeNormal - $nSizeSmall, $arPos[1], $arPos[2] - $nSizeNormal + $nSizeSmall)
		WinMove($hConfGUI, "", $nSizeSmall, 1)
		WinMove($hIdentGUI, "", $nSizeSmall, 1)
		WinMove($hSharesGUI, "", $nSizeSmall, 1)
		WinMove($hDrivesGUI, "", $nSizeSmall, 1)
		WinMove($hProfilesGUI, "", $nSizeSmall, 1)
		WinMove($hOtherGUI, "", $nSizeSmall, 1)
		WinMove($hAboutGUI, "", $nSizeSmall, 1)
		
		GUICtrlSetPos($nTIConf, 0, $nY, $nSizeSmall)
		ControlMove($hMainGUI, "", $nTIConf, 0, $nY, $nSizeSmall)
		$nY += $nS - 1
		
		If Not BitAnd($nGUIDisable, 1) Then
			GUICtrlSetPos($nTIIdent, 0, $nY, $nSizeSmall)
			ControlMove($hMainGUI, "", $nTIIdent, 0, $nY, $nSizeSmall)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 2) Then
			GUICtrlSetPos($nTISharing, 0, $nY, $nSizeSmall)
			ControlMove($hMainGUI, "", $nTISharing, 0, $nY, $nSizeSmall)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 4) Then
			GUICtrlSetPos($nTIDrives, 0, $nY, $nSizeSmall)
			ControlMove($hMainGUI, "", $nTIDrives, 0, $nY, $nSizeSmall)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 8) Then
			GUICtrlSetPos($nTIProfiles, 0, $nY, $nSizeSmall)
			ControlMove($hMainGUI, "", $nTIProfiles, 0, $nY, $nSizeSmall)
			$nY += $nS - 1
		EndIf
		If Not BitAnd($nGUIDisable, 16) Then
			GUICtrlSetPos($nTIOther, 0, $nY, $nSizeSmall)
			ControlMove($hMainGUI, "", $nTIOther, 0, $nY, $nSizeSmall)
			$nY += $nS - 1	
		EndIf
		
		GUICtrlSetPos($nTIAbout, 0, $nY, $nSizeSmall)
		ControlMove($hMainGUI, "", $nTIAbout, 0, $nY, $nSizeSmall)
		$nY += $nS - 1
		
		If Not BitAnd($nGUIDisable, 512) Then
			SetODBtnIcon($nTISize, 17, FALSE)
			GUICtrlSetPos($nTISize, 0, $nY, $nSizeSmall)
			ControlMove($hMainGUI, "", $nTISize, 0, $nY, $nSizeSmall)
		EndIf
		
		GUICtrlSetTip($nTIConf, $sTIConfig)
		GUICtrlSetTip($nTIIdent, $sTIIdent)
		GUICtrlSetTip($nTISharing, $sTISharing)
		GUICtrlSetTip($nTIDrives, $sTIDrives)
		GUICtrlSetTip($nTIProfiles, $sTIProfiles)
		GUICtrlSetTip($nTIOther, $sTIOther)
		GUICtrlSetTip($nTIAbout, $sTIAbout)
		
		$bPaint = TRUE
		InvalidateRect($hMainGUI, 0, FALSE)
			
		$bTabSmall = TRUE
	EndIf
EndFunc


;**********************************************************************
; Apply (new) ctrl colors to (sub)GUI's
;**********************************************************************
Func ApplyCtrlColors($nGUI)
	$bPaint = FALSE
	
	; ConfGUI
	If $hConfGUI <> 0 And BitAnd($nGUI, 1) Then
		GUICtrlSetColor($nLblAdapterState, $nClrLblNormal)
		GUICtrlSetColor($nLblAdapterSpeed, $nClrLblNormal)
		GUICtrlSetColor($nChkScan, $nClrLblNormal)
		
		GUICtrlSetBkColor($nLblTop2, $nClrGUIBkConfFrame)
		GUICtrlSetBkColor($nLblLeft2, $nClrGUIBkConfFrame)
		GUICtrlSetBkColor($nLblBottom2, $nClrGUIBkConfFrame)
		GUICtrlSetBkColor($nLblRight2, $nClrGUIBkConfFrame)
	EndIf
	
	; IdentGUI
	If $hIdentGUI <> 0 And BitAnd($nGUI, 2) Then
		GUICtrlSetColor($nLblCNI, $nClrLblNormal)
		GUICtrlSetColor($nLblCN,$nClrLblNormal)
		GUICtrlSetColor($nLblWG, $nClrLblNormal)
		GUICtrlSetColor($nLblPriDNS, $nClrLblNormal)
		GUICtrlSetColor($nLblPing, $nClrLblNormal)
		GUICtrlSetColor($nLblCount, $nClrLblNormal)
		GUICtrlSetColor($nLblTime, $nClrLblNormal)
		GUICtrlSetColor($nChkPing, $nClrLblNormal)
		GUICtrlSetColor($nLVPing, $nClrLVPingTxt)
		GUICtrlSetBkColor($nLVPing, $nClrLVPingBk)		
		GUICtrlSetColor($nChkTrace, $nClrLblNormal)
		GUICtrlSetColor($nLblTrace, $nClrLblNormal)
		GUICtrlSetColor($nChkReverse, $nClrLblNormal)		
	EndIf
	
	; SharesGUI
	If $hSharesGUI <> 0 And BitAnd($nGUI, 4) Then
		GUICtrlSetColor($nLblFileShr, $nClrLblNormal)
		If IsServiceRunning("lanmanserver") Then
			GUICtrlSetBkColor($nLblShrInfo, $nClrSvcStart)
		Else
			GUICtrlSetBkColor($nLblShrInfo, $nClrSvcStop)
		EndIf
		GUICtrlSetColor($nLblShrUsr, $nClrLblNormal)
		GUICtrlSetColor($nLblShrPW, $nClrLblNormal)
		GUICtrlSetColor($nChkShrAll, $nClrLblNormal)
		GUICtrlSetColor($nLblShrFolders, $nClrLblNormal)
		GUICtrlSetColor($nLblShrName, $nClrLblNormal)
		GUICtrlSetColor($nInpShrName, $nClrLblNormal)
		GUICtrlSetColor($nLblShrPath, $nClrLblNormal)
		GUICtrlSetColor($nLVShares, $nClrLVSharesTxt)
		GUICtrlSetBkColor($nLVShares, $nClrLVSharesBk)
	EndIf
	
	; DrivesGUI
	If $hDrivesGUI <> 0 And BitAnd($nGUI, 8) Then
		GUICtrlSetColor($nLblDrvLetter, $nClrLblNormal)
		GUICtrlSetColor($nLblDrvPath, $nClrLblNormal)
		GUICtrlSetColor($nLblDrvUsr, $nClrLblNormal)
		GUICtrlSetColor($nLblDrvPW, $nClrLblNormal)
		GUICtrlSetColor($nLblDrvCon, $nClrLblNormal)
		GUICtrlSetColor($nLVDrives, $nClrLVDrivesTxt)
		GUICtrlSetBkColor($nLVDrives, $nClrLVDrivesBk)
		GUICtrlSetColor($nLblDrvNet, $nClrLblNormal)
		;GUICtrlSetColor($nInpDrvNet, $nClrLVDrivesTxt)
		;GUICtrlSetBkColor($nInpDrvNet, $nClrLVDrivesBk)
		GUICtrlSetColor($nTVDrvNet, $nClrLVDrivesTxt)
		GUICtrlSetBkColor($nTVDrvNet, $nClrLVDrivesBk)
	EndIf
	
	; ProfilesGUI
	If $hProfilesGUI <> 0 And BitAnd($nGUI, 16) Then
		GUICtrlSetColor($nLblProfFile, $nClrLblNormal)
		GUICtrlSetColor($nLblProfList, $nClrLblNormal)
		GUICtrlSetColor($nLblProfDesc, $nClrLblNormal)
		GUICtrlSetColor($nListProf, $nClrLProfileTxt)
		GUICtrlSetBkColor($nListProf, $nClrLProfileBk)
	EndIf
	
	; OtherGUI
	If $hOtherGUI <> 0 And BitAnd($nGUI, 32) Then
		GUICtrlSetColor($nLblLang, $nClrLblNormal)
		GUICtrlSetColor($nLblSurface, $nClrLblNormal)
		GUICtrlSetColor($nLblClr, $nClrLblNormal)
		GUICtrlSetColor($nLblTrayOpt, $nClrLblNormal)
		GUICtrlSetColor($nLblTrouble, $nClrLblNormal)
		GUICtrlSetColor($nChkDebug,	$nClrLblNormal)
		GUICtrlSetColor($nChkStartTray, $nClrLblNormal)
		GUICtrlSetColor($nChkMinTray, $nClrLblNormal)
		GUICtrlSetColor($nChkEndTray, $nClrLblNormal)
		GUICtrlSetColor($nChkShowAct, $nClrLblNormal)
		GUICtrlSetColor($nChkShowAlways, $nClrLblNormal)
		GUICtrlSetColor($nChkShowTip, $nClrLblNormal)
		GUICtrlSetColor($nChkShowOnlyCon, $nClrLblNormal)
		GUICtrlSetColor($nChkTrayLimitInfo, $nClrLblNormal)
		GUICtrlSetColor($nChkTrayAdaptWiFi, $nClrLblNormal)
		GUICtrlSetColor($nChkTrayShowMAC, $nClrLblNormal)
		GUICtrlSetColor($nChkTrayShowIPv6, $nClrLblNormal)
		GUICtrlSetColor($nLblOtherOpt, $nClrLblNormal)		
		GUICtrlSetColor($nChkLastPos, $nClrLblNormal)
		GUICtrlSetColor($nChkLastPage, $nClrLblNormal)
		GUICtrlSetColor($nLblLastPage, $nClrLblNormal)
		GUICtrlSetColor($nChkUseWMI, $nClrLblNormal)
		
		;GUICtrlSetColor($nLblCMDActions, $nClrLblNormal)
		;GUICtrlSetColor($nChkCMDIPChg, $nClrLblNormal)
		;GUICtrlSetColor($nLblCMDIPChg, $nClrLblNormal)
		;GUICtrlSetColor($nLblCMDLineNum, $nClrLblNormal)
		;GUICtrlSetColor($nLblCMDLineMode, $nClrLblNormal)
	EndIf
	
	; AboutGUI
	If $hAboutGUI <> 0 And BitAnd($nGUI, 64) Then
		GUICtrlSetColor($nLblAbout, $nClrLblNormal)
		GUICtrlSetColor($nLblAboutAuthor, $nClrLblNormal)
		GUICtrlSetColor($nLblAboutAI3, $nClrLblNormal)
	EndIf
	
	; ConfIPGUI
	If $hConfIPGUI <> 0 And BitAnd($nGUI, 128) Then
		GUICtrlSetColor($nLblStaticIP, $nClrLblConf)
		GUICtrlSetColor($nLblStaticSM, $nClrLblConf)
		GUICtrlSetColor($nLblStaticDG, $nClrLblConf)
		GUICtrlSetColor($nLblDNS, $nClrLblConf)
		GUICtrlSetColor($nLblWINS, $nClrLblConf)
		GUICtrlSetColor($nRadIPDHCP, $nClrLblConf)
		GUICtrlSetColor($nRadIPPrivate, $nClrLblConf)
		GUICtrlSetColor($nRadIPNone, $nClrLblConf)
		GUICtrlSetColor($nRadIPUser, $nClrLblConf)
		GUICtrlSetColor($nRadIPStatic, $nClrLblConf)
		GUICtrlSetColor($nRadDNSDHCP, $nClrLblConf)
		GUICtrlSetColor($nRadDNSStatic, $nClrLblConf)
		GUICtrlSetColor($nRadWINSDHCP, $nClrLblConf)
		GUICtrlSetColor($nRadWINSStatic, $nClrLblConf)

		SetODBtnData($nBtnDHCPInfo, "", $nClrBtnDhcpTxt, $nClrBtnDhcpBk, FALSE, $nClrBtnDhcpGrad)
		SetODBtnData($nBtnDHCPRelease, "", $nClrBtnDhcpTxt, $nClrBtnDhcpBk, FALSE, $nClrBtnDhcpGrad)
		SetODBtnData($nBtnDHCPRenew, "", $nClrBtnDhcpTxt, $nClrBtnDhcpBk, FALSE, $nClrBtnDhcpGrad)
		SetODBtnData($nBtnIPAltShow, "", $nClrBtnDhcpTxt, $nClrBtnDhcpBk, FALSE, $nClrBtnDhcpGrad)
		SetODBtnData($nBtnIPAltHide, "", $nClrBtnDhcpTxt, $nClrBtnDhcpBk, FALSE, $nClrBtnDhcpGrad)
	
		GUISetBkColor($nClrGUIBkConf, $hConfIPGUI)
	EndIf
	
	; ConfWiFiGUI
	If BitAnd($nGUI, 256) Then
		If $hConfWiFiGUI <> 0 Then GUISetBkColor($nClrGUIBkConf, $hConfWiFiGUI)
		If $hConfPreWiFiGUI <> 0 Then
			GUICtrlSetColor($nLblPreWiFiState, $nClrLblConf)
			GUICtrlSetColor($nLblWLNot, $nClrLblConf)
			GUICtrlSetColor($nLblWLNoApi, $nClrLblConf)
			GUISetBkColor($nClrGUIBkConf, $hConfPreWiFiGUI)
		EndIf
		If $hWiFiAvailGUI <> 0 Then
			GUICtrlSetColor($nLVWLAvail, $nClrLVWiFiTxt)
			GUICtrlSetBkColor($nLVWLAvail, $nClrLVWiFiBk)
			GUISetBkColor($nClrGUIBkWiFi, $hWiFiAvailGUI)
		EndIf
		If $hWiFiPrefGUI <> 0 Then
			GUICtrlSetColor($nLVWLPref, $nClrLVWiFiTxt)
			GUICtrlSetBkColor($nLVWLPref, $nClrLVWiFiBk)
			GUISetBkColor($nClrGUIBkWiFi, $hWiFiPrefGUI)
		EndIf
		If $hWiFiSrvGUI <> 0 Then
			GUICtrlSetBkColor($nLblWiFiState, $nClrGUIBkWiFi)
			GUICtrlSetColor($nLblWiFiState, $nClrLblWiFi)
			GUISetBkColor($nClrGUIBkWiFi, $hWiFiSrvGUI)
		EndIf
		
		GUICtrlSetBkColor($nLblTop3, $nClrGUIBkWiFiFrame)
		GUICtrlSetBkColor($nLblLeft3, $nClrGUIBkWiFiFrame)
		GUICtrlSetBkColor($nLblBottom3, $nClrGUIBkWiFiFrame)
		GUICtrlSetBkColor($nLblRight3, $nClrGUIBkWiFiFrame)
	EndIf
	
	; ConfExtGUI
	If BitAnd($nGUI, 512) Then
		If $hConfExtGUI <> 0 Then
			GUICtrlSetColor($nLblExtProp, $nClrLblConf)	
			GUICtrlSetColor($nListExtProp, $nClrLExtTxt)
			GUICtrlSetBkColor($nListExtProp, $nClrLExtBk)
		
			GUICtrlSetColor($nLblProp, $nClrLblConf)
			GUICtrlSetColor($nLblPropVal, $nClrLblConf)
			GUICtrlSetColor($nRadioExtSet, $nClrLblConf)
			GUICtrlSetColor($nRadioExtNotSet, $nClrLblConf)
			GUICtrlSetColor($nUDInpExtVal, $nClrLblConf)
			
			GUISetBkColor($nClrGUIBkConf, $hConfExtGUI)
		EndIf
	EndIf

	; ConfFWGUI
	If BitAnd($nGUI, 4096) Then
		If $hConfFWGUI <> 0 Then		
			GUICtrlSetColor($nLblFWState, $nClrLblConf)
			GUICtrlSetColor($nLblFWCurState, $nClrLblConf)
						
			GUISetBkColor($nClrGUIBkConf, $hConfFWGUI)
		EndIf
	EndIf
	
	; MACGUI
	If BitAnd($nGUI, 1024) Then
		GUICtrlSetColor($nLblCurMAC, $nClrLblNormal)
		GUICtrlSetColor($nLblNewMAC, $nClrLblNormal)
	EndIf
	
	; AltConfIPGUI
	If BitAnd($nGUI, 2048) Then
		GUICtrlSetColor($nLblAltIPConf, $nClrLblConf)
		GUICtrlSetColor($nLblAltIP, $nClrLblConf)
		GUICtrlSetColor($nLblAltSM, $nClrLblConf)
		GUICtrlSetColor($nLblAltDG, $nClrLblConf)
		GUICtrlSetColor($nLblAltDNS1, $nClrLblConf)
		GUICtrlSetColor($nLblAltDNS2, $nClrLblConf)
		GUICtrlSetColor($nLblAltWINS1, $nClrLblConf)
		GUICtrlSetColor($nLblAltWINS2, $nClrLblConf)
		GUISetBkColor($nClrGUIBkConf, $hConfAltIPGUI)
	EndIf 
			
	; MainGUI
	GUICtrlSetColor($nLblState, $nClrStateGreen)
	
	GUICtrlSetBkColor($nLblTop1, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nLblLeft1, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nLblBottom1, $nClrGUIBkFrame)
	GUICtrlSetBkColor($nLblRight1, $nClrGUIBkFrame)
	
	; Tray WiFi GUI
	If BitAnd($nGUI, 8192) Then
		GUICtrlSetBkColor($nLVWLAvailTray, $nClrTrayBk)
		GUICtrlSetColor($nLVWLAvailTray, $nClrTrayTxt)
	EndIf
	
	$bPaint = TRUE
EndFunc


;**********************************************************************
; Apply GUI colors to (sub)GUI's
;**********************************************************************
Func ApplyGUIColors()
	$bPaint = FALSE
	
	GUISetBkColor($nClrGUIBk, $hConfGUI)
	GUISetBkColor($nClrGUIBk, $hIdentGUI)
	GUISetBkColor($nClrGUIBk, $hSharesGUI)
	GUISetBkColor($nClrGUIBk, $hDrivesGUI)
	GUISetBkColor($nClrGUIBk, $hProfilesGUI)
	GUISetBkColor($nClrGUIBk, $hOtherGUI)
	GUISetBkColor($nClrGUIBk, $hAboutGUI)
	GUISetBkColor($nClrTrayBk, $hTrayWiFiGUI)
	WinSetTrans($hTrayWiFiGUI, "", $nClrTrayTrans)
	
	$bPaint = TRUE
EndFunc


;**********************************************************************
; Apply new icons
;**********************************************************************
Func ApplyIcons()
	$bPaint = FALSE
	
	If $bIconLib Then
		SetWindowIcon($hMainGUI, $sIconLib, 4)
	Else
		SetWindowIcon($hMainGUI, @AutoItExe, 161)
	EndIf
	
	;AddILIcon($hIL, $nRes, $nResIcl, $sIniIcon = "", $sIconFile = "", $bSmallIcon = TRUE, $nIconSize = -1, $bReplace = FALSE, $nIdx = -1)
	AddILIcon($hILBtn, -170, 1, "Icon10", "", TRUE, -1, TRUE, 0) 	;  0 - Up
	AddILIcon($hILBtn, -171, 2, "Icon11", "", TRUE, -1, TRUE, 1) 	;  1 - Down
	AddILIcon($hILBtn, -172, 12, "Icon12", "", TRUE, -1, TRUE, 2)	;  2 - OK
	AddILIcon($hILBtn, -173, 13, "Icon13", "", TRUE, -1, TRUE, 3)	;  3 - Cancel
	AddILIcon($hILBtn, -174, 14, "Icon14", "", TRUE, -1, TRUE, 4)	;  4 - Apply
	AddILIcon($hILBtn, -175, 15, "Icon15", "", TRUE, -1, TRUE, 5)	;  5 - Plus
	AddILIcon($hILBtn, -176, 16, "Icon16", "", TRUE, -1, TRUE, 6)	;  6 - Minus
	AddILIcon($hILBtn, -177, 17, "Icon17", "", TRUE, -1, TRUE, 7)	;  7 - Refresh
	AddILIcon($hILBtn, -184, 8, "Icon18", "", TRUE, -1, TRUE, 8)	;  8 - Search
	AddILIcon($hILBtn, -186, 10, "Icon19", "", TRUE, -1, TRUE, 9)	;  9 - Edit
	AddILIcon($hILBtn, -189, 21, "Icon20", "", TRUE, -1, TRUE, 10)	; 10 - Netdrv conn
	AddILIcon($hILBtn, -190, 22, "Icon21", "", TRUE, -1, TRUE, 11)	; 11 - Netdrv disconn
	AddILIcon($hILBtn, -204, 36, "Icon22", "", TRUE, -1, TRUE, 12)	; 12 - Disabled
	AddILIcon($hILBtn, -223, 53, "Icon23", "", TRUE, -1, TRUE, 13)	; 13 - Start
	AddILIcon($hILBtn, -224, 54, "Icon24", "", TRUE, -1, TRUE, 14)	; 14 - Stop
	AddILIcon($hILBtn, -225, 55, "Icon25", "", TRUE, -1, TRUE, 15)	; 15 - Import
	AddILIcon($hILBtn, -226, 56, "Icon26", "", TRUE, -1, TRUE, 16)	; 16 - Export
	AddILIcon($hILBtn, -228, 58, "Icon27", "", TRUE, -1, TRUE, 17)	; 17 - Arrow back
	AddILIcon($hILBtn, -231, 61, "Icon28", "", TRUE, -1, TRUE, 18)	; 18 - Double arrow up
	AddILIcon($hILBtn, -232, 62, "Icon29", "", TRUE, -1, TRUE, 19)	; 19 - Double arrow down
	AddILIcon($hILBtn, -227, 57, "Icon30", "", TRUE, -1, TRUE, 20)	; 20 - Profiles
	AddILIcon($hILBtn, -236, 66, "Icon31", "", TRUE, -1, TRUE, 21)	; 21 - Trace start
	AddILIcon($hILBtn, -237, 67, "Icon32", "", TRUE, -1, TRUE, 22)	; 22 - Trace stop
	AddILIcon($hILBtn, -186, 10, "Icon33", "", TRUE, -1, TRUE, 23)	; 23 - Size button to right
	AddILIcon($hILBtn, -186, 10, "Icon52", "", TRUE, -1, TRUE, 24)	; 24 - WiFi Connect
	AddILIcon($hILBtn, -173, 13, "Icon53", "", TRUE, -1, TRUE, 25)	;  25 - WiFi Disconnect
	AddILIcon($hILBtn, -231, 78, "Icon84", "", TRUE, -1, TRUE, 26)	; 26 - Double arrow left
	AddILIcon($hILBtn, -232, 79, "Icon85", "", TRUE, -1, TRUE, 27)	; 27 - Double arrow right	
	AddILIcon($hILBtn, -182, 5, "Icon6", "", TRUE, -1, TRUE, 28)	; 28 - About
	AddILIcon($hILBtn, -177, 106, "Icon86", "", TRUE, -1, TRUE, 29)	; 29 - Refresh Tray
	
	AddILIcon($hILBtn2, -203, 35, "Icon0", "", TRUE, -1, TRUE, 0)	;  0 - Settings
	AddILIcon($hILBtn2, -229, 59, "Icon1", "", TRUE, -1, TRUE, 1)	;  1 - Ident
	AddILIcon($hILBtn2, -181, 6, "Icon2", "", TRUE, -1, TRUE, 2)	;  2 - Sharing
	AddILIcon($hILBtn2, -188, 20, "Icon3", "", TRUE, -1, TRUE, 3)	;  3 - Netdrives
	AddILIcon($hILBtn2, -227, 57, "Icon4", "", TRUE, -1, TRUE, 4)	;  4 - Profiles
	AddILIcon($hILBtn2, -191, 23, "Icon5", "", TRUE, -1, TRUE, 5)	;  5 - Other
	AddILIcon($hILBtn2, -182, 5, "Icon6", "", TRUE, -1, TRUE, 6)	;  6 - About
	AddILIcon($hILBtn2, -195, 27, "Icon7", "", TRUE, -1, TRUE, 7)	;  7 - WiFi
	AddILIcon($hILBtn2, -210, 41, "Icon8", "", TRUE, -1, TRUE, 8)	;  8 - NoWiFi
	AddILIcon($hILBtn2, -205, 37, "Icon9", "", TRUE, -1, TRUE, 9)	;  9 - Advanced
	AddILIcon($hILBtn2, -201, 33, "", "", TRUE, -1, TRUE, 10)	;  10 - Globe
	AddILIcon($hILBtn2, -202, 34, "", "", TRUE, -1, TRUE, 11)	;  11 - CMD
	AddILIcon($hILBtn2, -242, 72, "", "", TRUE, -1, TRUE, 12)	;  12 - Desktop
	AddILIcon($hILBtn2, -247, 77, "Icon83", "", TRUE, -1, TRUE, 13)	;  13 - Firewall
	
	AddILIcon($hILLVWLA, -196, 28, "Icon34", "", TRUE, -1, TRUE, 0) ; WiFi0
	AddILIcon($hILLVWLA, -197, 29, "Icon35", "", TRUE, -1, TRUE, 1) ; WiFi1-20
	AddILIcon($hILLVWLA, -198, 30, "Icon36", "", TRUE, -1, TRUE, 2) ; WiFi21-40
	AddILIcon($hILLVWLA, -199, 31, "Icon37", "", TRUE, -1, TRUE, 3) ; WiFi41-60
	AddILIcon($hILLVWLA, -200, 32, "Icon38", "", TRUE, -1, TRUE, 4) ; WiFi61-80
	AddILIcon($hILLVWLA, -211, 42, "Icon40", "", TRUE, -1, TRUE, 5) ; Secured
	AddILIcon($hILLVWLA, -212, 43, "Icon41", "", TRUE, -1, TRUE, 6) ; Unsecured
	AddILIcon($hILLVWLA, -213, 44, "Icon42", "", TRUE, -1, TRUE, 7) ; Infrastr.
	AddILIcon($hILLVWLA, -214, 45, "Icon43", "", TRUE, -1, TRUE, 8) ; Infrastr.Conn.
	AddILIcon($hILLVWLA, -215, 46, "Icon44", "", TRUE, -1, TRUE, 9) ; Adhoc
	AddILIcon($hILLVWLA, -216, 47, "Icon45", "", TRUE, -1, TRUE, 10) ; Adhoc-Conn.
	AddILIcon($hILLVWLA, -217, 48, "Icon46", "", TRUE, -1, TRUE, 11) ; Profile
	AddILIcon($hILLVWLA, -218, 49, "Icon47", "", TRUE, -1, TRUE, 12) ; N
	AddILIcon($hILLVWLA, -219, 50, "Icon48", "", TRUE, -1, TRUE, 13) ; G
	AddILIcon($hILLVWLA, -220, 51, "Icon49", "", TRUE, -1, TRUE, 14) ; B
	AddILIcon($hILLVWLA, -221, 52, "Icon50", "", TRUE, -1, TRUE, 15) ; A
	AddILIcon($hILLVWLA, -209, 73, "Icon39", "", TRUE, -1, TRUE, 16) ; WiFi81-100
	AddILIcon($hILLVWLA, -243, 74, "Icon51", "", TRUE, -1, TRUE, 17) ; AC
	AddILIcon($hILLVWLA, -257, 81, "Icon87", "", TRUE, -1, TRUE, 18) ; NotConnectable
	
	AddILIcon($hILLVWLP, -213, 44, "Icon54", "", TRUE, -1, TRUE, 0) ; Preferred Infra
	AddILIcon($hILLVWLP, -214, 45, "Icon55", "", TRUE, -1, TRUE, 1) ; Preferred Infra connected
	AddILIcon($hILLVWLP, -215, 46, "Icon56", "", TRUE, -1, TRUE, 2) ; Preferred Adhoc
	AddILIcon($hILLVWLP, -216, 47, "Icon57", "", TRUE, -1, TRUE, 3) ; Preferred Adhoc connected
	
	AddILIcon($hILLVShares, -230, 60, "Icon62", "", TRUE, -1, TRUE, 0)
	AddILIcon($hILLVShares, -241, 71, "Icon63", "", TRUE, -1, TRUE, 1)
	
	AddILIcon($hILTVDrv, -201, 33, "Icon64", "", TRUE, -1, TRUE, 0)
	AddILIcon($hILTVDrv, -229, 59, "Icon65", "", TRUE, -1, TRUE, 1)
	AddILIcon($hILTVDrv, -230, 60, "Icon66", "", TRUE, -1, TRUE, 2)
	AddILIcon($hILTVDrv, -241, 71, "Icon67", "", TRUE, -1, TRUE, 3)
	
	AddILIcon($hILCombo, -203, 35, "Icon0", "", TRUE, -1, TRUE, 0)		;  Settings
	AddILIcon($hILCombo, 0, 59, "Icon1", "", TRUE, -1, TRUE, 1)			;  Ident
	AddILIcon($hILCombo, -181, 6, "Icon2", "", TRUE, -1, TRUE, 2)		;  Sharing
	AddILIcon($hILCombo, -188, 20, "Icon3", "", TRUE, -1, TRUE, 3)		;  Netdrives
	AddILIcon($hILCombo, -227, 57, "Icon4", "", TRUE, -1, TRUE, 4)		;  Profiles
	AddILIcon($hILCombo, -191, 23, "Icon5", "", TRUE, -1, TRUE, 5)		;  Other
	AddILIcon($hILCombo, -182, 5, "Icon6", "", TRUE, -1, TRUE, 6)		;  About
	AddILIcon($hILCombo, -195, 27, "Icon7", "", TRUE, -1, TRUE, 7)		;  WiFi
	AddILIcon($hILCombo, -205, 37, "Icon9", "", TRUE, -1, TRUE, 8)		;  Advanced
	AddILIcon($hILCombo, -217, 48, "Icon46", "", TRUE, -1, TRUE, 9)	;  Favorite
	AddILIcon($hILCombo, -183, 7, "Icon58", "", TRUE, -1, TRUE, 10)		;  Service
	
	Local $bIsWLANI = IsWlanI($sLastAdapterShow)
	If $nLastAdapterState = 4 Or $nLastAdapterState = 5 Then
		If IsWlanI($sLastAdapterShow) Then
			SetIconFrom($nIconState, 195, -27, "Icon81")
		Else
			SetIconFrom($nIconState, 185, -9, "Icon79")
		EndIf
	Else
		If $bIsWLANI Then
			SetIconFrom($nIconState, 235, -65, "Icon82")
		ELse
			SetIconFrom($nIconState, 179, -19, "Icon80")
		EndIf
	EndIf
		
	SetIconFrom($nIconPreWiFiState, 183, -7, "Icon58")
	SetIconFrom($nIconWiFiState, 183, -7, "Icon58")
	SetIconFrom($nIconFWState, 183, -7, "Icon58")
	SetIconFrom($nIconIdent, 185, -9, "Icon59")
	SetIconFrom($nIconPing, 238, -68, "Icon60")
	SetIconFrom($nIconShareState, 183, -7, "Icon61")
	SetIconFrom($nIconLang, 201, -33, "Icon68")
	SetIconFrom($nIconScheme, 191, -23, "Icon69")
	SetIconFrom($nIconDebug, 184, -8, "Icon70")
	SetIconFrom($nIconStartTray, 233, -63, "Icon71")
	SetIconFrom($nIconMinTray, 206, -38, "Icon72")
	SetIconFrom($nIconCloseTray, 207, -39, "Icon73")
	SetIconFrom($nIconShowTrayAct, 208, -40, "Icon74")
	SetIconFrom($nIconShowTrayAlways, 0, -4, "")
	SetIconFrom($nIconTrayTip, 239, -69, "Icon75")
	SetIconFrom($nIconShowOnlyCon, 185, -9, "Icon83")
	SetIconFrom($nIconTrayLimitInfo, 288, -111, "Icon98")
	SetIconFrom($nIconTrayAdaptWiFi, 289, -112, "Icon99")
	SetIconFrom($nIconTrayShowMAC, 290, -113, "Icon100")
	SetIconFrom($nIconTrayShowIPv6, 291, -114, "Icon101")
	SetIconFrom($nIconLastPos, 242, -72, "Icon76")
	SetIconFrom($nIconLastPage, 240, -70, "Icon77")
	SetIconFrom($nIconWMI, 183, -7, "Icon78")
	SetIconFrom($nIconAbout, 0, -4, "", FALSE)
	SetIconFrom($nIconAboutAI3, 180, -3, "", FALSE)
	
	AddILIcon($hILLVWLATray, -272, 95, "Icon34", "", FALSE, $nIconSizeBig, TRUE, 2) ; WiFi0
	AddILIcon($hILLVWLATray, -273, 96, "Icon35", "", FALSE, $nIconSizeBig, TRUE, 3) ; WiFi1-20
	AddILIcon($hILLVWLATray, -274, 97, "Icon36", "", FALSE, $nIconSizeBig, TRUE, 4) ; WiFi21-40
	AddILIcon($hILLVWLATray, -275, 98, "Icon37", "", FALSE, $nIconSizeBig, TRUE, 5) ; WiFi41-60
	AddILIcon($hILLVWLATray, -276, 99, "Icon38", "", FALSE, $nIconSizeBig, TRUE, 6) ; WiFi61-80
	AddILIcon($hILLVWLATray, -277, 100, "Icon39", "", FALSE, $nIconSizeBig, TRUE, 7) ; WiFi81-100
	AddILIcon($hILLVWLATray, -278, 101, "Icon40", "", FALSE, $nIconSizeBig, TRUE, 8) ; Secured
	AddILIcon($hILLVWLATray, -279, 102, "Icon44", "", FALSE, $nIconSizeBig, TRUE, 9) ; Adhoc
	AddILIcon($hILLVWLATray, -280, 103, "Icon46", "", FALSE, $nIconSizeBig, TRUE, 10) ; Preferred
	AddILIcon($hILLVWLATray, -281, 104, "Icon87", "", FALSE, $nIconSizeBig, TRUE, 11) ; No access
	
	If $hILTrayWiFi <> 0 Then ImageList_Destroy($hILTrayWiFi)
	If $hILTrayRS <> 0 Then ImageList_Destroy($hILTrayRS)		
	TrayInitIcons()
	If $bShowTrayAct Or $bShowTrayAlways Or $bInTray Then
		TrayIconSetState(2)
		TrayIconSetState()
		If $bShowTrayAct Then SetTrayIcon($nLastTrayState)
	EndIf
	
	$bPaint = TRUE
EndFunc


;**********************************************************************
; Get default scheme
;**********************************************************************
Func GetSchemeDefault()
	$nClrStateGreen		= 0x007500
	$nClrStateRed		= 0xB00000
	$nClrSvcStart		= 0x44DD44
	$nClrSvcStop		= 0xDD4444
	$nClrBtnChkTxt		= 0x0
	$nClrBtnChkBk		= 0xC8DCFF
	$nClrBtnChkGrad		= 0x96AAE6
	$nClrBtnUnchkTxt	= 0x0
	$nClrBtnUnchkBk		= 0xE6FFFF
	$nClrBtnUnchkGrad	= 0xB4D2D2
	$nClrBtnDhcpTxt		= 0x0
	$nClrBtnDhcpBk		= GetBGRColor(0xFEFEFE) ; 0xF0FFCD
	$nClrBtnDhcpGrad	= GetBGRColor(0xACACB0) ; 0xBECD9B
	$nClrBtnTxtDisabled	= GetBGRColor(0x48484A)
	$nClrBtnBkActive	= -1
	$nClrBtnFocus		= GetBGRColor(0xFF9000)
	$nClrBtnNormalTxt	= 0x0
	$nClrBtnNormalBk	= GetBGRColor(0xFEFEFE)
	$nClrBtnNormalGrad	= GetBGRColor(0xACACB0)
	$nClrBtnFrame		= 0x323030
	$nClrBtnFrameDisabled = 0x525050
	$nClrWiFiConnect	= GetBGRColor(0x0000FF)
	$nClrTITxt			= 0x0
	$nClrTIBk			= GetBGRColor(0xD0D0D4)
	$nClrTIGrad			= GetBGRColor(0x8D8D91)
	$nClrTISelTxt		= 0x0
	$nClrTISelBk		= GetBGRColor(0xE8E8EC)
	$nClrTISelGrad		= GetBGRColor(0xE8E8EC)
	$nClrTIFocus		= GetBGRColor(0xFF9000)
	$nClrTIConfTxt		= 0x0
	$nClrTIConfBk		= GetBGRColor(0xFFFFFF)
	$nClrTIConfGrad		= GetBGRColor(0xD0D0D4)
	$nClrTIConfSelTxt	= 0x0
	$nClrTIConfSelBk	= GetBGRColor(0xD0D0D4)
	$nClrTIConfSelGrad	= GetBGRColor(0xD0D0D4)
	$nClrGUIBkMain		= 0xD0D0D4
	$nClrGUIBk			= 0xE8E8EC
	$nClrGUIBkSub		= 0xD0D0D4
	$nClrGUIBkConf		= 0xD0D0D4
	$nClrTIWiFiTxt		= 0x0
	$nClrTIWiFiBk		= GetBGRColor(0xFFFFFF)
	$nClrTIWiFiGrad		= GetBGRColor(0xBEBEC2)
	$nClrTIWiFiSelTxt	= 0x0
	$nClrTIWiFiSelBk	= GetBGRColor(0xE8E8EC)
	$nClrTIWiFiSelGrad	= GetBGRColor(0xE8E8EC)
	$nClrGUIBkWiFi		= 0xE8E8EC
	$nClrGUIBkAuth		= 0xE8E8EC
	$nClrLblNormal		= 0x0
	$nClrLblConf		= 0x0
	$nClrLblWiFi		= 0x0
	$nClrLVWiFiTxt		= 0x0
	$nClrLVWiFiBk		= 0xFFFFFF
	$nClrLVSharesTxt	= 0x0
	$nClrLVSharesBk		= 0xFFFFFF
	$nClrLVDrivesTxt	= 0x0
	$nClrLVDrivesBk		= 0xFFFFFF
	$nClrLVPingTxt		= 0x0
	$nClrLVPingBk		= 0xFFFFFF
	$nClrLProfileTxt	= 0x0
	$nClrLProfileBk		= 0xFFFFFF
	$nClrLExtTxt		= 0x0
	$nClrLExtBk			= 0xFFFFFF
	$nClrGUIBkFrame		= 0x303032
	$nClrGUIBkConfFrame	= 0x303032
	$nClrGUIBkWiFiFrame	= 0x303032
	$nClrTrayBk			= 0xFFFFFF
	$nClrTrayTxt		= 0x0
	$nClrTrayTrans		= 0x0000FF
	$nClrTraySelBk		= GetBGRColor(GetSysColor($COLOR_HIGHLIGHT))
	$nClrTraySelTxt		= GetBGRColor(GetSysColor($COLOR_HIGHLIGHTTEXT))
	$nClrTrayConnect	= GetBGRColor(0x0000FF)
	$nClrTrayBtnTxt		= 0x0
	$nClrTrayBtnBk		= 0xFEFEFE
	$nClrTrayBtnGrad	= 0xB0ACAC
	$nClrTrayBtnFrame	= 0x323030
	$nClrTrayTxtGray	= 0x686868
EndFunc


;**********************************************************************
; Classic scheme
;**********************************************************************
Func GetSchemeClassic()
	$nClrStateGreen		= 0x007500
	$nClrStateRed		= 0xB00000
	$nClrSvcStart		= 0x44DD44
	$nClrSvcStop		= 0xDD4444
	$nClrBtnChkTxt		= 0x0
	$nClrBtnChkBk		= 0x95B0D0
	$nClrBtnChkGrad		= 0x95B0D0
	$nClrBtnUnchkTxt	= 0x0
	$nClrBtnUnchkBk		= 0xD0E5E5
	$nClrBtnUnchkGrad	= 0xD0E5E5
	$nClrBtnDhcpTxt		= 0x0
	$nClrBtnDhcpBk		= 0xD0E0B0
	$nClrBtnDhcpGrad	= 0xD0E0B0
	$nClrBtnTxtDisabled	= GetBGRColor(0x4D4D4D)
	$nClrBtnBkActive	= 0xFFFFFF
	$nClrBtnFocus		= 0x0
	$nClrBtnNormalTxt	= 0x0
	$nClrBtnNormalBk	= GetBGRColor(0xD4D0C8)
	$nClrBtnNormalGrad	= GetBGRColor(0xD4D0C8)
	$nClrBtnFrame		= 0x0
	$nClrBtnFrameDisabled = 0x0
	$nClrWiFiConnect	= GetBGRColor(0x0000FF)
	$nClrTITxt			= 0x0
	$nClrTIBk			= GetBGRColor(0xBFBDB8)
	$nClrTIGrad			= GetBGRColor(0xBFBDB8)
	$nClrTISelTxt		= 0x0
	$nClrTISelBk		= GetBGRColor(0xE6E4E0)
	$nClrTISelGrad		= GetBGRColor(0xE6E4E0)
	$nClrTIFocus		= 0x0
	$nClrTIConfTxt		= 0x0
	$nClrTIConfBk		= GetBGRColor(0xD6D4D0)
	$nClrTIConfGrad		= GetBGRColor(0xD6D4D0)
	$nClrTIConfSelTxt	= 0x0
	$nClrTIConfSelBk	= GetBGRColor(0xBFBDB8)
	$nClrTIConfSelGrad	= GetBGRColor(0xBFBDB8)
	$nClrGUIBkMain		= 0xD4D0C8
	$nClrGUIBk			= 0xE6E4E0
	$nClrGUIBkSub		= 0xD4D0C8
	$nClrGUIBkConf		= 0xBFBDB8
	$nClrTIWiFiTxt		= 0x0
	$nClrTIWiFiBk		= GetBGRColor(0xD6D4D0)
	$nClrTIWiFiGrad		= GetBGRColor(0xD6D4D0)
	$nClrTIWiFiSelTxt	= 0x0
	$nClrTIWiFiSelBk	= GetBGRColor(0xE6E4E0)
	$nClrTIWiFiSelGrad	= GetBGRColor(0xE6E4E0)
	$nClrGUIBkWiFi		= 0xE6E4E0
	$nClrGUIBkAuth		= 0xD4D0C8
	$nClrLblNormal		= 0x0
	$nClrLblConf		= 0x0
	$nClrLblWiFi		= 0x0
	$nClrLVWiFiTxt		= 0x0
	$nClrLVWiFiBk		= 0xFFFFFF
	$nClrLVSharesTxt	= 0x0
	$nClrLVSharesBk		= 0xFFFFFF
	$nClrLVDrivesTxt	= 0x0
	$nClrLVDrivesBk		= 0xFFFFFF
	$nClrLVPingTxt		= 0x0
	$nClrLVPingBk		= 0xFFFFFF
	$nClrLProfileTxt	= 0x0
	$nClrLProfileBk		= 0xFFFFFF
	$nClrLExtTxt		= 0x0
	$nClrLExtBk			= 0xFFFFFF
	$nClrGUIBkFrame		= 0x0
	$nClrGUIBkConfFrame	= 0x0
	$nClrGUIBkWiFiFrame	= 0x0
	$nClrTrayBk			= 0xFFFFFF
	$nClrTrayTxt		= 0x0
	$nClrTrayTrans		= 255
	$nClrTraySelBk		= GetBGRColor(GetSysColor($COLOR_HIGHLIGHT))
	$nClrTraySelTxt		= GetBGRColor(GetSysColor($COLOR_HIGHLIGHTTEXT))
	$nClrTrayConnect	= GetBGRColor(0x0000FF)
	$nClrTrayBtnTxt		= 0x0
	$nClrTrayBtnBk		= GetBGRColor(0xD4D0C8)
	$nClrTrayBtnGrad	= GetBGRColor(0xD4D0C8)
	$nClrTrayBtnFrame	= 0x323030
	$nClrTrayBtnFocus	= 0x0
	$nClrTrayTxtGray	= 0x686868
EndFunc


;**********************************************************************
; Apply (new) language strings to ctrl's
;**********************************************************************
Func ApplyLanguage()
	If $sCurLangFile = "" Then Return
	
	SetDefaultLang()
	ReadLanguageFile($sCurLangFile, $sGSection)
	
	WinSetTitle($hMainGUI, "", $sMainTitle)
	
	;Properties GUI
	GUICtrlSetTip($nBtnRefresh, $sTTRefresh)
	GUICtrlSetData($nChkScan, $sChkForceScan)
	SetCtrlPos($hConfGUI, $nChkScan, $sChkForceScan, 6, 53, 394)
	
	SetODBtnData($nTIConf, $sTIConfig)
	SetODBtnData($nTIIdent, $sTIIdent)
	SetODBtnData($nTISharing, $sTISharing)
	SetODBtnData($nTIDrives, $sTIDrives)
	SetODBtnData($nTIProfiles, $sTIProfiles)
	SetODBtnData($nTIOther, $sTIOther)
	SetODBtnData($nTIAbout, $sTIAbout)
	
	If $bTabSmall Then
		GUICtrlSetTip($nTIConf, $sTIConfig)
		GUICtrlSetTip($nTIIdent, $sTIIdent)
		GUICtrlSetTip($nTISharing, $sTISharing)
		GUICtrlSetTip($nTIDrives, $sTIDrives)
		GUICtrlSetTip($nTIProfiles, $sTIProfiles)
		GUICtrlSetTip($nTIOther, $sTIOther)
		GUICtrlSetTip($nTIAbout, $sTIAbout)
	EndIf
	
	Local $nX = GetScaled(6)
	Local $nY = GetScaled(84)
	Local $nS = 3 ; GetScaled(3)
	
	SetODBtnSize($hConfGUI, $nTIIP, $sTIIPSettings, $nX, $nY, FALSE)
	
	If Not BitAnd($nGUIDisable, 32) Then
		$nX += $nS
		SetODBtnSize($hConfGUI, $nTIWiFi, $sTIWiFi, $nX, $nY)
	EndIf
	
	If Not BitAnd($nGUIDisable, 64) Then
		$nX += $nS
		SetODBtnSize($hConfGUI, $nTIAdv, $sTIAdvanced, $nX, $nY)
	EndIf
	
	If Not BitAnd($nGUIDisable, 1024) Then
		$nX += $nS
		SetODBtnSize($hConfGUI, $nTIFirewall, $sTIFirewall, $nX, $nY)
	EndIf
	
	$nX = GetScaled(6)
	$nY = GetScaled(7)
	
	SetODBtnSize($hConfWiFiGUI, $nTIWiFiAV, $sTIWiFiAvailable, $nX, $nY, FALSE)
	
	If Not BitAnd($nGUIDisable, 128) Then
		$nX += $nS
		SetODBtnSize($hConfWiFiGUI, $nTIWiFiPref, $sTIWiFiPreferred, $nX, $nY, FALSE)
	EndIf
	
	If Not BitAnd($nGUIDisable, 256) Then
		$nX += $nS
		SetODBtnSize($hConfWiFiGUI, $nTIWiFiSrv, $sTIWiFiService, $nX, $nY, FALSE)
	EndIf
	
	SetODBtnData($nTIIP, $sTIIPSettings, -1, -1, FALSE)
	SetODBtnData($nTIWiFi, $sTIWiFi, -1, -1, FALSE)
	GUICtrlSetTip($nBtnWLRef, $sTTWiFiRefresh)
	SetODBtnData($nTIWiFiAV, $sTIWiFiAvailable, -1, -1, FALSE)
	GUICtrlSetData($nLVWLAvail, $sLVWiFiList & "| | | ")
	GUICtrlSetData($nLVWLPref, " |" & $sLVWiFiPref)
	SetODBtnData($nTIWiFiPref, $sTIWiFiPreferred, -1, -1, FALSE)
	GUICtrlSetTip($nBtnWLRefPref, $sTTWiFiRefPref)
	SetODBtnData($nTIWiFiSrv, $sTIWiFiService, -1, -1, FALSE)
	GUICtrlSetData($nLblPreWiFiState, $sLblWiFiCurState & ":")
	GUICtrlSetData($nLblPreWiFiCurState, $sServiceStopped)
	SetODBtnData($nBtnPreWiFi, $sServiceStart, -1, -1, FALSE)
	
	GUICtrlSetData($nLblWiFiState, $sLblWiFiCurState & ":")
	GUICtrlSetData($nLblWiFiCurState, $sServiceStopped)
	SetODBtnData($nBtnWiFi, $sServiceStart, -1, -1, FALSE)
	If $bWiFiCreated Then UpdateWiFiState()
	
	GUICtrlSetData($nLblAdapterState, $sLblAdapterState & ":")
	GUICtrlSetData($nLblAdapterSpeed, $sLblAdapterSpeed & ":")
	
	SetODBtnData($nBtnSpeed, $nLastAdapterSpeed & " " & $sAdapterSpeed, -1, -1, FALSE)
	SetODBtnData($nBtnAdapterMAC, $sLblAdapterMAC & ":", -1, -1, FALSE)
	GUICtrlSetData($nLblCurMAC, $sLblCurMAC & ":")
	GUICtrlSetData($nLblNewMAC, $sLblNewMAC & ":")
	
	SetODBtnData($nBtnMACApply, $sBtnApply, -1, -1, FALSE)
	SetODBtnData($nBtnMACCancel, $sBtnCancel, -1, -1, FALSE)
	SetODBtnData($nBtnMACRestore, $sBtnRestore, -1, -1, FALSE)

	GUICtrlSetTip($nBtnDhcpInfo, StringReplace($sBtnDHCPInfo, "&", ""))
	GUICtrlSetTip($nBtnDhcpRelease, StringReplace($sBtnDHCPRelease, "&", ""))
	GUICtrlSetTip($nBtnDhcpRenew, StringReplace($sBtnDHCPRenew, "&", ""))
	GUICtrlSetTip($nBtnIPAltShow, $sTTAltConf)
	GUICtrlSetTip($nBtnIPAltHide, $sTTGenConf)
	
	GUICtrlSetData($nRadIPDHCP, $sBtnIPDHCP)
	GUICtrlSetData($nRadIPStatic, $sBtnIPStatic & ":")
	GUICtrlSetData($nChkDGMode, $sBtnDynamic)
	GUICtrlSetData($nLblStaticIP, $sLblStaticIP & ":")
	GUICtrlSetData($nLblStaticSM, $sLblStaticSM & ":")
	GUICtrlSetData($nLblStaticDG, $sLblStaticDG & ":")
	GUICtrlSetData($nLblDNS, $sLblDNS & ":")
	GUICtrlSetData($nRadDNSDHCP, $sBtnDNSDHCP)
	GUICtrlSetData($nRadDNSStatic, $sBtnDNSStatic & ":")
	GUICtrlSetData($nLblWINS, $sLblWINS & ":")
	GUICtrlSetData($nRadWINSDHCP, $sBtnWINSDHCP)
	GUICtrlSetData($nRadWINSStatic, $sBtnWINSStatic & ":")

	GUICtrlSetData($nRadIPPrivate, $sBtnIPAutoOn)
	GUICtrlSetData($nRadIPNone, $sBtnIPAutoOff)
	GUICtrlSetData($nRadIPUser, $sUserConf & ":")
	GUICtrlSetTip($nRadIPUser, $sTTAltIP)
	
	SetCtrlPos($hConfIPGUI, $nRadIPDHCP, $sBtnIPDHCP, 6, 7, 298, 20)
	SetCtrlPos($hConfIPGUI, $nRadIPStatic, $sBtnIPStatic & ":", 6, 28, 298, 20)
	SetCtrlPos($hConfIPGUI, $nRadDNSDHCP, $sBtnDNSDHCP, 6, 127, 356, 21)
	SetCtrlPos($hConfIPGUI, $nRadDNSStatic, $sBtnDNSStatic & ":", 6, 148, 356, 21)
	SetCtrlPos($hConfIPGUI, $nRadWINSDHCP, $sBtnWINSDHCP, 6, 198, 356, 21)
	SetCtrlPos($hConfIPGUI, $nRadWINSStatic, $sBtnWINSStatic & ":", 6, 219, 356, 21)
	
	SetCtrlPos($hConfAltIPGUI, $nRadIPPrivate, $sBtnIPAutoOn, 6, 7, 330, 20)
	SetCtrlPos($hConfAltIPGUI, $nRadIPNone, $sBtnIPAutoOff, 6, 28, 356, 20)
	SetCtrlPos($hConfAltIPGUI, $nRadIPUser, $sUserConf & ":", 6, 49, 356, 20)
		
	SetODBtnData($nBtnApply, $sBtnApply)
	SetODBtnData($nBtnOK, $sBtnOK)
	SetODBtnData($nBtnCancel, $sBtnCancel)
	
	GUICtrlSetData($nLblState, $sStateReady)
	SetODBtnData($nBtnYes, $sBtnYes)
	SetODBtnData($nBtnNo, $sBtnNo)
	
	SetODBtnData($nBtnAddrAdd, $sBtnAdd, -1, -1, FALSE)
	SetODBtnData($nBtnAddrDel, $sBtnDelete, -1, -1, FALSE)
	SetODBtnData($nBtnAddrOK, $sBtnOK, -1, -1, FALSE)
	SetODBtnData($nBtnAddrCancel, $sBtnCancel, -1, -1, FALSE)
	SetODBtnData($nBtnAddAddrAdd, $sBtnAddShort, -1, -1, FALSE)
	SetODBtnData($nBtnAddAddrCancel, $sBtnCancel, -1, -1, FALSE)
	
	If $nLastAdapterState < 3 Then
		GUICtrlSetTip($nIconState, $sTTDiscon)
	Else
		GUICtrlSetTip($nIconState, $sTTCon)
	EndIf
	
	;WiFi
	GUICtrlSetData($nLblWLNot, $sLblWiFiNoDevice)
	GUICtrlSetData($nLblWLNoApi, $sLblWiFiWlanApiNF)
	GUICtrlSetData($nChkWLEditUI, $sChkWiFiEditUI)
	SetCtrlPos($hWiFiPrefGUI, $nChkWLEditUI, $sChkWiFiEditUI, 263, 36, 105)
	
	SetODBtnData($nBtnWLCon, $sBtnWiFiConnect, -1, -1, FALSE)
	SetODBtnData($nBtnWLDiscon, $sBtnWiFiDisconnect, -1, -1, FALSE)
	SetODBtnData($nBtnWLAdd, $sBtnAddShort, -1, -1, FALSE)
	SetODBtnData($nBtnWLDel, $sBtnDelete, -1, -1, FALSE)
	SetODBtnData($nBtnWLEdit, $sBtnChange, -1, -1, FALSE)
	SetODBtnData($nBtnWLImport, $sBtnWiFiImport, -1, -1, FALSE)
	SetODBtnData($nBtnWLExport, $sBtnWiFiExport, -1, -1, FALSE)
	
	;Advanced
	SetODBtnData($nTIAdv, $sTIAdvanced)
	GUICtrlSetData($nLblExtProp, $sLblExtProp)
	GUICtrlSetData($nLblProp, $sLblProp)
	GUICtrlSetData($nLblPropVal, $sLblPropVal)
	GUICtrlSetData($nRadioExtNotSet, $sRadioNotSet)
	
	;Firewall
	SetODBtnData($nTIFirewall, $sTIFirewall)
		
	;Ident GUI
	GUICtrlSetData($nLblCNI, $sLblCNI & ":")
	GUICtrlSetData($nLblCN, $sLblComputer & ":")
	GUICtrlSetData($nLblWG, $sLblWorkgroup & ":")
	GUICtrlSetData($nLblPriDNS, $sLblPriDNS & ":")
	GUICtrlSetData($nLblPing, $sLblPing & ":")
	SetODBtnIcon($nBtnPing, 13, FALSE)
	SetODBtnData($nBtnPing, $sBtnPingStart, -1, -1, FALSE)
	GUICtrlSetData($nLblCount, $sLblPingCount & ":")
	GUICtrlSetData($nLblTime, $sLblPingTime & ":")
	GUICtrlSetData($nChkPing, $sChkPingLimit)
	SetCtrlPos($hIdentGUI, $nChkPing, $sChkPingLimit, 170, 153, 110)
	GUICtrlSendMsg($nLVPing, $LVM_DELETEALLITEMS, 0, 0)
	SetODBtnData($nBtnTrace, $sBtnTrace, -1, -1, FALSE)
	GUICtrlSetData($nChkTrace, $sChkTrace)
	SetCtrlPos($hIdentGUI, $nChkTrace, $sChkTrace, 290, 153, 110)
	GUICtrlSetData($nLblTrace, $sLblTrace)
	GUICtrlSetData($nChkReverse, $sChkReverse)
	SetCtrlPos($hIdentGUI, $nChkReverse, $sChkReverse, 5, 207, 380)
		
	;Shares GUI
	GUICtrlSetData($nLblFileShr, $sLblFileSharing & ":")
	GUICtrlSetData($nLblShrInfo, $sServiceStopped)
	SetODBtnData($nBtnShr, $sBtnShareStart, -1, -1, FALSE)
	SetODBtnData($nBtnShrAdd, $sBtnAddShort, -1, -1, FALSE)
	SetODBtnData($nBtnShrDel, $sBtnDelete, -1, -1, FALSE)
	SetODBtnData($nBtnShrAddShow, $sBtnAdd, -1, -1, FALSE)
	GUICtrlSetData($nLblShrName, $sLblShareName & ":")
	GUICtrlSetData($nLblShrPath, $sLblSharePath & ":")
	GUICtrlSetData($nLblShrUsr, $sLblShareUser & ":")
	GUICtrlSetData($nLblShrPW, $sLblSharePW & ":")
	GUICtrlSetTip($nComboShrUsr, $sTTShareUser & @LF & $sTTShareUserLen & " " & $UNLEN & " " & $sTTInputChars & ".")
	GUICtrlSetTip($nInpShrPW, $sTTSharePWLen & " " & $PWLEN & " " & $sTTInputChars & ".")
	GUICtrlSetTip($nInpShrName, $sTTShareName)
	GUICtrlSetTip($nBtnShrRef, $sTTShareRefresh)
	GUICtrlSetData($nChkShrAll, $sChkShareAll)
	SetCtrlPos($hSharesGUI, $nChkShrAll, $sChkShareAll, 5, 87, 270)
	GUICtrlSetTip($nChkShrAll, $sTTShareAll)
	SetODBtnData($nBtnShrSetPW, $sBtnShareSetPW, -1, -1, FALSE)
	GUICtrlSetData($nEditShrAdmin, $sEditShareAdmin)
	GUICtrlSetData($nLblShrFolders, $sLblSharedFolders & ":")
	GUICtrlSetData($nLVShares, $sLVShares)
	GUICtrlSetData($nMIBrowseShr, $sMIShareBrowse)
	GUICtrlSetData($nMIDelShr, $sMIShareDel)
	
	GUICtrlSetData($nLVNetConDet, $sLVNetConPropVal)
		
	;Drives GUI
	GUICtrlSetData($nLblDrvLetter, $sLblDriveLetter & ":")
	GUICtrlSetTip($nBtnDrvRef, $sTTDrivesRefresh)
	
	SetODBtnData($nBtnDrvAdd, $sBtnConnect, -1, -1, FALSE)
	SetODBtnData($nBtnDrvDel, $sBtnDisconnect, -1, -1, FALSE)
	GUICtrlSetData($nMIBrowseNetDrv, $sBtnConnect)
	
	GUICtrlSetData($nLblDrvPath, $sLblDrivePath & ":")
	GUICtrlSetData($nLblDrvUsr, $sLblDriveUser & ":")
	GUICtrlSetData($nLblDrvPW, $sLblDrivePW & ":")
	GUICtrlSetData($nLblDrvCon, $sLblDrivesCon & ":")
	GUICtrlSetData($nLVDrives, $sLVDrivesCon)
	GUICtrlSetData($nMIBrowseDrv, $sMIDriveBrowse)
	GUICtrlSetData($nMIDelDrv, $sMIDriveDiscon)
	
	SetODBtnData($nBtnDrvNet, $sBtnDrvNet, -1, -1, FALSE)
	SetODBtnData($nBtnDrvNetShow, $sBtnDrvNetShow, -1, -1, FALSE)
	GUICtrlSetData($nLblDrvNet, $sLblDrvNet & ":")
	SetODBtnData($nBtnDrvNetAdd, $sBtnAddShort, -1, -1, FALSE)
	SetODBtnData($nBtnDrvNetDel, $sBtnDelete, -1, -1, FALSE)
	SetODBtnData($nBtnDrvNetReset, $sBtnDrvNetReset, -1, -1, FALSE)
	
	; Profiles GUI
	GUICtrlSetData($nLblProfFile, $sLblProfFile & ":")
	GUICtrlSetTip($nBtnProfFile, $sBtnProfFile)
	GUICtrlSetTip($nBtnProfInt, $sBtnProfInt)
	GUICtrlSetTip($nBtnProfExt, $sBtnProfExt)
	GUICtrlSetTip($nBtnProfRef, $sTTProfRefresh)
	SetODBtnData($nBtnProfApply, $sBtnApply, -1, -1, FALSE)
	GUICtrlSetData($nLblProfList, $sLblProfList & ":")
	GUICtrlSetData($nLblProfDesc, $sLblProfDesc & ":")
	
	; Others GUI
	GUICtrlSetData($nLblSurface, $sLblSurface & ":")
	GUICtrlSetData($nLblLang, $sGrpLanguage & ":")
	GUICtrlSetTip($nComboLang, $sLblLangAuthor & ": " & $sCurLangAuthor & @LF & $sLblLangVersion & ": " & $sCurLangVer)
	GUICtrlSetTip($nBtnLangExt, $sBtnLangExt)
	GUICtrlSetData($nRadioOSFont, $sRadioOSFont)
	GUICtrlSetData($nRadioFont, $sRadioFont & ":")
	GUICtrlSetData($nChkIcons, $sChkIcons)
	
	GUICtrlSetData($nLblTrayOpt, $sGrpTrayOptions & ":")	
	GUICtrlSetData($nChkStartTray, $sChkTrayStart)
	GUICtrlSetData($nChkMinTray, $sChkTrayMin)
	GUICtrlSetData($nChkEndTray, $sChkTrayClose)
	GUICtrlSetData($nChkShowAct, $sChkShowActivity)
	GUICtrlSetData($nChkShowAlways, $sChkShowAlways)
	GUICtrlSetData($nChkShowTip, $sChkShowTip)
	GUICtrlSetData($nChkShowOnlyCon, $sChkShowOnlyCon)
	GUICtrlSetData($nChkTrayLimitInfo, $sChkTrayLimitInfo)
	GUICtrlSetData($nChkTrayAdaptWiFi, $sChkTrayAdaptWiFi)
	GUICtrlSetData($nChkTrayShowMAC, $sChkTrayShowMAC)
	GUICtrlSetData($nChkTrayShowIPv6, $sChkTrayShowIPv6)
	GUICtrlSetData($nChkLastPos, $sChkLastPos)
	GUICtrlSetData($nChkLastPage, $sChkLastPage)
	GUICtrlSetData($nLblLastPage, $sLblLastPage & ":")
	GUICtrlSetData($nChkUseWMI, $sChkUseWMI)
	
	SendMessage($hComboLastPage, $CB_RESETCONTENT, 0, 0)
	FillPageList($hComboLastPage)
	
	GUICtrlSetData($nLblTrouble, $sGrpTrouble & ":")
	GUICtrlSetData($nChkDebug, $sChkDebug)
	
	SetODBtnData($nBtnDebug, $sBtnDebug)
	GUICtrlSetTip($nBtnLogDel, $sBtnLogDel)
	
	GUICtrlSetData($nLblClr, $sLblClr & ":")
	GUICtrlSetData($nLblOtherOpt, $sGrpOtherOptions & ":")
	
	CheckSchemes(FALSE)
	RegWrite($sGURegKey, "Scheme", "REG_SZ", $sCurScheme)	
	GUICtrlSetData($nComboScheme, $sAllSchemes, $sCurScheme)
	
	;sChkIcons
	SetCtrlPos($hOtherGUI, $nRadioOSFont, $sRadioOSFont, 25, 76, 378 - GetScaled($nSBSize, 2))
	;SetCtrlPos($hOtherGUI, $nRadioFont, $sRadioFont & ":", 25, 94, 134)
	SetCtrlPos($hOtherGUI, $nChkIcons, $sChkIcons, 25, 117, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkDebug, $sChkDebug, 25, 165, 135)
	SetCtrlPos($hOtherGUI, $nChkStartTray, $sChkTrayStart, 25, 215, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkMinTray, $sChkTrayMin, 25, 233, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkEndTray, $sChkTrayClose, 25, 251, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkShowAct, $sChkShowActivity, 25, 269, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkShowAlways, $sChkShowAlways, 25, 287, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkShowTip, $sChkShowTip, 25, 305, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkShowOnlyCon, $sChkShowOnlyCon, 25, 323, 378 - GetScaled($nSBSize, 2))	
	SetCtrlPos($hOtherGUI, $nChkTrayLimitInfo, $sChkTrayLimitInfo, 25, 341, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkTrayAdaptWiFi, $sChkTrayAdaptWiFi, 25, 359, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkTrayShowMAC, $sChkTrayShowMAC, 25, 377, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkTrayShowIPv6, $sChkTrayShowIPv6, 25, 395, 378 - GetScaled($nSBSize, 2))	
	SetCtrlPos($hOtherGUI, $nChkLastPos, $sChkLastPos, 25, 442, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkLastPage, $sChkLastPage, 25, 460, 378 - GetScaled($nSBSize, 2))
	SetCtrlPos($hOtherGUI, $nChkUseWMI, $sChkUseWMI, 25, 508, 378 - GetScaled($nSBSize, 2))
	
	;About GUI
	GUICtrlSetData($nLblAbout, $sMainTitle)
	GUICtrlSetData($nLblAboutAI3, $sLblAboutAI3)
	
	$nX = GetScaled(345)
	SetODBtnSize($hAboutGUI, $nLblAboutAI3, $sLblAboutAI3, $nX, GetScaled(105), FALSE, FALSE, TRUE)
	
	; Additional
	GUICtrlSetData($nTIShoGUI, $sTrayShowGUI)
	GUICtrlSetData($nTIShoAct, $sTrayShowAni)
	GUICtrlSetData($nTIExit, $sTrayExit)
	
EndFunc


;**********************************************************************
; Checks if WLANAPI does exists
;**********************************************************************
Func ChkWlanAPI()
	If $bIsVista Then $bWLAPIOK = TRUE
	If $sOSVersion = "WIN_XP" And (FileExists(@ScriptDir & "\wlanapi.dll") Or FileExists(@SystemDir & "\wlanapi.dll")) Then $bWLAPIOK = TRUE
	If $hWlanapi = -1 Then $bWLAPIOK = FALSE
	
	If $bWLAPIOK Then
		Debug("IN: State Wlan API: OK")
	Else
		Debug("IN: State Wlan API: ERROR")
	EndIf
EndFunc


;**********************************************************************
; Checks if Interface is WLAN int.
;**********************************************************************
Func IsWLANI($sDesc)
	Local $i = 0
	
	$i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return 0

	$i = GetWlanAdapterIndexByGUID($arNAList[$i][1])
	If $i = 0 Then Return 0

	Return $i
EndFunc


;**********************************************************************
; Get short infos for tray tooltip
;**********************************************************************
Func Infos2Tray()
	Local $i, $sText = "", $sIP, $sType
	
	Local $oConf = 0
	Local $oConfigs = 0
	Local $oConfItem = 0
	
	For $i = 1 To $arNAList[0][0] - 1
		If $bUseWMI Then
			$oConfigs	= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
			
			For $oConfItem In $oConfigs
				$oConf = $oConfItem
			Next
		EndIf
		
		$sType = ""
		$sIP = GetAdapterProperty($arNAList[$i][1], 1, $oConf)
		If GetAdapterProperty($arNAList[$i][1], 0, $oConf) Then
			$sIP = GetAdapterProperty($arNAList[$i][1], 6, $oConf)
			$sType = " (DHCP)"
		EndIf
		$sIP = GetFirstAddrEntry($sIP, @LF)
		If $sIP = "" Then $sIP = "0.0.0.0"
		$sText = $sText & "IP" & $i & ":" & $sIP & $sType & @LF
	Next
	
	For $i = $arNAList[0][0] To $arNAList[0][0]
		If $bUseWMI Then
			$oConfigs	= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
			
			For $oConfItem In $oConfigs
				$oConf = $oConfItem
			Next
		EndIf
		
		$sType = ""
		$sIP = GetAdapterProperty($arNAList[$i][1], 1, $oConf)
		If GetAdapterProperty($arNAList[$i][1], 0, $oConf) Then
			$sIP = GetAdapterProperty($arNAList[$i][1], 6, $oConf)
			$sType = " (DHCP)"
		EndIf
		$sIP = GetFirstAddrEntry($sIP, @LF)
		If $sIP = "" Then $sIP = "0.0.0.0"
		$sText = $sText & "IP" & $i & ":" & $sIP & $sType
	Next
	
	Return $sText
EndFunc


;**********************************************************************
; Switches between 2 GUI's
;**********************************************************************
Func SwitchGUI($hGUI)
	If $hLastGUI <> 0 Then GUISetState(@SW_HIDE, $hLastGUI)
	GUISetState(@SW_SHOW, $hGUI)
	
	$hLastGUI = $hGUI
	If $hGUI <> $hIdentGUI Then $bLoopPing = FALSE
EndFunc


;**********************************************************************
; Switches between 2 GUI's
;**********************************************************************
Func SwitchConfGUI($hGUI)
	If $hLastConfGUI <> 0 Then GUISetState(@SW_HIDE, $hLastConfGUI)
	GUISetState(@SW_SHOW, $hGUI)
	$hLastConfGUI = $hGUI				
EndFunc


;**********************************************************************
; Switches between 2 WiFi GUI's
;**********************************************************************
Func SwitchWiFiGUI($hGUI)
	If $hLastWiFiGUI <> 0 Then GUISetState(@SW_HIDE, $hLastWiFiGUI)
	GUISetState(@SW_SHOW, $hGUI)
	$hLastWiFiGUI = $hGUI
EndFunc


;**********************************************************************
; Open GUI with the last used tab
;**********************************************************************
Func LoadLastPage()
	#cs
		   1 - Config - IP
		   2 - Config - WiFi
		   3 - Config - WiFi available
		   4 - Config - WiFi preferred
		   5 - Config - WiFi service
		   6 - Config - Advanced
		   7 - Computer
		   8 - Sharing
		   9 - Drives
		  10 - Drives - Browser
		  11 - Profiles
		  12 - Other
		  13 - About
	#ce
	
	If $nLastItemGUI <> 0 Then GUICtrlSendMsg($nLastItemGUI, $BM_SETSTATE, FALSE, 0)
	
	If RegRead($sGURegKey, "OpenPage") <> 1 Then Return
	
	Local $nLastPage = RegRead($sGURegKey, "LastPage")
		
	If BitAnd($nGUIDisable, 1) And $nLastPage = 7 Then $nLastPage = 0
	If BitAnd($nGUIDisable, 2) And $nLastPage = 8 Then $nLastPage = 0
	If BitAnd($nGUIDisable, 4) And ($nLastPage = 9 Or $nLastPage = 10) Then $nLastPage = 0
	If BitAnd($nGUIDisable, 8) And $nLastPage = 11  Then $nLastPage = 0
	If BitAnd($nGUIDisable, 16) And $nLastPage = 12 Then $nLastPage = 0
	If BitAnd($nGUIDisable, 32) And $nLastPage >= 2 And $nLastPage <=5 Then $nLastPage = 0
	If BitAnd($nGUIDisable, 64) And $nLastPage = 6 Then $nLastPage = 0
	If BitAnd($nGUIDisable, 128) And $nLastPage = 4 Then $nLastPage = 0
	If BitAnd($nGUIDisable, 256) And $nLastPage = 5 Then $nLastPage = 0
	
	If $nLastPage = "" Or $nLastPage = 0 Then $nLastPage = 1
	
	$nValPagelast = $nLastPage
			
	Local $hGUI = $hConfGUI
	Local $nItem = $nTIConf
	
	Switch $nLastPage
		Case 1, 2, 3, 4, 5, 6
			$hGUI = $hConfGUI
			$nItem = $nTIConf
		Case 7
			$hGUI = $hIdentGUI
			$nItem = $nTIIdent
			If Not $bIdentCreated Then CreateIdentGUI()
			GUICtrlSetData($nInpPCName, @ComputerName)
			GUICtrlSetData($nInpPCWG, GetWorkGroup())
			GUICtrlSetData($nInpPCDNS, GetDNSSuffix())
		Case 8
			$hGUI = $hSharesGUI
			$nItem = $nTISharing
			If Not $bSharesCreated Then CreateSharesGUI()
			If $bIsWinPE Then UpdateShareUsrCombo()
			UpdateSharingInfo(FALSE)
			EnumShares()
		Case 9, 10
			$hGUI = $hDrivesGUI
			$nItem = $nTIDrives
			If Not $bDrivesCreated Then CreateDrivesGUI()
			EnumDrives()
			EnumDriveLetters()
			If $nLastPage = 10 Then ShowNetBrowse($nBtnDrvNet)
		Case 11
			$hGUI = $hProfilesGUI
			$nItem = $nTIProfiles
			If Not $bProfilesCreated Then CreateProfilesGUI()
			If GUICtrlRead($nInpProfFile) <> $sProfFile Then UpdateProfileList()
		Case 12
			$hGUI = $hOtherGUI
			$nItem = $nTIOther
			If Not $bOtherCreated Then CreateOtherGUI()
		Case 13
			$hGUI = $hAboutGUI
			$nItem = $nTIAbout
			If Not $bAboutCreated Then CreateAboutGUI()
	EndSwitch
	
	Local $nSubConfItem = $nTIIP
	Local $hSubConfGUI = $hConfIPGUI

	Switch $nLastPage
		Case 1
			$nSubConfItem = $nTIIP
			$hSubConfGUI = $hConfIPGUI
		Case 2, 3, 4, 5
			If $nItem = $nTIConf And $arNAList[0][0] > 0 Then UpdateWiFiInfo($arNAList[1][0], TRUE)
			$nSubConfItem = $nTIWiFi
			If IsWLANI($arNALIST[1][0]) Then
				$hSubConfGUI = $hConfWiFiGUI
			Else
				$hSubConfGUI = $hConfPreWiFiGUI
			EndIf
		Case 6
			$nSubConfItem = $nTIAdv
			$hSubConfGUI = $hConfExtGUI
		Case 14
			$nSubConfItem = $nTIFirewall
			$hSubConfGUI = $hConfFWGUI
	EndSwitch
	
	Local $nSubWiFiItem = $nTIWiFiAV
	Local $hSubWiFiGUI = $hWiFiAvailGUI
	
	Switch $nLastPage
		Case 2, 3
			$nSubWiFiItem = $nTIWiFiAV
			$hSubWiFiGUI = $hWiFiAvailGUI
		Case 4
			$nSubWiFiItem = $nTIWiFiPref
			$hSubWiFiGUI = $hWiFiPrefGUI
		Case 5
			$nSubWiFiItem = $nTIWiFiSrv
			$hSubWiFiGUI = $hWiFiSrvGUI
	EndSwitch
	
	$nLastItemGUI = $nItem
	
	SwitchGUI($hGUI)
	
	If $nItem = $nTIConf And $nSubConfItem <> 0 Then
		$nLastItemConf = $nSubConfItem
		SwitchConfGUI($hSubConfGUI)
		
		If $nSubConfItem = $nTIWiFi Then
			$nLastItemWiFi = $nSubWiFiItem
			SwitchWiFiGUI($hSubWiFiGUI)
		EndIf
	EndIf
	
	GUISwitch($hMainGUI)
	
	SetODBtnState($nBtnCancel, $GUI_FOCUS, FALSE)
EndFunc


;**********************************************************************
; Checks for tray icon dependings
;**********************************************************************
Func CheckTrayIcon($nID, $bChecked = FALSE)
	If $nID = $nTIShoAct Then
		If BitAnd(GUICtrlRead($nTIShoAct), $GUI_UNCHECKED) Then
			GUICtrlSetState($nTIShoAct, $GUI_CHECKED)
			GUICtrlSetState($nChkShowAct, $GUI_CHECKED)
			$bChecked = TRUE
		Else
			GUICtrlSetState($nTIShoAct, $GUI_UNCHECKED)
			GUICtrlSetState($nChkShowAct, $GUI_UNCHECKED)
		EndIf
	ElseIf $nID = $nChkShowAct Then
		If BitAnd(GUICtrlRead($nChkShowAct), $GUI_CHECKED) Then
			GUICtrlSetState($nTIShoAct, $GUI_CHECKED)
			$bChecked = TRUE
		Else
			GUICtrlSetState($nTIShoAct, $GUI_UNCHECKED)
		EndIf
	ElseIf $nID = $nChkShowAlways Then
		If BitAnd(GUICtrlRead($nChkShowAlways), $GUI_CHECKED) Then
			RegWrite($sGURegKey, "ShowTrayAlways", "REG_DWORD", 1)
			$bShowTrayAlways = TRUE
			$bInTray = TRUE
		Else
			RegWrite($sGURegKey, "ShowTrayAlways", "REG_DWORD", 0)
			$bShowTrayAlways = FALSE
			If $bShowTrayAct = FALSE Then $bInTray = FALSE
		EndIf
		
		If $bShowTrayAct Then $bChecked = TRUE
	EndIf
	
	If $bChecked Then
		TrayIconSetState()
		If $bShowTrayTip Then TrayIconSetToolTip($sMainTitle & @LF & Infos2Tray())
			
		$bShowTrayAct = TRUE
		
		SetTimer($hMainGUI, $nTimerID, $nTimerTimeOut, 0)	
		SetTrayIcon($nLastTrayState)
						
		RegWrite($sGURegKey, "ShowTrayActivity", "REG_DWORD", 1)
	Else
		$bShowTrayAct = FALSE
		
		KillTimer($hMainGUI, $nTimerID)
		
		If Not $bInTray Then
			TrayIconSetState(2)
		Else
			SetTrayIcon()
			If $bShowTrayTip Then TrayIconSetToolTip($sMainTitle & @LF & Infos2Tray())
		EndIf
		
		RegWrite($sGURegKey, "ShowTrayActivity", "REG_DWORD", 0)
	EndIf
EndFunc


;**********************************************************************
; Sets the tray icon
;**********************************************************************
Func SetTrayIcon($nState = 0)
	; 0 = Default, 1 = Both Data, 2 = No Data, 3 = Send data, 4 = Recieve data
	Switch $nState
		Case 0
			If $bShowTrayAct Then
				TrayIconSetIcon($hTrayIconNoData)
			Else
				TrayIconSetIcon()
			EndIf
		Case 1
			TrayIconSetIcon($hTrayIconData)
		Case 2
			TrayIconSetIcon($hTrayIconSendData)
		Case 3
			TrayIconSetIcon($hTrayIconRecData)
		Case 4
			TrayIconSetIcon($hTrayIconNoConnect)
		Case 5
			TrayIconSetIcon($hTrayIconWiFiAvail)
		Case 6
			TrayIconSetIcon($hTrayIconWiFiNull)
		Case 7
			TrayIconSetIcon($hTrayIconWiFiSR1)
		Case 8
			TrayIconSetIcon($hTrayIconWiFiSR2)
		Case 9
			TrayIconSetIcon($hTrayIconWiFiSR3)
		Case 10
			TrayIconSetIcon($hTrayIconWiFiSR4)
		Case 11
			TrayIconSetIcon($hTrayIconWiFiSR5)
		Case 12
			TrayIconSetIcon($hTrayIconWiFiS1)
		Case 13
			TrayIconSetIcon($hTrayIconWiFiS2)
		Case 14
			TrayIconSetIcon($hTrayIconWiFiS3)
		Case 15
			TrayIconSetIcon($hTrayIconWiFiS4)
		Case 16
			TrayIconSetIcon($hTrayIconWiFiS5)
		Case 17
			TrayIconSetIcon($hTrayIconWiFiR1)
		Case 18
			TrayIconSetIcon($hTrayIconWiFiR2)
		Case 19
			TrayIconSetIcon($hTrayIconWiFiR3)
		Case 20
			TrayIconSetIcon($hTrayIconWiFiR4)
		Case 21
			TrayIconSetIcon($hTrayIconWiFiR5)
		Case 22
			TrayIconSetIcon($hTrayIconWiFiND1)
		Case 23
			TrayIconSetIcon($hTrayIconWiFiND2)
		Case 24
			TrayIconSetIcon($hTrayIconWiFiND3)
		Case 25
			TrayIconSetIcon($hTrayIconWiFiND4)
		Case 26
			TrayIconSetIcon($hTrayIconWiFiND5)
	EndSwitch
EndFunc


;**********************************************************************
; Set default language strings
;**********************************************************************
Func SetDefaultLang()
	$sMainTitle			= $sPreTitle & " Network Manager " & $sVersion
	$sBtnAdd			= "&Add..."
	$sBtnAddShort		= "&Add"
	$sBtnDelete			= "&Delete"
	$sBtnApply			= "&Apply"
	$sBtnCancel			= "&Close"
	$sStateReady		= "Ready"
	$sBtnChange			= "Change..."
	$sBtnOK				= "&OK"
	$sBtnYes			= "&Yes"
	$sBtnNo				= "&No"
	$sBtnRestore		= "Restore"
	$sTIConfig			= "Properties"
	$sTIIdent			= "Computer"
	$sTISharing			= "Sharing"
	$sTIDrives			= "Network Drives"
	$sTIProfiles		= "Profiles"
	$sTIOther			= "Other"
	$sTIAbout			= "About"
	$sTTRefresh			= "Refresh adapter list"
	$sLblAdapterState	= "State"
	$sLblAdapterSpeed	= "Speed"
	$sAdapterSpeed		= "MBit/s"
	$sLblAdapterMAC		= "MAC"
	$sLblCurMac			= "Current MAC"
	$sLblNewMac			= "New MAC"
	$sTChangeMAC		= "Change MAC address"
	$sMsgMACChangeErr	= "Wrong MAC address"
	$sMsgMACApply		= "Applying new MAC..."
	$sMsgMACRestore		= "Restoring original MAC..."
	$sChkForceScan		= "Force scanning for new devices on adapter list refresh"
	$sBtnIPDHCP			= "Obtain an IP address automatically"
	$sBtnDHCPInfo		= "&Info"
	$sBtnDHCPRelease	= "&Release"
	$sBtnDHCPRenew		= "Re&new"
	$sBtnIPAutoOn		= "Use automatic private IP address (169.254.X.X)"
	$sBtnIPAutoOff		= "Disable automatic IP address (0.0.0.0)"
	$sTDHCPInfo			= "Network DHCP information"
	$sLblDHCPAdapter	= "Device"
	$sLblDHCPDNSSrv		= "DNS Server"
	$sLblDHCPWINSSrv	= "WINS Server"
	$sLblDHCPSrv		= "DHCP Server"
	$sLblDHCPLTO		= "Lease Obtained"
	$sLblDHCPLTE		= "Lease Expires"
	$sBtnIPStatic		= "Use static IP address"
	$sLblStaticIP		= "IP Address"
	$sLblStaticSM		= "Subnet Mask"
	$sLblStaticDG		= "Default Gateway"
	$sBtnStatic			= "&Static"
	$sBtnDynamic		= "&Dynamic"
	$sBtnDNSDHCP		= "Obtain DNS address automatically"
	$sBtnDNSStatic		= "Use static DNS address"
	$sLblDNS			= "DNS address"
	$sBtnWINSDHCP		= "Obtain WINS address automatically"
	$sBtnWINSStatic		= "Use static WINS address"
	$sLblWINS			= "WINS address"
	$sLblComputer		= "Computername"
	$sLblWorkgroup		= "Workgroup"
	$sLblPriDNS			= "Primary DNS suffix"
	$sTAddIP			= "IP addresses"
	$sTAddDG			= "Default gateway addresses"
	$sTAddDNS			= "DNS addresses"
	$sTAddWINS			= "WINS addresses"
	$sTAddIPAddr		= "Add IP address"
	$sTAddDGAddr		= "Add Gateway address"
	$sTAddDNSAddr		= "Add DNS server address"
	$sTAddWINSAddr		= "Add WINS server address"
	$sTTShareRefresh	= "Refresh shared folders list"
	$sTTDrivesRefresh	= "Refresh network drives list"
	$sTTWiFiRefresh		= "Scan and refresh available network list"
	$sTTWiFiRefPref		= "Refresh preferred network list"
	$sChkShowActivity	= "Show connection activity in tray"
	$sTrayShowGUI		= "Show main GUI"
	$sTrayShowAni		= "Animation on network activity"
	$sTrayExit			= "Exit"
	$sMsgDllNotFound	= "Could not find the following libraries"
	$sMsgWait			= "Please wait..."
	$sMsgChangesApply	= "Changings are being applied to the system..."
	$sMsgReleaseAddr	= "Releasing address..."
	$sMsgRenewAddr		= "Renewing address..."
	$sMsgInitWait		= "Initialization is not finished yet..."
	$sTIWiFiAvailable	= "Available Networks"
	$sBtnWiFiConnect	= "Connect"
	$sBtnWiFiDisconnect	= "Disconnect"
	$sLVWiFiList		= "Signal|SSID|Security"
	$sLVWiFiPref		= "Profile name|Mode"
	$sTIWiFiPreferred	= "Preferred Networks"
	$sTIWiFiService		= "Service"
	$sLblWiFiCurState	= "Current State"
	$sLblWiFiNoDevice	= "This is not a WiFi device or WiFi functionality is disabled for this device!"
	$sLblWiFiWlanApiNF	= "WLANAPI not found on this system!"
	$sServiceNotInst	= "Not installed"
	$sServiceStop		= "Stop"
	$sServiceStopped	= "Stopped"
	$sServiceStart		= "Start"
	$sServiceStarted	= "Started"
	$sTIIPSettings		= "IP-Settings"
	$sTIWINS			= "WINS"
	$sTIWiFi			= "WiFi"
	$sLblCNI			= "Network identification"
	$sLblPing			= "Ping other computer (host or IP address)"
	$sBtnPingStart		= "Start"
	$sBtnPingStop		= "Stop"
	$sLblPingCount		= "Count"
	$sLblPingTime		= "Timeout"
	$sChkPingLimit		= "Unlimited"
	$sLVPing			= "Info"
	$sLVIReply			= "Reply from "
	$sLVIReplyTime		= "Time"
	$sLVIReplyTimeMS	= "ms"
	$sLVITimeOut		= "Request timed out."
	$sLVIUnreachable	= "Destination host unreachable."
	$sLVIInvalid		= "Destination specified is invalid."
	$sLVIGeneral		= "General failure."
	$sLblFileSharing	= "File Sharing"
	$sBtnShareStart		= "Start"
	$sLblShareUser		= "Username"
	$sLblSharePW		= "Password"
	$sChkShareAll		= "Share all drives"
	$sTTShareAll		= "The drives will be shared with the drive letters only."
	$sBtnShareSetPW		= "Set password"
	$sEditShareAdmin	= "Note: to connect to the shares of this host you must at least enter one user account with a password!"
	$sLblSharedFolders	= "Shared folders"
	$sLVShares			= "Share|Folder|Connections"
	$sLblShareName		= "Share name"
	$sTTShareName		= "Use a ""$"" at the end of the share name to create a hidden share."
	$sLblSharePath		= "Local path"
	$sMIShareBrowse		= "Browse..."
	$sMIShareDel		= "Delete"
	$sTTShareUser		= "This is the username to connect from the remote host to the shared folders of this computer."
	$sTTShareUserLen	= "The username length is limited to"
	$sTTInputChars		= "characters"
	$sTTSharePWLen		= "The password length is limited to"
	$sLblDriveLetter	= "Drive letter"
	$sTTDriveLetter		= "automatically select an unused drive letter."
	$sTTDriveLetterNo	= "do not assign a drive letter."
	$sTTDriveNoFree1	= "There are no more free available drive letters!"
	$sTTDriveNoFree2	= "Please disconnect one at first."
	$sBtnConnect		= "Connect"
	$sBtnDisconnect		= "Disconnect"
	$sLblDrivePath		= "Path"
	$sLblDriveUser		= "Username"
	$sLblDrivePW		= "Password"
	$sLblDrivesCon		= "Connected network drives"
	$sLVDrivesCon		= "Local|Remote|Status|Open"
	$sMIDriveBrowse		= "Browse..."
	$sMIDriveDiscon		= "Disconnect"
	$sGrpTrayOptions	= "Tray (notification area) options"
	$sChkTrayStart		= "Start directly in tray, main window is hidden on program start"
	$sChkTrayMin		= "On minimizing 'move' main window to tray"
	$sChkTrayClose		= "On closing 'move' main window to tray"
	$sGrpTrouble		= "Debugging options"
	$sChkDebug			= "Debug Mode"
	$sBtnDebug			= "Open Debug Logfile..."
	$sLblAboutAI3		= "Created with ""AutoIt3""."
	$sLVIPSM			= "IP Address|Subnet Mask"
	$sWiFiUnnamed		= "Other network"
	$sWiFiNone			= "None"
	$sERROR				= "ERROR"
	$sINFO				= "INFO"
	$sWARNING			= "WARNING"
	$sQUESTION			= "QUESTION"
	$sProfSelTitle		= "Profile Selector"
	$sLblProfSelect		= "Please select a network profile"
	$sLblProfDesc		= "Profile description"
	$sLblProfFile		= "File with network profiles"
	$sLblProfList		= "Network profile list"
	$sTTProfRefresh		= "Refresh profile list"
	$sTTProfIniFiles	= "Config files (*.ini)"
	$sLblProfApply		= "Applying profile settings..."
	$sProfIn			= "in"
	$sProfSec			= "sec"
	$sLblSearchDevice	= "Searching for installable devices..."
	$sDeviceFound		= "Found"
	$sDeviceSucces		= "Successfull installation of"
	$sErrorNetShared	= "A network resource cannot be shared!"
	$sNetShareOK		= "Successfully shared local path"
	$sNetShareOKAs		= "as"
	$sNetShrNotExist	= "The local path does not exist"
	$sNetShrAccDen		= "Access denied"
	$sNetShrInvName		= "Invalid name"
	$sNetShrPNE			= "The local path does not exist"
	$sNetShrNameDup		= "The share name is already in use"
	$sErrorNetSharing	= "Error while sharing local path"
	$sTTCharsMax		= "characters are allowed only"
	$sTTCharsNoAllow	= "The following characters are not allowed"
	$sNetStartNet		= "Start network support now?"
	$sLblStartNet		= "Starting network support..."
	$sLblStartNetWpe	= "Starting network support (Wpeinit)..."
	$sNetRegisterObj	= "Registering network objects..."
	$sNetChkDrv			= "Checking for needed network driver files..."
	$sNetDetectDev		= "Detecting network devices..."
	$sNetDetectNew		= "Scanning for new added devices..."
	$sNetInstTCP		= "Installing ""TCP/IP"" protocol..."
	$sNetApplyProfile	= "Applying profile settings..."
	$sNetInstMSClient	= "Installing ""Client for Microsoft Networks""..."
	$sNetChkServices	= "Checking services..."
	$sNetStartTCPIP		= "Starting ""TCP/IP Protocol Driver"" service..."
	$sNetStartDHCP		= "Starting ""DHCP-Client"" service..."
	$sNetStartNLA		= "Starting ""Network Location Awareness"" service..."
	$sNetStartLMH		= "Starting ""TCP/IP NetBIOS Helper"" service..."
	$sNetNoNetcards		= "No network cards detected!"
	$sProgramExit		= "Program will be Exit now."
	$sShareSelFolder	= "Please select a folder to share"
	$sShareChkDrv		= "Checking for needed ""File Sharing"" service installation files..."
	$sShareInstSrv		= "Installing ""File Sharing"" service..."
	$sServiceChkSrv		= "Check if service is properly installed..."
	$sShareStartSrv		= "Starting ""File Sharing"" service..."
	$sShareStopSrv		= "Stopping ""File Sharing"" service..."
	$sServiceInstFinish	= "Finished."
	$sShareSetPW		= "Setting password..."
	$sShareStopInfo1	= "Connections from other PC's will be disconnected and transferred data could be lost !"
	$sShareStopInfo2	= "You also need the following to know"
	$sShareStopInfo3	= "If you started the service(s) a few minutes ago, sometimes it takes some more minutes again (5-10min) before you can stop and restart the service(s)."
	$sShareStopInfo4	= "Are you sure you want to stop the ""File Sharing"" service ?"
	$sShareMsgOpen		= "There seems to be open resources on this share!"
	$sShareMsgRemove	= "Are you sure you want to remove it nevertheless?"
	$sShareMsgSpecial	= "The special share"
	$sShareMsgDel1		= "is reserved for interprocess communication and cannot be deleted!"
	$sShareMsgDel2		= "is reserved for interprocess communication and should not be deleted!"
	$sShareMsgDel3		= "However it will be deleted only temporary and will be re-created after restarting of the ""Server"" service or the computer."
	$sShareMsgDel4		= "Are you sure you want to delete this special share?"
	$sShareMsgDel5		= "Are you sure you want to delete the share"
	$sLblShareRemove	= "Removing share..."
	$sNetShrNameNotEx	= "The share name does not exist"
	$sNetErrShareInfo	= "Error while retrieving share info about"
	$sNetShareRemSucc	= "Successfully removed the share"
	$sNetShareRemErr	= "Error while removing the share"
	$sLblDriveConnect	= "Connecting remote share..."
	$sNetDriveSucc1		= "Successfully mapped"
	$sNetDriveSucc2		= "to local drive"
	$sNetDriveAddErr1	= "Unknown error while mapping drive!"
	$sNetDriveAddErr2	= "Access denied to the remote path!"
	$sNetDriveAddErr3	= "The device is already in use!"
	$sNetDriveAddErr4	= "Invalid device name!"
	$sNetDriveAddErr5	= "Invalid remote path!"
	$sNetDriveAddErr6	= "Invalid password!"
	$sNetDriveAddErr7	= "The network path was not found!"
	$sNetDriveMsgDel1	= "There seems to be open resources on this connection!"
	$sNetDriveMsgDel2	= "Are you sure you want to disconnect it nevertheless?"
	$sLblDriveDel		= "Disconnecting network drive..."
	$sNetDriveDelErr	= "Error while disconnecting drive!"
	$sMsgUtilNotFnd1	= "Network utility"
	$sMsgUtilNotFnd2	= "not found"
	$sNetErrRegister	= "An error occured while registering ""netcfgx.dll"""
	$sNetErrTCPNotFnd	= """nettcpip.inf"" not found"
	$sNetErrMSCNotFnd	= """netmscli.inf"" not found"
	$sNetErrDetDev		= "An error occured while detecting devices"
	$sNetErrTCPInst		= "An error occured while installing the ""TCP/IP Protocol Driver"" service"
	$sNetErrMSCInst		= "An error occured while installing the ""Client for Microsoft Networks"""
	$sNetErrTCPStart	= "An error occured while starting the ""TCP/IP Protocol Driver"" service"
	$sNetErrDHCPStart	= "An error occured while starting the ""DHCP-Client"" service"
	$sNetErrTCPRegStart	= "An error occured while starting the ""TCP/IP Registry Compatibility"" service"
	$sNetErrStatOnly	= "Only static IP addresses will work."
	$sNetErrNLAStart	= "An error occured while starting the ""Network Location Awareness"" service"
	$sNetErrLMHStart	= "An error occured while starting the ""TCP/IP NetBIOS Helper"" service"
	$sServiceStopping	= "Stopping"
	$sServiceDesc		= "service"
	$sServiceStarting	= "Starting"
	$sShareErrInf		= """netserv.inf"" not found"
	$sShareErrInst		= "Couldn't install the ""File Sharing"" service"
	$sShareErrInst2		= "An error occured while installing the ""File Sharing"" service"
	$sShareErrStart		= "An error occured while starting the ""File Sharing"" service"
	$sShareErrCB		= "An error occured while starting the ""Browser"" service"
	$sShareErrStop		= "An error occured while stopping the ""File Sharing"" service"
	$sShareErrPW		= "An error occured while updating the specified user with the new password"
	$sShareErrUsr		= "An error occured while adding the specified user to the system"
	$sShareErrAdmin		= "An error occured while adding the specified user to the admin group"
	$sShareAddUser		= "Adding local users..."
	$sGrpLanguage		= "Language"
	$sLblLangAuthor		= "Author"
	$sLblLangVersion	= "Version"
	$sWiFiChkDrv		= "Checking for needed ""Wireless Zero Configuration"" service installation files..."
	$sWiFiErrInf		= """ndisuio.inf"" not found"
	$sWiFiErrInf2		= """netwzc.inf"" not found"
	$sWiFiErrInf3		= """netnwifi.inf"" not found"
	$sWiFiErrInst		= "An error occured while installing the ""Wireless Zero Configuration"" service"
	$sWiFiErrInst2		= "An error occured while installing the ""Native WiFi Filter"" driver"
	$sWiFiRegXML		= "Registering ""Microsoft XML version 6""..."
	$sWiFiInstSrv		= "Installing ""NDIS Usermode I/O"" driver..."
	$sWiFiInstSrv2		= "Installing ""Wireless Zero Configuration"" service..."
	$sWiFiInstSrv3		= "Installing ""Native WiFi Filter"" driver..."
	$sWiFiStop			= "Are you sure you want to stop the ""Wireless Zero Configuration"" service ?"
	$sWiFiStartSrv		= "Starting ""Wireless Zero Configuration"" service..."
	$sWiFiStopSrv		= "Stopping ""Wireless Zero Configuration"" service..."
	$sWiFiStartSrv2		= "Starting ""WLAN AutoConfig"" service..."
	$sWiFiStopSrv2		= "Stopping ""WLAN AutoConfig"" service..."
	$sWiFiErrStart		= "An error occured while starting the ""NDIS Usermode I/O"" driver"
	$sWiFiErrStart2		= "An error occured while starting the ""Wireless Zero Configuration"" service"
	$sWiFiErrStart3		= "An error occured while starting the ""Native WiFi Filter"" driver"
	$sWiFiErrStart4		= "An error occured while starting the ""WLAN AutoConfig"" service"
	$sWiFiErrStop		= "An error occured while stopping the ""Wireless Zero Configuration"" service"
	$sWiFiErrStop2		= "An error occured while stopping the ""WLAN AutoConfig"" service"

	$sCMDActions		= "Actions"
	$sCMDIPChange		= "Run commands after IP change"
	$sCMDIPModeN		= "Normal"
	$sCMDIPModeH		= "Hidden"
	$sCMDIPModeMin		= "Minimized"
	$sCMDIPModeMax		= "Maximized"
	$sCMDIPModeWait		= "Wait"
	$sCMDIPModeNowait	= "Nowait"
	$sCMDLine			= "CMDLine"
	$sCMDLineMode		= "Mode"
	$sCMDLIneNumber		= "Number"
	$sWiFiConnected		= "Connected"
	$sLblNoNetcards		= "Cause there were no network cards detected the program is running only in simple mode." & @LF & _
							"Please perform a research for new network devices."
	$sBtnSearchDevice	= "&Search"
	$sTWiFiProp			= "Wireless Connection Properties"
	$sLblWiFiSSID		= "Network name (SSID)"
	$sLblWiFiAuth		= "Network authentication"
	$sLblWiFiEnc		= "Data encryption"
	$sLblWiFiKey		= "Network key"
	$sChkWiFiKey		= "Show networkkey on input"
	$sChkWiFiAuto		= "Connect automatically when this network is in range"
	$sChkWiFiAdhoc		= "This is an ad-hoc network"
	$sChkWiFiHidden		= "Connect even if this network is not broadcasting"
	$sCMDStart			= "Starting additional operations..."
	$sTWiFiConn			= "Wireless key"

	$arConState[0]			= "OK"
	$arConState[1]		 	= "Paused"
	$arConState[2]			= "Disconnected"
	$arConState[3]			= "Error"
	$arConState[4]			= "Network Error"
	$arConState[5]			= "Connecting"
	$arConState[6]			= "Reconnecting"
	$arConState[7]			= ""
	
	$sTIAdvanced		= "Advanced"
	$sLblExtProp		= "The following advanced properties are available for this network device."
	$sLblExtNoProp		= "This network device does not have any configurable advanced properties."
	$sLblProp			= "Property:"
	$sLblPropVal		= "Value:"
	$sRadioNotSet		= " Not set"
	$sTTCon				= "Connected"
	$sTTDiscon			= "Disconnected"
	$sLblWiFiCon		= "Trying to connect with wireless network..."

	$sWiFiBalConTo		= "Connected to:"
	$sWiFiBalNetSec		= "This is a secured network."
	$sWiFiBalNetNonSec	= "This is a nonsecured network."
	$sWiFiBalNetPref	= "This is a preferred network."
	$sWiFiBalNetInfra	= "This is an infrastructure network."
	$sWiFiBalNetAdhoc	= "This is an ad-hoc network."
	$sWiFiDelProf		= "Delete Wireless networks profile?"
	$sWiFiDelTxt		= "Are you sure you want to delete the wireless networks profile"
	$sWiFiDelWarn		= "Attention: possibly the current connection could be lost."

	$sBtnWiFiImport		= "Import..."
	$sTTWiFiImport		= "Import WiFi preferred network profile"
	$sTTWiFiXMLFiles	= "XML files (*.xml)"
	$sWiFiImportOK		= "Sucessfully imported WiFi profile."
	$sWiFiErrImport		= "Error while importing WiFi profile!"
	$sBtnWiFiExport		= "Export..."
	$sTTWiFiExport		= "Export WiFi preferred network profile"
	$sWiFiExportOK		= "Successfully exported WiFi profile"
	$sWiFiErrExport		= "Error while exporting WiFi profile"
	$sWiFiErrAddProf	= "Error while adding WiFi profile"

	$sLblDefault		= "Default"
	$sLblCurrent		= "Current"
	$sLblClassic		= "Classic"
	$sLblClr			= "Color scheme"
	
	$sBtnDrvNet			= "Browse network..."
	$sBtnDrvNetShow		= "Show network drives..."
	$sLblDrvNet			= "Domain or \\server name"
	$sTTNetConDetails	= "Network connection details"
	$sLVNetConPropVal	= "Property|Value"
	$sLblNetResSearch	= "Looking for resources - please wait..."
	$sBtnDrvNetReset	= "&Reset view"
	
	$sBtnLogDel			= "Delete Logfile"
	$sMsgLogDel			= "Are you sure you want to delete the log file"
	$sLblTCPtoIP		= "Converting TCP name to IP adress"
	$sLblIPtoTCP		= "Converting IP adress to TCP name"
	$sChkWiFiEditUI		= "Use OS WiFi profile UI for property changing"
	$sBtnProfFile		= "Open config file"
	$sBtnProfInt		= "Open config file with PENM profile editor"
	$sBtnProfExt		= "Open config file with external editor"
	
	$sNetworkAccess		= "Network access"
	$sBtnTrace			= "Trace"
	$sChkTrace			= "Address resolve"
	$sLblTrace			= "Hops"
	$sStateTrace		= "Trace"
	$sChkReverse		= "Write last result into first line"
	
	$sLblSurface		= "Interface customization"
	$sBtnLangExt		= "Open language file with external editor"
	$sChkShowTip		= "Show default tooltip instead of an info window"
	$sChkShowOnlyCon	= "Show only connected devices in info window"
	$sGrpOtherOptions	= "Other"
	$sChkLastPage		= "Remember open tool page on program start"
	$sLblLastPage		= "Page to open"
	$sLblLastOpened		= "Last opened"
	$sChkUseWMI			= "Use WMI to apply IP settings (WMI must be available and running)"
	$sChkLastPos		= "Remember last position of main window on the Desktop"
	$sRadioOSFont		= "Use OS default font for GUI (restart of GUI is required)"
	$sRadioFont			= "Use following font"
	$sChkIcons			= "Load GUI icons from ini file (restart of GUI is required)"
	
	$sTIFirewall		= "Firewall"
	$sFWStartSrv		= "Starting ""Firewall"" service..."
	$sFWStopSrv			= "Stopping ""Firewall"" service..."
	$sFWErrStart		= "An error occured while starting the ""Firewall"" service"
	$sFWErrStop			= "An error occured while stopping the ""Firewall"" service"
	
	$sTTAltIP			= "Set alternate IP configuration for using in different networks."	
	$sTTAltConf			= "Alternate configuration"
	$sTTGenConf			= "General"
	$sUserConf			= "User configured IP address"
		
	$sWiFiBalSignal		= "Signal Strength"
	$sWiFiBalSec		= "Security Type"
	$sWiFiBalRadio		= "Radio Type"
	
	$sChkShowAlways		= "Always show PENM icon in tray"
	
	$sWiFiSecured		= "Secured"
	$sWiFiOpen			= "Open"
	$sWiFiConnecting	= "Connecting..."
	$sWiFiUnknown		= "Unknown"
	
	$sLblWiFiProfile	= "Profile name"
	
	$sLblNetbiosEnabled	= "NetBIOS over TCPIP enabled"
	$sLblYes			= "Yes"
	$sLblNo				= "No"
	
	$sChkTrayLimitInfo	= "Limit tray info height (default: 1/2 desktop)"
	$sChkTrayAdaptWiFi	= "Adapt tray wifi height to height of tray info"
	$sChkTrayShowMAC	= "Show MAC addresses in tray info"
	$sChkTrayShowIPv6	= "Show IPv6 addresses in tray info"
EndFunc


;**********************************************************************
; Read strings from language file
;**********************************************************************
Func ReadLanguageFile($sFile, $sSection)
	If $sFile = "" Then Return
	
	$sMainTitle			= $sPreTitle & " " & IniRead($sFile, $sSection, "MainTitle", "Network Manager") & " " & $sVersion
	$sBtnAdd			= IniRead($sFile, $sSection, "BtnAdd", $sBtnAdd)
	$sBtnAddShort		= IniRead($sFile, $sSection, "BtnAddShort", $sBtnAddShort)
	$sBtnDelete			= IniRead($sFile, $sSection, "BtnDelete", $sBtnDelete)
	$sBtnApply			= IniRead($sFile, $sSection, "BtnApply", $sBtnApply)
	$sBtnCancel			= IniRead($sFile, $sSection, "BtnCancel", $sBtnCancel)
	$sStateReady		= IniRead($sFile, $sSection, "StateReady", $sStateReady)
	$sBtnChange			= IniRead($sFile, $sSection, "BtnChange", $sBtnChange)
	$sBtnOK				= IniRead($sFile, $sSection, "BtnOK", $sBtnOK)
	$sBtnYes			= IniRead($sFile, $sSection, "BtnYes", $sBtnYes)
	$sBtnNo				= IniRead($sFile, $sSection, "BtnNo", $sBtnNo)
	$sBtnRestore		= IniRead($sFile, $sSection, "BtnRestore", $sBtnRestore)
	$sTIConfig			= IniRead($sFile, $sSection, "TIConfig", $sTIConfig)
	$sTIIdent			= IniRead($sFile, $sSection, "TIIdent", $sTIIdent)
	$sTISharing			= IniRead($sFile, $sSection, "TISharing", $sTISharing)
	$sTIDrives			= IniRead($sFile, $sSection, "TIDrives", $sTIDrives)
	$sTIProfiles		= IniRead($sFile, $sSection, "TIProfiles", $sTIProfiles)
	$sTIOther			= IniRead($sFile, $sSection, "TIOther", $sTIOther)
	$sTIAbout			= IniRead($sFile, $sSection, "TIAbout", $sTIAbout)
	$sTTRefresh			= IniRead($sFile, $sSection, "TTRefresh", $sTTRefresh)
	$sLblAdapterState	= IniRead($sFile, $sSection, "LblAdapterState", $sLblAdapterState)
	$sLblAdapterSpeed	= IniRead($sFile, $sSection, "LblAdapterSpeed", $sLblAdapterSpeed)
	$sAdapterSpeed		= IniRead($sFile, $sSection, "AdapterSpeed", $sAdapterSpeed)
	$sLblAdapterMAC		= IniRead($sFile, $sSection, "LblAdapterMAC", $sLblAdapterMAC)
	$sLblCurMac			= IniRead($sFile, $sSection, "LblCurMac", $sLblCurMac)
	$sLblNewMac			= IniRead($sFile, $sSection, "LblNewMac", $sLblNewMac)
	$sTChangeMAC		= IniRead($sFile, $sSection, "TChangeMAC", $sTChangeMAC)
	$sMsgMACChangeErr	= IniRead($sFile, $sSection, "MsgMACChangeErr", $sMsgMACChangeErr)
	$sMsgMACApply		= IniRead($sFile, $sSection, "MsgMACApply", $sMsgMACApply)
	$sMsgMACRestore		= IniRead($sFile, $sSection, "MsgMACRestore", $sMsgMACRestore)
	$sChkShowActivity	= IniRead($sFile, $sSection, "ChkShowActivity", $sChkShowActivity)
	$sBtnIPDHCP			= IniRead($sFile, $sSection, "RadioDHCP", $sBtnIPDHCP)
	$sBtnDHCPInfo		= IniRead($sFile, $sSection, "BtnDHCPInfo", $sBtnDHCPInfo)
	$sBtnDHCPRelease	= IniRead($sFile, $sSection, "BtnDHCPRelease", $sBtnDHCPRelease)
	$sBtnDHCPRenew		= IniRead($sFile, $sSection, "BtnDHCPRenew", $sBtnDHCPRenew)
	$sBtnIPAutoOn		= IniRead($sFile, $sSection, "BtnIPAutoOn", $sBtnIPAutoOn)
	$sBtnIPAutoOff		= IniRead($sFile, $sSection, "BtnIPAutoOff", $sBtnIPAutoOff)
	$sTDHCPInfo			= IniRead($sFile, $sSection, "TDHCPInfo", $sTDHCPInfo)
	$sLblDHCPAdapter	= IniRead($sFile, $sSection, "LblDHCPAdapter", $sLblDHCPAdapter)
	$sLblDHCPDNSSrv		= IniRead($sFile, $sSection, "LblDHCPDNSSrv", $sLblDHCPDNSSrv)
	$sLblDHCPWINSSrv	= IniRead($sFile, $sSection, "LblDHCPWINSSrv", $sLblDHCPWINSSrv)
	$sLblDHCPSrv		= IniRead($sFile, $sSection, "LblDHCPSrv", $sLblDHCPSrv)
	$sLblDHCPLTO		= IniRead($sFile, $sSection, "LblDHCPLTO", $sLblDHCPLTO)
	$sLblDHCPLTE		= IniRead($sFile, $sSection, "LblDHCPLTE", $sLblDHCPLTE)
	$sBtnIPStatic		= IniRead($sFile, $sSection, "RadioStatic", $sBtnIPStatic)
	$sLblStaticIP		= IniRead($sFile, $sSection, "LblStaticIP", $sLblStaticIP)
	$sLblStaticSM		= IniRead($sFile, $sSection, "LblStaticSM", $sLblStaticSM)
	$sLblStaticDG		= IniRead($sFile, $sSection, "LblStaticDG", $sLblStaticDG)
	$sBtnStatic			= IniRead($sFile, $sSection, "BtnStatic", $sBtnStatic)
	$sBtnDynamic		= IniRead($sFile, $sSection, "BtnDynamic", $sBtnDynamic)
	$sBtnDNSDHCP		= IniRead($sFile, $sSection, "RadioDNSDHCP", $sBtnDNSDHCP)
	$sBtnDNSStatic		= IniRead($sFile, $sSection, "RadioDNSStatic", $sBtnDNSStatic)
	$sLblDNS			= IniRead($sFile, $sSection, "LblDNS", $sLblDNS)
	$sBtnWINSDHCP		= IniRead($sFile, $sSection, "RadioWINSDHCP", $sBtnWINSDHCP)
	$sBtnWINSStatic		= IniRead($sFile, $sSection, "RadioWINSStatic", $sBtnWINSStatic)
	$sLblWINS			= IniRead($sFile, $sSection, "LblWINS", $sLblWINS)
	$sLblComputer		= IniRead($sFile, $sSection, "LblComputer", $sLblComputer)
	$sLblWorkgroup		= IniRead($sFile, $sSection, "LblWorkgroup", $sLblWorkgroup)
	$sLblPriDNS			= IniRead($sFile, $sSection, "LblPriDNS", $sLblPriDNS)
	$sTAddIP			= IniRead($sFile, $sSection, "TAddIP", $sTAddIP)
	$sTAddDG			= IniRead($sFile, $sSection, "TAddDG", $sTAddDG)
	$sTAddDNS			= IniRead($sFile, $sSection, "TAddDNS", $sTAddDNS)
	$sTAddWINS			= IniRead($sFile, $sSection, "TAddWINS", $sTAddWINS)
	$sTAddIPAddr		= IniRead($sFile, $sSection, "TAddIPAddr", $sTAddIPAddr)
	$sTAddDGAddr		= IniRead($sFile, $sSection, "TAddDGAddr", $sTAddDGAddr)
	$sTAddDNSAddr		= IniRead($sFile, $sSection, "TAddDNSAddr", $sTAddDNSAddr)
	$sTAddWINSAddr		= IniRead($sFile, $sSection, "TAddWINSAddr", $sTAddWINSAddr)
	$sTTShareRefresh	= IniRead($sFile, $sSection, "TTShareRefresh", $sTTShareRefresh)
	$sTTDrivesRefresh	= IniRead($sFile, $sSection, "TTDrivesRefresh", $sTTDrivesRefresh)
	$sTTWiFiRefresh		= IniRead($sFile, $sSection, "TTWiFiRefresh", $sTTWiFiRefresh)
	$sTTWiFiRefPref		= IniRead($sFile, $sSection, "TTWiFiRefPref", $sTTWiFiRefPref)
	$sChkForceScan		= IniRead($sFile, $sSection, "ChkForceScan", $sChkForceScan)
	$sTrayShowGUI		= IniRead($sFile, $sSection, "TrayShowGUI", $sTrayShowGUI)
	$sTrayShowAni		= IniRead($sFile, $sSection, "TrayShowAni", $sTrayShowAni)
	$sTrayExit			= IniRead($sFile, $sSection, "TrayExit", $sTrayExit)
	$sMsgWait			= IniRead($sFile, $sSection, "MsgWait", $sMsgWait)
	$sMsgChangesApply	= IniRead($sFile, $sSection, "MsgChangesApply", $sMsgChangesApply)
	$sMsgReleaseAddr	= IniRead($sFile, $sSection, "MsgReleaseAddr", $sMsgReleaseAddr)
	$sMsgRenewAddr		= IniRead($sFile, $sSection, "MsgRenewAddr", $sMsgRenewAddr)
	$sMsgInitWait		= IniRead($sFile, $sSection, "MsgInitWait", $sMsgInitWait)
	$sTIWiFiAvailable	= IniRead($sFile, $sSection, "TIWiFiAvailable", $sTIWiFiAvailable)
	$sBtnWiFiConnect	= IniRead($sFile, $sSection, "BtnWiFiConnect", $sBtnWiFiConnect)
	$sBtnWiFiDisconnect	= IniRead($sFile, $sSection, "BtnWiFiDisconn", $sBtnWiFiDisconnect)
	$sLVWiFiList		= IniRead($sFile, $sSection, "LVWiFiList", $sLVWiFiList)
	$sLVWiFiPref		= IniRead($sFile, $sSection, "LVWiFiPref", $sLVWiFiPref)
	$sTIWiFiPreferred	= IniRead($sFile, $sSection, "TIWiFiPrefered", $sTIWiFiPreferred)
	$sTIWiFiService		= IniRead($sFile, $sSection, "TIWiFiService", $sTIWiFiService)
	$sLblWiFiCurState	= IniRead($sFile, $sSection, "LblWiFiCurState", $sLblWiFiCurState)
	$sLblWiFiNoDevice	= IniRead($sFile, $sSection, "LblWiFiNoDevice", $sLblWiFiNoDevice)
	$sLblWiFiWlanApiNF	= IniRead($sFile, $sSection, "LblWiFiWlanApiNF", $sLblWiFiWlanApiNF)
	$sServiceNotInst	= IniRead($sFile, $sSection, "ServiceNotInst", $sServiceNotInst)
	$sServiceStop		= IniRead($sFile, $sSection, "ServiceStop", $sServiceStop)
	$sServiceStopped	= IniRead($sFile, $sSection, "ServiceStopped", $sServiceStopped)
	$sServiceStart		= IniRead($sFile, $sSection, "ServiceStart", $sServiceStart)
	$sServiceStarted	= IniRead($sFile, $sSection, "ServiceStarted", $sServiceStarted)
	$sTIIPSettings		= IniRead($sFile, $sSection, "TIIPSettings", $sTIIPSettings)
	$sTIWINS			= IniRead($sFile, $sSection, "TIWINS", $sTIWINS)
	$sTIWiFi			= IniRead($sFile, $sSection, "TIWiFi", $sTIWiFi)
	$sLblCNI			= IniRead($sFile, $sSection, "LblCNI", $sLblCNI)
	$sLblPing			= IniRead($sFile, $sSection, "LblPing", $sLblPing)
	$sBtnPingStart		= IniRead($sFile, $sSection, "BtnPingStart", $sBtnPingStart)
	$sBtnPingStop		= IniRead($sFile, $sSection, "BtnPingStop", $sBtnPingStop)
	$sLblPingCount		= IniRead($sFile, $sSection, "LblPingCount", $sLblPingCount)
	$sLblPingTime		= IniRead($sFile, $sSection, "LblPingTime", $sLblPingTime)
	$sChkPingLimit		= IniRead($sFile, $sSection, "ChkPingLimit", $sChkPingLimit)
	$sLVPing			= IniRead($sFile, $sSection, "LVPing", $sLVPing)
	$sLVIReply			= IniRead($sFile, $sSection, "LVIReply", $sLVIReply)
	$sLVIReplyTime		= IniRead($sFile, $sSection, "LVIReplyTime", $sLVIReplyTime)
	$sLVIReplyTimeMS	= IniRead($sFile, $sSection, "LVIReplyTimeMS", $sLVIReplyTimeMS)
	$sLVITimeOut		= IniRead($sFile, $sSection, "LVITimeOut", $sLVITimeOut)
	$sLVIUnreachable	= IniRead($sFile, $sSection, "LVIUnreachable", $sLVIUnreachable)
	$sLVIInvalid		= IniRead($sFile, $sSection, "LVIInvalid", $sLVIInvalid)
	$sLVIGeneral		= IniRead($sFile, $sSection, "LVIGeneral", $sLVIGeneral)
	$sLblFileSharing	= IniRead($sFile, $sSection, "LblFileSharing", $sLblFileSharing)
	$sBtnShareStart		= IniRead($sFile, $sSection, "BtnShareStart", $sBtnShareStart)
	$sLblShareUser		= IniRead($sFile, $sSection, "LblShareUser", $sLblShareUser)
	$sLblSharePW		= IniRead($sFile, $sSection, "LblSharePW", $sLblSharePW)
	$sChkShareAll		= IniRead($sFile, $sSection, "ChkShareAll", $sChkShareAll)
	$sTTShareAll		= IniRead($sFile, $sSection, "TTShareAll", $sTTShareAll)
	$sBtnShareSetPW		= IniRead($sFile, $sSection, "BtnShareSetPW", $sBtnShareSetPW)
	$sEditShareAdmin	= IniRead($sFile, $sSection, "LblShareAdmin", $sEditShareAdmin)
	$sLblSharedFolders	= IniRead($sFile, $sSection, "LblSharedFolders", $sLblSharedFolders)
	$sLVShares			= IniRead($sFile, $sSection, "LVShares", $sLVShares)
	$sLblShareName		= IniRead($sFile, $sSection, "LblShareName", $sLblShareName)
	$sTTShareName		= IniRead($sFile, $sSection, "TTShareName", $sTTShareName)
	$sLblSharePath		= IniRead($sFile, $sSection, "LblSharePath", $sLblSharePath)
	$sMIShareBrowse		= IniRead($sFile, $sSection, "MIShareBrowse", $sMIShareBrowse)
	$sMIShareDel		= IniRead($sFile, $sSection, "MIShareDel", $sMIShareDel)
	$sTTShareUser		= IniRead($sFile, $sSection, "TTShareUser", $sTTShareUser)
	$sTTShareUserLen	= IniRead($sFile, $sSection, "TTShareUserLen", $sTTShareUserLen)
	$sTTInputChars		= IniRead($sFile, $sSection, "TTInputChars", $sTTInputChars)
	$sTTSharePWLen		= IniRead($sFile, $sSection, "TTSharePWLen", $sTTSharePWLen)
	$sLblDriveLetter	= IniRead($sFile, $sSection, "LblDriveLetter", $sLblDriveLetter)
	$sTTDriveLetter		= IniRead($sFile, $sSection, "TTDriveLetter", $sTTDriveLetter)
	$sTTDriveLetterNo	= IniRead($sFile, $sSection, "TTDriveLetterNo", $sTTDriveLetterNo)
	$sTTDriveNoFree1	= IniRead($sFile, $sSection, "TTDriveNoFree1", $sTTDriveNoFree1)
	$sTTDriveNoFree2	= IniRead($sFile, $sSection, "TTDriveNoFree2", $sTTDriveNoFree2)
	$sBtnConnect		= IniRead($sFile, $sSection, "BtnConnect", $sBtnConnect)
	$sBtnDisconnect		= IniRead($sFile, $sSection, "BtnDisconnect", $sBtnDisconnect)
	$sLblDrivePath		= IniRead($sFile, $sSection, "LblDrivePath", $sLblDrivePath)
	$sLblDriveUser		= IniRead($sFile, $sSection, "LblDriveUser", $sLblDriveUser)
	$sLblDrivePW		= IniRead($sFile, $sSection, "LblDrivePW", $sLblDrivePW)
	$sLblDrivesCon		= IniRead($sFile, $sSection, "LblDrivesCon", $sLblDrivesCon)
	$sLVDrivesCon		= IniRead($sFile, $sSection, "LVDrivesCon", $sLVDrivesCon)
	$sMIDriveBrowse		= IniRead($sFile, $sSection, "MIDriveBrowse", $sMIDriveBrowse)
	$sMIDriveDiscon		= IniRead($sFile, $sSection, "MIDriveDiscon", $sMIDriveDiscon)
	$sGrpTrayOptions	= IniRead($sFile, $sSection, "GrpTrayOptions", $sGrpTrayOptions)
	$sChkTrayStart		= IniRead($sFile, $sSection, "ChkTrayStart", $sChkTrayStart)
	$sChkTrayMin		= IniRead($sFile, $sSection, "ChkTrayMin", $sChkTrayMin)
	$sChkTrayClose		= IniRead($sFile, $sSection, "ChkTrayClose", $sChkTrayClose)
	$sLblAboutAI3		= IniRead($sFile, $sSection, "LblAboutAI3", $sLblAboutAI3)
	$sLVIPSM			= IniRead($sFile, $sSection, "LVIPSM", $sLVIPSM)
	$sWiFiUnnamed		= IniRead($sFile, $sSection, "WiFiUnnamed", $sWiFiUnnamed)
	$sWiFiNone			= IniRead($sFile, $sSection, "WiFiNone", $sWiFiNone)
	$sERROR				= IniRead($sFile, $sSection, "ERROR", $sERROR)
	$sINFO				= IniRead($sFile, $sSection, "INFO", $sINFO)
	$sWARNING			= IniRead($sFile, $sSection, "WARNING", $sWARNING)
	$sQUESTION			= IniRead($sFile, $sSection, "QUESTION", $sQUESTION)
	$sProfSelTitle		= IniRead($sFile, $sSection, "ProfSelTitle", $sProfSelTitle)
	$sLblProfSelect		= IniRead($sFile, $sSection, "LblProfSelect", $sLblProfSelect)
	$sLblProfDesc		= IniRead($sFile, $sSection, "LblProfDesc", $sLblProfDesc)
	$sLblProfFile		= IniRead($sFile, $sSection, "LblProfFile", $sLblProfFile)
	$sLblProfList		= IniRead($sFile, $sSection, "LblProfList", $sLblProfList)
	$sTTProfRefresh		= IniRead($sFile, $sSection, "TTProfRefresh", $sTTProfRefresh)
	$sTTProfIniFiles	= IniRead($sFile, $sSection, "TTProfIniFiles", $sTTProfIniFiles)
	$sLblProfApply		= IniRead($sFile, $sSection, "LblProfApply", $sLblProfApply)
	$sProfIn			= IniRead($sFile, $sSection, "ProfIn", $sProfIn)
	$sProfSec			= IniRead($sFile, $sSection, "ProfSec", $sProfSec)
	$sLblSearchDevice	= IniRead($sFile, $sSection, "LblSearchDevice", $sLblSearchDevice)
	$sDeviceFound		= IniRead($sFile, $sSection, "DeviceFound", $sDeviceFound)
	$sDeviceSucces		= IniRead($sFile, $sSection, "DeviceSucces", $sDeviceSucces)
	$sErrorNetShared	= IniRead($sFile, $sSection, "ErrorNetShared", $sErrorNetShared)
	$sNetShareOK		= IniRead($sFile, $sSection, "NetShareOK", $sNetShareOK)
	$sNetShareOKAs		= IniRead($sFile, $sSection, "NetShareOKAs", $sNetShareOKAs)
	$sNetShrNotExist	= IniRead($sFile, $sSection, "NetShrNotExist", $sNetShrNotExist)
	$sNetShrAccDen		= IniRead($sFile, $sSection, "NetShrAccDen", $sNetShrAccDen)
	$sNetShrInvName		= IniRead($sFile, $sSection, "NetShrInvName", $sNetShrInvName)
	$sNetShrPNE			= IniRead($sFile, $sSection, "NetShrPNE", $sNetShrPNE)
	$sNetShrNameDup		= IniRead($sFile, $sSection, "NetShrNameDup", $sNetShrNameDup)
	$sErrorNetSharing	= IniRead($sFile, $sSection, "ErrorNetSharing", $sErrorNetSharing)
	$sTTCharsMax		= IniRead($sFile, $sSection, "TTCharsMax", $sTTCharsMax)
	$sTTCharsNoAllow	= IniRead($sFile, $sSection, "TTCharsNoAllow", $sTTCharsNoAllow)
	$sNetStartNet		= IniRead($sFile, $sSection, "NetStartNet", $sNetStartNet)
	$sLblStartNet		= IniRead($sFile, $sSection, "LblStartNet", $sLblStartNet)
	$sLblStartNetWpe	= IniRead($sFile, $sSection, "LblStartNetWpe", $sLblStartNetWpe)
	$sNetRegisterObj	= IniRead($sFile, $sSection, "NetRegisterObj", $sNetRegisterObj)
	$sNetChkDrv			= IniRead($sFile, $sSection, "NetChkDrv", $sNetChkDrv)
	$sNetDetectDev		= IniRead($sFile, $sSection, "NetDetectDev", $sNetDetectDev)
	$sNetDetectNew		= IniRead($sFile, $sSection, "NetDetectNew", $sNetDetectNew)
	$sNetInstTCP		= IniRead($sFile, $sSection, "NetInstTCP", $sNetInstTCP)
	$sNetApplyProfile	= IniRead($sFile, $sSection, "NetApplyProfile", $sNetApplyProfile)
	$sNetInstMSClient	= IniRead($sFile, $sSection, "NetInstMSClient", $sNetInstMSClient)
	$sNetChkServices	= IniRead($sFile, $sSection, "NetChkServices", $sNetChkServices)
	$sNetStartTCPIP		= IniRead($sFile, $sSection, "NetStartTCPIP", $sNetStartTCPIP)
	$sNetStartDHCP		= IniRead($sFile, $sSection, "NetStartDHCP", $sNetStartDHCP)
	$sNetStartNLA		= IniRead($sFile, $sSection, "NetStartNLA", $sNetStartNLA)
	$sNetStartLMH		= IniRead($sFile, $sSection, "NetStartLMH", $sNetStartLMH)
	$sNetNoNetcards		= IniRead($sFile, $sSection, "NetNoNetcards", $sNetNoNetcards)
	$sProgramExit		= IniRead($sFile, $sSection, "ProgramExit", $sProgramExit)
	$sShareSelFolder	= IniRead($sFile, $sSection, "ShareSelFolder", $sShareSelFolder)
	$sShareChkDrv		= IniRead($sFile, $sSection, "ShareChkDrv", $sShareChkDrv)
	$sShareInstSrv		= IniRead($sFile, $sSection, "ShareInstSrv", $sShareInstSrv)
	$sServiceChkSrv		= IniRead($sFile, $sSection, "ServiceChkSrv", $sServiceChkSrv)
	$sShareStartSrv		= IniRead($sFile, $sSection, "ShareStartSrv", $sShareStartSrv)
	$sShareStopSrv		= IniRead($sFile, $sSection, "ShareStopSrv", $sShareStopSrv)
	$sServiceInstFinish	= IniRead($sFile, $sSection, "ServiceFinish", $sServiceInstFinish)
	$sShareSetPW		= IniRead($sFile, $sSection, "ShareSetPW", $sShareSetPW)
	$sShareStopInfo1	= IniRead($sFile, $sSection, "ShareStopInfo1", $sShareStopInfo1)
	$sShareStopInfo2	= IniRead($sFile, $sSection, "ShareStopInfo2", $sShareStopInfo2)
	$sShareStopInfo3	= IniRead($sFile, $sSection, "ShareStopInfo3", $sShareStopInfo3)
	$sShareStopInfo4	= IniRead($sFile, $sSection, "ShareStopInfo4", $sShareStopInfo4)
	$sShareMsgOpen		= IniRead($sFile, $sSection, "ShareMsgOpen", $sShareMsgOpen)
	$sShareMsgRemove	= IniRead($sFile, $sSection, "ShareMsgRemove", $sShareMsgRemove)
	$sShareMsgSpecial	= IniRead($sFile, $sSection, "ShareMsgSpecial", $sShareMsgSpecial)
	$sShareMsgDel1		= IniRead($sFile, $sSection, "ShareMsgDel1", $sShareMsgDel1)
	$sShareMsgDel2		= IniRead($sFile, $sSection, "ShareMsgDel2", $sShareMsgDel2)
	$sShareMsgDel3		= IniRead($sFile, $sSection, "ShareMsgDel3", $sShareMsgDel3)
	$sShareMsgDel4		= IniRead($sFile, $sSection, "ShareMsgDel4", $sShareMsgDel4)
	$sShareMsgDel5		= IniRead($sFile, $sSection, "ShareMsgDel5", $sShareMsgDel5)
	$sLblShareRemove	= IniRead($sFile, $sSection, "LblShareRemove", $sLblShareRemove)
	$sNetShrNameNotEx	= IniRead($sFile, $sSection, "NetShrNameNotEx", $sNetShrNameNotEx)
	$sNetErrShareInfo	= IniRead($sFile, $sSection, "NetErrShareInfo", $sNetErrShareInfo)
	$sNetShareRemSucc	= IniRead($sFile, $sSection, "NetShareRemSucc", $sNetShareRemSucc)
	$sNetShareRemErr	= IniRead($sFile, $sSection, "NetShareRemErr", $sNetShareRemErr)
	$sLblDriveConnect	= IniRead($sFile, $sSection, "LblDriveConnect", $sLblDriveConnect)
	$sNetDriveSucc1		= IniRead($sFile, $sSection, "NetDriveSucc1", $sNetDriveSucc1)
	$sNetDriveSucc2		= IniRead($sFile, $sSection, "NetDriveSucc2", $sNetDriveSucc2)
	$sNetDriveAddErr1	= IniRead($sFile, $sSection, "NetDriveAddErr1", $sNetDriveAddErr1)
	$sNetDriveAddErr2	= IniRead($sFile, $sSection, "NetDriveAddErr2", $sNetDriveAddErr2)
	$sNetDriveAddErr3	= IniRead($sFile, $sSection, "NetDriveAddErr3", $sNetDriveAddErr3)
	$sNetDriveAddErr4	= IniRead($sFile, $sSection, "NetDriveAddErr4", $sNetDriveAddErr4)
	$sNetDriveAddErr5	= IniRead($sFile, $sSection, "NetDriveAddErr5", $sNetDriveAddErr5)
	$sNetDriveAddErr6	= IniRead($sFile, $sSection, "NetDriveAddErr6", $sNetDriveAddErr6)
	$sNetDriveAddErr7	= IniRead($sFile, $sSection, "NetDriveAddErr7", $sNetDriveAddErr7)
	$sNetDriveMsgDel1	= IniRead($sFile, $sSection, "NetDriveMsgDel1", $sNetDriveMsgDel1)
	$sNetDriveMsgDel2	= IniRead($sFile, $sSection, "NetDriveMsgDel2", $sNetDriveMsgDel2)
	$sLblDriveDel		= IniRead($sFile, $sSection, "LblDriveDel", $sLblDriveDel)
	$sNetDriveDelErr	= IniRead($sFile, $sSection, "NetDriveDelErr", $sNetDriveDelErr)
	$sMsgUtilNotFnd1	= IniRead($sFile, $sSection, "MsgUtilNotFnd1", $sMsgUtilNotFnd1)
	$sMsgUtilNotFnd2	= IniRead($sFile, $sSection, "MsgUtilNotFnd2", $sMsgUtilNotFnd2)
	$sNetErrRegister	= IniRead($sFile, $sSection, "NetErrRegister", $sNetErrRegister)
	$sNetErrTCPNotFnd	= IniRead($sFile, $sSection, "NetErrTCPNotFnd", $sNetErrTCPNotFnd)
	$sNetErrMSCNotFnd	= IniRead($sFile, $sSection, "NetErrMSCNotFnd", $sNetErrMSCNotFnd)
	$sNetErrDetDev		= IniRead($sFile, $sSection, "NetErrDetDev", $sNetErrDetDev)
	$sNetErrTCPInst		= IniRead($sFile, $sSection, "NetErrTCPInst", $sNetErrTCPInst)
	$sNetErrMSCInst		= IniRead($sFile, $sSection, "NetErrMSCInst", $sNetErrMSCInst)
	$sNetErrTCPStart	= IniRead($sFile, $sSection, "NetErrTCPStart", $sNetErrTCPStart)
	$sNetErrDHCPStart	= IniRead($sFile, $sSection, "NetErrDHCPStart", $sNetErrDHCPStart)
	$sNetErrTCPRegStart	= IniRead($sFile, $sSection, "NetErrTCPRegStart", $sNetErrTCPRegStart)
	$sNetErrStatOnly	= IniRead($sFile, $sSection, "NetErrStatOnly", $sNetErrStatOnly)
	$sNetErrNLAStart	= IniRead($sFile, $sSection, "NetErrNLAStart", $sNetErrNLAStart)
	$sNetErrLMHStart	= IniRead($sFile, $sSection, "NetErrLMHStart", $sNetErrLMHStart)
	$sServiceStopping	= IniRead($sFile, $sSection, "ServiceStopping", $sServiceStopping)
	$sServiceDesc		= IniRead($sFile, $sSection, "ServiceDesc", $sServiceDesc)
	$sServiceStarting	= IniRead($sFile, $sSection, "ServiceStarting", $sServiceStarting)
	$sShareErrInf		= IniRead($sFile, $sSection, "ShareErrInf", $sShareErrInf)
	$sShareErrInst		= IniRead($sFile, $sSection, "ShareErrInst", $sShareErrInst)
	$sShareErrInst2		= IniRead($sFile, $sSection, "ShareErrInst2", $sShareErrInst2)
	$sShareErrStart		= IniRead($sFile, $sSection, "ShareErrStart", $sShareErrStart)
	$sShareErrCB		= IniRead($sFile, $sSection, "ShareErrCB", $sShareErrCB)
	$sShareErrStop		= IniRead($sFile, $sSection, "ShareErrStop", $sShareErrStop)
	$sShareErrPW		= IniRead($sFile, $sSection, "ShareErrPW", $sShareErrPW)
	$sShareErrUsr		= IniRead($sFile, $sSection, "ShareErrUsr", $sShareErrUsr)
	$sShareErrAdmin		= IniRead($sFile, $sSection, "ShareErrAdmin", $sShareErrAdmin)
	$sShareAddUser		= IniRead($sFile, $sSection, "ShareAddUser", $sShareAddUser)
	$sGrpLanguage		= IniRead($sFile, $sSection, "GrpLanguage", $sGrpLanguage)
	$sLblLangAuthor		= IniRead($sFile, $sSection, "LblLangAuthor", $sLblLangAuthor)
	$sLblLangVersion	= IniRead($sFile, $sSection, "LblLangVersion", $sLblLangVersion)
	$arConState[0]		= IniRead($sFile, $sSection, "ConStateOK", $arConState[0])
	$arConState[1]		= IniRead($sFile, $sSection, "ConStatePause", $arConState[1])
	$arConState[2]		= IniRead($sFile, $sSection, "ConStateDiscon", $arConState[2])
	$arConState[3]		= IniRead($sFile, $sSection, "ConStateErr", $arConState[3])
	$arConState[4]		= IniRead($sFile, $sSection, "ConStateNetErr", $arConState[4])
	$arConState[5]		= IniRead($sFile, $sSection, "ConStateCon", $arConState[5])
	$arConState[6]		= IniRead($sFile, $sSection, "ConStateRecon", $arConState[6])
	$sWiFiChkDrv		= IniRead($sFile, $sSection, "WiFiChkDrv", $sWiFiChkDrv)
	$sWiFiErrInf		= IniRead($sFile, $sSection, "WiFiErrInf", $sWiFiErrInf)
	$sWiFiErrInf2		= IniRead($sFile, $sSection, "WiFiErrInf2", $sWiFiErrInf2)
	$sWiFiErrInf3		= IniRead($sFile, $sSection, "WiFiErrInf3", $sWiFiErrInf3)
	$sWiFiErrInst		= IniRead($sFile, $sSection, "WiFiErrInst", $sWiFiErrInst)
	$sWiFiErrInst2		= IniRead($sFile, $sSection, "WiFiErrInst2", $sWiFiErrInst2)
	$sWiFiRegXML		= IniRead($sFile, $sSection, "WiFiRegXML", $sWiFiRegXML)
	$sWiFiInstSrv		= IniRead($sFile, $sSection, "WiFiInstSrv", $sWiFiInstSrv)
	$sWiFiInstSrv2		= IniRead($sFile, $sSection, "WiFiInstSrv2", $sWiFiInstSrv2)
	$sWiFiInstSrv3		= IniRead($sFile, $sSection, "WiFiInstSrv3", $sWiFiInstSrv3)
	$sWiFiStop			= IniRead($sFile, $sSection, "WiFiStop", $sWiFiStop)
	$sWiFiStartSrv		= IniRead($sFile, $sSection, "WiFiStartSrv", $sWiFiStartSrv)
	$sWiFiStopSrv		= IniRead($sFile, $sSection, "WiFiStopSrv", $sWiFiStopSrv)
	$sWiFiStartSrv2		= IniRead($sFile, $sSection, "WiFiStartSrv2", $sWiFiStartSrv2)
	$sWiFiStopSrv2		= IniRead($sFile, $sSection, "WiFiStopSrv2", $sWiFiStopSrv2)
	$sWiFiErrStart		= IniRead($sFile, $sSection, "WiFiErrStart", $sWiFiErrStart)
	$sWiFiErrStart2		= IniRead($sFile, $sSection, "WiFiErrStart2", $sWiFiErrStart2)
	$sWiFiErrStart3		= IniRead($sFile, $sSection, "WiFiErrStart3", $sWiFiErrStart3)
	$sWiFiErrStart4		= IniRead($sFile, $sSection, "WiFiErrStart4", $sWiFiErrStart4)
	$sWiFiErrStop		= IniRead($sFile, $sSection, "WiFiErrStop", $sWiFiErrStop)
	$sWiFiErrStop2		= IniRead($sFile, $sSection, "WiFiErrStop2", $sWiFiErrStop2)
	$sWiFiConnected		= IniRead($sFile, $sSection, "WiFiConnected", $sWiFiConnected)
	$sLblNoNetcards		= StringReplace(IniRead($sFile, $sSection, "LblNoNetcards", $sLblNoNetcards), "@LF", @LF)
	$sBtnSearchDevice	= IniRead($sFile, $sSection, "BtnSearchDevice", $sBtnSearchDevice)
	$sTWiFiProp			= IniRead($sFile, $sSection, "TWiFiProp", $sTWiFiProp)
	$sLblWiFiSSID		= IniRead($sFile, $sSection, "LblWiFiSSID", $sLblWiFiSSID)
	$sLblWiFiAuth		= IniRead($sFile, $sSection, "LblWiFiAuth", $sLblWiFiAuth)
	$sLblWiFiEnc		= IniRead($sFile, $sSection, "LblWiFiEnc", $sLblWiFiEnc)
	$sLblWiFiKey		= IniRead($sFile, $sSection, "LblWiFiKey", $sLblWiFiKey)
	$sChkWiFiKey		= IniRead($sFile, $sSection, "ChkWiFiKey", $sChkWiFiKey)
	$sChkWiFiAuto		= IniRead($sFile, $sSection, "ChkWiFiAuto", $sChkWiFiAuto)
	$sChkWiFiHidden		= IniRead($sFile, $sSection, "ChkWiFiHidden", $sChkWiFiHidden)
	$sChkWiFiAdhoc		= IniRead($sFile, $sSection, "ChkWiFiAdhoc", $sChkWiFiAdhoc)
	$sCMDStart			= IniRead($sFile, $sSection, "CMDStart", $sCMDStart)
	$sCMDActions		= IniRead($sFile, $sSection, "CMDActions", $sCMDActions)
	$sCMDIPChange		= IniRead($sFile, $sSection, "CMDIPChange", $sCMDIPChange)
	$sCMDIPModeN		= IniRead($sFile, $sSection, "CMDIPModeN", $sCMDIPModeN)
	$sCMDIPModeH		= IniRead($sFile, $sSection, "CMDIPModeH", $sCMDIPModeH)
	$sCMDIPModeMin		= IniRead($sFile, $sSection, "CMDIPModeMin", $sCMDIPModeMin)
	$sCMDIPModeMax		= IniRead($sFile, $sSection, "CMDIPModeMax", $sCMDIPModeMax)
	$sCMDIPModeWait		= IniRead($sFile, $sSection, "CMDIPModeWait", $sCMDIPModeWait)
	$sCMDIPModeNowait	= IniRead($sFile, $sSection, "CMDIPModeNowait", $sCMDIPModeNowait)
	$sCMDLine			= IniRead($sFile, $sSection, "CMDLine", $sCMDLine)
	$sCMDLineMode		= IniRead($sFile, $sSection, "CMDLineMode", $sCMDLineMode)
	$sCMDLIneNumber		= IniRead($sFile, $sSection, "CMDLIneNumber", $sCMDLIneNumber)
	$sTIAdvanced		= IniRead($sFile, $sSection, "TIAdvanced", $sTIAdvanced)
	$sLblExtProp		= IniRead($sFile, $sSection, "LblExtProp", $sLblExtProp)
	$sLblExtNoProp		= IniRead($sFile, $sSection, "LblExtNoProp", $sLblExtNoProp)
	$sLblProp			= IniRead($sFile, $sSection, "LblProp", $sLblProp)
	$sLblPropVal		= IniRead($sFile, $sSection, "LblPropVal", $sLblPropVal)
	$sRadioNotSet		= IniRead($sFile, $sSection, "RadioNotSet", $sRadioNotSet)
	$sTTCon				= IniRead($sFile, $sSection, "TTCon", $sTTCon)
	$sTTDiscon			= IniRead($sFile, $sSection, "TTDiscon", $sTTDiscon)
	$sGrpTrouble		= IniRead($sFile, $sSection, "GrpTrouble", $sGrpTrouble)
	$sChkDebug			= IniRead($sFile, $sSection, "ChkDebug", $sChkDebug)	
	$sBtnDebug			= IniRead($sFile, $sSection, "BtnDebug", $sBtnDebug)
	$sLblWiFiCon		= IniRead($sFile, $sSection, "LblWiFiCon", $sLblWiFiCon)
	$sWiFiBalConTo		= IniRead($sFile, $sSection, "WiFiBalConTo", $sWiFiBalConTo)
	$sWiFiBalNetSec		= IniRead($sFile, $sSection, "WiFiBalNetSec", $sWiFiBalNetSec)
	$sWiFiBalNetNonSec	= IniRead($sFile, $sSection, "WiFiBalNetNonSec", $sWiFiBalNetNonSec)
	$sWiFiBalNetPref	= IniRead($sFile, $sSection, "WiFiBalNetPref", $sWiFiBalNetPref)
	$sWiFiBalNetInfra	= IniRead($sFile, $sSection, "WiFiBalNetInfra", $sWiFiBalNetInfra)
	$sWiFiBalNetAdhoc	= IniRead($sFile, $sSection, "WiFiBalNetAdhoc", $sWiFiBalNetAdhoc)
	$sWiFiDelProf		= IniRead($sFile, $sSection, "WiFiDelProf", $sWiFiDelProf)
	$sWiFiDelTxt		= IniRead($sFile, $sSection, "WiFiDelTxt", $sWiFiDelTxt)
	$sWiFiDelWarn		= IniRead($sFile, $sSection, "WiFiDelWarn", $sWiFiDelWarn)
	$sBtnWiFiImport		= IniRead($sFile, $sSection, "BtnWiFiImport", $sBtnWiFiImport)
	$sTTWiFiImport		= IniRead($sFile, $sSection, "TTWiFiImport", $sTTWiFiImport)
	$sTTWiFiXMLFiles	= IniRead($sFile, $sSection, "TTWiFiXMLFiles", $sTTWiFiXMLFiles)
	$sWiFiImportOK		= IniRead($sFile, $sSection, "WiFiImportOK", $sWiFiImportOK)
	$sWiFiErrImport		= IniRead($sFile, $sSection, "WiFiErrImport", $sWiFiErrImport)
	$sBtnWiFiExport		= IniRead($sFile, $sSection, "BtnWiFiExport", $sBtnWiFiExport)
	$sTTWiFiExport		= IniRead($sFile, $sSection, "TTWiFiExport", $sTTWiFiExport)
	$sWiFiExportOK		= IniRead($sFile, $sSection, "WiFiExportOK", $sWiFiExportOK)
	$sWiFiErrExport		= IniRead($sFile, $sSection, "WiFiErrExport", $sWiFiErrExport)
	$sLblClr			= IniRead($sFile, $sSection, "LblClr", $sLblClr)
	$sWiFiErrAddProf	= IniRead($sFile, $sSection, "WiFiErrAddProf", $sWiFiErrAddProf)
	$sTWiFiConn			= IniRead($sFile, $sSection, "TWiFiConn", $sTWiFiConn)
	$sLblDefault		= IniRead($sFile, $sSection, "LblDefault", $sLblDefault)
	$sLblCurrent		= IniRead($sFile, $sSection, "LblCurrent", $sLblCurrent)
	$sLblClassic		= IniRead($sFile, $sSection, "LblClassic", $sLblClassic)
	$sBtnDrvNet			= IniRead($sFile, $sSection, "BtnDrvNet", $sBtnDrvNet)
	$sBtnDrvNetShow		= IniRead($sFile, $sSection, "BtnDrvNetShow", $sBtnDrvNetShow)
	$sLblDrvNet			= IniRead($sFile, $sSection, "LblDrvNet", $sLblDrvNet)
	$sTTNetConDetails	= IniRead($sFile, $sSection, "TTNetConDetails", $sTTNetConDetails)
	$sLVNetConPropVal	= IniRead($sFile, $sSection, "LVNetConPropVal", $sLVNetConPropVal)
	$sLblNetResSearch	= IniRead($sFile, $sSection, "LblNetResSearch", $sLblNetResSearch)
	$sBtnDrvNetReset	= IniRead($sFile, $sSection, "BtnDrvNetReset", $sBtnDrvNetReset)
	$sBtnLogDel			= IniRead($sFile, $sSection, "BtnLogDel", $sBtnLogDel)
	$sMsgLogDel			= IniRead($sFile, $sSection, "MsgLogDel", $sMsgLogDel)
	$sLblTCPtoIP		= IniRead($sFile, $sSection, "LblTCPtoIP", $sLblTCPtoIP)
	$sLblIPtoTCP		= IniRead($sFile, $sSection, "LblIPtoTCP", $sLblIPtoTCP)
	$sChkWiFiEditUI		= IniRead($sFile, $sSection, "ChkWiFiEditUI", $sChkWiFiEditUI)
	$sBtnProfFile		= IniRead($sFile, $sSection, "BtnProfFile", $sBtnProfFile)
	$sBtnProfInt		= IniRead($sFile, $sSection, "BtnProfInt", $sBtnProfInt)
	$sBtnProfExt		= IniRead($sFile, $sSection, "BtnProfExt", $sBtnProfExt)
	$sNetworkAccess		= IniRead($sFile, $sSection, "NetworkAccess", $sNetworkAccess)
	$sBtnTrace			= IniRead($sFile, $sSection, "BtnTrace", $sBtnTrace)
	$sChkTrace			= IniRead($sFile, $sSection, "ChkTrace", $sChkTrace)
	$sLblTrace			= IniRead($sFile, $sSection, "LblTrace", $sLblTrace)
	$sStateTrace		= IniRead($sFile, $sSection, "StateTrace", $sStateTrace)
	$sChkReverse		= IniRead($sFile, $sSection, "ChkReverse", $sChkReverse)
	$sLblSurface		= IniRead($sFile, $sSection, "LblSurface", $sLblSurface)
	$sBtnLangExt		= IniRead($sFile, $sSection, "BtnLangExt", $sBtnLangExt)
	$sChkShowTip		= IniRead($sFile, $sSection, "ChkShowTip", $sChkShowTip)
	$sGrpOtherOptions	= IniRead($sFile, $sSection, "GrpOtherOptions", $sGrpOtherOptions)
	$sChkLastPage		= IniRead($sFile, $sSection, "ChkLastPage", $sChkLastPage)
	$sLblLastPage		= IniRead($sFile, $sSection, "LblLastPage", $sLblLastPage)
	$sLblLastOpened		= IniRead($sFile, $sSection, "LblLastOpened", $sLblLastOpened)
	$sChkUseWMI			= IniRead($sFile, $sSection, "ChkUseWMI", $sChkUseWMI)
	$sChkLastPos		= IniRead($sFile, $sSection, "ChkLastPos", $sChkLastPos)
	$sRadioOSFont		= IniRead($sFile, $sSection, "RadioOSFont", $sRadioOSFont)
	$sRadioFont			= IniRead($sFile, $sSection, "RadioFont", $sRadioFont)
	$sChkIcons			= IniRead($sFile, $sSection, "ChkIcons", $sChkIcons)
	$sTIFirewall		= IniRead($sFile, $sSection, "TIFirewall", $sTIFirewall)
	$sChkShowOnlyCon	= IniRead($sFile, $sSection, "ChkShowOnlyCon", $sChkShowOnlyCon)
	$sTTAltConf			= IniRead($sFile, $sSection, "TTAltConf", $sTTAltConf)
	$sTTGenConf			= IniRead($sFile, $sSection, "TTGenConf", $sTTGenConf)
	$sWiFiBalSignal		= IniRead($sFile, $sSection, "WiFiBalSignal", $sWiFiBalSignal)
	$sWiFiBalSec		= IniRead($sFile, $sSection, "WiFiBalSec", $sWiFiBalSec)
	$sWiFiBalRadio		= IniRead($sFile, $sSection, "WiFiBalRadio", $sWiFiBalRadio)
	$sUserConf			= IniRead($sFile, $sSection, "UserConf", $sUserConf)
	$sChkShowAlways		= IniRead($sFile, $sSection, "ChkShowAlways", $sChkShowAlways)
	$sWiFiSecured		= IniRead($sFile, $sSection, "WiFiSecured", $sWiFiSecured)
	$sWiFiOpen			= IniRead($sFile, $sSection, "WiFiOpen", $sWiFiOpen)
	$sWiFiConnecting	= IniRead($sFile, $sSection, "WiFiConnecting", $sWiFiConnecting)
	$sWiFiUnknown		= IniRead($sFile, $sSection, "WiFiUnknown", $sWiFiUnknown)
	$sLblWiFiProfile	= IniRead($sFile, $sSection, "LblWiFiProfile", $sLblWiFiProfile)
	$sLblNetbiosEnabled	= IniRead($sFile, $sSection, "LblNetbiosEnabled", $sLblNetbiosEnabled)
	$sLblYes			= IniRead($sFile, $sSection, "LblYes", $sLblYes)
	$sLblNo				= IniRead($sFile, $sSection, "LblNo", $sLblNo)
	$sChkTrayLimitInfo	= IniRead($sFile, $sSection, "ChkTrayLimitInfo", $sChkTrayLimitInfo)
	$sChkTrayAdaptWiFi	= IniRead($sFile, $sSection, "ChkTrayAdaptWiFi", $sChkTrayAdaptWiFi)	
	$sChkTrayShowMAC	= IniRead($sFile, $sSection, "ChkTrayShowMAC", $sChkTrayShowMAC)
	$sChkTrayShowIPv6	= IniRead($sFile, $sSection, "ChkTrayShowIPv6", $sChkTrayShowIPv6)
EndFunc


;**********************************************************************
; Check if other instances are running
;**********************************************************************
Func CheckInstance()
	Debug("IN: CheckInstance CmdLineRaw: " & $CmdLineRaw)
	Local $i, $p, $bProcFound = FALSE, $arPID[10]
	Local $nResult = 0
	
	$arPID[0] = 0
	
	If ChkCmdParam("/waitforshell") Then
		While 1
			$bReloadAfterWait = TRUE
			$bShellLoaded = CheckShellState(FALSE)
			If $bShellLoaded Then ExitLoop
			Sleep(500)
		WEnd
		
		$arPID = 0
		Return
	EndIf	
	
	If @Compiled Then
		Local $arProcList = ProcessList(@ScriptName)
		If IsArray($arProcList) Then
			For $i = 1 To $arProcList[0][0]
				If StringUpper($arProcList[$i][0]) = StringUpper(@ScriptName) And $arProcList[$i][1] <> @AutoItPID Then
					$bProcFound = TRUE
					$arPID[0] += 1
					$arPID[$arPID[0]] = $arProcList[$i][1]
				EndIf
			Next
			
			If $bProcFound Then
				If ChkCmdParam("/reinitsetup") Then
					$arPID = 0
					Return
				EndIf
				
				Local $bWndFound = FALSE
				Local $arWinList = WinList()
				
				If IsArray($arWinList) Then
					For $i = 1 To $arWinList[0][0]
						For $k = 1 To $arPID[0]
							If WinGetProcess($arWinList[$i][1]) = $arPID[$k] And StringInStr($arWinList[$i][0], $sMainTitle) Then
								$bWndFound = TRUE
								Debug("IN: CheckInstance: Another PENM instance with PID " & $arPID[$k] & " found, sending message.")
								SendMessage($arWinList[$i][1], 0x7FFF, $arPID[$k], 0)
								ExitLoop
							EndIf
						Next
						
						If $bWndFound Then ExitLoop
					Next
				EndIf
				
				$arPID = 0
				
				If Not $bWndFound Then Return
				
				Exit
			EndIf
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Check if WindowsPE is running
;**********************************************************************
Func CheckPE()
	Debug("IN: Check for WinPE...")
	
	RegRead($sCCS & "\Control\MiniNT", "")
	If @Error = 0 Or @Error = -1 Then
		$bIsWinPE = TRUE
	Else
		Local $i = 1, $sKey
		While 1
			$sKey = RegEnumKey($sCCS & "\Control", $i)
			If @Error <> 0 Then ExitLoop
			
			If $sKey = "MiniNT" Then
				$bIsWinPE = TRUE
				Exitloop
			EndIf
			
			$i += 1
		WEnd
	EndIf
	
	; Get OS version info
	Local $stOVIEx = DllStructCreate("dword;dword;dword;dword;dword;wchar[128];ushort;ushort;ushort;byte;byte")
	DllStructSetData($stOVIEx, 1, DllStructGetSize($stOVIEx))
	
	Local $nMin = 0
	
	If GetVersionExW(DllStructGetPtr($stOVIEx)) Then
	
		Local $nMaj = DllStructGetData($stOVIEx, 2)
		$nMin		= DllStructGetData($stOVIEx, 3)
		Local $nType= DllStructGetData($stOVIEx, 10)
		
		If $nMaj = 5 Then
			Switch $nMin
				Case 0
					$sOSVersion = "WIN_2000"
				Case 1
					$sOSVersion = "WIN_XP"
				Case 2
					If $nType = 1 Then
						$sOSVersion = "WIN_XP" ; 64bit version
					Else
						$sOSVersion = "WIN_2003"
					EndIf
			EndSwitch
		ElseIf $nMaj = 6 Then
			$bIsVista = TRUE
			Switch $nMin
				Case 0
					If $nType = 1 Then
						$sOSVersion = "WIN_VISTA"
					Else
						$sOSVersion = "WIN_2008"
					EndIf
				Case 1
					$bOSCanEncKey = TRUE
					If $nType = 1 Then
						$sOSVersion = "WIN_7"
					Else
						$sOSVersion = "WIN_2008R2"
					EndIf
				Case 2
					$bOSCanEncKey = TRUE
					; Cause wrong return value for 8.1 one more check
					Local $sCurVer = RegRead("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "CurrentVersion")
					Local $sCurMajVer = RegRead("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "CurrentMajorVersionNumber")
					
					If $nType = 1 Then
						If $sCurVer = "6.3" Then
							If $sCurMajVer = 10 Then
								$sOSVersion = "WIN_10"
								$bIsWin10 = TRUE
								$bIsWin8 = TRUE
							Else
								$sOSVersion = "WIN_8.1"
								$bIsWin8 = TRUE
							EndIf
							$nMin = 3
						Else
							$sOSVersion = "WIN_8"
							$bIsWin8 = TRUE
						EndIf
					Else
						If $sCurVer = "6.3" Then
							If $sCurMajVer = 10 Then
								$sOSVersion = "WIN_2016"
								$bIsWin10 = TRUE
								$bIsWin8 = TRUE
							Else
								$sOSVersion = "WIN_2012R2"
								$bIsWin8 = TRUE
							EndIf
							$nMin = 3
						Else
							$sOSVersion = "WIN_2012"
							$bIsWin8 = TRUE
						EndIf
					EndIf
			EndSwitch
		ElseIf $nMaj = 10 Then
			$bIsVista = TRUE
			$bIsWin8 = TRUE
			$bIsWin10 = TRUE
			$bOSCanEncKey = TRUE
			
			Switch $nMin
				Case 0
					If $nType = 1 Then
						$sOSVersion = "WIN_10"
					Else
						$sOSVersion = "WIN_2016"
					EndIf
			EndSwitch			
		EndIf
	Else
		$sOSVersion = @OSVersion
	EndIf
		
	If $bIsWinPE Then
		If $bIsVista Then
			$bIsWinPE20 = TRUE
			Switch $nMin
				Case 0
					Debug("IN: PE sys: WinPE2.X")
				Case 1
					Debug("IN: PE sys: WinPE3.X")
				Case 2
					Debug("IN: PE sys: WinPE4.X")
				Case Else
					If $sOSVersion = "WIN_10" Or $sOSVersion = "WIN_2016" Then
						Debug("IN: PE sys: WinPE10.X")
					Else
						Debug("IN: PE sys: WinPE5.X")
					EndIf
			EndSwitch
		Else
			Debug("IN: PE sys: WinPE1.X")
		EndIf
	Else
		Debug("IN: PE sys: No")
	EndIf
EndFunc


;**********************************************************************
; Check and install network services
;**********************************************************************
Func CheckNetwork($bTCPInst = FALSE)
	Debug("IN: CheckNetwork:" & $bTCPInst)
	Local $bNetcfgxReg	= FALSE
	Local $bShowErr		= TRUE
	Local $bShowGUI		= TRUE
	If $nStartMode = 0 Then $bShowGUI = FALSE	
	Local $nResult		= 0
	Local $nIcon, $i
	
	;If $bTCPInst Then $bShowMainGUI = TRUE ; 06.06.2016 Logic error, was replaced by bShowGUI and nStartMode, used prior in LiveXP to force showing of GUI

	If Not FileExists($sDefNetUtil) And _
		Not FileExists(@ScriptDir & "\" & $sDefNetUtil) And _
		Not FileExists(@WindowsDir & "\" & $sDefNetUtil) And _
		Not FileExists(@SystemDir & "\" & $sDefNetUtil) Then
		If $bTCPInst Then
			Return 1 ; If TCP is installed then just maybe don't need to do anything
		Else
			If $bShowErr Then MsgBox(16, $sERROR, $sMsgUtilNotFnd1 & " " & $sDefNetUtil & " " & $sMsgUtilNotFnd2 & "!" & @LF & $sProgramExit)
			Return 0
		EndIf
	ElseIf Not $bTCPInst And Not $bAutoStart Then
	;ElseIf Not $bAutoStart Then ; 19.09.2015 - maybe better?
		If ShowNetworkStartup() <> 6 Then Return 0
	EndIf
	
	If $bFirstRun And $bUseProfiles Then ;And Not $bTCPInst Then
		If $bUseProfileSelect Then
			ShowProfileSelector()
		Else
			$sProfileSelected = $sProfileDefault
		EndIf

		If $hPSG <> 0 Then
			GUIDelete($hPSG)
			DelODBtnGrp($arODBtnMain)
			
			$nBtnOK = 0
			$nBtnCancel = 0
		EndIf
	EndIf
	
	If $bShowGUI Then
		; StartMode: 0 - Hidden / 1 - Center / 2 - TopLeft / 3 - TopRight / 4 - BottomLeft / 5 - BottomRight / 6 - Depends on systray position
		Local $nX = -1
		Local $nY = -1
		Local $nW = 300
		Local $nH = 78
		Local $nBkClr = $nClrGUIBkSub ; 0xFFFFFF
		Local $nTxtClr = $nClrLblNormal ; 0x0
		Local $nWType = BitOr($WS_POPUP, $WS_BORDER)
		Local $nWExType = BitOr($WS_EX_TOPMOST, $WS_EX_TOOLWINDOW)
		Local $arPos
		
		If $nStartMode = 6 Then
			$arPos = WinGetPos("[CLASS:Shell_TrayWnd]")
			If Not IsArray($arPos) Then $nStartMode = 1
		EndIf
		
		Switch $nStartMode
			Case 2
				$nX = 0
				$nY = 0
			Case 3
				$nX = @DesktopWidth - $nW
				$nY = 0
			Case 4
				$nX = 0
				$nY = @DesktopHeight - $nH			
			Case 5
				$nX = @DesktopWidth - $nW
				$nY = @DesktopHeight - $nH			
			Case 6			
				If $arPos[0] <= 0 Then
					If $arPos[1] > 0 Then
						$nX = (2 * $arPos[0] + $arPos[2]) - $nW - 5
					Else
						$nX = 2 * $arPos[0] + $arPos[2] + 5
					EndIf
				Else
					$nX = $arPos[0] - $nW - 5
				EndIf
				
				If $arPos[1] > 0 Then	
					$nY = $arPos[1] - $nH - 5
				Else
					If $arPos[2] > $arPos[3] Then
						$nX = (2 * $arPos[0] + $arPos[2]) - $nW - 5
						$nY = 2 * $arPos[1] + $arPos[3] + 5
					Else
						$nY = 2 * $arPos[1] + $arPos[3] - $nH - 5
					EndIf
				EndIf
		EndSwitch
		
		;$hStartNetGUI	= GUICreate($sMainTitle, $nW, $nH, $nX, $nY, $nWType, $nWExType, $hMainGUI)
		$hStartNetGUI	= CreateGUI($sMainTitle, $nW, $nH, $nX, $nY, $nWType, $nWExType, $hMainGUI)
		GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
		SendMessage($hStartNetGUI, $WM_SETFONT, $hGlobalFont, 1)
		GUISetBkColor($nBkClr)

		$nIcon = CreateCtrlIcon("shell32.dll", -1, 4, 2, $nIconSizeSmall, $nIconSizeSmall)
		SetIconFrom(-1, 0, -4, "")

		CreateCtrlLabel($sMainTitle, 26, 2, $nW - 32, 18, $SS_CENTERIMAGE)
		GUICtrlSetBkColor(-1, $nBkClr)
		GUICtrlSetColor(-1, $nTxtClr)
		GUICtrlSetFont(-1, $nGlobalFontSize, 600)
		
		CreateCtrlLabel("", 0, 22, $nW + 1, 2, $SS_SUNKEN)
		
		$nLblStartTxt	= CreateCtrlLabel($sLblStartNet, 5, 27, $nW - 10, 34, $SS_LEFTNOWORDWRAP)
		GUICtrlSetBkColor(-1, $nBkClr)
		GUICtrlSetColor(-1, $nTxtClr)
	
		$nPrgrStart		= CreateCtrlProg(5, 62, $nW - 10, 10, $PBS_SMOOTH)
		
		GUISetState()
	EndIf
	
	If $bIsWinPE20 Then
		If ProcessExists("wpeinit.exe") or ProcessExists("wpeutil.exe") Then
			Debug("IN: Network check - Wait for Wpeinit/Wpeutil finish")
			If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sMsgInitWait)
		
			While 1
				If Not ProcessExists("wpeinit.exe") And Not ProcessExists("wpeutil.exe") Then ExitLoop
				Sleep(150)		
			WEnd
			
			;$bTCPInst = TRUE
		EndIf
		
		If $bShowGUI Then GUICtrlSetData($nPrgrStart, 5)
	Else
		; 1.) Register network component
		RegRead("HKCR\CLSID\{5B035261-40F9-11D1-AAEC-00805FC1270E}\InProcServer32", "")
		If Not (@Error = 0 Or @Error = -1) Then
			Debug("IN: Network check - Register netcfgx.dll")
			If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetRegisterObj)
			If RegisterFile("netcfgx.dll") <> 0 Then
				If $bShowGUI Then GUIDelete($hStartNetGUI)
				If $bShowErr Then MsgBox(16, $sERROR, $sNetErrRegister & "!" & @LF & $sProgramExit)
				Return 0
			EndIf
			
			If $bShowGUI Then GUICtrlSetData($nPrgrStart, 5)
		EndIf
	
		; 2.) - check for network files
		If Not $bTCPInst Then
			If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetChkDrv)
			If Not FileExists(@WindowsDir & "\inf\nettcpip.inf") Then
				If $bShowGUI Then GUIDelete($hStartNetGUI)
				If $bShowErr Then MsgBox(16, $sERROR, $sNetErrTCPNotFnd & "!" & @LF & $sProgramExit)
				Return 0
			EndIf
				
			If Not FileExists(@WindowsDir & "\inf\netmscli.inf") Then
				If $bShowGUI Then GUIDelete($hStartNetGUI)
				If $bShowErr Then MsgBox(16, $sERROR, $sNetErrMSCNotFnd & "!" & @LF & $sProgramExit)
				Return 0
			EndIf
		EndIf
	EndIf
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 10)
				
	; 3.) - detect network cards, will be replaced later by 2 cmds: -pnp, -wg
	If $bShowGUI Then
		If Not $bTCPInst Then
			GUICtrlSetData($nLblStartTxt, $sNetDetectDev)
		ElseIf $bForceSearchDevice Then
      SetIconFrom($nIcon, 246, -11)
			GUICtrlSetData($nLblStartTxt, $sNetDetectNew)
		EndIf
	EndIf
	
	$nWiFiCard = 0
	
	If Not $bTCPInst Then
		If Not $bUseProfiles Then SetWorkGroup("workgroup")
		$nResult = DetectDevices($bShowGUI, $nLblStartTxt)
	ElseIf $bForceSearchDevice Then
		$nResult = DetectDevices($bShowGUI, $nLblStartTxt)
	Else
		; If no network cards detected start a new scan
		RegEnumKey("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards", 1)
		If @Error <> 0 Then $nResult = DetectDevices($bShowGUI, $nLblStartTxt)
	EndIf
	
	If $bShowGUI Then
		GUICtrlSetData($nPrgrStart, 20)
		SetIconFrom($nIcon, 0, -4)
	EndIf
	
	$bNoNetcards = FALSE
	
	RegEnumKey("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards", 1)
	If @Error <> 0 Then
		Local $nCount	= 0
		Local $stCount	= DllStructCreate("dword")
			
		If GetNumberOfInterfaces(DllStructGetPtr($stCount)) = $NO_ERROR Then $nCount = DllStructGetData($stCount, 1)
		Debug("IN: Number of interfaces -> " & $nCount)
		
		; When TCPIP is installed then +1 for Loopback
		If $nCount < 2 Then
			$bNoNetcards = TRUE
			If $bForceServices Then
				Debug("IN: Network check - No Networkcards detected -> Forcing installing of services")
			Else
				Debug("IN: Network check - No Networkcards detected")
				If $bShowGUI Then GUIDelete($hStartNetGUI)
				If $bShowErr Then MsgBox(16, $sERROR, $sNetNoNetcards & @LF & $sProgramExit)
				Return 0
			EndIf
		EndIf
	EndIf
	
	If $bIsWinPE20 And FileExists(@SystemDir & "\wpeutil.exe") Then
		If $bTCPInst = FALSE Then
			; Start wpeinit
			Debug("IN: Network check - Start Wpeutil InitializeNetwork")
			If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sLblStartNetWpe)
			RunCMD("wpeutil.exe InitializeNetwork")
		EndIf
		
		If $bShowGUI Then GUICtrlSetData($nPrgrStart, 25)
			
		; Start tcpipreg service
		If IsServiceInstalled("tcpipreg") Then
			If Not IsServiceRunning("tcpipreg") Then
				Debug("IN: Network check - Start TCPIP registry compatibility service")
				$nResult = RunCMD("net start tcpipreg")
				If $nResult <> 0 Then
					If $bShowGUI Then GUIDelete($hStartNetGUI)
					If $bShowErr Then MsgBox(16, $sERROR, $sNetErrTCPRegStart & " (" & $nResult & ")!" & @LF & $sProgramExit)
					Return 0
				EndIf
			EndIf
		EndIf
		
		If $bShowGUI Then GUICtrlSetData($nPrgrStart, 33)
		
		; Check if WMI is available
		If IsObj($oWMISrv) And RegRead($sGURegKey, "UseWMI") = 1 Then $bUseWMI = TRUE
		Debug("IN: UseWMI: " & $bUseWMI)
	EndIf
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 35)
	
	; 4.) - install protocol
	; Precheck if service ist already installed
	If Not IsCompInstalled("nettrans", "ms_tcpip") Then
		Debug("IN: Network check - Install TCPIP protocoll")
		If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetInstTCP)
		$nResult = RunCMD($sDefNetUtil & " -c p -i ms_tcpip")
		If $nResult <> 0 Then
			If $bShowGUI Then GUIDelete($hStartNetGUI)
			If $bShowErr Then MsgBox(16, $sERROR, $sNetErrTCPInst & " (" & $nResult & ")!" & @LF & $sProgramExit)
			Return 0
		EndIf
	EndIf
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 40)
	
	If $bFirstRun Then
		ChkWlanAPI()
		If $bWLAPIOK Then
			If $nWiFiCard = 0 Then $nWiFiCard = EnumWlanDevices() ; 2nd try if devices were maybe already installed successfully
			Debug("IN: WiFi cards found: " & $nWiFiCard)
			RegWrite($sGURegKey, "WiFiCards", "REG_DWORD", $nWiFiCard)
			If $nWiFiCard > 0 Then
				StartWiFi(FALSE)
				LoadWiFiProfiles($sProfileSelected, $bShowGUI)
			EndIf
		EndIf
	EndIf

	; 5.) - applying profile settings
	If $bFirstRun And $bUseProfiles And $sProfileSelected <> "" Then
		Debug("IN: Network check - Applying profile: " & $sProfileSelected)
		If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetApplyProfile)
		
		ApplyProfile($sPENMini, $sProfileSelected, FALSE, FALSE)
	EndIf
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 50)
	
	; 6.) - install client
	If Not IsCompInstalled("netclient", "ms_msclient") Then
		Debug("IN: Network check - Install MS Client")
		If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetInstMSClient)
		$nResult = RunCMD($sDefNetUtil & " -c c -i ms_msclient")
		If $nResult <> 0 Then
			If $bShowGUI Then GUIDelete($hStartNetGUI)
			If $bShowErr Then MsgBox(16, $sERROR, $sNetErrMSCInst & " (" & $nResult & ")!" & @LF & $sProgramExit)
			Return 0
		EndIf
	EndIf
	
	If $bShowGUI Then
		GUICtrlSetData($nLblStartTxt, $sNetChkServices)
		GUICtrlSetData($nPrgrStart, 55)
	EndIf
	
	; 7.) - start TCP/IP service
	If Not IsServiceRunning("tcpip") Then
		Debug("IN: Network check - Start TCPIP protocoll")
		If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetStartTCPIP)
		$nResult = RunCMD("net start tcpip")
		If $nResult <> 0 Then
			If $bShowGUI Then GUIDelete($hStartNetGUI)
			If $bShowErr Then MsgBox(16, $sERROR, $sNetErrTCPStart & " (" & $nResult & ")!" & @LF & $sProgramExit)
			Return 0
		EndIf
	EndIf	
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 60)
	
	; 8.) - start DHCP service
	If IsServiceInstalled("dhcp") And Not IsServiceRunning("dhcp") Then
		Debug("IN: Network check - Start DHCP client")
		If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetStartDHCP)
		$nResult = RunCMD("net start dhcp")
		If $nResult <> 0 And $bShowErr Then MsgBox(16, $sERROR, $sNetErrDHCPStart & " (" & $nResult & ")!" & @LF & $sNetErrStatOnly)
	EndIf
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 65)
	
	; 9.) - start NLA service, only check 1 time, cause for networking it is not really needed
	If $bFirstRun Or $bTCPInst = FALSE Then
		Local $sNLA = "nla"
		;If $bIsWinPE20 Then $sNLA = "nlasvc"
		If Not $bIsWinPE20 Then
			If IsServiceInstalled($sNLA) And Not IsServiceRunning($sNLA) Then
				If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetStartNLA)
				$nResult = RunCMD("net start " & $sNLA)
				Debug("IN: Network check - Start NLA service - Result: " & $nResult)
			EndIf
		EndIf
	EndIf
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 70)
	
	; 10.) - start LMHOSTS service
	If IsServiceInstalled("lmhosts") And Not IsServiceRunning("lmhosts") Then
		If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sNetStartLMH)
		$nResult = RunCMD("net start lmhosts")
		Debug("IN: Network check - Start LMHOSTS service - Result: " & $nResult)
	EndIf
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 75)
				
	Sleep(250)
	
	If Not IsServiceRunning("lanmanserver") And $bStartSharing Then StartSharing()
	
	If $bShowGUI Then GUICtrlSetData($nPrgrStart, 90)
	
	If $bFirstRun Then
		If $sProfileSelected <> "" Then
			Debug("IN: Selected profile: " & $sProfileSelected)
			; Adding local users
			If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sShareAddUser)
			
			$i = 1
			Local $sUserName, $sPassWord
			
			While 1
				$sUserName = ProfileGetDText(IniRead($sPENMini, $sProfileSelected, "Share.User" & $i, ""))
				If $sUserName = "" Then ExitLoop
				
				$sPassWord = ProfileGetDText(IniRead($sPENMini, $sProfileSelected, "Share.Pass" & $i, ""))
				
				If EnableWriteAccess($sUserName, $sPassWord) Then
					Debug("OK: Profiles	- Adding user:"	& $sUserName)
				Else
					Debug("ER: Profiles	- Adding user:"	& $sUserName)
				EndIf
				
				$i += 1
			WEnd
			
			If $bShowGUI Then GUICtrlSetData($nPrgrStart, 92)
			
			; Adding network drives
			If IsServiceRunning("tcpip") And _
				IsServiceRunning("dhcp") Then
			
				; Wait for 1 connection before trying to connect network drive
				If $bWaitConnect Then
					Local $nAdapterState, $nAdapterSpeed, $sAdapterMAC, $nTimerStart, $sIP, $oConf = 0	
					Local $bConnected = FALSE
					Debug("IN: Waiting for one of the devices to be connecting...")
					$nTimerStart = TimerInit()
					
					While 1			
						EnumNetworkAdapters(FALSE)
						If $arNAList[0][0] = 0 Then ExitLoop ; No devices are installed
						
						For $i = 1 To $arNAList[0][0]
							$nAdapterState	= -1
							$nAdapterSpeed	= 0
							$sAdapterMAC	= ""	
		
							If GetNetInterfaceInfos($arNAList[$i][2], $nAdapterState, $nAdapterSpeed, $sAdapterMAC) = $NO_ERROR Then
								If $nAdapterState = 4 Or $nAdapterState = 5 Then ; Device is connected
									If GetAdapterProperty($arNAList[$i][1], 0, $oConf) Then
										$sIP = GetAdapterProperty($arNAList[$i][1], 6, $oConf) ; DHCP
									Else
										$sIP = GetAdapterProperty($arNAList[$i][1], 1, $oConf)
									EndIf
									Debug("IN: Device: """ & $arNAList[$i][2] & """ seems to be connected - IP: " & $sIP)
									$bConnected = TRUE
									ExitLoop
								EndIf
							EndIf						
						Next
						
						If $bConnected Then ExitLoop
						
						Sleep(2500)
						
						If TimerDiff($nTimerStart) > ($nWaitConnectTime * 1000) Then ExitLoop
					WEnd
				EndIf
				
				If Not $bNoNetcards Then
					If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sLblDriveConnect)
					$i = 1
					Local $sRemote, $sDevice
					
					While 1
						$sRemote = IniRead($sPENMini, $sProfileSelected, "NetDrv.Path" & $i, "")
						If $sRemote	= "" Then ExitLoop
						
						$sUserName	= ProfileGetDText(IniRead($sPENMini, $sProfileSelected, "NetDrv.User" & $i, ""))
						$sPassWord	= ProfileGetDText(IniRead($sPENMini, $sProfileSelected, "NetDrv.Pass" & $i, ""))
						$sDevice	= IniRead($sPENMini, $sProfileSelected, "NetDrv.Letter" & $i, "")
						
						MapDrive($sDevice, $sRemote, $sUserName, $sPassWord, FALSE)
						
						$i += 1
					WEnd
				EndIf
				
				If $bShowGUI Then GUICtrlSetData($nPrgrStart, 95)
		
				; Run commands				
				If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sCMDStart)
				ProfileStartCMD($sProfileSelected, TRUE)
			EndIf
		EndIf
	EndIf
	
	If $bShowGUI Then
		GUICtrlSetData($nPrgrStart, 100)
		Sleep(250)
	EndIf
	
	If $bShowGUI Then GUIDelete($hStartNetGUI)
	
	Return 1
EndFunc


;**********************************************************************
; Check if shell is loaded to safely move to tray
;**********************************************************************
Func CheckShellState($bPrintDbg = TRUE)
	If $bPrintDbg Then Debug("IN: Check shell state")
	
	If GetShellWindow() <> 0 Then
		If $bPrintDbg Then Debug("IN: Shell is running.")
		Return TRUE
	Else
		If $bPrintDbg Then Debug("IN: No shell is running.")
		Return FALSE
	EndIf
EndFunc


;**********************************************************************
; Start a CMD after finishing network/chaning IP settings
;**********************************************************************

Func LoadWiFiProfiles($sProfile, $bShowGUI = TRUE)
	Debug("IN: Adding WiFi profiles")
				
	Local $sWiFiSrv = "wzcsvc"
	If $bIsVista Then $sWiFiSrv = "wlansvc"
				
	EnumWlanAdapters()
						
	Local $sWiFiSSID, $sWiFiKey, $sWiFiAuth, $sWiFiEnc, $sWiFiAuto, $sWiFiHidden, $sWiFiAdhoc
	Local $bWiFiAuto, $bWiFiHidden, $bWiFiAdhoc, $nWiFiCode, $k, $hSearch, $sFile, $sData
	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)
	Local $stData		= 0
	Local $hWlan		= 0
	Local $stGUID		= DllStructCreate($sGUID)
	Local $stPtr		= DllStructCreate("ptr")
	Local $stCode		= DllStructCreate("int")
	
	For $k = 1 To $arWLANList[0]
		Debug("IN: WLAN adapter GUID: " & $arWLANList[$k])
		If $arWLANList[$k] <> "" Then
			; First get count of WiFi profiles, cause must be added in reverse order
			If $sProfile <> "" Then
				Local $c = 0
				$i = 1
				While 1
					$sWiFiSSID	= IniRead($sPENMini, $sProfile, "WiFiProfile.SSID" & $i, "")
					If $sWiFiSSID = "" Then ExitLoop
					$c += 1
					$i += 1
				WEnd
				
				For $i = $c To 1 Step -1
					$sWiFiSSID	= IniRead($sPENMini, $sProfile, "WiFiProfile.SSID" & $i, "")
					If $sWiFiSSID = "" Then ExitLoop
					
					$bWiFiAuto	= FALSE
					$bWiFiHidden= FALSE
					$bWiFiAdhoc	= FALSE
					
					$sWiFiKey	= ProfileGetDText(IniRead($sPENMini, $sProfile, "WiFiProfile.Key" & $i, ""))
					$sWiFiAuth	= GetAuthStr(IniRead($sPENMini, $sProfile, "WiFiProfile.Auth" & $i, "none"), TRUE)
					$sWiFiEnc	= IniRead($sPENMini, $sProfile, "WiFiProfile.Enc" & $i, "")
					$sWiFiAuto	= IniRead($sPENMini, $sProfile, "WiFiProfile.Auto" & $i, "No")
					$sWiFiHidden= IniRead($sPENMini, $sProfile, "WiFiProfile.Hidden" & $i, "No")
					$sWiFiAdhoc	= IniRead($sPENMini, $sProfile, "WiFiProfile.Adhoc" & $i, "No")
					
					If $sWiFiAuto = "Yes" Then $bWiFiAuto = TRUE
					If $sWiFiHidden = "Yes" Then $bWiFiHidden = TRUE
					If $sWiFiAdhoc = "Yes" Then $bWiFiAdhoc = TRUE
					
					Debug("IN: Adding WiFi profile: " & $sWiFiSSID)
					If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sTTWiFiImport & ": " & $sWiFiSSID)
					AddWlanProfileSub($k, $sWiFiSSID, $sWiFiSSID, $sWiFiAuth, $sWiFiEnc, "passPhrase", $sWiFiKey, $nWiFiCode, $bWiFiAuto, $bWiFiAdhoc, $bWiFiHidden)
				Next
			EndIf
			
			; Find XML file with WiFi profile
			$hSearch = FileFindFirstFile(@ScriptDir & "\*.xml")
			If $hSearch <> -1 Then
				If WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle)) = $ERROR_SUCCESS Then
					$hWlan = DllStructGetData($stHandle, 1)
							
					While 1
						$sFile = FileFindNextFile($hSearch) 
						If @Error Then ExitLoop
						
						Debug("IN: Found XML file: " & $sFile)
						
						$sData = ""
						$sData = FileRead(@ScriptDir & "\" & $sFile)
						If @Error = 0 Then
							If $sData <> "" And StringInStr($sData, "<WLANProfile") Then
								Debug("IN: Importing WiFi profile from file: " & $sFile)									
								$stData	= DllStructCreate("wchar[" & StringLen($sData) + 1 & "]")
								DllStructSetData($stData, 1, $sData)
																			
								CreateGUIDFromString($stGUID, $arWLANList[$k])																									
								WlanSetProfile($hWlan, DllStructGetPtr($stGUID), 0, DllStructGetPtr($stData), 0, 1, 0, DllStructGetPtr($stCode))
								If $bShowGUI Then GUICtrlSetData($nLblStartTxt, $sTTWiFiImport & ": " & GetXmlStr($sData, "name"))
								
								$stData = 0
							EndIf
						EndIf								
					WEnd
					
					WlanCloseHandle($hWlan, 0)
				EndIf

				FileClose($hSearch)
			EndIf
		EndIf
	Next
EndFunc


;**********************************************************************
; Start a CMD after finishing network/changing IP settings
;**********************************************************************
Func ProfileStartCMD($sProfile, $bStart = FALSE)
	If $bStart Then
		Debug("IN: Run commands after starting network")
	Else
		Debug("IN: Run commands after changing network settings")
	EndIf
	
	Local $i = 1, $sCMD, $sStart, $sWait
	Local $sC = "Change"
	If $bStart Then $sC = "Start"

	Local $nOldMode = Opt("ExpandEnvStrings", 1)
	Local $nStart
	
	$i = 1
	While 1
		$sCMD	= IniRead($sPENMini, $sProfile, "CMD" & $sC & ".CMD" & $i, "IniReadError")
		If $sCMD = "IniReadError" Then ExitLoop
		If $sCMD <> "" Then
		
			$sStart	= IniRead($sPENMini, $sProfile, "CMD" & $sC & ".Start" & $i, "Normal")
			$sWait	= IniRead($sPENMini, $sProfile, "CMD" & $sC & ".Wait" & $i, "Yes")
			
			Switch StringLower($sStart)
				Case "hidden"
					$nStart = @SW_HIDE
				Case "minimized"
					$nStart = @SW_MINIMIZE
				Case "maximized"
					$nStart = @SW_MAXIMIZE
				Case Else
					$nStart = @SW_SHOW
			EndSwitch
	
			Debug("IN: Run commandline: " & $sCMD & " -> Mode: " & $sStart & " -> Wait: " & $sWait)
			
			If StringLower($sWait) = "yes" Then
				RunWait($sCMD, "", $nStart)
			Else
				Run($sCMD, "", $nStart)
			EndIf		
			
			;ProfileCMDAdd($nLVCMDStart, $sCMD, $sStart, $sWait)		
		EndIf
				
		$i += 1
	WEnd
	
	Opt("ExpandEnvStrings", $nOldMode)
EndFunc


;**********************************************************************
; Register a file
;**********************************************************************
Func RegisterFile($sFile)
	Local $nResult = RunCMD("regsvr32 /s " & $sFile)
	Return $nResult
EndFunc


;**********************************************************************
; Run a console cmd
;**********************************************************************
Func RunCMD($sCMD, $bHide = TRUE, $sWorkDir = "")
	Local $nShowState = @SW_HIDE
	If Not $bHide Then $nShowState = @SW_SHOW
	
	Local $nResult = RunWait(@Comspec & " /c " & $sCMD, $sWorkDir, $nShowState)
	
	Debug("IN: RunCMD: " & $sCMD & " -> Result: " & $nResult)
	
	Return $nResult
EndFunc


;**********************************************************************
; Check if service is already installed
;**********************************************************************
Func IsServiceInstalled($sService)
	Local $hSCM = OpenSCManagerW(0, 0, $SC_MANAGER_ENUMERATE_SERVICE)
	If $hSCM = 0 Then Return 0
	
	Local $nResult = 1
	
	Local $hService = OpenServiceW($hSCM, $sService, $SERVICE_QUERY_STATUS)
	If $hService = 0 Then
		$nResult = 0
	Else
		CloseServiceHandle($hService)
	EndIf
	
	CloseServiceHandle($hSCM)
	
	Return $nResult
EndFunc


;**********************************************************************
; Check if component is already installed
;**********************************************************************
Func IsCompInstalled($sClass, $sComp)
	Local $i = 1, $sCID, $sKey, $sVal, $bResult = FALSE
	
	Switch StringUpper($sClass)
		Case "NETTRANS"
			$sCID = "{4D36E975-E325-11CE-BFC1-08002BE10318}"
		Case "NETSERVICE"
			$sCID = "{4D36E974-E325-11CE-BFC1-08002BE10318}"
		Case "NETCLIENT"
			$sCID = "{4D36E973-E325-11CE-BFC1-08002BE10318}"
		Case Else
			$sCID = "{4D36E972-E325-11CE-BFC1-08002BE10318}"
	EndSwitch
	
	Local $sNetKey = "HKLM\System\CurrentControlSet\Control\Network\"
	While 1
		$sKey = RegEnumKey($sNetKey & $sCID, $i)
		If @Error <> 0 Then ExitLoop
		
		$sVal = RegRead($sNetKey & $sCID & "\" & $sKey, "ComponentId")
		If $sVal <> "" And $sComp = $sVal Then
			$bResult = TRUE
			ExitLoop
		EndIf
		
		$i += 1		
	WEnd

	Debug("IN: IsCompInstalled - " & $sClass & "; " & $sComp & ": " & $bResult)
	
	Return $bResult
EndFunc


;**********************************************************************
; Check if service is already running
;**********************************************************************
Func IsServiceRunning($sService)
	Local $bResult = FALSE
	
	If GetServiceStatus($sService) = $SERVICE_RUNNING Then $bResult = TRUE
	
	Return $bResult
EndFunc


;**********************************************************************
; Get current service status
;**********************************************************************
Func GetServiceStatus($sService)
	Local $hSCM = OpenSCManagerW(0, 0, $SC_MANAGER_ENUMERATE_SERVICE)
	If $hSCM = 0 Then Return 0
	
	Local $hService = OpenServiceW($hSCM, $sService, BitOr($SERVICE_QUERY_STATUS, $SERVICE_INTERROGATE))
	If $hService = 0 Then
		CloseServiceHandle($hSCM)
		Return 0
	EndIf

	Local $nResult
	Local $stStatus = DllStructCreate($sSERVICE_STATUS)

	ControlService($hService, $SERVICE_CONTROL_INTERROGATE, DllStructGetPtr($stStatus))

	If QueryServiceStatus($hService, DllStructGetPtr($stStatus)) = 0 Then
		$nResult = 0
	Else
		$nResult = DllStructGetData($stStatus, 2)
	EndIf
	
	CloseServiceHandle($hService)	
	CloseServiceHandle($hSCM)

	Debug("IN: GetServiceStatus: " & $sService & ": " & $nResult & " (" & $arSrvState[$nResult] & ")")
	
	Return $nResult
EndFunc


;**********************************************************************
; Stops a service and dependend too
;**********************************************************************
Func StopSvc($sService, $bStopDepended = TRUE)
	Debug("IN: Stopping service: " & $sService)
	
	Local $hSCM = OpenSCManagerW(0, 0, BitOr($GENERIC_READ, $GENERIC_EXECUTE))
	If $hSCM = 0 Then Return 0
	
	Local $hService = OpenServiceW($hSCM, $sService, BitOr($GENERIC_READ, $GENERIC_EXECUTE))
	If $hService = 0 Then
		CloseServiceHandle($hSCM)
		Return 0
	EndIf
	
	Local $nState, $nResult = 0
	Local $stStatus = DllStructCreate($sSERVICE_STATUS)
	ControlService($hService, $SERVICE_CONTROL_INTERROGATE, DllStructGetPtr($stStatus))

	If QueryServiceStatus($hService, DllStructGetPtr($stStatus)) Then
		$nState = DllStructGetData($stStatus, 2)
		
		If $nState = $SERVICE_STOPPED Then
			$nResult = 1
		ElseIf $nState = $SERVICE_STOP_PENDING Then
			Do
				Sleep($nSvcST)
				QueryServiceStatus($hService, DllStructGetPtr($stStatus))
			Until DllStructGetData($stStatus, 2) <> $SERVICE_STOP_PENDING
			
			$nResult = 1
		Else
			$nResult = StopSvcProc($hSCM, $hService, $sService, $bStopDepended)
		EndIf
	EndIf

	CloseServiceHandle($hService)	
	CloseServiceHandle($hSCM)
	
	If $nResult = 1 Then Debug("IN: Service: " & $sService & " stopped")
	
	Return $nResult
EndFunc


;**********************************************************************
; Stop service subroutine
;**********************************************************************
Func StopSvcProc($hSCM, $hService, $sService, $bStopDepended = TRUE)
	Debug("IN: StopSvcProc")
	
	Local $i
	Local $stDependies		= DllStructCreate("ptr;ptr;" & $sSERVICE_STATUS)
	Local $stBytesNeeded	= DllStructCreate("dword")
	Local $stCount			= DllStructCreate("dword")
	Local $stStatus			= DllStructCreate($sSERVICE_STATUS)
	Local $nError			= 0
	Local $nState			= 0
	
	If $bStopDepended Then
		If EnumDependentServicesW($hService, $SERVICE_ACTIVE, DllStructGetPtr($stDependies), 0, _
			DllStructGetPtr($stBytesNeeded), DllStructGetPtr($stCount)) Then
			; No dependend services
			Debug("IN: StopSvcProc: " & $sService & " - No dependend services found.")
		Else
			If GetLastError() <> $ERROR_MORE_DATA Then Return GetLastError()
			
			Local $stBuffer = DllStructCreate("byte[" & DllStructGetData($stBytesNeeded, 1) & "]")
			
			If Not EnumDependentServicesW($hService, $SERVICE_ACTIVE, DllStructGetPtr($stBuffer), DllStructGetSize($stBuffer), _
				DllStructGetPtr($stBytesNeeded), DllStructGetPtr($stCount)) Then Return GetLastError()
			
			Debug("IN: StopSvcProc: " & $sService & " - " & DllStructGetData($stCount, 1) & " dependend services found.")
					
			Local $pBuf = DllStructGetData($stBuffer, 1)			
			Local $stSName
			Local $hDepService	= 0
			$stDependies = 0
			
			For $i = 1 To DllStructGetData($stCount, 1)
				$stDependies = DllStructCreate("ptr;ptr;" & $sSERVICE_STATUS, $pBuf)
				$pBuf += DllStructGetSize($stDependies)
				
				$stSName = DllStructCreate("wchar[256]", DllStructGetData($stDependies, $i * 9 + 1))
				
				If $bHelperRun Then GUICtrlSetData($nLblStartTxt, $sServiceStopping & " """ & DllStructGetData($stSName, 1) & """ " & $sServiceDesc & "...")
				Debug("IN: StopSvcProc: " & $sService & " - Stopping dependend service: " & DllStructGetData($stSName, 1))
				
				$hDepService = OpenServiceW($hSCM, DllStructGetData($stSName, 1), BitOr($GENERIC_READ, $GENERIC_EXECUTE))
				If $hDepService = 0 Then Return GetLastError()
				
				If ControlService($hDepService, $SERVICE_CONTROL_STOP, DllStructGetPtr($stStatus)) = 0 Then
					$nError = GetLastError()
					CloseServiceHandle($hDepService)
					Return $nError
				EndIf
				
				Do
					ControlService($hDepService, $SERVICE_CONTROL_INTERROGATE, DllStructGetPtr($stStatus))
					
					If QueryServiceStatus($hDepService, DllStructGetPtr($stStatus)) = 0 Then
						$nState = 0
					Else
						$nState = DllStructGetData($stStatus, 2)
					EndIf
					
					Debug("IN: StopSvcProc - QueryDependedServiceStatus: " & DllStructGetData($stSName, 1) & " :" & $nState & " (" & $arSrvState[$nState] & ")")
					Sleep($nSvcST)
				Until $nState <> $SERVICE_STOP_PENDING
				
				CloseServiceHandle($hDepService)
			Next
		EndIf
	EndIf
	
	If $bHelperRun Then GUICtrlSetData($nLblStartTxt, $sServiceStopping & " """ & $sService & """ " & $sServiceDesc & "...")
		
	If ControlService($hService, $SERVICE_CONTROL_STOP, DllStructGetPtr($stStatus)) = 0 Then Return GetLastError()
		
	Do
		Sleep($nSvcST)
		ControlService($hService, $SERVICE_CONTROL_INTERROGATE, DllStructGetPtr($stStatus))
		
		If QueryServiceStatus($hService, DllStructGetPtr($stStatus)) = 0 Then
			$nState = 0
		Else
			$nState = DllStructGetData($stStatus, 2)
		EndIf
		
		Debug("IN: StopSvcProc - QueryServiceStatus: " & $sService & " :" & $nState & " (" & $arSrvState[$nState] & ")")
	Until $nState <> $SERVICE_STOP_PENDING
		
	Return 1
EndFunc


;**********************************************************************
; Starts a service
;**********************************************************************
Func StartSvc($sService, $bStartDepended = TRUE)
	Debug("IN: Starting service: " & $sService)
	
	Local $hSCM = OpenSCManagerW(0, 0, BitOr($GENERIC_READ, $GENERIC_EXECUTE))
	If $hSCM = 0 Then Return 0
	
	Local $hService = OpenServiceW($hSCM, $sService, BitOr($GENERIC_READ, $GENERIC_EXECUTE))
	If $hService = 0 Then
		CloseServiceHandle($hSCM)
		Return 0
	EndIf
	
	Local $nState, $nResult = 0
	Local $stStatus = DllStructCreate($sSERVICE_STATUS)
	ControlService($hService, $SERVICE_CONTROL_INTERROGATE, DllStructGetPtr($stStatus))

	If QueryServiceStatus($hService, DllStructGetPtr($stStatus)) Then
		$nState = DllStructGetData($stStatus, 2)
		
		If $nState = $SERVICE_RUNNING Then
			$nResult = 1
		ElseIf $nState = $SERVICE_START_PENDING Then
			Do
				Sleep($nSvcST)
				QueryServiceStatus($hService, DllStructGetPtr($stStatus))
			Until DllStructGetData($stStatus, 2) <> $SERVICE_START_PENDING
			
			$nResult = 1
		Else
			$nResult = StartSvcProc($hSCM, $hService, $sService, $bStartDepended)
		EndIf
	EndIf
		
	CloseServiceHandle($hService)
	CloseServiceHandle($hSCM)
	
	If $nResult = 1 Then Debug("IN: Service: " & $sService & " running")
	
	Return $nResult
EndFunc


;**********************************************************************
; Start service subroutine
;**********************************************************************
Func StartSvcProc($hSCM, $hService, $sService, $bStartDepended = TRUE)
	Debug("IN: StartSvcProc: " & $sService)
	
	Local $stDependies		= DllStructCreate("ptr;ptr;" & $sSERVICE_STATUS)
	Local $stBytesNeeded	= DllStructCreate("dword")
	Local $stCount			= DllStructCreate("dword")
	Local $stStatus			= DllStructCreate($sSERVICE_STATUS)
	Local $nState			= 0
	
	If $bHelperRun Then GUICtrlSetData($nLblStartTxt, $sServiceStarting & " """ & $sService & """ " & $sServiceDesc & "...")
		
	If StartServiceW($hService, 0, 0) = 0 Then
		Return 0
	Else
		Do
			ControlService($hService, $SERVICE_CONTROL_INTERROGATE, DllStructGetPtr($stStatus))
			
			If QueryServiceStatus($hService, DllStructGetPtr($stStatus)) = 0 Then
				$nState = 0
			Else
				$nState = DllStructGetData($stStatus, 2)
			EndIf
			
			Debug("IN: StartSvcProc - QueryServiceStatus: " & $hService & " :" & $nState & " (" & $arSrvState[$nState] & ")")
			Sleep($nSvcST)
		Until $nState <> $SERVICE_START_PENDING
	EndIf
	
	If $bStartDepended Then
		If EnumDependentServicesW($hService, $SERVICE_INACTIVE, DllStructGetPtr($stDependies), 0, _
			DllStructGetPtr($stBytesNeeded), DllStructGetPtr($stCount)) Then
			; No dependend services
			Debug("IN: StartSvcProc: " & $sService & " - No dependend services found.")
		Else
			If GetLastError() <> $ERROR_MORE_DATA Then Return GetLastError()
			
			Local $stBuffer = DllStructCreate("byte[" & DllStructGetData($stBytesNeeded, 1) & "]")
			
			If Not EnumDependentServicesW($hService, $SERVICE_INACTIVE, DllStructGetPtr($stBuffer), DllStructGetSize($stBuffer), _
				DllStructGetPtr($stBytesNeeded), DllStructGetPtr($stCount)) Then Return GetLastError()
			
			Debug("IN: StartSvcProc: " & $sService & " - " & DllStructGetData($stCount, 1) & " dependend services found.")
			
			Local $pBuf = DllStructGetData($stBuffer, 1)
			Local $stSName, $i
			Local $hDepService	= 0
			$stDependies = 0
			
			For $i = 1 To DllStructGetData($stCount, 1)
				$stDependies = DllStructCreate("ptr;ptr;" & $sSERVICE_STATUS, $pBuf)
				$pBuf += DllStructGetSize($stDependies)
				
				$stSName = DllStructCreate("wchar[256]", DllStructGetData($stDependies, 1))
				
				If $bHelperRun Then GUICtrlSetData($nLblStartTxt, $sServiceStarting & " """ & DllStructGetData($stSName, 1) & """ " & $sServiceDesc & "...")
				Debug("IN: StartSvcProc: " & $sService & " - Starting dependend service: " & DllStructGetData($stSName, 1))
				
				$hDepService = OpenServiceW($hSCM, DllStructGetData($stSName, 1), BitOr($GENERIC_READ, $GENERIC_EXECUTE))
				If $hDepService = 0 Then Return GetLastError()
								
				If StartServiceW($hDepService, 0, 0) = 0 Then
					CloseServiceHandle($hDepService)
					ContinueLoop
				EndIf
				
				Do
					ControlService($hService, $SERVICE_CONTROL_INTERROGATE, DllStructGetPtr($stStatus))
					
					If QueryServiceStatus($hDepService, DllStructGetPtr($stStatus)) = 0 Then
						$nState = 0
					Else
						$nState = DllStructGetData($stStatus, 2)
					EndIf
					
					Debug("IN: StartSvcProc - QueryDependedServiceStatus: " & DllStructGetData($stSName, 1) & " :" & $nState & " (" & $arSrvState[$nState] & ")")
					Sleep($nSvcST)
				Until $nState <> $SERVICE_START_PENDING
	
				CloseServiceHandle($hDepService)
			Next
			
			$stBuffer = 0
		EndIf
	EndIf
	
	Return 1
EndFunc


;**********************************************************************
; Checks the current state of the server service
;**********************************************************************
Func UpdateSharingInfo($bSwitch = TRUE)
	If Not IsServiceInstalled("lanmanserver") Then
		GUICtrlSetData($nLblShrInfo, $sServiceNotInst)
		GUICtrlSetBkColor($nLblShrInfo, $nClrSvcStop)
		If $bSwitch Then
			SetODBtnData($nBtnShr, $sBtnShareStart)
		Else
			SetODBtnData($nBtnShr, $sBtnShareStart, -1, -1, FALSE)
		EndIf
		GUICtrlSetState($nChkShrAll, $GUI_ENABLE)
	ElseIf Not IsServiceRunning("lanmanserver") Then
		GUICtrlSetData($nLblShrInfo, $sServiceStopped)
		GUICtrlSetBkColor($nLblShrInfo, $nClrSvcStop)
		If $bSwitch Then
			SetODBtnData($nBtnShr, $sBtnShareStart)
		Else
			SetODBtnData($nBtnShr, $sBtnShareStart, -1, -1, FALSE)
		EndIf
		GUICtrlSetState($nChkShrAll, $GUI_ENABLE)
	Else
		GUICtrlSetData($nLblShrInfo, $sServiceStarted)
		GUICtrlSetBkColor($nLblShrInfo, $nClrSvcStart)
		If $bSwitch Then
			SetODBtnData($nBtnShr, $sServiceStop)
		Else
			SetODBtnData($nBtnShr, $sServiceStop, -1, -1, FALSE)
		EndIf
		GUICtrlSetState($nChkShrAll, $GUI_DISABLE)
	EndIf
EndFunc


;**********************************************************************
; Fill the account combo with data
;**********************************************************************
Func UpdateShareUsrCombo()
	Local $stPtr	= DllStructCreate($sUSER_INFO_1)
	Local $stRead	= DllStructCreate("dword")
	Local $stMax	= DllStructCreate("dword")
	Local $stNext	= DllStructCreate("dword")
	DllStructSetData($stNext, 1, 0)
	
	Local $sCmbData	= "|"
	Local $sCmbDef	= GUICtrlRead($nComboShrUsr)
	
	Local $stAdminsSID		= DllStructCreate($sSID)
	Local $stAdminsBytes	= DllStructCreate("dword")
	DllStructSetData($stAdminsBytes, 1, DllStructGetSize($stAdminsSID))
	
	; Success: > 0
	Local $nResult = CreateWellKnownSid($WinBuiltinAdministratorsSid, 0, _
								DllStructGetPtr($stAdminsSID), _
								DllStructGetPtr($stAdminsBytes))

	; Max. group name length = 256 wide chars + NULL-termination
	Local $stGroupName		= DllStructCreate("wchar[" & 256 + 1 & "]")
	Local $stGroupSize		= DllStructCreate("dword")
	DllStructSetData($stGroupSize, 1, 256 + 1)
	
	Local $stDomainName		= DllStructCreate("wchar[" & 256 + 1 & "]")
	Local $stDomainSize		= DllStructCreate("dword")
	DllStructSetData($stDomainSize, 1, 256 + 1)
	
	Local $stSIDType		= DllStructCreate("dword")
	
	; Success: > 0
	$nResult = LookupAccountSidW(0, DllStructGetPtr($stAdminsSID), _
								DllStructGetPtr($stGroupName), _
								DllStructGetPtr($stGroupSize), _
								DllStructGetPtr($stDomainName), _
								DllStructGetPtr($stDomainSize), _
								DllStructGetPtr($stSIDType))

	If $nResult > 0 Then							
		Local $stBuffer	= DllStructCreate("long_ptr")
		Local $stRead	= DllStructCreate("dword")
		Local $stMax	= DllStructCreate("dword")
		Local $stHandle	= DllStructCreate("ulong_ptr")
		DllStructSetData($stHandle, 1, 0)
		Local $nResult, $sUserName, $stUserName, $nFlags, $nCount, $nLen, $pLGMI1
		
		Do
			$nResult = NetLocalGroupGetMembers(0, DllStructGetPtr($stGroupName), 1, DllStructGetPtr($stBuffer), $MAX_PREFERRED_LENGTH, _
												DllStructGetPtr($stRead), DllStructGetPtr($stMax), DllStructGetPtr($stHandle))
			
			If $nResult = $NERR_Success Or $nResult = $ERROR_MORE_DATA Then
				Local $sUserName	= ""
				Local $stUserName	= 0
				
				$pLGMI1 = DllStructGetData($stBuffer, 1)
								
				For $i = 1 To DllStructGetData($stRead, 1)
					$stLGMI1 = DllStructCreate($sLOCALGROUP_MEMBERS_INFO_1, $pLGMI1)
					$pLGMI1 += DllStructGetSize($stLGMI1)
					
					If DllStructGetData($stLGMI1, 2) = $SidTypeUser Or DllStructGetData($stLGMI1, 2) = $SidTypeWellKnownGroup Then
						$stUserName	= DllStructCreate("wchar[" & (wcslen(DllStructGetData($stLGMI1, 3)) + 1) & "]", DllStructGetData($stLGMI1, 3))
						$sUserName	= DllStructGetData($stUserName, 1)
	
						$sCmbData = $sCmbData & $sUserName & "|"
					EndIf
				Next
			EndIf
			
			NetApiBufferFree(DllStructGetData($stBuffer, 1))
			
		Until $nResult <> $ERROR_MORE_DATA		
	EndIf
	
	GUICtrlSetData($nComboShrUsr, $sCmbData, $sCmbDef)
EndFunc


;**********************************************************************
; Installs/Start the server service for file sharing
;**********************************************************************
Func StartSharing($bFromStart = TRUE)
	Debug("IN: StartSharing")
	
	If Not FileExists(@SystemDir & "\srvsvc.dll") Then Return
	
	Local $bInstRun = TRUE
	Local $nError	= 0
	
	;UpdateSharingInfo()
	
	If IsServiceRunning("lanmanserver") Then
		If MsgBoxEx(52 + 256, $sWARNING, $sShareStopInfo1 & @LF & @LF & _
								$sShareStopInfo2 & ":" & @LF & _
								$sShareStopInfo3 & @LF & @LF & _
								$sShareStopInfo4, $hMainGUI) = 7 Then Return 1
	EndIf

	;If Not IsServiceInstalled("lanmanserver") Then
	If Not IsCompInstalled("netservice", "ms_server") Then
		If $bFromStart Then
			GUICtrlSetData($nLblStartTxt, $sShareChkDrv)
		Else
			GUICtrlSetData($nLblState, $sShareChkDrv)
		EndIf
		
		If Not FileExists(@WindowsDir & "\inf\netserv.inf") Then
			MsgBoxEx(16, $sERROR, $sShareErrInf & "!" & @LF & $sShareErrInst & ".", $hSharesGUI)
			Return 0
		EndIf

		If $bFromStart Then
			GUICtrlSetData($nLblStartTxt, $sShareInstSrv)
		Else
			GUICtrlSetData($nLblState, $sShareInstSrv)
		EndIf
		
		$nResult = RunCMD($sDefNetUtil & " -c s -i ms_server")
		If $nResult <> 0 Then
			MsgBoxEx(16, $sERROR, $sShareErrInst2 & " (" & $nResult & ")!", $hSharesGUI)
			Return 0
		EndIf
		
		If Not $bIsWinPE20 Then
			RegWrite($sCCS & "\Services\LanmanServer\Parameters", "NullSessionPipes", "REG_MULTI_SZ", _
					"COMNAP" & @LF & "COMNODE" & @LF & "SQL\QUERY" & @LF & "SPOOLSS" & @LF & "LLSRPC" & @LF & "EPMAPPER" & @LF & _
					"LOCATOR" & @LF & "TrkWks" & @LF & "TrkSvr" & @LF & "SRVSVC"& @LF & "BROWSER")
		EndIf
		
		; ReCheck if service was properly installed
		If $bFromStart Then
			GUICtrlSetData($nLblStartTxt, $sServiceChkSrv)
		Else
			GUICtrlSetData($nLblState, $sServiceChkSrv)
		EndIf
		
		;If Not IsServiceInstalled("lanmanserver") Then
		If Not IsCompInstalled("netservice", "ms_server") Then
			MsgBoxEx(16, $sERROR, $sShareErrInst2 & " !", $hSharesGUI)
			Return 0
		EndIf
	Else
		$bInstRun = FALSE
	EndIf	
	
	If Not IsServiceRunning("LanmanServer") Then
		If $bFromStart Then
			$bHelperRun = TRUE
			GUICtrlSetData($nLblStartTxt, $sShareStartSrv)
		Else
			GUICtrlSetData($nLblState, $sShareStartSrv)
		EndIf

		If $bInstRun Then
			$nResult = StartSvc("LanmanServer")
		Else
			$nResult = StartSvc("LanmanServer")
		EndIf
		
		If $nResult = 0 Then
			$nError = GetLastError()
			
			If $bFromStart Then $bHelperRun = FALSE
			
			MsgBoxEx(16, $sERROR, $sShareErrStart & " (" & $nError & ")!", $hSharesGUI)
			Return 0
		EndIf
		
		$bHelperRun = FALSE
	ElseIf Not $bInstRun Then
		If $bFromStart Then
			$bHelperRun = TRUE
			GUICtrlSetData($nLblStartTxt, $sShareStopSrv)
		Else
			GUICtrlSetData($nLblState, $sShareStopSrv)
		EndIf
		
		$nResult = StopSvc("LanmanServer")
		
		$bHelperRun = FALSE
		
		If $nResult = 0 Then
			$nError = GetLastError()
		
			MsgBoxEx(16, $sERROR, $sShareErrStop & " (" & $nError & ")!", $hSharesGUI)
			Return 0
		EndIf
	EndIf
	
	If Not $bFromStart Then
		GUICtrlSetData($nLblState, $sServiceInstFinish)
		Sleep(250)
	EndIf

	ShareAllDrives()
	
	If Not $bFromStart Then
		UpdateSharingInfo()
		EnumShares()
	EndIf
EndFunc


;**********************************************************************
; Share all fixed drives
;**********************************************************************
Func ShareAllDrives()
	If Not $bShareAllDrives Then Return
	If Not IsServiceRunning("LanmanServer") Then Return

	Debug("IN: ShareAllDrives")
	
	Local $i, $sType, $sDrive
	Local $arDrives = DriveGetDrive("ALL")
	
	If IsArray($arDrives) Then
		For $i = 1 To $arDrives[0]
			$sDrive	= StringUpper($arDrives[$i])
			$sType	= DriveGetType($arDrives[$i])
			If StringInStr($sType, "Fixed") Or _
			StringInStr($sType,"CDROM") Or _
			StringInStr($sType,"Removable") Or _
			StringInStr($sType,"RAMDisk") Then
				If StringInStr($sType, "Fixed") Then
					$sType = "Local Disk"
				ElseIf StringInStr($sType, "CDROM") Then
					$sType = "CD/DVD Drive"
				ElseIf StringInStr($sType, "Removable") Then
					$sType = "Removable Disk"
				EndIf
				
				ShareFolder(StringLeft($sDrive, 1), $sDrive & "\", $sDrive, "Shared " & $sType & " " & $sDrive, TRUE)
			EndIf
		Next
	
	EndIf
EndFunc


;**********************************************************************
; Delete a user created locally for sharing access
;**********************************************************************
Func DelShareUsr()
	Local $sUserName = GUICtrlRead($nComboShrUsr) 
	If $sUserName = "" Then Return
	
	Local $stUserName = DllStructCreate("wchar[" & (StringLen($sUserName) + 1) & "]")
	DllStructSetData($stUserName, 1, $sUserName)
	
	If NetUserDel(0, DllStructGetPtr($stUserName)) = $NERR_Success Then UpdateShareUsrCombo()
EndFunc


;**********************************************************************
; ReSetting the user password for file sharing
;**********************************************************************
Func SetSharingPW()
	Local $sUserName = GUICtrlRead($nComboShrUsr)
	Local $sPassWord = GUICtrlRead($nInpShrPW)
	
	
	If $sUserName <> "" And (($bLimitBlankPW = TRUE And $sPassWord <> "") Or $bLimitBlankPW = FALSE) And $bIsWinPE Then
		GUICtrlSetData($nBtnShrSetPW, $sShareSetPW)
		EnableWriteAccess($sUserName, $sPassWord)
		GUICtrlSetData($nBtnShrSetPW, $sBtnShareSetPW)
		GUICtrlSetData($nInpShrPW, $sHiddenInput) ;"")
	EndIf
EndFunc


;**********************************************************************
; Add the specified user to the Administrator-group for write access
;**********************************************************************
Func EnableWriteAccess($sUserName, $sPassWord)
	Local $nResult = -1

	Local $stWStrName = DllStructCreate("byte[" & (2 * 20) + 2 & "]")
	DllStructSetData($stWStrName, 1, StringToBinary($sUserName, 2))
	
	Local $stWStrPW = DllStructCreate("byte[" & (2 * 256) + 2 & "]")
	DllStructSetData($stWStrPW, 1, StringToBinary($sPassWord, 2))
	
	Local $stUI1		= DllStructCreate($sUSER_INFO_1)
	
	DllStructSetData($stUI1, 1, DllStructGetPtr($stWStrName))
	DllStructSetData($stUI1, 2, DllStructGetPtr($stWStrPW))
	DllStructSetData($stUI1, 3, 0)
	DllStructSetData($stUI1, 4, $USER_PRIV_USER)
	DllStructSetData($stUI1, 5, 0)
	DllStructSetData($stUI1, 6, 0)
	DllStructSetData($stUI1, 7, BitOr($UF_SCRIPT, $UF_NORMAL_ACCOUNT, $UF_DONT_EXPIRE_PASSWD))
	DllStructSetData($stUI1, 8, 0)
	
	Local $stError		= DllStructCreate("dword")

	$nResult = NetUserAdd(0, 1, DllStructGetPtr($stUI1), DllStructGetPtr($stError))
	If $nResult = $NERR_UserExists Then ; Set the new password
		Local $stUserBuffer = DllStructCreate("ptr")
		$nResult = NetUserGetInfo(0, DllStructGetPtr($stWStrName), 1, DllStructGetPtr($stUserBuffer))
		
		$stUI1 = DllStructCreate($sUSER_INFO_1, DllStructGetData($stUserBuffer, 1))
		DllStructSetData($stUI1, 2, DllStructGetPtr($stWStrPW))
		
		$nResult = NetUserSetInfo(0, DllStructGetPtr($stWStrName), 1, DllStructGetPtr($stUI1), DllStructGetPtr($stError))
		If $nResult <> $NERR_Success Then
			MsgBoxEx(16, $sERROR, $sShareErrPW & " (" & $nResult & ")!", $hSharesGUI)
			NetApiBufferFree(DllStructGetData($stUserBuffer, 1))
			Return 0
		EndIf
		
		NetApiBufferFree(DllStructGetData($stUserBuffer, 1))
	ElseIf $nResult <> $NERR_Success Then
		MsgBoxEx(16, $sERROR, $sShareErrUsr & " (" & $nResult & ")!", $hSharesGUI)
		Return 0
	EndIf

	Local $stAdminsSID		= DllStructCreate($sSID)
	Local $stAdminsBytes	= DllStructCreate("dword")
	DllStructSetData($stAdminsBytes, 1, DllStructGetSize($stAdminsSID))
	
	; Success: > 0
	$nResult = CreateWellKnownSid($WinBuiltinAdministratorsSid, 0, _
								DllStructGetPtr($stAdminsSID), _
								DllStructGetPtr($stAdminsBytes))

	; Max. group name length = 256 chars								
	Local $stGroupName	= DllStructCreate("byte[" & (2 * 256) + 2 & "]")
	Local $stGroupSize	= DllStructCreate("dword")
	DllStructSetData($stGroupSize, 1, (2 * 256) + 2)
	
	Local $stDomainName	= DllStructCreate("byte[" & (2 * 256) + 2 & "]")
	Local $stDomainSize	= DllStructCreate("dword")
	DllStructSetData($stDomainSize, 1, (2 * 256) + 2)
	
	Local $stSIDType	= DllStructCreate("dword")
	
	; Success: > 0
	$nResult = LookupAccountSidW(0, DllStructGetPtr($stAdminsSID), _
								DllStructGetPtr($stGroupName), _
								DllStructGetPtr($stGroupSize), _
								DllStructGetPtr($stDomainName), _
								DllStructGetPtr($stDomainSize), _
								DllStructGetPtr($stSIDType))
		
	Local $stInfoBuffer	= DllStructCreate("ptr")
	
	; Success: NERR_Success
	$nResult = NetUserGetInfo(0, DllStructGetPtr($stWStrName), _
							23, DllStructGetPtr($stInfoBuffer))

	Local $stUI23		= DllStructCreate($sUSER_INFO_23, DllStructGetData($stInfoBuffer, 1))
	Local $stSID		= DllStructCreate($sSID, DllStructGetData($stUI23, 5))
	Local $stPID		= DllStructCreate("ptr")
	DllStructSetData($stPID, 1, DllStructGetPtr($stSID))

	; Success: NERR_Success
	$nResult = NetLocalGroupAddMembers(0, DllStructGetPtr($stGroupName), 0, DllStructGetPtr($stPID), 1)
	If $nResult <> $NERR_Success And $nResult <> $ERROR_MEMBER_IN_ALIAS Then
		MsgBoxEx(48, $sWARNING, $sShareErrAdmin & " (" & $nResult & ")!", $hSharesGUI)
		NetApiBufferFree(DllStructGetData($stInfoBuffer, 1))
		Return 0
	EndIf

	NetApiBufferFree(DllStructGetData($stInfoBuffer, 1))
	
	Return 1
EndFunc


;**********************************************************************
; Create imagelist for OD buttons and load all icon resources
;**********************************************************************
Func CreateODBtnIL()
	$hILBtn = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)

	AddILIcon($hILBtn, -170, 1, "Icon10") 	;  0 - Up
	AddILIcon($hILBtn, -171, 2, "Icon11") 	;  1 - Down
	AddILIcon($hILBtn, -172, 12, "Icon12")	;  2 - OK
	AddILIcon($hILBtn, -173, 13, "Icon13")	;  3 - Cancel
	AddILIcon($hILBtn, -174, 14, "Icon14")	;  4 - Apply
	AddILIcon($hILBtn, -175, 15, "Icon15")	;  5 - Plus
	AddILIcon($hILBtn, -176, 16, "Icon16")	;  6 - Minus
	AddILIcon($hILBtn, -177, 17, "Icon17")	;  7 - Refresh
	AddILIcon($hILBtn, -184, 8, "Icon18")	;  8 - Search
	AddILIcon($hILBtn, -186, 10, "Icon19")	;  9 - Edit
	AddILIcon($hILBtn, -189, 21, "Icon20")	; 10 - Netdrv conn
	AddILIcon($hILBtn, -190, 22, "Icon21")	; 11 - Netdrv disconn
	AddILIcon($hILBtn, -204, 36, "Icon22")	; 12 - Disabled
	AddILIcon($hILBtn, -223, 53, "Icon23")	; 13 - Start
	AddILIcon($hILBtn, -224, 54, "Icon24")	; 14 - Stop
	AddILIcon($hILBtn, -225, 55, "Icon25")	; 15 - Import
	AddILIcon($hILBtn, -226, 56, "Icon26")	; 16 - Export
	AddILIcon($hILBtn, -228, 58, "Icon27")	; 17 - Arrow back
	AddILIcon($hILBtn, -231, 61, "Icon28")	; 18 - Double arrow up
	AddILIcon($hILBtn, -232, 62, "Icon29")	; 19 - Double arrow down
	AddILIcon($hILBtn, -227, 57, "Icon30")	; 20 - Profiles
	AddILIcon($hILBtn, -236, 66, "Icon31")	; 21 - Trace start
	AddILIcon($hILBtn, -237, 67, "Icon32")	; 22 - Trace stop
	AddILIcon($hILBtn, -186, 10, "Icon33")	; 23 - Size button to right
	AddILIcon($hILBtn, -186, 10, "Icon52")	; 24 - WiFi Connect
	AddILIcon($hILBtn, -173, 13, "Icon53")	;  25 - WiFi Disconnect
	AddILIcon($hILBtn, -231, 78, "Icon84")	; 26 - Double arrow left
	AddILIcon($hILBtn, -232, 79, "Icon85")	; 27 - Double arrow right	
	AddILIcon($hILBtn, -182, 5, "Icon6")	; 28 - About
	AddILIcon($hILBtn, -177, 106, "Icon86")	; 29 - Refresh Tray
EndFunc


Func CreateODBtnIL2()
	$hILBtn2 = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	
	AddILIcon($hILBtn2, -203, 35, "Icon0")	;  0 - Settings
	AddILIcon($hILBtn2, -229, 59, "Icon1")	;  1 - Ident
	AddILIcon($hILBtn2, -181, 6, "Icon2")	;  2 - Sharing
	AddILIcon($hILBtn2, -188, 20, "Icon3")	;  3 - Netdrives
	AddILIcon($hILBtn2, -227, 57, "Icon4")	;  4 - Profiles
	AddILIcon($hILBtn2, -191, 23, "Icon5")	;  5 - Other
	AddILIcon($hILBtn2, -182, 5, "Icon6")	;  6 - About
	AddILIcon($hILBtn2, -195, 27, "Icon7")	;  7 - WiFi
	AddILIcon($hILBtn2, -210, 41, "Icon8")	;  8 - NoWiFi
	AddILIcon($hILBtn2, -205, 37, "Icon9")	;  9 - Advanced
	
	; Only used by editor
	AddILIcon($hILBtn2, -201, 33)	;  10 - Globe
	AddILIcon($hILBtn2, -202, 34)	;  11 - CMD
	AddILIcon($hILBtn2, -242, 72)	;  12 - Desktop
	
	AddILIcon($hILBtn2, -247, 77, "Icon83")	;  13 - Firewall
EndFunc


;**********************************************************************
; Add an icon to an image list
;**********************************************************************
Func AddILIcon($hIL, $nRes, $nResIcl, $sIniIcon = "", $sIconFile = "", $bSmallIcon = TRUE, $nIconSize = -1, $bReplace = FALSE, $nIdx = -1)
	Local $nIconID		= $nResIcl - 1
	Local $bUseExtern	= FALSE

	If $bIconLib Then
		If $sIconFile = "" Then $sIconFile = $sIconLib
	Else
		If $sIconFile = "" Then $sIconFile = @AutoItExe
		$nIconID = $nRes
	EndIf
	
	If $bUseIniIcons And $sIniIcon <> "" Then
		Local $nOldOpt	= Opt("ExpandEnvStrings", 1)
		Local $sFile	= IniRead($sPENMini, $sGSection, $sIniIcon, "")
		Local $nResFile	= 0
		
		If $sFile <> "" Then
			Local $nPos = StringInStr($sFile, ",")
			If $nPos > 0 Then
				Local $nIcon = Number(StringTrimLeft($sFile, $nPos))
				$sFile = StringLeft($sFile, $nPos - 1)
				If FileExists($sFile) Then
					$nResFile = $nIcon
					If $nResFile > 0 Then $nResFile -= 1
				Else
					$sFile = ""
				EndIf
			Else
				If FileExists($sFile) Then
					$nResFile = 0
				Else
					$sFile = ""
				EndIf		
			EndIf
		EndIf
		
		If $sFile <> "" Then
			$sIconFile	= $sFile
			$nIconID	= $nResFile
			If $nIconID = -1 Then $nIconID = 0
			$bUseExtern	= TRUE
		EndIf
		
		Opt("ExpandEnvStrings", $nOldOpt)
	EndIf
	
	Local $hIcon = 0
	Local $stIcon = DllStructCreate("hwnd")
	DllStructSetData($stIcon, 1, 0)
	Local $stIconSM = DllStructCreate("hwnd")
	DllStructSetData($stIconSM, 1, 0)
	
	If $nIconSize <> -1 Then
		If $nIconID < 0 Then $nIconID *= -1
		If $bIconLib Then $nIconID += 1
		Local $stFile = DllStructCreate("wchar[" & (StringLen($sIconFile) + 1) & "]")
		DllStructSetData($stFile, 1, $sIconFile)
		Local $hFile = LoadLibraryExW(DllStructGetPtr($stFile), 0, 0x00000032)

		Local $sIdx = String($nIconID); + 1)
		Local $stIdx = DllStructCreate("wchar[" & (StringLen($sIdx) + 2) & "]")
		DllStructSetData($stIdx, 1, "#" & $sIdx)		
		$hIcon = LoadImageW($hFile, DllStructGetPtr($stIdx), 1, $nIconSize, $nIconSize, 0)
		DllStructSetData($stIcon, 1, $hIcon)
		FreeLibrary($hFile)
	Else
		If ExtractIconExW($sIconFile, $nIconID, DllStructGetPtr($stIcon), DllStructGetPtr($stIconSM), 1) = 0 Then
			;2nd try if external icon could not be extracted
			If $bUseExtern Then
				If $bIconLib Then
					$sIconFile	= $sIconLib
					$nIconID	= $nResIcl
				Else
					$sIconFile	= @AutoItExe
					$nIconID	= $nRes
				EndIf
				
				ExtractIconExW($sIconFile, $nIconID, DllStructGetPtr($stIcon), DllStructGetPtr($stIconSM), 1)
			EndIf
		EndIf
	EndIf
	
	Local $nIconIdx = -1
	If $bSmallIcon Then
		$hIcon = DllStructGetData($stIconSM, 1)
	Else
		$hIcon = DllStructGetData($stIcon, 1)
	EndIf
	
	If $hIcon <> 0 Then
		If $bReplace And $nIdx > -1 Then
			$nIconIdx = ImageList_ReplaceIcon($hIL, $nIdx, $hIcon)
		Else
			$nIconIdx = ImageList_AddIcon($hIL, $hIcon)
		EndIf
	EndIf
	
	If DllStructGetData($stIcon, 1) <> 0 Then DestroyIcon(DllStructGetData($stIcon, 1))
	If DllStructGetData($stIconSM, 1) <> 0 Then DestroyIcon(DllStructGetData($stIconSM, 1))
	
	Return $nIconIdx
EndFunc


;**********************************************************************
; Set icon to one from external file, icon library or internal
;**********************************************************************
Func SetIconFrom($nCtrlID, $nRes, $nResIcl, $sIniIcon = "", $bSmall = TRUE)
	Local $sIconFile	= $sIconLib
	Local $nIconID		= $nResIcl
	Local $bUseExtern	= FALSE
	
	If Not $bIconLib Then
		$sIconFile	= @AutoItExe
		$nIconID	= $nRes
	EndIf
	
	If $bUseIniIcons And $sIniIcon <> "" Then
		Local $nOldOpt	= Opt("ExpandEnvStrings", 1)
		Local $sFile	= IniRead($sPENMini, $sGSection, $sIniIcon, "")
		Local $nResFile	= 0
		
		If $sFile <> "" Then
			Local $nPos = StringInStr($sFile, ",")
			If $nPos > 0 Then
				Local $nIcon = Number(StringTrimLeft($sFile, $nPos))
				$sFile = StringLeft($sFile, $nPos - 1)
				If FileExists($sFile) Then
					$nResFile = $nIcon
					$nResFile *= -1
				Else
					$sFile = ""
				EndIf
			Else
				If FileExists($sFile) Then
					$nResFile = 0
				Else
					$sFile = ""
				EndIf		
			EndIf
		EndIf
		
		If $sFile <> "" Then
			$sIconFile	= $sFile
			$nIconID	= $nResFile
			If $nIconID = -1 Then $nIconID = 0
			$bUseExtern	= TRUE
		EndIf
		
		Opt("ExpandEnvStrings", $nOldOpt)
	EndIf
	
	Local $nType = 1
	If $bSmall Then $nType = 0
	
	If $bIconLib Then
		Local $hIcon
		Local $stIcon = DllStructCreate("hwnd")
			
		If $bSmall Then
			ExtractIconExW($sIconLib, $nResIcl, 0, DllStructGetPtr($stIcon), 1)
		Else
			ExtractIconExW($sIconLib, $nResIcl, DllStructGetPtr($stIcon), 0, 1)
		EndIf
		
		$hIcon = DllStructGetData($stIcon, 1)
		
		Local $hOldIcon = GUICtrlSendMsg($nCtrlID, $STM_GETICON, 0, 0)
		GUICtrlSendMsg($nCtrlID, $STM_SETICON, $hIcon, 0)
		DestroyIcon($hOldIcon)
	Else	
		If Not GUICtrlSetImage($nCtrlID, $sIconFile, $nIconID, $nType) Then
			;2nd try if external icon could not be set
			If $bUseExtern Then
				If $bIconLib Then
					$sIconFile	= $sIconLib
					$nIconID	= $nResIcl
				Else
					$sIconFile	= @AutoItExe
					$nIconID	= $nRes
				EndIf
				
				GUICtrlSetImage($nCtrlID, $sIconFile, $nIconID, $nType)
			EndIf
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Start simple mode if no network cards could be found
;**********************************************************************
Func StartSimpleMode()	
	CreateDeviceGUI()
	
	Local $Msg
	
	While 1
		$Msg = GUIGetMsg()
		Switch $Msg
			Case $GUI_EVENT_CLOSE, $nBtnCancel
				ExitLoop
				
			Case $nBtnOK
				GUICtrlSetColor($nLblState, $nClrStateRed)
				DetectDevices(TRUE, $nLblState)
				GUICtrlSetData($nLblState, $sStateReady)
				GUICtrlSetColor($nLblState, $nClrStateGreen)
				
				RegEnumKey("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards", 1)
				If @Error = 0 Then
					GUIDelete($hMainGUI)
					DelODBtnGrp($arODBtnMain)
										
					$nBtnOK			= 0
					$nBtnCancel		= 0
					$nLblState		= 0
					$bNoNetcards	= FALSE
					
					Return 1
				EndIf
		EndSwitch
	WEnd
	
	Exit
EndFunc


;**********************************************************************
; Create device GUI
;**********************************************************************
Func CreateDeviceGUI()
	Debug("IN: CreateDeviceGUI")

	;$hMainGUI	= GUICreate($sMainTitle, 300, 120, -1, -1, -1, $WS_EX_CONTROLPARENT)
	$hMainGUI	= CreateGUI($sMainTitle, 300, 120, -1, -1, -1, $WS_EX_CONTROLPARENT)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hMainGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkSub)
	
	If $bIconLib Then
		SetWindowIcon($hMainGUI, $sIconLib, 4)
	Else
		SetWindowIcon($hMainGUI, @AutoItExe, 161)
	EndIf
	
	CreateCtrlLabel($sLblNoNetcards, 5, 5, 290, 45)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrLblNormal)
	
	$nBtnOK		= CreateODBtn($sBtnSearchDevice, 5, 65, 140, 25, $arODBtnMain, 8)
	$nBtnCancel	= CreateODBtn($sBtnCancel, 155, 65, 140, 25, $arODBtnMain, 3)

	$nLblState	= CreateCtrlLabel($sStateReady, 5, 98, 290, 16, $SS_SUNKEN)
	GUICtrlSetBkColor(-1, $nClrGUIBkSub)
	GUICtrlSetColor(-1, $nClrStateGreen)
	
	SetODBtnState($nBtnCancel, $GUI_FOCUS, FALSE)
		
	GUISetState()
EndFunc


;**********************************************************************
; Create the Main GUI
;**********************************************************************
Func CreateMainGUI()
	Debug("IN: CreateMainGUI")
	
	Local $nMW		= 535
	Local $nMH		= 442
	
	$hMainGUI	= CreateGUI($sMainTitle, $nMW, $nMH, -1, -1, -1, $WS_EX_CONTROLPARENT)
	GUISetBkColor($nClrGUIBkMain)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hMainGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	If $bIconLib Then
		SetWindowIcon($hMainGUI, $sIconLib, 4)
	Else
		SetWindowIcon($hMainGUI, @AutoItExe, 161)
	EndIf
	
	Local $nChkTmp = GUICtrlCreateCheckBox("CHECKBOX", 0, 0, -1, -1)
	GUICtrlSetState(-1, $GUI_HIDE)
	Local $nSize = GetTextSize($hMainGUI, "CHECKBOX")
	Local $arSize = WinGetClientSize(GUICtrlGetHandle($nChkTmp))
	If IsArray($arSize) Then $nChkSize = GetScaled($arSize[0] - $nSize)
	GUICtrlDelete($nChkTmp)
	
	Local $nBtnX	= 0
	Local $nBtnY	= 0
	Local $nBtnH	= GetScaled(26)
	Local $nBtnL	= GetScaled(130)
	Local $nR		= GetScaled($nMW)
	Local $nB		= GetScaled($nMH - 58) ; Height of all GUIs
	
	$nLblTop1		= GUICtrlCreateLabel("", $nBtnL, 0, $nR - $nBtnL, 1)
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	GUICtrlSetResizing(-1, 256 + 4)
	$nLblBottom1	= GUICtrlCreateLabel("", $nBtnL - 1, $nB, $nR - $nBtnL + 1, 1)
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	GUICtrlSetResizing(-1, 256 + 4)
	$nLblRight1		= GUICtrlCreateLabel("", $nR - 1, 0, 1, $nB)
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	GUICtrlSetResizing(-1, 256 + 4)
	
	$nTIConf		= CreateODTab($hMainGUI, $sTIConfig, 0, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 0, FALSE, -1, -1, 1)	
	$nBtnY += $nBtnH - 1
	
	If Not BitAnd($nGUIDisable, 1) Then
		$nTIIdent	= CreateODTab($hMainGUI, $sTIIdent, 0, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 1, FALSE, -1, -1, 1)
		$nBtnY += $nBtnH - 1
	EndIf
	
	If Not BitAnd($nGUIDisable, 2) Then
		$nTISharing	= CreateODTab($hMainGUI, $sTISharing, 0, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 2, FALSE, -1, -1, 1)
		$nBtnY += $nBtnH - 1
	EndIf
	
	If Not BitAnd($nGUIDisable, 4) Then
		$nTIDrives	= CreateODTab($hMainGUI, $sTIDrives, 0, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 3, FALSE, -1, -1, 1)
		$nBtnY += $nBtnH - 1
	EndIf
	
	If Not BitAnd($nGUIDisable, 8) Then
		$nTIProfiles	= CreateODTab($hMainGUI, $sTIProfiles, 0, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 4, FALSE, -1, -1, 1)
		$nBtnY += $nBtnH - 1
	EndIf
	
	If Not BitAnd($nGUIDisable, 16) Then
		$nTIOther	= CreateODTab($hMainGUI, $sTIOther, 0, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 5, FALSE, -1, -1, 1)
		$nBtnY += $nBtnH - 1
	EndIf
	
	; About and config are always shown
	$nTIAbout		= CreateODTab($hMainGUI, $sTIAbout, 0, $nBtnY, $nBtnL, $nBtnH, $arODBtnMain, 6, FALSE, -1, -1, 1)
	$nBtnY += $nBtnH - 1
	
	If Not BitAnd($nGUIDisable, 512) Then
		$nTISize		= CreateODTab($hMainGUI, ">", $nBtnL - GetScaled(26), $nBtnY, GetScaled(26), GetScaled(16), $arODBtnMain, 23, TRUE)	
		$nBtnY += GetScaled(16)
	EndIf
	
	$nBtnApply		= CreateODBtn($sBtnApply, 129, $nMH - 50, 129, 25, $arODBtnMain, 4)
	GUICtrlSetResizing(-1, 260)
	$nBtnOK			= CreateODBtn($sBtnOK, 264, $nMH - 50, 129, 25, $arODBtnMain, 2)
	GUICtrlSetResizing(-1, 260)
	$nBtnCancel		= CreateODBtn($sBtnCancel, 399, $nMH - 50, 130, 25, $arODBtnMain, 3)
	GUICtrlSetResizing(-1, 260)
	
	$nLblLeft1		= GUICtrlCreateLabel("", $nBtnL - 1, $nBtnY, 1, $nB - $nBtnY)
	GUICtrlSetBkColor(-1, $nClrGUIBkFrame)
	GUICtrlSetResizing(-1, 256 + 4)
		
	CreateCtrlLabel("", 0, $nMH - 17, $nMW + 1, 2, $SS_SUNKEN)
	GUICtrlSetResizing(-1, 6)
	
	$nLblState	= CreateCtrlLabel($sStateReady, 2, $nMH - 14, $nMW, 16)
	GUICtrlSetColor(-1, $nClrStateGreen)
	
	If $bIsWinPE Then
		If $bFirstRun Then GUISetState(@SW_HIDE)
	Else
		GUISetState(@SW_HIDE)
	EndIf
	
	$nAccDummy1 = GUICtrlCreateDummy()
	$nAccDummy2 = GUICtrlCreateDummy()
	Local $arAcc[2][2]
	$arAcc[0][0] = "^!c"
	$arAcc[0][1] = $nAccDummy1
	$arAcc[1][0] = "^!a"
	$arAcc[1][1] = $nAccDummy2
	GUISetAccelerators($arAcc)
	
	;******************************
	; Configuration - GUI
	;******************************
	$hConfGUI		= GUICreate("", $nR - $nBtnL - 1, $nB - 1, $nBtnL, 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hMainGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hConfGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBk)
	
	$nBtnRefresh	= CreateODBtn(">", 6, 5, 21, 20, $arODBtnMain, 7, TRUE)
	GUICtrlSetTip(-1, $sTTRefresh)	
	
	$nComboNA		= CreateCtrlCombo("", 32, 5, 366, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, $sNAList, $sDefData)
	GUICtrlSetTip(-1, GetConName($sDefData))
	
	$nLblAdapterState	= CreateCtrlLabel($sLblAdapterState & ":", 6, 34, 65, 20, $SS_RIGHT)
	
	$nIconState		= CreateCtrlIcon("shell32.dll", -1, 75, 33, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 179, -19, "Icon79")
	
	$nLblAdapterSpeed	= CreateCtrlLabel($sLblAdapterSpeed & ":", 95, 34, 70, 20, $SS_RIGHT)
	$nBtnSpeed		= CreateODBtn("", 170, 32, 70, 18, $arODBtnMain)
	$nDummySpeed	= GUICtrlCreateDummy()
	$nMenuSpeed		= GUICtrlCreateContextMenu($nDummySpeed)

	$nBtnAdapterMAC	= CreateODBtn($sLblAdapterMAC & ":", 245, 32, 46, 18, $arODBtnMain)
	$nLblMac		= CreateCtrlInput("", 290, 32, 108, 18, BitOr($ES_READONLY, $SS_CENTER, $WS_BORDER), 0)
	$hLblMac		= GUICtrlGetHandle($nLblMac)
	$nChkScan		= CreateCtrlCheck($sChkForceScan, 6, 53, 394, 18, -1, -1, $hConfGUI)
	If Not $bIsWinPE Then
		GUICtrlSetState(-1, $GUI_UNCHECKED)
		GUICtrlSetState(-1, $GUI_DISABLE)
	EndIf
	
	CreateCtrlLabel("", 0, 75, 405, 2, $SS_SUNKEN)
	
	Local $nBtnXC	= GetScaled(6)
	Local $nBtnYC	= GetScaled(84)
	Local $nBtnHC	= GetScaled(23)
	Local $nXS		= GetScaled(6)
	Local $nYS		= GetScaled(107)
	Local $nRS		= GetScaled(397)
	Local $nBS		= GetScaled($nMH - 67) ; height config GUI's
	Local $nSC		= GetScaled(3)
	
	$nLblLeft2		= GUICtrlCreateLabel("", $nBtnXC, $nBtnYC + $nBtnHC, 1, $nBS - $nBtnYC - $nBtnHC);247)
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	$nLblTop2		= GUICtrlCreateLabel("", $nBtnXC, $nBtnYC + $nBtnHC - 1, $nRS - $nBtnXC, 1)
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	$nLblRight2		= GUICtrlCreateLabel("", $nRS, $nBtnYC + $nBtnHC - 1, 1, $nBS - $nBtnYC - $nBtnHC + 1)
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	$nLblBottom2	= GUICtrlCreateLabel("", $nBtnXC, $nBS, $nRS - $nBtnXC + 1, 1)
	GUICtrlSetBkColor(-1, $nClrGUIBkConfFrame)
	
	Local $nW = 0
	SetODBtnSize($hConfGUI, 0, $sTIIPSettings, $nW, $nBtnYC, FALSE)
	$nTIIP			= CreateODTab($hConfGUI, $sTIIPSettings, $nBtnXC, $nBtnYC, $nW, $nBtnHC, $arODBtnMain, -1, FALSE, -1, -1, 2)
	
	If Not BitAnd($nGUIDisable, 32) Then
		$nBtnXC += $nW + $nSC
		SetODBtnSize($hConfGUI, 0, $sTIWiFi, $nW, $nBtnYC, TRUE)
		$nTIWiFi		= CreateODTab($hConfGUI, $sTIWiFi, $nBtnXC, $nBtnYC, $nW, $nBtnHC, $arODBtnMain, 7, FALSE, -1, -1, 2)
	EndIf
	
	If Not BitAnd($nGUIDisable, 64) Then
		$nBtnXC += $nW + $nSC
		SetODBtnSize($hConfGUI, 0, $sTIAdvanced, $nW, $nBtnYC, TRUE)
		$nTIAdv			= CreateODTab($hConfGUI, $sTIAdvanced, $nBtnXC, $nBtnYC, $nW, $nBtnHC, $arODBtnMain, 9, FALSE, -1, -1, 2)
	EndIf
	
	If Not BitAnd($nGUIDisable, 1024) Then
		$nBtnXC += $nW + $nSC
		SetODBtnSize($hConfGUI, 0, $sTIAdvanced, $nW, $nBtnYC, TRUE)
		$nTIFirewall	= CreateODTab($hConfGUI, $sTIFirewall, $nBtnXC, $nBtnYC, $nW, $nBtnHC, $arODBtnMain, 13, FALSE, -1, -1, 2)
	EndIf
	
	ApplyCtrlColors(1)
			
	GUISetState()
		
	$hConfIPGUI		= GUICreate("", $nRS - $nXS, $nBS - $nBtnYC - $nBtnHC, $nXS, $nYS, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hConfIPGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	
	$nRadIPDHCP		= CreateCtrlRadio($sBtnIPDHCP, 6, 7, 298, 20, $WS_GROUP, -1, $hConfIPGUI)

	$nBtnDhcpInfo	= CreateODBtn("?", 304, 7, 21, 21, $arODBtnMain, 28, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, StringReplace($sBtnDHCPInfo, "&", ""))
	$nBtnDhcpRelease	= CreateODBtn("->", 324, 7, 21, 21, $arODBtnMain, 4, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, StringReplace($sBtnDHCPRelease, "&", ""))
	$nBtnDhcpRenew	= CreateODBtn("+", 344, 7, 21, 21, $arODBtnMain, 7, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, StringReplace($sBtnDHCPRenew, "&", ""))	
	$nBtnIPAltShow	= CreateODBtn("v", 364, 7, 21, 21, $arODBtnMain, 19, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, $sTTAltConf)
	
	$nRadIPStatic	= CreateCtrlRadio($sBtnIPStatic & ":", 6, 28, 298, 20, -1, -1, $hConfIPGUI)
	$nChkDGMode		= CreateCtrlCheck($sBtnDynamic, 295, 98, 90, 21)

	CreateCtrlLabel("", 0, 124, $nRS - $nXS + 1, 2, $SS_SUNKEN)
	
	$nLblStaticIP	= CreateCtrlLabel($sLblStaticIP & ":", 20, 52, 125, 21, $SS_LEFTNOWORDWRAP)
	$hIP			= GUICtrlCreateIPAddr(144, 48, 120, 21, $hConfIPGUI, $hGlobalFont)
	$nBtnIP			= CreateODBtn("...", 264, 48, 21, 21, $arODBtnMain, 12)	
				
	$nLblStaticSM	= CreateCtrlLabel($sLblStaticSM & ":", 20, 76, 123, 21, $SS_LEFTNOWORDWRAP)
	$hSM			= GUICtrlCreateIPAddr(144, 73, 120, 21, $hConfIPGUI, $hGlobalFont)
	
	$nLblStaticDG	= CreateCtrlLabel($sLblStaticDG & ":", 20, 101, 125, 21, $SS_LEFTNOWORDWRAP)
	$hDG			= GUICtrlCreateIPAddr(144, 98, 120, 21, $hConfIPGUI, $hGlobalFont)
	$nBtnDG			= CreateODBtn("...", 264, 98, 21, 21, $arODBtnMain, 12)
	
	$nRadDNSDHCP	= CreateCtrlRadio($sBtnDNSDHCP, 6, 127, 356, 21, $WS_GROUP, -1, $hConfIPGUI)
	$nRadDNSStatic	= CreateCtrlRadio($sBtnDNSStatic & ":", 6, 148, 356, 21, -1, -1, $hConfIPGUI)
	
	$nLblDNS		= CreateCtrlLabel($sLblDNS & ":", 20, 172, 125, 21, $SS_LEFTNOWORDWRAP)
	$hDNS			= GUICtrlCreateIPAddr(144, 169, 120, 21, $hConfIPGUI, $hGlobalFont)
	$nBtnDNS		= CreateODBtn("...", 264, 169, 21, 21, $arODBtnMain, 12)

	CreateCtrlLabel("", 0, 195, $nRS - $nXS + 1, 2, $SS_SUNKEN)
	
	$nRadWINSDHCP	= CreateCtrlRadio($sBtnWINSDHCP, 6, 198, 356, 21, $WS_GROUP, -1, $hConfIPGUI)
	$nRadWINSStatic	= CreateCtrlRadio($sBtnWINSStatic & ":", 6, 219, 356, 21, -1, -1, $hConfIPGUI)
	
	$nLblWINS		= CreateCtrlLabel($sLblWINS & ":", 20, 244, 125, 21, $SS_LEFTNOWORDWRAP)
	$hWINS			= GUICtrlCreateIPAddr(144, 241, 120, 21, $hConfIPGUI, $hGlobalFont)
	$nBtnWINS		= CreateODBtn("...", 264, 241, 21, 21, $arODBtnMain, 12)
	
	ApplyCtrlColors(128)	
	GUISetState()
	$hLastConfGUI = $hConfIPGUI	
	
	;******************************
	; Alternate IP config - GUI
	;******************************
	$hConfAltIPGUI	= GUICreate("", $nRS - $nXS, $nBS - $nBtnYC - $nBtnHC, $nXS, $nYS, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hConfAltIPGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	
	$nRadIPPrivate	= CreateCtrlRadio($sBtnIPAutoOn, 6, 7, 330, 20, -1, -1, $hConfAltIPGUI)
	GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nBtnIPAltHide	= CreateODBtn("^", 364, 7, 21, 21, $arODBtnMain, 18, TRUE, $nClrBtnDhcpTxt, $nClrBtnDhcpBk, -1, $nClrBtnDhcpGrad)
	GUICtrlSetTip(-1, $sTTGenConf)
	
	$nRadIPNone		= CreateCtrlRadio($sBtnIPAutoOff, 6, 28, 356, 20, -1, -1, $hConfAltIPGUI)
	
	$nRadIPUser		= CreateCtrlRadio($sUserConf & ":", 6, 49, 356, 20, -1, -1, $hConfAltIPGUI)
	GUICtrlSetTip(-1, $sTTAltIP)
	
	$nLblAltIP		= CreateCtrlLabel($sLblStaticIP & ":", 20, 76, 124, 21, $SS_LEFTNOWORDWRAP)
	$hAltIP			= GUICtrlCreateIPAddr(144, 73, 120, 21, $hConfAltIPGUI, $hGlobalFont)
			
	$nLblAltSM		= CreateCtrlLabel($sLblStaticSM & ":", 20, 101, 124, 21, $SS_LEFTNOWORDWRAP)
	$hAltSM			= GUICtrlCreateIPAddr(144, 98, 120, 21, $hConfAltIPGUI, $hGlobalFont)
	
	$nLblAltDG		= CreateCtrlLabel($sLblStaticDG & ":", 20, 124, 124, 21, $SS_LEFTNOWORDWRAP)
	$hAltDG			= GUICtrlCreateIPAddr(144, 123, 120, 21, $hConfAltIPGUI, $hGlobalFont)
	
	$nLblAltDNS1	= CreateCtrlLabel($sLblDNS & " 1:", 20, 172, 124, 21, $SS_LEFTNOWORDWRAP)
	$hAltDNS1		= GUICtrlCreateIPAddr(144, 169, 120, 21, $hConfAltIPGUI, $hGlobalFont)
	
	$nLblAltDNS2	= CreateCtrlLabel($sLblDNS & " 2:", 20, 195, 124, 21, $SS_LEFTNOWORDWRAP)
	$hAltDNS2		= GUICtrlCreateIPAddr(144, 192, 120, 21, $hConfAltIPGUI, $hGlobalFont)
	
	$nLblAltWINS1	= CreateCtrlLabel($sLblWINS & " 1:", 20, 220, 124, 21, $SS_LEFTNOWORDWRAP)
	$hAltWINS1		= GUICtrlCreateIPAddr(144, 217, 120, 21, $hConfAltIPGUI, $hGlobalFont)

	$nLblAltWINS2	= CreateCtrlLabel($sLblWINS & " 2:", 20, 243, 124, 21, $SS_LEFTNOWORDWRAP)
	$hAltWINS2		= GUICtrlCreateIPAddr(144, 240, 120, 21, $hConfAltIPGUI, $hGlobalFont)

	ApplyCtrlColors(2048)
	
	;******************************
	; WiFi Configuration - GUI
	;******************************		
	$hConfPreWiFiGUI		= GUICreate("", $nRS - $nXS, $nBS - $nBtnYC - $nBtnHC, $nXS, $nYS, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hConfPreWiFiGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	
	$nIconPreWiFiState = CreateCtrlIcon("shell32.dll", -1, 6, 7, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 183, -7, "Icon58")
	
	$nLblPreWiFiState		= CreateCtrlLabel($sLblWiFiCurState & ":", 25, 10, 120, 20)
	$nLblPreWiFiCurState	= CreateCtrlLabel($sServiceStopped, 144, 7, 120, 22, BitOr($SS_CENTERIMAGE, $SS_CENTER, $SS_SUNKEN))
	GUICtrlSetBkColor(-1, $nClrSvcStop)
	;$nBtnPreWiFi			= GUICtrlCreateButton($sServiceStart, 265, 5, 120, 22)
	$nBtnPreWiFi			= CreateODBtn($sServiceStart, 264, 7, 120, 22, $arODBtnMain)
	
	$nLblWLNot				= CreateCtrlLabel($sLblWiFiNoDevice, 5, 35, 380, 40)
	GUICtrlSetColor(-1, 0xC00000)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nLblWLNoApi			= CreateCtrlLabel($sLblWiFiWlanApiNF, 5, 5, 380, 40)
	GUICtrlSetColor(-1, 0xC00000)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$hConfWiFiGUI	= GUICreate("", $nRS - $nXS, $nBS - $nBtnYC - $nBtnHC, $nXS, $nYS, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hConfWiFiGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	
	$hILLVWLA = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	AddILIcon($hILLVWLA, -196, 28, "Icon34") ; WiFi0			-> 0	
	AddILIcon($hILLVWLA, -197, 29, "Icon35") ; WiFi1-20			-> 1	
	AddILIcon($hILLVWLA, -198, 30, "Icon36") ; WiFi21-40		-> 2	
	AddILIcon($hILLVWLA, -199, 31, "Icon37") ; WiFi41-60		-> 3
	AddILIcon($hILLVWLA, -200, 32, "Icon38") ; WiFi61-80		-> 4	
	AddILIcon($hILLVWLA, -211, 42, "Icon40") ; Secured			-> 5	
	AddILIcon($hILLVWLA, -212, 43, "Icon41") ; Unsecured		-> 6
	AddILIcon($hILLVWLA, -213, 44, "Icon42") ; Infrastr.		-> 7
	AddILIcon($hILLVWLA, -214, 45, "Icon43") ; Infrastr.Conn.	-> 8
	AddILIcon($hILLVWLA, -215, 46, "Icon44") ; Adhoc			-> 9
	AddILIcon($hILLVWLA, -216, 47, "Icon45") ; Adhoc-Conn.		-> 10
	AddILIcon($hILLVWLA, -217, 48, "Icon46") ; Profile			-> 11
	AddILIcon($hILLVWLA, -218, 49, "Icon47") ; N				-> 12
	AddILIcon($hILLVWLA, -219, 50, "Icon48") ; G				-> 13
	AddILIcon($hILLVWLA, -220, 51, "Icon49") ; B				-> 14
	AddILIcon($hILLVWLA, -221, 52, "Icon50") ; A				-> 15
	AddILIcon($hILLVWLA, -209, 73, "Icon39") ; WiFi81-100		-> 16
	AddILIcon($hILLVWLA, -243, 74, "Icon51") ; AC				-> 17
	AddILIcon($hILLVWLA, -257, 81, "Icon87") ; NotConnectable	-> 18
	
	$hConfExtGUI	= GUICreate("", $nRS - $nXS, $nBS - $nBtnYC - $nBtnHC, $nXS, $nYS, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hConfExtGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	CreateExtGUI()
	
	$hConfFWGUI		= GUICreate("", $nRS - $nXS, $nBS - $nBtnYC - $nBtnHC, $nXS, $nYS, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hConfWiFiGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	CreateFWGUI()
	
	ApplyCtrlColors(256)
	
	GUISwitch($hConfGUI)
	
	$hLastGUI = $hConfGUI
	
	
	;******************************
	; Identification - GUI
	;******************************
	$hIdentGUI	= GUICreate("", $nR - $nBtnL - 1, $nB - 1, $nBtnL, 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hMainGUI)
	GUISetBkColor($nClrGUIBk)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hIdentGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	
	;******************************
	; File Sharing - GUI
	;******************************
	$hSharesGUI		= GUICreate("", $nR - $nBtnL - 1, $nB - 1, $nBtnL, 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hMainGUI)
	GUISetBkColor($nClrGUIBk)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hSharesGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	
	;******************************
	; Drives - GUI
	;******************************
	$hDrivesGUI		= GUICreate("", $nR - $nBtnL - 1, $nB - 1, $nBtnL, 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hMainGUI)
	GUISetBkColor($nClrGUIBk)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hDrivesGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	
	;******************************
	; Other - GUI
	;******************************
	$hOtherGUI		= GUICreate("", $nR - $nBtnL - 1, $nB - 1, $nBtnL, 1, BitOr($WS_CHILD, $WS_TABSTOP, $WS_VSCROLL), $WS_EX_CONTROLPARENT, $hMainGUI)
	GUISetBkColor($nClrGUIBk)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hOtherGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	
	;******************************
	; Profiles - GUI
	;******************************
	$hProfilesGUI	= GUICreate("", $nR - $nBtnL - 1, $nB - 1, $nBtnL, 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hMainGUI)
	GUISetBkColor($nClrGUIBk)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hProfilesGUI, $WM_SETFONT, $hGlobalFont, 1)

	
	;******************************
	; About - GUI
	;******************************
	$hAboutGUI		= GUICreate("", $nR - $nBtnL - 1, $nB - 1, $nBtnL, 1, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hMainGUI)
	GUISetBkColor($nClrGUIBk)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hAboutGUI, $WM_SETFONT, $hGlobalFont, 1)

	GUISwitch($hMainGUI)
	
	GUICtrlSendMsg($nTIConf, $BM_SETSTATE, TRUE, 0)
	$nLastItemGUI = $nTIConf
	
	SetODBtnState($nTIIP, $GUI_HIDE, FALSE)
	SetODBtnState($nTIIP, $GUI_SHOW)
	$nLastItemConf = $nTIIP
	
	If $bStartTabSmall Then ApplyGUIChange()
	
	$nW = 540
	If $bTabSmall Then $nW = 437
	If $bSaveWinPos Then SetWinPos($hMainGUI, $sGURegKey, $nW, 420, 52)
EndFunc


;**********************************************************************
; Set main window to loaded position
;**********************************************************************
Func SetWinPos($hGUI, $sKey, $nW, $nH, $nD)
	Local $nPosX = RegRead($sKey, "PosX")
	Local $nPosY = RegRead($sKey, "PosY")
	
	If $nPosX = "" And $nPosY = "" Then Return
	
	If $nPosX < 0 Then $nPosX = 0
	If $nPosY < 0 Then $nPosY = 0

	If $nPosX >= (@DesktopWidth - $nW) Then $nPosX = @DesktopWidth - $nW
	If $nPosY >= (@DesktopHeight - $nH - $nD) Then $nPosY = @DesktopHeight - $nH - $nD
	
	WinMove($hGUI, "", $nPosX, $nPosY)
EndFunc


;**********************************************************************
; Save current main windows position
;**********************************************************************
Func SaveWinPos($hGUI, $sKey)
	Local $stWP = DllStructCreate("uint;uint;uint;long[2];long[2];long[4]")
	DllStructSetData($stWP, 1, DllStructGetSize($stWP))
		
	If GetWindowPlacement($hGUI, DllStructGetPtr($stWP)) Then
		RegWrite($sKey, "PosX", "REG_DWORD", DllStructGetData($stWP, 6, 1))
		RegWrite($sKey, "PosY", "REG_DWORD", DllStructGetData($stWP, 6, 2))
	EndIf
EndFunc


;**********************************************************************
; CreateExtGUI()
;**********************************************************************
Func CreateExtGUI()
	GUISwitch($hConfExtGUI)
	
	$bExtCreated = TRUE
	
	$nLblExtProp		= CreateCtrlLabel($sLblExtProp, 5, 10, 380, 34)
	
	$nLblProp			= CreateCtrlLabel($sLblProp, 5, 50, 185, 20)
	$nListExtProp		= CreateCtrlList("", 5, 74, 215, 190)
	;GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nLblPropVal		= CreateCtrlLabel($sLblPropVal, 245, 50, 140, 20)
	$nComboExtVal		= CreateCtrlCombo("", 245, 74, 140, 40, BitOr($CBS_DROPDOWNLIST, $CBS_SORT))
	;GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nInpExtVal			= CreateCtrlInput("", 245, 74, 140, 20)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nRadioExtSet		= CreateCtrlRadio("", 225, 74, 16, 20)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nRadioExtNotSet	= CreateCtrlRadio($sRadioNotSet, 225, 99, 140, 20)
	GUICtrlSetState(-1, $GUI_HIDE)
	
	$nInpExtNumVal		= CreateCtrlInput("", 245, 74, 140, 20)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nUDInpExtVal		= GUICtrlCreateUpdown($nInpExtNumVal, BitOr($UDS_NOTHOUSANDS, $UDS_ALIGNRIGHT))
	GUICtrlSetState(-1, $GUI_HIDE)
	
	ApplyCtrlColors(512)
	
	GUISwitch($hConfGUI)
EndFunc


;**********************************************************************
; CreateWiFiGUI()
;**********************************************************************
Func CreateWiFiGUI()
	GUISwitch($hConfWiFiGUI)
	
	Local $nBtnX	= GetScaled(6)
	Local $nBtnY	= GetScaled(7)
	Local $nBtnH	= GetScaled(23)
	;Local $nBtnL	= GetScaled(130)
	
	Local $nXS		= GetScaled(6)
	Local $nYS		= GetScaled(29)
	Local $nRS		= GetScaled(384)
	Local $nBS		= GetScaled(260)
	Local $nSC		= GetScaled(3)

	$nLblLeft3		= GUICtrlCreateLabel("", $nBtnX, $nBtnY + $nBtnH, 1, $nBS - $nBtnY - $nBtnH)
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	$nLblTop3		= GUICtrlCreateLabel("", $nBtnX, $nBtnY + $nBtnH - 1, $nRS - $nBtnX + 1, 1)
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	$nLblRight3		= GUICtrlCreateLabel("", $nRS, $nBtnY + $nBtnH, 1, $nBS - $nBtnY - $nBtnH)
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	$nLblBottom3	= GUICtrlCreateLabel("", $nBtnX, $nBS, $nRS - $nBtnX + 1, 1)
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFiFrame)
	
	Local $nW = 0
	
	SetODBtnSize($hConfWiFiGUI, 0, $sTIWiFiAvailable, $nW, $nBtnY, FALSE)
	$nTIWiFiAV		= CreateODTab($hConfWiFiGUI, $sTIWiFiAvailable, $nBtnX, $nBtnY, $nW, $nBtnH, $arODBtnMain, -1, FALSE, -1, -1, 3)
	
	If Not BitAnd($nGUIDisable, 128) Then
		$nBtnX += $nW + $nSC
		SetODBtnSize($hConfWiFiGUI, 0, $sTIWiFiPreferred, $nW, $nBtnY, FALSE)
		$nTIWiFiPref	= CreateODTab($hConfWiFiGUI, $sTIWiFiPreferred, $nBtnX, $nBtnY, $nW, $nBtnH, $arODBtnMain, -1, FALSE, -1, -1, 3)
	EndIf
	
	If Not BitAnd($nGUIDisable, 256) Then
		$nBtnX += $nW + $nSC
		SetODBtnSize($hConfWiFiGUI, 0, $sTIWiFiService, $nW, $nBtnY, FALSE)
		$nTIWiFiSrv		= CreateODTab($hConfWiFiGUI, $sTIWiFiService, $nBtnX, $nBtnY, $nW, $nBtnH, $arODBtnMain, -1, FALSE, -1, -1, 3)
	EndIf
	
	$hWiFiAvailGUI	= GUICreate("", $nRS - $nXS - 1, $nBS - $nBtnY - $nBtnH, $nXS + 1, $nBtnY + $nBtnH, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfWiFiGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hWiFiAvailGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkWiFi)
	
	$nBtnWLRef		= CreateODBtn(">", 6, 8, 22, 22, $arODBtnMain, 7, TRUE)
	GUICtrlSetTip(-1, $sTTWiFiRefresh)
	
	$nBtnWLCon		= CreateODBtn($sBtnWiFiConnect, 35, 8, 107, 22, $arODBtnMain, 24)
	SetODBtnState($nBtnWLCon, $GUI_DISABLE, FALSE)
	$nBtnWLDiscon	= CreateODBtn($sBtnWiFiDisconnect, 149, 8, 107, 22, $arODBtnMain, 25)

	$nLVWLAvail		= CreateCtrlListView($sLVWiFiList & "| | | ", 6, 37, 365, 186, _
						BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_NOSORTHEADER))
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_SUBITEMIMAGES, $LVS_EX_SUBITEMIMAGES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(56))	; Signal
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(116))	; SSID
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 2, GetScaled(100))	; Security
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 3, GetScaled(18))	; Type 
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 4, GetScaled(26))	; SignalType
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 5, GetScaled(18))	; Profile
	GUICtrlSendMsg(-1, $LVM_SETIMAGELIST, $LVSIL_SMALL, $hILLVWLA)
	
	GUISetState()

	$hLastWiFiGUI = $hWiFiAvailGUI
		
	$hWiFiPrefGUI	= GUICreate("", $nRS - $nXS - 1, $nBS - $nBtnY - $nBtnH, $nXS + 1, $nBtnY + $nBtnH, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfWiFiGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hWiFiPrefGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkWiFi)
	
	$nBtnWLRefPref	= CreateODBtn(">", 6, 8, 22, 22, $arODBtnMain, 7, TRUE)
	GUICtrlSetTip(-1, $sTTWiFiRefPref)
	
	$nBtnWLAdd		= CreateODBtn($sBtnAddShort, 35, 8, 107, 22, $arODBtnMain, 5)
	$nBtnWLDel		= CreateODBtn($sBtnDelete, 149, 8, 107, 22, $arODBtnMain, 6)
	SetODBtnState($nBtnWLDel, $GUI_DISABLE, FALSE)
	$nBtnWLEdit		= CreateODBtn($sBtnChange, 263, 8, 107, 22, $arODBtnMain, 9)
	SetODBtnState($nBtnWLEdit, $GUI_DISABLE, FALSE)
	
	$nChkWLEditUI	= CreateCtrlCheck($sChkWiFiEditUI, 263, 36, 105, 100, BitOr($BS_MULTILINE, $BS_TOP), -1, $hWiFiPrefGUI)
	If Not $bIsVista Then GUICtrlSetState(-1, BitOr($GUI_UNCHECKED, $GUI_DISABLE))
	
	$nBtnWLImport	= CreateODBtn($sBtnWiFiImport, 263, 143, 107, 22, $arODBtnMain, 15)
	$nBtnWLExport	= CreateODBtn($sBtnWiFiExport, 263, 172, 107, 22, $arODBtnMain, 16)
	SetODBtnState($nBtnWLExport, $GUI_DISABLE, FALSE)
	$nBtnWLUp		= CreateODBtn("^", 263, 201, 50, 22, $arODBtnMain, 0, TRUE)
	SetODBtnState($nBtnWLUp, $GUI_DISABLE, FALSE)
	$nBtnWLDown		= CreateODBtn("v", 320, 201, 50, 22, $arODBtnMain, 1, TRUE)
	SetODBtnState($nBtnWLDown, $GUI_DISABLE, FALSE)
	
	$nLVWLPref		= CreateCtrlListView(" |" & $sLVWiFiPref, 6, 37, 251, 186, _
											BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_NOSORTHEADER))
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_SUBITEMIMAGES, $LVS_EX_SUBITEMIMAGES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(26))	; Type
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(150))	; SSID
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 2, GetScaled(50))	; Mode
	
	$hILLVWLP = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	GUICtrlSendMsg(-1, $LVM_SETIMAGELIST, $LVSIL_SMALL, $hILLVWLP)
	
	AddILIcon($hILLVWLP, -213, 44, "Icon54") ; Preferred Infra
	AddILIcon($hILLVWLP, -214, 45, "Icon55") ; Preferred Infra connected
	AddILIcon($hILLVWLP, -215, 46, "Icon56") ; Preferred Adhoc
	AddILIcon($hILLVWLP, -216, 47, "Icon57") ; Preferred Adhoc connected
	
	$hWiFiSrvGUI	= GUICreate("", $nRS - $nXS - 1, $nBS - $nBtnY - $nBtnH, $nXS + 1, $nBtnY + $nBtnH, BitOr($WS_CHILD, $WS_TABSTOP), $WS_EX_CONTROLPARENT, $hConfWiFiGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hWiFiSrvGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkWiFi)	
	
	$nIconWiFiState = CreateCtrlIcon("shell32.dll", -1, 6, 8, $nIconSizeSmall, $nIconSizeSmall)
	SetIconFrom(-1, 183, -7, "Icon58")
	
	$nLblWiFiState	= CreateCtrlLabel($sLblWiFiCurState & ":", 25, 11, 100, 30)
	GUICtrlSetBkColor(-1, $nClrGUIBkWiFi)
	GUICtrlSetColor(-1, $nClrLblWiFi)
	
	$nLblWiFiCurState	= CreateCtrlLabel($sServiceStopped, 130, 8, 120, 22, BitOr($SS_CENTERIMAGE, $SS_CENTER, $SS_SUNKEN))
	GUICtrlSetBkColor(-1, $nClrSvcStop)
	
	$nBtnWiFi		= CreateODBtn($sServiceStart, 250, 8, 120, 22, $arODBtnMain)
	
	SetODBtnState($nTIWiFiAV, $GUI_HIDE, FALSE)
	SetODBtnState($nTIWiFiAV, $GUI_SHOW)
	$nLastItemWiFi = $nTIWiFiAV
	
	ApplyCtrlColors(256)
	
	$bWiFiCreated = TRUE
	
	GUISwitch($hConfGUI)
EndFunc


;**********************************************************************
; CreateFWGUI()
;**********************************************************************
Func CreateFWGUI()
	GUISwitch($hConfFWGUI)
	
	$nIconFWState = CreateCtrlIcon("shell32.dll", -1, 6, 7, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 183, -7, "Icon58")
	
	$nLblFWState	= CreateCtrlLabel($sLblWiFiCurState & ":", 25, 10, 120, 20)
	$nLblFWCurState	= CreateCtrlLabel($sServiceStopped, 144, 7, 120, 22, BitOr($SS_CENTERIMAGE, $SS_CENTER, $SS_SUNKEN))
	GUICtrlSetBkColor(-1, $nClrSvcStop)
	$nBtnFW			= CreateODBtn($sServiceStart, 264, 7, 120, 22, $arODBtnMain)
	
	ApplyCtrlColors(4096)
	
	GUISwitch($hConfGUI)
EndFunc


;**********************************************************************
; CreateIdentGUI()
;**********************************************************************
Func CreateIdentGUI()
	GUISwitch($hIdentGUI)
			
	$nIconIdent = CreateCtrlIcon("shell32.dll", -1, 5, 6, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 185, -9, "Icon59")
	
	$nLblCNI	= CreateCtrlLabel($sLblCNI & ":", 25, 5, 375, 18, $SS_CENTERIMAGE)
	$nLblCN		= CreateCtrlLabel($sLblComputer & ":", 5, 26, 150, 18)
	$nInpPCName	= CreateCtrlInput("", 160, 23, 240, 20)
	GUICtrlSetLimit(-1, $MAX_COMPUTERNAME_LENGTH)
	If Not $bIsWinPE Then GUICtrlSetStyle(-1, $ES_READONLY)
	$hInpPCName	= GUICtrlGetHandle($nInpPCName)
	
	$nLblWG		= CreateCtrlLabel($sLblWorkgroup & ":", 5, 50, 150, 18)
	$nInpPCWG	= CreateCtrlInput("", 160, 47, 240, 20, BitOr($ES_AUTOHSCROLL, $ES_UPPERCASE))
	GUICtrlSetLimit(-1, $MAX_COMPUTERNAME_LENGTH)
	GUICtrlSetData(-1, "")
	If Not $bIsWinPE Then GUICtrlSetStyle(-1, $ES_READONLY)
	$hInpPCWG	= GUICtrlGetHandle($nInpPCWG)
	
	$nLblPriDNS	= CreateCtrlLabel($sLblPriDNS & ":", 5, 74, 150, 20)
	$nInpPCDNS	= CreateCtrlInput("", 160, 71, 240, 20)
	GUICtrlSetLimit(-1, 255 - $MAX_COMPUTERNAME_LENGTH)
	If Not $bIsWinPE Then GUICtrlSetStyle(-1, $ES_READONLY)
	$hInpPCDNS	= GUICtrlGetHandle($nInpPCDNS)
	
	CreateCtrlLabel("", 0, 98, 405, 2, $SS_SUNKEN)
	
	$nIconPing = CreateCtrlIcon("shell32.dll", -1, 5, 103, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 238, -68, "Icon60")
		
	$nLblPing	= CreateCtrlLabel($sLblPing & ":", 25, 105, 375, 20)
	CreateCtrlLabel("", 0, 123, 405, 2, $SS_SUNKEN)
	
	$nComboPing	= CreateCtrlCombo("", 5, 130, 155, 40, BitOr($CBS_DROPDOWN, $CBS_AUTOHSCROLL, $WS_VSCROLL))
	GUICtrlSendMsg(-1, $CB_LIMITTEXT, 260, 0)
	$hCbEditPing= GetCtrlHandle($nComboPing)
	
	$nAddrPing	= CreateCtrlInput("", 5, 151, 155, 20, $ES_READONLY)
	$hAddrPing	= GUICtrlGetHandle($nAddrPing)
	$nLblTime	= CreateCtrlLabel($sLblPingTime & ":", 5, 179, 92, 18, $SS_RIGHT)
	$nInpTime	= CreateCtrlInput("1000", 100, 177, 60, 20)
	$hInpTime	= GUICtrlGetHandle($nInpTime)
	GUICtrlCreateUpDown($nInpTime)
	GUICtrlSetLimit(-1, 5000, 10)
	
	CreateCtrlLabel("", 164, 124, 2, 78, $SS_SUNKEN)
	
	$nBtnPing	= CreateODBtn($sBtnPingStart, 170, 130, 109, 20, $arODBtnMain, 13)
	$nChkPing	= CreateCtrlCheck($sChkPingLimit, 170, 153, 110, 18, -1, -1, $hIdentGUI)
	$nLblCount	= CreateCtrlLabel($sLblPingCount & ":", 167, 179, 70, 18, $SS_RIGHT)
	$nLimPing	= CreateCtrlInput("4", 240, 177, 40, 20, $ES_READONLY)
	$hLimPing	= GUICtrlGetHandle($nLimPing)
	GUICtrlCreateUpDown($nLimPing)
	GUICtrlSetLimit(-1, 99, 1)
	
	CreateCtrlLabel("", 284, 124, 2, 78, $SS_SUNKEN)
	
	$nBtnTrace	= CreateODBtn($sBtnTrace, 290, 130, 109, 20, $arODBtnMain, 21)
	$nChkTrace	= CreateCtrlCheck($sChkTrace, 290, 153, 110, 18, -1, -1, $hIdentGUI)
	$nLblTrace	= CreateCtrlLabel($sLblTrace & ":", 287, 179, 70, 18, $SS_RIGHT)
	$nInpTrace	= CreateCtrlInput("20", 360, 177, 40, 20, $ES_READONLY)
	$hInpTrace	= GUICtrlGetHandle($nInpTrace)	
	GUICtrlCreateUpDown($nInpTrace)
	GUICtrlSetLimit(-1, 30, 1)
	
	CreateCtrlLabel("", 0, 201, 405, 2, $SS_SUNKEN)
	$nChkReverse= CreateCtrlCheck($sChkReverse, 5, 207, 380, 20, -1, -1, $hIdentGUI)
	GUICtrlSetState(-1, $GUI_CHECKED)
		
	$nLVPing	= CreateCtrlListView($sLVPing, 5, 230, 394, 147, _
					BitOr($LVS_NOCOLUMNHEADER, $LVS_NOSORTHEADER, $LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $WS_VSCROLL))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(375))
	
	$nLVTrace	= CreateCtrlListView("|||", 5, 230, 394, 147, _
					BitOr($LVS_NOCOLUMNHEADER, $LVS_NOSORTHEADER, $LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $WS_VSCROLL))
	;GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(25))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(70))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 2,GetScaled(275))
	
	Local $stCol = DllStructCreate("uint;int;int;ptr;int;int;int;int;int;int;int")
	DllStructSetData($stCol, 1, 0x0001) ; LVCF_FMT
	DllStructSetData($stCol, 2, 0x0001) ; LVCFMT_RIGHT
	
	For $i = 0 To 1         
		GUICtrlSendMsg(-1, $LVM_FIRST + 96, $i, DllStructGetPtr($stCol)) ; LVM_SETCOLUMNW  = LVM_FIRST + 96
	Next
	
	$stCol = 0
	
	GUICtrlSetState(-1, $GUI_HIDE)
	
	ApplyCtrlColors(2)
	
	$bIdentCreated = TRUE
	
	GUISwitch($hMainGUI)
EndFunc


;**********************************************************************
; CreateSharesGUI()
;**********************************************************************
Func CreateSharesGUI()
	GUISwitch($hSharesGUI)
		
	Local $stIcon	= DllStructCreate("hwnd")
		
	$nIconShareState = CreateCtrlIcon("shell32.dll", -1, 5, 5, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 183, -7, "Icon61")
	
	$nLblFileShr	= CreateCtrlLabel($sLblFileSharing & ":", 25, 7, 130, 20)
	$nLblShrInfo	= CreateCtrlLabel($sServiceStopped, 160, 5, 119, 22, BitOr($SS_CENTERIMAGE, $SS_CENTER, $SS_SUNKEN))
	GUICtrlSetBkColor(-1, $nClrSvcStop)
	;GUICtrlSetColor(-1, 0xFFFF00)
	$nBtnShr		= CreateODBtn($sBtnShareStart, 279, 5, 120, 22, $arODBtnMain)
	
	$nLblShrUsr		= CreateCtrlLabel($sLblShareUser & ":", 5, 37, 150, 20)
	$nComboShrUsr	= CreateCtrlCombo("", 160, 35, 219, 40, BitOr($CBS_DROPDOWN, $CBS_AUTOHSCROLL, $WS_VSCROLL, $CBS_SORT))
	GUICtrlSendMsg(-1, $CB_LIMITTEXT, $UNLEN, 0)
	GUICtrlSetTip(-1, $sTTShareUser & @LF & _
						$sTTShareUserLen & " " & $UNLEN & " " & $sTTInputChars & ".")
	If Not $bIsWinPE Then GUICtrlSetState(-1, $GUI_DISABLE)
	$hCbEditShrUsr	= GetCtrlHandle($nComboShrUsr)
	$hComboShrUsr	= GUICtrlGetHandle($nComboShrUsr)
	
	$nBtnShrUsrDel	= CreateODBtn("Del", 379, 35, 20, 20, $arODBtnMain, 6, TRUE)
	If Not $bIsWinPE Then SetODBtnState($nBtnShrUsrDel, $GUI_DISABLE, FALSE)
	$nLblShrPW		= CreateCtrlLabel($sLblSharePW & ":", 5, 62, 150, 20)
	$nInpShrPW		= CreateCtrlInput("", 160, 60, 240, 20, BitOr($ES_AUTOHSCROLL, $ES_PASSWORD))
	GUICtrlSetLimit(-1, $PWLEN)
	GUICtrlSetTip(-1, $sTTSharePWLen & " " & $PWLEN & " " & $sTTInputChars & ".")
	If Not $bIsWinPE Then GUICtrlSetState(-1, $GUI_DISABLE)
	$hInpShrPW		= GUICtrlGetHandle($nInpShrPW)
	
	$nChkShrAll		= CreateCtrlCheck($sChkShareAll, 5, 87, 270, 20, -1, -1, $hSharesGUI)
	GUICtrlSetTip(-1, $sTTShareAll)
	If $bShareAllDrives Then GUICtrlSetState(-1, $GUI_CHECKED)
	If Not $bIsWinPE Then GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nBtnShrSetPW	= CreateODBtn($sBtnShareSetPW, 279, 86, 120, 22, $arODBtnMain)
	If Not $bIsWinPE Then SetODBtnState($nBtnShrSetPW, $GUI_DISABLE, FALSE)

	$nEditShrAdmin	= CreateCtrlEdit($sEditShareAdmin, 5, 113, 395, 32, BitOr($ES_READONLY, $WS_VSCROLL))
	GUICtrlSetColor(-1, $nClrStateRed)
	GUICtrlSetStyle(-1, BitOr($ES_READONLY, $WS_VSCROLL, $WS_BORDER), 0)
	$hEditShrAdmin	= GUICtrlGetHandle($nEditShrAdmin)
	
	CreateCtrlLabel("", 0, 150, 405, 2, $SS_SUNKEN)
	
	$nBtnShrRef	= CreateODBtn(">", 5, 158, 22, 22, $arODBtnMain, 7, TRUE)
	GUICtrlSetTip(-1, $sTTShareRefresh)
	
	$nLblShrFolders	= CreateCtrlLabel($sLblSharedFolders & ":", 30, 162, 130, 20)

	$nBtnShrAddShow	= CreateODBtn($sBtnAdd, 160, 158, 113, 22, $arODBtnMain, 19)
	$nBtnShrDel		= CreateODBtn($sBtnDelete, 279, 158, 120, 22, $arODBtnMain, 6)
	SetODBtnState($nBtnShrDel, $GUI_DISABLE, FALSE)
	
	$nLVShares	= CreateCtrlListView($sLVShares, 5, 186, 394, 191, _
					BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_SORTASCENDING, $LVS_NOSORTHEADER))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(90))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(180))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 2, GetScaled(90))
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	
	$hILLVShares = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	GUICtrlSendMsg(-1, $LVM_SETIMAGELIST, $LVSIL_SMALL, $hILLVShares)

	AddILIcon($hILLVShares, -230, 60, "Icon62")
	AddILIcon($hILLVShares, -241, 71, "Icon63")
	
	$nLblShrName	= CreateCtrlLabel($sLblShareName & ":", 5, 189, 155, 20, $SS_LEFTNOWORDWRAP)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nInpShrName	= CreateCtrlInput("", 160, 186, 240, 20)
	GUICtrlSetTip(-1, $sTTShareName)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nLblShrPath	= CreateCtrlLabel($sLblSharePath & ":", 5, 214, 155, 20, $SS_LEFTNOWORDWRAP)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nInpShrPath	= CreateCtrlInput("", 160, 211, 219, 20)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nBtnShrPath	= CreateODBtn("...", 379, 211, 20, 20, $arODBtnMain)
	SetODBtnState($nBtnShrPath, $GUI_HIDE, FALSE) 
	
	$nBtnShrAdd		= CreateODBtn($sBtnAddShort, 160, 158, 113, 22, $arODBtnMain, 5)
	SetODBtnState($nBtnShrAdd, $GUI_HIDE, FALSE)
	
	Local $nDummy	= GUICtrlCreateDummy()
	$nConMenuShr	= GUICtrlCreateContextMenu($nDummy)
	$nMIBrowseShr	= GUICtrlCreateMenuItem($sMIShareBrowse, $nConMenuShr)
	GUICtrlSetState(-1, $GUI_DEFBUTTON)
	GUICtrlCreateMenuItem("", $nConMenuShr)
	$nMIDelShr		= GUICtrlCreateMenuItem($sMIShareDel, $nConMenuShr)
	
	ApplyCtrlColors(4)
	
	$bSharesCreated = TRUE
		
	GUISwitch($hMainGUI)
EndFunc


;**********************************************************************
; CreateDrivesGUI()
;**********************************************************************
Func CreateDrivesGUI()
	GUISwitch($hDrivesGUI)
		
	Local $stIcon	= DllStructCreate("hwnd")
	
	$nLblDrvLetter	= CreateCtrlLabel($sLblDriveLetter & ":", 5, 7, 150, 20)
	$nComboDrv		= CreateCtrlCombo("*", 160, 5, 115, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetTip(-1, "<*> - " & $sTTDriveLetter & @LF & "<  > - " & $sTTDriveLetterNo)
	
	$nLblDrvPath	= CreateCtrlLabel($sLblDrivePath & ":", 5, 37, 150, 20)
	$nComboDrvPath	= CreateCtrlCombo("", 160, 35, 240, 20)
	GUICtrlSetLimit(-1, $MAX_PATH)
	$hCbEditDrvPath	= GetCtrlHandle($nComboDrvPath)
	$nLblDrvUsr		= CreateCtrlLabel($sLblDriveUser & ":", 5, 62, 150, 20)
	$nInpDrvUsr		= CreateCtrlInput("", 160, 60, 240, 20)
	GUICtrlSetLimit(-1, $UNLEN)
	$nLblDrvPW		= CreateCtrlLabel($sLblDrivePW & ":", 5, 86, 150, 20)
	$nInpDrvPW		= CreateCtrlInput("", 160, 84, 240, 20, BitOr($ES_AUTOHSCROLL, $ES_PASSWORD))
	GUICtrlSetLimit(-1, $PWLEN)
	
	$nBtnDrvAdd		= CreateODBtn($sBtnConnect, 279, 5, 120, 22, $arODBtnMain, 10)
	
	CreateCtrlLabel("", 0, 112, 405, 2, $SS_SUNKEN)
	
	$nBtnDrvNet		= CreateODBtn($sBtnDrvNet, 5, 120, 150, 23, $arODBtnMain, 19)
	$nBtnDrvNetShow	= CreateODBtn($sBtnDrvNetShow, 5, 120, 150, 23, $arODBtnMain, 18)
	SetODBtnState($nBtnDrvNetShow, $GUI_HIDE)
	
	$nLblDrvNet		= CreateCtrlLabel($sLblDrvNet & ":", 5, 150, 150, 18)
	GUICtrlSetState(-1, $GUI_HIDE)
	$nInpDrvNet		= CreateCtrlInput("", 5, 168, 150, 20, BitOr($ES_AUTOHSCROLL, $ES_UPPERCASE))
	GUICtrlSetState(-1, $GUI_HIDE)
	GUICtrlSetLimit(-1, $MAX_PATH)
	$nBtnDrvNetAdd	= CreateODBtn($sBtnAddShort, 5, 194, 150, 22, $arODBtnMain, 5)
	SetODBtnState($nBtnDrvNetAdd, $GUI_HIDE, FALSE)
	$nBtnDrvNetDel	= CreateODBtn($sBtnDelete, 5, 223, 150, 22, $arODBtnMain, 6)
	SetODBtnState($nBtnDrvNetDel, $GUI_DISABLE, FALSE)
	SetODBtnState($nBtnDrvNetDel, $GUI_HIDE, FALSE)
	$nBtnDrvNetReset= CreateODBtn($sBtnDrvNetReset, 5, 252, 150, 22, $arODBtnMain, 7)
	SetODBtnState($nBtnDrvNetReset, $GUI_HIDE, FALSE)
	
	$nEditDrvDesc	= CreateCtrlEdit("", 5, 281, 150, 96, _
										BitOr($WS_VSCROLL, $ES_AUTOVSCROLL, $ES_READONLY))
	GUICtrlSetState(-1, $GUI_HIDE)
	$hEditDrvDesc	= GUICtrlGetHandle($nEditDrvDesc)
										
	$nTVDrvNet		= CreateCtrlTreeView(160, 120, 239, 257, -1, 0x00000200)
	GUICtrlSetState(-1, $GUI_HIDE)
	$hTVDrvNet		= GUICtrlGetHandle($nTVDrvNet)
	
	$hILTVDrv = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	GUICtrlSendMsg(-1, $TVM_SETIMAGELIST, 0, $hILTVDrv)

	AddILIcon($hILTVDrv, -201, 33, "Icon64")
	AddILIcon($hILTVDrv, -229, 59, "Icon65")
	AddILIcon($hILTVDrv, -230, 60, "Icon66")
	AddILIcon($hILTVDrv, -241, 71, "Icon67")

	Local $sWG = GUICtrlRead($nInpPCWG)
	If $sWG = "" Then $sWG = GetWorkGroup()
	CreateAdvTVItem($sWG, $nTVDrvNet, $TVI_ROOT, $TVI_LAST, 0, TRUE)
	
	Local $nDummy	= GUICtrlCreateDummy()
	$nConMenuNetDrv	= GUICtrlCreateContextMenu($nDummy)
	$nMIBrowseNetDrv= GUICtrlCreateMenuItem($sBtnConnect, $nConMenuNetDrv)
	
	$nLblDrvNetLine	= CreateCtrlLabel("", 0, 150, 405, 2, $SS_SUNKEN)
		
	$nBtnDrvDel		= CreateODBtn($sBtnDisconnect, 279, 158, 120, 22, $arODBtnMain, 11)
	SetODBtnState($nBtnDrvDel, $GUI_DISABLE)
	
	$nBtnDrvRef		= CreateODBtn(">", 5, 158, 22, 22, $arODBtnMain, 7, TRUE)
	GUICtrlSetTip(-1, $sTTDrivesRefresh)
	
	$nLblDrvCon		= CreateCtrlLabel($sLblDrivesCon & ":", 30, 162, 245, 20)
	
	$nLVDrives		= CreateCtrlListView($sLVDrivesCon, 5, 186, 394, 191, _
					BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_SORTASCENDING, $LVS_NOSORTHEADER))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(50))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(180))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 2, GetScaled(90))
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	
	$nDummy			= GUICtrlCreateDummy()
	$nConMenuDrv	= GUICtrlCreateContextMenu($nDummy)
	$nMIBrowseDrv	= GUICtrlCreateMenuItem($sMIDriveBrowse, $nConMenuDrv)
	GUICtrlSetState(-1, $GUI_DEFBUTTON)
	GUICtrlCreateMenuItem("", $nConMenuDrv)
	$nMIDelDrv		= GUICtrlCreateMenuItem($sMIDriveDiscon, $nConMenuDrv)
	
	ApplyCtrlColors(8)

	$bDrivesCreated = TRUE
	
	GUISwitch($hMainGUI)
EndFunc


;**********************************************************************
; Show/hide network browsing controls
;**********************************************************************
Func ShowNetBrowse($nMsg)
	Local $arPos, $i
	
	If Not $bDrvShowInp Then
		$nValPagelast = 10
		
		GUICtrlSetState($nLblDrvNetLine, $GUI_HIDE)
		GUICtrlSetState($nBtnDrvRef, $GUI_HIDE)
		GUICtrlSetState($nLblDrvCon, $GUI_HIDE)
		GUICtrlSetState($nBtnDrvDel, $GUI_HIDE)
		GUICtrlSetState($nLVDrives, $GUI_HIDE)
		SetODBtnState($nBtnDrvNet, $GUI_HIDE)
		
		GUICtrlSetState($nLblDrvNet, $GUI_SHOW)
		GUICtrlSetState($nInpDrvNet, $GUI_SHOW)
		SetODBtnState($nBtnDrvNetAdd, $GUI_SHOW)
		SetODBtnState($nBtnDrvNetDel, $GUI_SHOW)
		SetODBtnState($nBtnDrvNetReset, $GUI_SHOW)
		GUICtrlSetState($nEditDrvDesc, $GUI_SHOW)
		GUICtrlSetState($nTVDrvNet, $GUI_SHOW)
		SetODBtnState($nBtnDrvNetShow, $GUI_SHOW + $GUI_FOCUS)
	
		$bDrvShowInp = TRUE
		
	ElseIf $nMsg = $nBtnDrvNetShow Then
		$nValPagelast = 9
		
		GUICtrlSetState($nLblDrvNet, $GUI_HIDE)
		GUICtrlSetState($nInpDrvNet, $GUI_HIDE)
		SetODBtnState($nBtnDrvNetAdd, $GUI_HIDE)
		SetODBtnState($nBtnDrvNetDel, $GUI_HIDE)
		SetODBtnState($nBtnDrvNetReset, $GUI_HIDE)
		GUICtrlSetState($nEditDrvDesc, $GUI_HIDE)
		GUICtrlSetState($nTVDrvNet, $GUI_HIDE)
		SetODBtnState($nBtnDrvNetShow, $GUI_HIDE)
		
		GUICtrlSetState($nLblDrvNetLine, $GUI_SHOW)
		GUICtrlSetState($nBtnDrvRef, $GUI_SHOW)
		GUICtrlSetState($nLblDrvCon, $GUI_SHOW)
		GUICtrlSetState($nBtnDrvDel, $GUI_SHOW)			
		GUICtrlSetState($nLVDrives, $GUI_SHOW)
		SetODBtnState($nBtnDrvNet, $GUI_SHOW + $GUI_FOCUS)
		
		$bDrvShowInp = FALSE
	EndIf
EndFunc


;**********************************************************************
; Add server/dom to network browse list
;**********************************************************************
Func AddNetBrowse()
	Local $sInpSrv = GUICtrlRead($nInpDrvNet)
	If $sInpSrv = "" Then Return
	
	Local $nImage = 0
	
	If StringLeft($sInpSrv, 2) = "\\" Then
		$sInpSrv = StringTrimLeft($sInpSrv, 2)
		$nImage = 1
	EndIf 

	CreateAdvTVItem($sInpSrv, $nTVDrvNet, $TVI_ROOT, $TVI_LAST, $nImage, TRUE)
EndFunc


;**********************************************************************
; Del server/dom from network browse list
;**********************************************************************
Func DelNetBrowse()
	Local $hItem = GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_CARET, 0)
	If $hItem = 0 Then Return
	
	GUICtrlSendMsg($nTVDrvNet, $TVM_DELETEITEM, 0, $hItem)
	
	If GUICtrlSendMsg($nTVDrvNet, $TVM_GETNEXTITEM, $TVGN_CARET, 0) = 0 Then
		SetODBtnState($nBtnDrvNetDel, $GUI_DISABLE)
		GUICtrlSetData($nEditDrvDesc, "")
	EndIf
EndFunc


;**********************************************************************
; Enumerate network shares
;**********************************************************************
Func EnumNetItems($sInpSrv, $hParent = $TVI_ROOT, $hItem = $TVI_LAST)
	Local $stServer = DllStructCreate("wchar[" & StringLen($sInpSrv) + 1 & "]")
	DllStructSetData($stServer, 1, $sInpSrv)
	
	Local $nImage = GetTVIImage($nTVDrvNet, $hParent)
	Local $nResult = 0
	
	Switch $nImage
		Case 0 ; Domain
			EnumNetResources(DllStructGetPtr($stServer), $hParent)
			
		Case 1 ; Server
			Local $stBuffer	= DllStructCreate("long_ptr")
			Local $stRead	= DllStructCreate("dword")
			DllStructSetData($stRead, 1, 0)			
			Local $stTotal	= DllStructCreate("dword")
			DllStructSetData($stTotal, 1, 0)			
			Local $stHandle	= DllStructCreate("dword")
			DllStructSetData($stHandle, 1, 0)
			Local $pSI1, $i, $stFolder = 0, $sFolder, $nLen, $nResult
			Local $hAccGUI, $arPos, $nMsg, $nInpAccUN, $nInpAccPW, $nBtnAccOK, $nBtnAccCancel, $bAccOK, $nAccRes
					
			Do
				$nResult = NetShareEnum(DllStructGetPtr($stServer), 1, DllStructGetPtr($stBuffer), $MAX_PREFERRED_LENGTH, DllStructGetPtr($stRead), _
										DllStructGetPtr($stTotal), DllStructGetPtr($stHandle))
				
				If $nResult = $ERROR_ACCESS_DENIED Then
					; Loginmask needed
					$bAccOK			= FALSE
					$arPos			= WinGetPos($hMainGUI)
					GUISetState(@SW_DISABLE, $hMainGUI)
				
					$hAccGUI		= CreateGUI($sNetworkAccess & " -> " & $sInpSrv, 285, 85, $arPos[0] + GetScaled(185, 2), $arPos[1] + 195, BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
												BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hMainGUI)
					If $bIconLib Then
						GUISetIcon($sIconLib, -64)
					Else
						SetWindowIcon($hSubGUI, @AutoItExe, 234)
					EndIf
						
					GUISetBkColor($nClrGUIBk)
					GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
					SendMessage($hAccGUI, $WM_SETFONT, $hGlobalFont, 1)
					
					CreateCtrlLabel($sLblDriveUser & ":", 5, 8, 100, 20)
					CreateCtrlLabel($sLblDrivePW & ":", 5, 33, 100, 20)
					
					$nInpAccUN		= CreateCtrlInput("", 120, 5, 160, 20)
					$nInpAccPW		= CreateCtrlInput("", 120, 30, 160, 20, BitOr($ES_PASSWORD, $ES_AUTOHSCROLL))
					$nBtnAccOK		= CreateODBtn($sBtnOK, 5, 55, 135, 25, $arODBtnSub, 2)
					$nBtnAccCancel	= CreateODBtn($sBtnCancel, 145, 55, 135, 25, $arODBtnSub, 3)
					
					GUISetState()
					While 1
						$nMsg = GUIGetMsg()
						Switch $nMsg
							Case $GUI_EVENT_CLOSE, $nBtnAccCancel
								ExitLoop
							Case $nBtnAccOK
								$nAccRes = DriveMapAdd("", "\\" & $sInpSrv & "\ipc$", 0, GUICtrlRead($nInpAccUN), GUICtrlRead($nInpAccPW))
								If $nAccRes Then
									$bAccOK = TRUE
									ExitLoop
								Else
									Switch @Error
										Case 1
											MsgBoxEx(16, $sError, GetErrStr(@Extended), $hAccGUI)
										Case 6
											MsgBoxEx(16, $sError, $sNetDriveAddErr6, $hAccGUI)
									EndSwitch
								EndIf
						EndSwitch
					WEnd
					
					GUISetState(@SW_ENABLE, $hMainGUI)
					
					GUIDelete($hAccGUI)
					DelODBtnGrp($arODBtnSub)
										
					If $bAccOK Then
						$nResult = NetShareEnum(DllStructGetPtr($stServer), 1, DllStructGetPtr($stBuffer), $MAX_PREFERRED_LENGTH, DllStructGetPtr($stRead), _
											DllStructGetPtr($stTotal), DllStructGetPtr($stHandle))
					EndIf
				EndIf
				
				If $nResult = $NERR_Success Or $nResult = $ERROR_MORE_DATA Then				
					$pSI1 = DllStructGetData($stBuffer, 1)
									
					For $i = 1 To DllStructGetData($stRead, 1)
						$stSI1		= DllStructCreate($sSHARE_INFO_1, $pSI1)
						If DllStructGetData($stSI1, 2) <> $STYPE_PRINTQ Then
							$stFolder	= DllStructCreate("wchar[" & (wcslen(DllStructGetData($stSI1, 1)) + 1) & "]", DllStructGetData($stSI1, 1))
							$nImage = 2
							If StringRight(DllStructGetData($stFolder, 1), 1) = "$" Then $nImage = 3
							$hItem = CreateAdvTVItem(DllStructGetData($stFolder, 1), $nTVDrvNet, $hParent, $hItem, $nImage)
						EndIf
						
						$pSI1 += DllStructGetSize($stSI1)
					Next
					
					NetApiBufferFree(DllStructGetData($stBuffer, 1))
				EndIf
			Until $nResult <> $ERROR_MORE_DATA
			
			$stBuffer = 0
	EndSwitch
	
	GUICtrlSendMsg($nTVDrvNet, $TVM_SORTCHILDREN, FALSE, $hParent)
EndFunc


;**********************************************************************
; Enumerate network resources
;**********************************************************************
Func EnumNetResources($pInpSrv, $hParent)
	Local $stNetResEnum = DllStructCreate($sNETRESOURCE)
			                    
	DllStructSetData($stNetResEnum, 1, $RESOURCE_GLOBALNET)
	DllStructSetData($stNetResEnum, 2, $RESOURCETYPE_DISK)
	DllStructSetData($stNetResEnum, 3, 0)
	DllStructSetData($stNetResEnum, 4, $RESOURCEUSAGE_CONTAINER)
	DllStructSetData($stNetResEnum, 5, 0)
	DllStructSetData($stNetResEnum, 6, $pInpSrv)
	DllStructSetData($stNetResEnum, 7, 0)
	DllStructSetData($stNetResEnum, 8, 0)
	
	Local $stEnum = DllStructCreate("long_ptr")
	If WNetOpenEnumW($RESOURCE_GLOBALNET, $RESOURCETYPE_DISK, 0, DllStructGetPtr($stNetResEnum), DllStructGetPtr($stEnum)) <> $NO_ERROR Then Return
	
	Local $hEnum = DllStructGetData($stEnum, 1)
	
	Local $stCount = DllStructCreate("dword")
	DllStructSetData($stCount, 1, -1)
	
	Local $stSize = DllStructCreate("dword")
	DllStructSetData($stSize, 1, 16384)
	
	Local $stBuffer, $pBuffer, $stNetRes, $nResult, $i, $stRemote, $sRemote
    
	Do
		$stBuffer = DllStructCreate("byte[16384]")
		
		$nResult = WNetEnumResourceW($hEnum, DllStructGetPtr($stCount), DllStructGetPtr($stBuffer), DllStructGetPtr($stSize))
		
		If $nResult = $NO_ERROR Or $nResult = $ERROR_MORE_DATA Then
			$pBuffer = DllStructGetPtr($stBuffer)
			
			For $i = 1 To DllStructGetData($stCount, 1)
				$stNetRes = DllStructCreate($sNETRESOURCE, $pBuffer)
				
			    $stRemote = DllStructCreate("wchar[" & (wcslen(DllStructGetData($stNetRes, 6)) + 1) & "]", DllStructGetData($stNetRes, 6))
			    $sRemote = DllStructGetData($stRemote, 1)
				If StringLeft($sRemote, 2) = "\\" Then $sRemote = StringTrimLeft($sRemote, 2)
				
				CreateAdvTVItem($sRemote, $nTVDrvNet, $hParent, $TVI_LAST, 1, TRUE)
				
				$pBuffer += DllStructGetSize($stNetRes)
			Next
		EndIf
		
		$stBuffer  = 0    
	Until $nResult <> $ERROR_MORE_DATA
        
	WNetCloseEnum($hEnum)

	$stNetResEnum = 0
EndFunc


;**********************************************************************
; Create a treeview item without internal ID
;**********************************************************************
Func CreateAdvTVItem($sText, $nTV, $hParent, $hInsertAfter, $nIconIdx = -1, $bHasChilds = FALSE)
	Local $stText = DllStructCreate("wchar[" & (StringLen($sText) + 1) & "]")
	DllStructSetData($stText, 1, $sText)
	
	Local $stTVIS = DllStructCreate("hwnd;hwnd;" & $sTVI)
	DllStructSetData($stTVIS, 1, $hParent)
	DllStructSetData($stTVIS, 2, $hInsertAfter)
		
	Local $nMask = $TVIF_TEXT
	If $nIconIdx > -1 Then
		$nMask = BitOr($nMask, $TVIF_IMAGE, $TVIF_SELECTEDIMAGE)
		DllStructSetData($stTVIS, 9, $nIconIdx)
		DllStructSetData($stTVIS, 10, $nIconIdx)
	EndIf
	
	If $bHasChilds Then
		$nMask = BitOr($nMask, $TVIF_CHILDREN)
		DllStructSetData($stTVIS, 11, 1)
	EndIf
	
	DllStructSetData($stTVIS, 3, $nMask)
	DllStructSetData($stTVIS, 4, 0)
	DllStructSetData($stTVIS, 7, DllStructGetPtr($stText))

	Local $hItem = GUICtrlSendMsg($nTV, $TVM_INSERTITEMW, 0, DllStructGetPtr($stTVIS))

	Return $hItem
EndFunc


;**********************************************************************
; CreateProfilesGUI()
;**********************************************************************
Func CreateProfilesGUI()
	GUISwitch($hProfilesGUI)
	
	$bProfilesCreated = TRUE
		
	$nLblProfFile	= CreateCtrlLabel($sLblProfFile & ":", 5, 7, 390, 16)
	$nInpProfFile	= CreateCtrlInput("", 5, 23, 336, 20, BitOr($ES_READONLY, $ES_AUTOHSCROLL))
	$hInpProfFile	= GUICtrlGetHandle($nInpProfFile)
	$nBtnProfFile	= CreateODBtn("...", 341, 23, 20, 20, $arODBtnMain)
	GUICtrlSetTip(-1, $sBtnProfFile)
	$nBtnProfInt	= CreateODBtn("I", 360, 23, 20, 20, $arODBtnMain, 20, TRUE)
	GUICtrlSetTip(-1, $sBtnProfInt)
	$nBtnProfExt	= CreateODBtn("E", 379, 23, 20, 20, $arODBtnMain, 16, TRUE)
	GUICtrlSetTip(-1, $sBtnProfExt)
	
	$nBtnProfRef	= CreateODBtn(">", 5, 50, 22, 22, $arODBtnMain, 7, TRUE)
	GUICtrlSetTip(-1, $sTTProfRefresh)
	
	$nLblProfList	= CreateCtrlLabel($sLblProfList & ":", 30, 54, 245, 20)
	$nBtnProfApply	= CreateODBtn($sBtnApply, 279, 50, 120, 22, $arODBtnMain, 9)
	SetODBtnState($nBtnProfApply, $GUI_DISABLE, FALSE)
	
	$nListProf		= CreateCtrlList("", 5, 78, 394, 150)
	GUICtrlSetStyle(-1, BitOr($WS_BORDER, $WS_VSCROLL, $WS_TABSTOP))
	
	$nLblProfDesc	= CreateCtrlLabel($sLblProfDesc & ":", 5, 238, 390, 18)
	$nEditProfDesc	= CreateCtrlEdit("", 5, 255, 394, 122, _
										BitOr($WS_VSCROLL, $WS_HSCROLL, $ES_AUTOVSCROLL, $ES_AUTOHSCROLL, $ES_READONLY))
	$hEditProfDesc	= GUICtrlGetHandle($nEditProfDesc)
	
	ApplyCtrlColors(16)

	GUISwitch($hMainGUI)
EndFunc


;**********************************************************************
; Update profile list in profiles GUI
;**********************************************************************
Func UpdateProfileList($sFile = "")
	If $sFile = "" Then
		If $sProfFile <> "" And FileExists($sProfFile) Then
			GUICtrlSetData($nInpProfFile, $sProfFile)
			GUICtrlSetTip($nInpProfFile, $sProfFile)
			GetProfiles($sProfFile)
		EndIf
	ElseIf $sFile <> "" And FileExists($sFile) Then
		GUICtrlSetData($nInpProfFile, $sFile)
		GUICtrlSetTip($nInpProfFile, $sFile)
		GetProfiles($sFile)
	EndIf
EndFunc


;**********************************************************************
; Load profiles in profile list
;**********************************************************************
Func GetProfiles($sFile = "")
	If $sFile = "" Then Return
	Local $arNetProfiles = IniReadSection($sFile, "NetProfiles")
	If @Error Then Return
	
	If $arNetProfiles[0][0] = 0 Then Return
	
	Local $i
	
	GUICtrlSendMsg($nListProf, $LB_RESETCONTENT, 0, 0)

	Local $sCurrent = RegRead($sGURegKey, "Profile")
	Local $sProfile = ""
	
	For $i = 1 To $arNetProfiles[0][0]
		$sProfile = $arNetProfiles[$i][0]
		If $sCurrent <> "" And $sCurrent = $sProfile Then $sProfile = $sProfile & " (" & $sLblCurrent & ")"
		GUICtrlSendMsg($nListProf, $LB_INSERTSTRING, -1, $sProfile)
	Next
EndFunc


;**********************************************************************
; Get profile description
;**********************************************************************
Func GetProfileDesc($sFile = "")
	If $sFile = "" Then Return
	
	GUICtrlSetData($nEditProfDesc, "")
	
	Local $nCurSel = GUICtrlSendMsg($nListProf, $LB_GETCURSEL, 0, 0)
	If $nCurSel = -1 Then Return
	
	Local $nLen = GUICtrlSendMsg($nListProf, $LB_GETTEXTLEN, $nCurSel, 0)
	If $nLen > 0 Then
		Local $stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
			
		If GUICtrlSendMsg($nListProf, $LB_GETTEXT, $nCurSel, DllStructGetPtr($stText)) > 0 Then
			Local $sSection = DllStructGetData($stText, 1)
			If $sSection <> "" Then
				Local $sCurrent = RegRead($sGURegKey, "Profile")
				If $sCurrent <> "" Then
					$sCurrent = $sCurrent & " (" & $sLblCurrent & ")"
					If $sSection = $sCurrent Then $sSection = StringTrimRight($sSection, StringLen($sLblCurrent) + 3)
				EndIf
				
				Local $i = 1
				Local $sDesc = "", $sLine = ""
				
				While 1
					$sLine = IniRead($sFile, $sSection, "Desc.Line" & $i, "IniReadError")
					If $sLine = "IniReadError" Then ExitLoop
					
					$sDesc &= $sLine & @CRLF
					$i += 1
				WEnd
				
				GUICtrlSetData($nEditProfDesc, $sDesc)
			EndIf
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Apply profile
;**********************************************************************
Func ApplyProfile($sFile, $sProfile, $bFromGUI = FALSE, $bReloadWiFiProfiles = TRUE)
	If $sFile = "" Or $sProfile = "" Then Return

	Debug("IN: Applying profile: " & $sProfile)
	
	; Setting computer identity
	Local $sProfCN	= IniRead($sFile, $sProfile, "Computername", "")
	Local $sProfWG	= IniRead($sFile, $sProfile, "Workgroup", "")
	Local $sProfSuf	= IniRead($sFile, $sProfile, "DNSSuffix", "")	
	Local $sProfNP	= IniRead($sFile, $sProfile, "NetPath", "")
	
	Local $nOldMode = Opt("ExpandEnvStrings", 1)
	
	RegWrite($sGURegKey, "Profile", "REG_SZ", $sProfile)
	
	If $bIsWinPE Then		
		Local $bRestartWS = FALSE
		Local $bRestartDev= FALSE
		
		If $sProfCN <> "" Then
			Local $cnc, $sc, $sProfNewCN = ""
			
			If StringLen($sProfCN) >= $MAX_COMPUTERNAME_LENGTH Then $sProfCN = StringLeft($sProfCN, $MAX_COMPUTERNAME_LENGTH)
			
			For $sc = 1 To StringLen($sProfCN)
				$cnc = StringMid($sProfCN, $sc, 1)
				If $cnc = "?" Then
					$sProfNewCN = $sProfNewCN & Chr(Random(65, 90, 1))
				ElseIf $cnc = "+" Then
					$sProfNewCN = $sProfNewCN & Chr(Random(48, 57, 1))
				Else
					$sProfNewCN = $sProfNewCN & $cnc
				EndIf
			Next
			
			If $sProfNewCN <> "" Then SetCN($sProfNewCN)
			$bRestartWS = TRUE			
		EndIf
		
		If $sProfWG <> "" Then
			If StringLen($sProfWG) > $MAX_COMPUTERNAME_LENGTH Then $sProfWG = StringLeft($sProfWG, $MAX_COMPUTERNAME_LENGTH)
			SetWorkGroup($sProfWG)
			$bRestartWS = TRUE
		EndIf
		
		If $sProfSuf <> "" Then
			SetDNSSuffix($sProfSuf)
			$bRestartWS = TRUE
		EndIf
		
		If $bFromGUI And $bRestartWS Then
			DelDriveAll()
					
			StopSvc("lanmanworkstation", FALSE)
			StartSvc("lanmanworkstation", FALSE)
			
			If IsServiceRunning("lanmanserver") Then
				StopSvc("lanmanserver", FALSE)
				StartSvc("lanmanserver", FALSE)			
			EndIf
		EndIf		
		
		If $sProfNP <> "" Then
			Local $arNP = StringSplit($sProfNP, ",")
			If IsArray($arNP) Then
				Local $z
				For $z = 1 To $arNP[0]
					If $arNP[$z] <> "" Then MapDriveSave($arNP[$z])
				Next
			EndIf
		EndIf
		
		; Updating sharing settings
		Local $sStartSharing	= IniRead($sFile, $sProfile, "StartSharing", "")
		Local $sShareAll		= IniRead($sFile, $sProfile, "ShareAll", "")
		
		If $sStartSharing = "Yes" Then
			$bStartSharing = TRUE
		ElseIf $sStartSharing = "No" Then
			$bStartSharing = FALSE
		EndIf
		
		If $sShareAll = "Yes" Then
			$bShareAllDrives = TRUE
			RegWrite($sGRegKey, "ShareAll", "REG_DWORD", 1)
		ElseIf $sShareAll = "No" Then
			$bShareAllDrives = FALSE
			RegWrite($sGRegKey, "ShareAll", "REG_DWORD", 0)
		EndIf
		
		Debug("IN: Profiles - Start sharing: " & $bStartSharing)
		Debug("IN: Profiles - Share all drives: " & $bShareAllDrives)
	EndIf
	
	Local $bTCPRun = FALSE
	If IsServiceRunning("tcpip") Then $bTCPRun = TRUE
	
	; Setting TCP/IP params
	If Not $bNoNetcards Then
		Local $sInfPath, $sService, $nChar, $i = 1, $k = 0, $a = 0, $s = 0, $sDesc = "", $sNA = ""
		Local $sClassKey = $sCCS & "\Control\Class\" & $sClassNet
		Local $bProfDHCP = "0"
		Local $sProfIP = "", $sProfSM = "", $sProfDG = "", $bProfApipa = "1"
		Local $sProfDNS = "", $sProfWINS = "", $sProfMAC = "", $sLine = ""
		Local $sFilter = "", $sPart = ""
		Local $arUsed[1], $arFilter, $bFound, $bUsed, $sDevService, $sDevID, $sLowerRange
		Local $bFilterUsed = FALSE
		Local $sDev, $hDev, $sMAC
		Local $stBuffer = DllStructCreate("ubyte[6]")
		Local $stBytes = DllStructCreate("dword")			
		Local $stCode = DllStructCreate("dword")
		DllStructSetData($stCode, 1, $OID_802_3_CURRENT_ADDRESS)									
				
		$arUsed[0] = 0
		
		; Precheck if filter are used
		$a = 1				
		While 1
			$sLine = IniRead($sFile, $sProfile, "NetAdapter" & $a & ".UseDHCP", "IniReadError")
			If $sLine = "IniReadError" Then ExitLoop
			If IniRead($sFile, $sProfile, "NetAdapter" & $a & ".Filter", "") <> "" Then
				$bFilterUsed = TRUE
				ExitLoop
			EndIf
			
			$a += 1
		WEnd
		
		Local $oConf
		Local $oConfigs
		Local $oConfItem
		
		While 1
			$bFound = FALSE
			
			$sKey = RegEnumKey($sClassKey, $i)
			If @Error <> 0 Then ExitLoop
			
			$nChar		= Number(RegRead($sClassKey & "\" & $sKey, "Characteristics"))
			$sInfPath	= RegRead($sClassKey & "\" & $sKey, "InfPath")
			$sService	= RegRead($sClassKey & "\" & $sKey, "NetCfgInstanceId")
			$sDesc		= RegRead($sClassKey & "\" & $sKey, "DriverDesc")
			$sDevID		= RegRead($sClassKey & "\" & $sKey, "DeviceInstanceID")
			$sDevService= RegRead($sClassKey & "\" & $sKey & "\Ndi", "Service")
			$sLowerRange= RegRead($sClassKey & "\" & $sKey & "\Ndi\Interfaces", "LowerRange")
			
			If ($nChar = 1 Or $nChar = 132) And $sInfPath <> "" And $sService <> "" Then
				$k += 1
				
				Debug("IN: Profiles - Reg" & StringFormat("%02d", $k) & " - " & $sKey & " - Characteristics: " & $nChar)
				Debug("IN: Profiles - Reg" & StringFormat("%02d", $k) & " - " & $sKey & " - DriverDesc: " & $sDesc)
				Debug("IN: Profiles - Reg" & StringFormat("%02d", $k) & " - " & $sKey & " - InfPath: " & $sInfPath)
				Debug("IN: Profiles - Reg" & StringFormat("%02d", $k) & " - " & $sKey & " - NetCfgInstanceId: " & $sService)
				Debug("IN: Profiles - Reg" & StringFormat("%02d", $k) & " - " & $sKey & " - DeviceId: " & $sDevID)
				Debug("IN: Profiles - Reg" & StringFormat("%02d", $k) & " - " & $sKey & " - Service: " & $sDevService)
		
				; Global APIPA
				If $bEnableAutoIP Then
					SetAdapterProperty($sService, 16, 1)
					Debug("IN: Enabled APIPA on device: " & $sDesc)
				Else
					SetAdapterProperty($sService, 16, 0)
					Debug("IN: Disabled APIPA on device: " & $sDesc)
				EndIf
				
				If $bFilterUsed Then					
					$a = 1				
					While 1
						$bUsed = FALSE
						
						For $s = 1 To $arUsed[0]
							If $a = $arUsed[$s] Then
								$bUsed = TRUE
								ExitLoop
							EndIf
						Next
						
						If $bUsed Then
							$a += 1
							ContinueLoop
						EndIf
						
						$sNA = "NetAdapter" & $a
						$sLine = IniRead($sFile, $sProfile, $sNA & ".UseDHCP", "IniReadError")
						If $sLine = "IniReadError" Then ExitLoop
						
						$sFilter = IniRead($sFile, $sProfile, $sNA & ".Filter", "")
						Debug("IN: Profiles - Filter" & $a & ": " & $sFilter)
										
						If $sFilter = "" Then
							$a += 1
							ContinueLoop
						EndIf
						
						;devicename::wifi||devicename::wireless||devicename::wlan||deviceid::USB\VID_0BDA&PID_8187||devicename::RTL8187
						;(devicename::wifi||devicename::wireless||devicename::wlan)&&deviceid::USB\VID_0BDA&PID_8187
						;servicename=rtl8187b||lowerrange::wlan||lowerrange::wifi
						;mac::00112233||mac==001122334455||mac=001122334455
						$arFilter = StringSplit($sFilter, "||", 1)
						If IsArray($arFilter) Then
							For $s = 1 To $arFilter[0]
								; MAC detection
								$sMAC = ""
								DllStructSetData($stBuffer, 1, "")
								DllStructSetData($stBytes, 1, 0)
								$sDev = "\\.\" & $sService
								
								$hDev = CreateFileW($sDev, 0, BitOr($FILE_SHARE_READ, $FILE_SHARE_WRITE), 0, $OPEN_EXISTING, 0, 0)
								If $hDev <> $INVALID_HANDLE_VALUE Then
									If DeviceIoControl($hDev, _
														$IOCTL_NDIS_QUERY_GLOBAL_STATS, _
														DllStructGetPtr($stCode), _
														DllStructGetSize($stCode), _
														DllStructGetPtr($stBuffer), _
														DllStructGetSize($stBuffer), _
														DllStructGetPtr($stBytes), _
														0) Then
										$sMAC = StringFormat("%02X-%02X-%02X-%02X-%02X-%02X", DllStructGetData($stBuffer, 1, 1), DllStructGetData($stBuffer, 1, 2), _
																						DllStructGetData($stBuffer, 1, 3), DllStructGetData($stBuffer, 1, 4), _
																						DllStructGetData($stBuffer, 1, 5), DllStructGetData($stBuffer, 1, 6))	
									EndIf
									
									CloseHandle($hDev)
								EndIf
								
								If $sMAC <> "" Then
									$nPos = StringInStr($arFilter[$s], "mac::") ; len 5
									If $nPos > 0 Then
										$sName = StringTrimLeft($arFilter[$s], $nPos + 4)
										If StringInStr($sMAC, $sName) Then
											Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'mac::' -> " & $sName)
											$bFound = TRUE
											ExitLoop
										EndIf
									EndIf
									
									$nPos = StringInStr($arFilter[$s], "mac==") ; len 5
									If $nPos > 0 Then
										$sName = StringTrimLeft($arFilter[$s], $nPos + 4)
										If $sMAC == $sName Then
											Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'mac==' -> " & $sName)
											$bFound = TRUE
											ExitLoop
										EndIf
									EndIf
									
									$nPos = StringInStr($arFilter[$s], "mac=") ; len 4
									If $nPos > 0 Then
										$sName = StringTrimLeft($arFilter[$s], $nPos + 3)
										If $sMAC = $sName Then
											Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'mac=' -> " & $sName)
											$bFound = TRUE
											ExitLoop
										EndIf
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "devicename::") ; len 12
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 11)
									If StringInStr($sDesc, $sName) Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'devicename::' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "devicename==") ; len 12
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 11)
									If $sDesc == $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'devicename==' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "devicename=") ; len 11
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 10)
									If $sDesc = $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'devicename=' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "deviceid::") ; len 10
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 9)
									If StringInStr($sDevID, $sName) Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'deviceid::' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "deviceid==") ; len 10
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 9)
									If $sDevID == $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'deviceid==' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "deviceid=") ; len 9
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 8)
									If $sDevID = $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'deviceid=' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "servicename::") ; len 13
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 12)
									If StringInStr($sDevService, $sName) Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'servicename::' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "servicename==") ; len 13
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 12)
									If $sDevService == $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'servicename==' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "servicename=") ; len 12
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 11)
									If $sDevService = $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'servicename=' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "lowerrange::") ; len 12
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 11)
									If StringInStr($sLowerRange, $sName) Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'lowerrange::' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "lowerrange==") ; len 12
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 11)
									If $sLowerRange == $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'lowerrange==' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
								
								$nPos = StringInStr($arFilter[$s], "lowerrange=") ; len 11
								If $nPos > 0 Then
									$sName = StringTrimLeft($arFilter[$s], $nPos + 10)
									If $sLowerRange = $sName Then
										Debug("IN: Profiles - NetAdapter" & $a & " entry selected via filter 'lowerrange=' -> " & $sName)
										$bFound = TRUE
										ExitLoop
									EndIf
								EndIf
							Next
						EndIf
						
						If $bFound Then ExitLoop
						
						$a += 1
					WEnd
					
					If $bFound Then
						$arUsed[0] += 1
						ReDim $arUsed[$arUsed[0] + 1]
						$arUsed[$arUsed[0]] = $a
						$sNA = "NetAdapter" & $a
					Else
						Debug("IN: Profiles - No matching filter found for adapter #" & $k & " -> " & $sDesc)
						$a = 1
						While 1
							$sNA = "NetAdapter" & $a
							$sLine = IniRead($sFile, $sProfile, $sNA & ".UseDHCP", "IniReadError")
							If $sLine = "IniReadError" Then ExitLoop	
							
							If IniRead($sFile, $sProfile, $sNA & ".Filter", "") <> "" Then
								$a += 1
								ContinueLoop
							EndIf
							
							$bUsed = FALSE
							For $s = 1 To $arUsed[0]
								If $a = $arUsed[$s] Then
									$bUsed = TRUE
									ExitLoop
								EndIf
							Next
							
							If $bUsed Then
								$a += 1
								ContinueLoop
							Else				
								$arUsed[0] += 1
								ReDim $arUsed[$arUsed[0] + 1]
								$arUsed[$arUsed[0]] = $a
								ExitLoop
							EndIf
							
							$a += 1					
						WEnd
					EndIf
				Else
					; No filter used/found
					$sNA = "NetAdapter" & $k					
				EndIf
				
				$sLine = IniRead($sFile, $sProfile, $sNA & ".UseDHCP", "IniReadError")				
				If $sLine <> "IniReadError" Then
					Debug("IN: Profiles - Found profile settings for adapter #" & $k & " -> " & $sDesc)
					
					$bProfDHCP	= Number(IniRead($sFile, $sProfile, $sNA & ".UseDHCP", "1"))
								
					Debug("IN: Profiles - IniEntry - " & $sNA & ".DHCP: " & $bProfDHCP)
						
					If $bProfDHCP Then
						SetAdapterProperty($sService, 0, 1)
						SetAdapterProperty($sService, 1, "0.0.0.0", "0.0.0.0")
						
						If $bFromGUI Then $bRestartDev = TRUE
					Else
						$sProfIP	= IniRead($sFile, $sProfile, $sNA & ".IP", "")
						$sProfIP	= StringReplace($sProfIP, ",", @LF)
						
						$sProfSM	= IniRead($sFile, $sProfile, $sNA & ".SM", "")
						$sProfSM	= StringReplace($sProfSM, ",", @LF)
						
						Debug("IN: Profiles - IniEntry - " & $sNA & ".IP: " & $sProfIP)
						Debug("IN: Profiles - IniEntry - " & $sNA & ".SM: " & $sProfSM)
						
						SetAdapterProperty($sService, 0, 0)
						SetAdapterProperty($sService, 1, $sProfIP, $sProfSM)
						
						$bRestartDev = TRUE
					EndIf
					
					$sProfDG	= IniRead($sFile, $sProfile, $sNA & ".DG", "")
					If $sProfDG <> "" Then $sProfDG = StringReplace($sProfDG, ",", @LF)
					
					$sProfDNS	= IniRead($sFile, $sProfile, $sNA & ".DNS", "")
					
					$sProfWINS	= IniRead($sFile, $sProfile, $sNA & ".WINS", "")
					If $sProfWINS <> "" Then $sProfWINS = StringReplace($sProfWINS, ",", @LF)
					
					$sProfMAC	= IniRead($sFile, $sProfile, $sNA & ".MAC", "")
					If StringRegExp($sProfMAC, $sMACChkPattern) Then
						Debug("IN: Profiles - IniEntry - " & $sNA & ".MAC: " & $sProfMAC)
						SetAdapterProperty($sService, 17, $sProfMAC)
						$bRestartDev = TRUE
					EndIf
					
					If $sProfDG = "" Then
						SetAdapterProperty($sService, 3, "")
					Else
						Debug("IN: Profiles - IniEntry - " & $sNA & ".DG: " & $sProfDG)
						SetAdapterProperty($sService, 3, $sProfDG)
						$bRestartDev = TRUE
					EndIf
					
					If $sProfDNS = "" Then
						SetAdapterProperty($sService, 4, "")
					Else
						Debug("IN: Profiles - IniEntry - " & $sNA & ".DNS: " & $sProfDNS)
						SetAdapterProperty($sService, 4, $sProfDNS)
						$bRestartDev = TRUE
					EndIf
					
					If $sProfWINS = "" Then
						SetAdapterProperty($sService, 5, "")
					Else
						Debug("IN: Profiles - IniEntry - " & $sNA & ".WINS: " & $sProfWINS)
						SetAdapterProperty($sService, 5, $sProfWINS)
						$bRestartDev = TRUE
					EndIf
					
					If $bTCPRun And $bRestartDev Then
						Debug("IN: Profiles - Restarting device: " & $sDesc & " (" & $sService & ")")
						If $bUseWMI And $bIsVista Then
							EnumNetworkAdapters()
							Local $iG = GetNetAdapterIndexByGUID($sService)
							If $iG > 0 Then
								$oConf		= 0	
								$oConfigs		= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapter Where Description = """ & $arNAList[$iG][2] & """")
								$oConfItem	= 0
								For $oConfItem In $oConfigs
									$oConf = $oConfItem
								Next
						
								$oConf.Disable
								$oConf.Enable					
						
								Sleep(2500)
							EndIf
						Else
							RestartNetDevice("", $sService)
						EndIf
					EndIf
				EndIf
			EndIf
			
			$i += 1
		WEnd
		
		If $bFromGUI And $bTCPRun Then
			$i = 1
			Local $sUserName, $sPassWord
			
			While 1
				$sUserName = ProfileGetDText(IniRead($sPENMini, $sProfile, "Share.User" & $i, ""))
				If $sUserName = "" Then ExitLoop
				
				$sPassWord = ProfileGetDText(IniRead($sPENMini, $sProfile, "Share.Pass" & $i, ""))
				
				If EnableWriteAccess($sUserName, $sPassWord) Then
					Debug("OK: Profiles	- Adding user:"	& $sUserName)
				Else
					Debug("ER: Profiles	- Adding user:"	& $sUserName)
				EndIf
				
				$i += 1
			WEnd
			
			; Adding WiFi profiles only if WiFi cards are installed
			If $bReloadWiFiProfiles Then LoadWiFiProfiles($sProfile, $bFromGUI)

			; Adding network drives
			$i = 1
			Local $sRemote, $sDevice
			
			While 1
				$sRemote = IniRead($sPENMini, $sProfile, "NetDrv.Path" & $i, "")
				If $sRemote	= "" Then ExitLoop
				
				$sUserName	= ProfileGetDText(IniRead($sPENMini, $sProfile, "NetDrv.User" & $i, ""))
				$sPassWord	= ProfileGetDText(IniRead($sPENMini, $sProfile, "NetDrv.Pass" & $i, ""))
				$sDevice	= IniRead($sPENMini, $sProfile, "NetDrv.Letter" & $i, "")
				
				MapDrive($sDevice, $sRemote, $sUserName, $sPassWord, FALSE)
				
				$i += 1
			WEnd
			
			; Run commands after appyling profile/changing network settings	
			ProfileStartCMD($sProfile)
		EndIf
	EndIf
EndFunc


;**********************************************************************
; CreateOtherGUI()
;**********************************************************************
Func CreateOtherGUI()
	GUISwitch($hOtherGUI)
	
	$nLblSurface		= CreateCtrlLabel($sLblSurface & ":", 5, 7, 395 - GetScaled($nSBSize, 2), 16) 
	
	$nIconLang = CreateCtrlIcon("shell32.dll", -1, 5, 24, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 201, -33, "Icon68")
	
	$nLblLang			= CreateCtrlLabel($sGrpLanguage & ":", 25, 26, 120, 18)
	$nComboLang			= CreateCtrlCombo("", 160, 23, 219 - $nSBSize, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, $sCurLang, $sCurLang)
	GUICtrlSetTip(-1, $sLblLangAuthor & ": " & $sCurLangAuthor & @LF & $sLblLangVersion & ": " & $sCurLangVer)
	
	$nBtnLangExt		= CreateODBtn(">", 379 - $nSBSize, 23, 20, 20, $arODBtnMain, 16, TRUE)
	GUICtrlSetTip(-1, $sBtnLangExt)
	
	$nIconScheme		= CreateCtrlIcon("shell32.dll", -1, 5, 49, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 191, -23, "Icon69")
	
	$nLblClr			= CreateCtrlLabel($sLblClr & ":", 25, 51, 120, 18)
	$nComboScheme		= CreateCtrlCombo("", 160, 48, 240 - $nSBSize, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, $sAllSchemes, $sCurScheme)
	
	$nRadioOSFont		= CreateCtrlRadio($sRadioOSFont, 25, 76, 378 - $nSBSize, 18, $WS_GROUP)
	$nRadioFont			= CreateCtrlRadio($sRadioFont & ":", 25, 94, 134, 18)
	$nInpFont			= CreateCtrlInput("", 160, 94, 220 - $nSBSize, 20)
	GUICtrlSetState(-1, $GUI_DISABLE)
	
	Local $sText = RegRead($sGURegKey, "GlobalFont")
	If @Error = 0 Then
		GUICtrlSetData(-1, $sText)
	Else
		GUICtrlSetData(-1, $sGlobalFont)
	EndIf
	
	$nBtnFont			= CreateODBtn("...", 160 + (220 - $nSBSize), 94, 20, 20, $arODBtnMain, 20)
	
	If $bUseOSFont Then
		GUICtrlSetState($nRadioFont, $GUI_UNCHECKED)
		GUICtrlSetState($nRadioOSFont, $GUI_CHECKED)
	Else
		GUICtrlSetState($nRadioOSFont, $GUI_UNCHECKED)
		GUICtrlSetState($nRadioFont, $GUI_CHECKED)
	EndIf
	
	$nChkIcons			= CreateCtrlCheck($sChkIcons, 25, 117, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bUseIniIcons Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	CreateCtrlLabel("", 0, 140, 405 - GetScaled($nSBSize, 2), 2, $SS_SUNKEN)	
		
	$nLblTrouble		= CreateCtrlLabel($sGrpTrouble & ":", 5, 148, 395 - $nSBSize, 16)
	$nIconDebug = CreateCtrlIcon("shell32.dll", -1, 5, 165, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 184, -8, "Icon70")

	Local $nX = GetScaled(25)
	Local $nH = GetScaled(18)
	
	$nChkDebug			= CreateCtrlCheck($sChkDebug, 25, 165, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bDebug Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nBtnDebug			= CreateODBtn($sBtnDebug, 160, 164, 220 - $nSBSize, 20, $arODBtnMain, 9)
	If Not $bDebug Then SetODBtnState($nBtnDebug, $GUI_DISABLE)
	
	$nBtnLogDel			= CreateODBtn("-", 379 - $nSBSize, 164, 20, 20, $arODBtnMain, 3, TRUE)
	GUICtrlSetTip(-1, $sBtnLogDel)
	
	CreateCtrlLabel("", 0, 190, 405 - GetScaled($nSBSize, 2), 2, $SS_SUNKEN)
	
	$nLblTrayOpt		= CreateCtrlLabel($sGrpTrayOptions & ":", 5, 198, 395 - $nSBSize, 18)
	
	$nIconStartTray = CreateCtrlIcon("shell32.dll", -1, 5, 215, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 233, -63, "Icon71")
	
	$nChkStartTray		= CreateCtrlCheck($sChkTrayStart, 25, 215, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bStartToTray Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nIconMinTray = CreateCtrlIcon("shell32.dll", -1, 5, 233, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 206, -38, "Icon72")

	$nChkMinTray		= CreateCtrlCheck($sChkTrayMin, 25, 233, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bMinToTray Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nIconCloseTray = CreateCtrlIcon("shell32.dll", -1, 5, 251, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 207, -39, "Icon73")
	
	$nChkEndTray		= CreateCtrlCheck($sChkTrayClose, 25, 251, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bCloseToTray Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nIconShowTrayAct = CreateCtrlIcon("shell32.dll", -1, 5, 270, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 208, -40, "Icon74")
	
	$nChkShowAct		= CreateCtrlCheck($sChkShowActivity, 25, 269, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bShowTrayAct Then GUICtrlSetState(-1, $GUI_CHECKED)
		
	$nIconShowTrayAlways = CreateCtrlIcon("shell32.dll", -1, 5, 288, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 161, -4, "")
	
	$nChkShowAlways		= CreateCtrlCheck($sChkShowAlways, 25, 287, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bShowTrayAlways Then GUICtrlSetState(-1, $GUI_CHECKED)
		
	$nIconTrayTip = CreateCtrlIcon("shell32.dll", -1, 5, 306, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 239, -69, "Icon75")
	
	$nChkShowTip		= CreateCtrlCheck($sChkShowTip, 25, 305, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bShowTrayTip Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nIconShowOnlyCon = CreateCtrlIcon("shell32.dll", -1, 5, 323, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 185, -9, "Icon83")
	
	$nChkShowOnlyCon	= CreateCtrlCheck($sChkShowOnlyCon, 25, 323, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bShowTrayOnlyCon Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nIconTrayLimitInfo = CreateCtrlIcon("shell32.dll", -1, 5, 341, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 288, -111, "Icon98")
	
	$nChkTrayLimitInfo	= CreateCtrlCheck($sChkTrayLimitInfo, 25, 341, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bTrayLimitInfo Then GUICtrlSetState(-1, $GUI_CHECKED)

	$nIconTrayAdaptWiFi = CreateCtrlIcon("shell32.dll", -1, 5, 359, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 289, -112, "Icon99")
	
	$nChkTrayAdaptWiFi	= CreateCtrlCheck($sChkTrayAdaptWiFi, 25, 359, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bTrayAdaptWiFi Then GUICtrlSetState(-1, $GUI_CHECKED)

	$nIconTrayShowMAC = CreateCtrlIcon("shell32.dll", -1, 5, 378, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 290, -113, "Icon100")
			
	$nChkTrayShowMAC	= CreateCtrlCheck($sChkTrayShowMAC, 25, 377, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bTrayShowMAC Then GUICtrlSetState(-1, $GUI_CHECKED)

	$nIconTrayShowIPv6 = CreateCtrlIcon("shell32.dll", -1, 5, 395, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 291, -114, "Icon101")
	
	$nChkTrayShowIPv6	= CreateCtrlCheck($sChkTrayShowIPv6, 25, 395, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bTrayShowIPv6 Then GUICtrlSetState(-1, $GUI_CHECKED)	
	
	CreateCtrlLabel("", 0, 417, 405 - GetScaled($nSBSize, 2), 2, $SS_SUNKEN)
	
	$nLblOtherOpt		= CreateCtrlLabel($sGrpOtherOptions & ":", 5, 424, 395 - $nSBSize, 18)
	
	$nIconLastPos = CreateCtrlIcon("shell32.dll", -1, 5, 442, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 242, -72, "Icon76")
	
	$nChkLastPos		= CreateCtrlCheck($sChkLastPos, 25, 442, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bSaveWinPos Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nIconLastPage = CreateCtrlIcon("shell32.dll", -1, 5, 460, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 240, -70, "Icon77")

	$nChkLastPage		= CreateCtrlCheck($sChkLastPage, 25, 460, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $bOpenPage Then GUICtrlSetState(-1, $GUI_CHECKED)
	
	$nLblLastPage		= CreateCtrlLabel($sLblLastPage & ":", 43, 482, 117, 18)
	
	$nComboLastPage = GUICtrlCreateDummy()
	$hComboLastPage = CreateWindowExW(0, "ComboBoxEx32", "", BitOr($WS_VISIBLE, $WS_CHILD, $WS_TABSTOP, $CBS_DROPDOWNLIST), _
							GetScaled(160), GetScaled(479), GetScaled(240) - GetScaled($nSBSize), GetScaled(136), $hOtherGUI, $nComboLastPage, 0, 0)
	SendMessage($hComboLastPage, $WM_SETFONT, $hGlobalFont, 1)
	
	$hILCombo = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	AddILIcon($hILCombo, -203, 35, "Icon0")		;  0 - Settings
	AddILIcon($hILCombo, 0, 59, "Icon1")			;  1 - Ident
	AddILIcon($hILCombo, -181, 6, "Icon2")		;  2 - Sharing
	AddILIcon($hILCombo, -188, 20, "Icon3")		;  3 - Netdrives
	AddILIcon($hILCombo, -227, 57, "Icon4")		;  4 - Profiles
	AddILIcon($hILCombo, -191, 23, "Icon5")		;  5 - Other
	AddILIcon($hILCombo, -182, 5, "Icon6")		;  6 - About
	AddILIcon($hILCombo, -195, 27, "Icon7")		;  7 - WiFi
	AddILIcon($hILCombo, -205, 37, "Icon9")		;  8 - Advanced
	AddILIcon($hILCombo, -217, 48, "Icon46")	;  9 - Favorite
	AddILIcon($hILCombo, -183, 7, "Icon58")		; 10 - Service
	
	SendMessage($hComboLastPage, $CBEM_SETIMAGELIST, 0, $hILCombo)
	FillPageList($hComboLastPage)
	
	$nIconWMI = CreateCtrlIcon("shell32.dll", -1, 5, 508, $nIconSizeSmall, $nIconSizeSmall)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 183, -7, "Icon78")
	
	$nChkUseWMI		= CreateCtrlCheck($sChkUseWMI, 25, 508, 378 - $nSBSize, 18, -1, -1, $hOtherGUI)
	If $oWMISrv = 0 Then
		GUICtrlSetState(-1, $GUI_DISABLE)
	Else
		If $bUseWMI Then GUICtrlSetState(-1, $GUI_CHECKED)
	EndIf
	
	Local $nMaxH = GetScaled(528) ; Last ctrl WMI chkbox 508y +18h +2space
	
	Local $stRect = DllStructCreate("long;long;long;long")
	GetWindowRect($hOtherGUI, DllStructGetPtr($stRect))
	Local $nH = DllStructGetData($stRect, 4) - DllStructGetData($stRect, 2)
	$stRect = 0
	
	Local $stSI = DllStructCreate($sSCROLLINFO)
	DllStructSetData($stSI, 1, DllStructGetSize($stSI))
	DllStructSetData($stSI, 2, BitOr($SIF_PAGE, $SIF_RANGE))
	DllStructSetData($stSI, 3, 0)
	DllStructSetData($stSI, 4, $nMaxH)
	DllStructSetData($stSI, 5, $nH)
	SetScrollInfo($hOtherGUI, $SB_VERT, DllStructGetPtr($stSI), FALSE)
	$arScrollInfo[0][0] = 0
	$arScrollInfo[0][1] = $nMaxH - $nH
	$stSI = 0
	
	ApplyCtrlColors(32)
	
	$bOtherCreated = TRUE
	
	GUISwitch($hMainGUI)
EndFunc


;**********************************************************************
; Fill the last page combo list with data
;**********************************************************************
Func FillPageList($hCtrl)
	Local $stText = DllStructCreate("wchar[" & $_MAX_PATH & "]")
	DllStructSetData($stText, 1, $sLblLastOpened)
	
	Local $stCBEXI = DllStructCreate($sCOMBOBOXEXITEM)
	DllStructSetData($stCBEXI, 1, $CBEIF_TEXT)
	DllStructSetData($stCBEXI, 2, -1)
	DllStructSetData($stCBEXI, 3, DllStructGetPtr($stText))
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIConfig)
	DllStructSetData($stCBEXI, 1, BitOr($CBEIF_TEXT, $CBEIF_IMAGE, $CBEIF_SELECTEDIMAGE))
	DllStructSetData($stCBEXI, 2, -1)
	DllStructSetData($stCBEXI, 3, DllStructGetPtr($stText))
	DllStructSetData($stCBEXI, 5, 0)
	DllStructSetData($stCBEXI, 6, 0)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))

	DllStructSetData($stText, 1, $sTIWiFi)
	DllStructSetData($stCBEXI, 1, BitOr($CBEIF_TEXT, $CBEIF_IMAGE, $CBEIF_SELECTEDIMAGE, $CBEIF_INDENT))
	DllStructSetData($stCBEXI, 5, 7)
	DllStructSetData($stCBEXI, 6, 7)
	DllStructSetData($stCBEXI, 8, 2)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))

	DllStructSetData($stText, 1, $sTIWiFiAvailable)
	DllStructSetData($stCBEXI, 8, 4)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIWiFiPreferred)
	DllStructSetData($stCBEXI, 5, 9)
	DllStructSetData($stCBEXI, 6, 9)
	DllStructSetData($stCBEXI, 8, 4)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIWiFiService)
	DllStructSetData($stCBEXI, 5, 10)
	DllStructSetData($stCBEXI, 6, 10)
	DllStructSetData($stCBEXI, 8, 4)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIAdvanced)
	DllStructSetData($stCBEXI, 5, 8)
	DllStructSetData($stCBEXI, 6, 8)
	DllStructSetData($stCBEXI, 8, 2)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))

	DllStructSetData($stText, 1, $sTIIdent)	
	DllStructSetData($stCBEXI, 1, BitOr($CBEIF_TEXT, $CBEIF_IMAGE, $CBEIF_SELECTEDIMAGE))
	DllStructSetData($stCBEXI, 5, 1)
	DllStructSetData($stCBEXI, 6, 1)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTISharing)
	DllStructSetData($stCBEXI, 5, 2)
	DllStructSetData($stCBEXI, 6, 2)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIDrives)
	DllStructSetData($stCBEXI, 5, 3)
	DllStructSetData($stCBEXI, 6, 3)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stCBEXI, 1, BitOr($CBEIF_TEXT, $CBEIF_IMAGE, $CBEIF_SELECTEDIMAGE, $CBEIF_INDENT))
	DllStructSetData($stText, 1, $sBtnDrvNet)
	DllStructSetData($stCBEXI, 5, 3)
	DllStructSetData($stCBEXI, 6, 3)
	DllStructSetData($stCBEXI, 8, 2)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIProfiles)
	DllStructSetData($stCBEXI, 1, BitOr($CBEIF_TEXT, $CBEIF_IMAGE, $CBEIF_SELECTEDIMAGE))
	DllStructSetData($stCBEXI, 5, 4)
	DllStructSetData($stCBEXI, 6, 4)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIOther)
	DllStructSetData($stCBEXI, 5, 5)
	DllStructSetData($stCBEXI, 6, 5)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))
	
	DllStructSetData($stText, 1, $sTIAbout)
	DllStructSetData($stCBEXI, 5, 6)
	DllStructSetData($stCBEXI, 6, 6)
	SendMessage($hCtrl, $CBEM_INSERTITEMW, 0, DllStructGetPtr($stCBEXI))

	If $bOpenLastPage Then
		SendMessage($hCtrl, $CB_SETCURSEL, 0, 0)
	Else
		SendMessage($hCtrl, $CB_SETCURSEL, RegRead($sGURegKey, "LastPage"), 0)
	EndIf
EndFunc


;**********************************************************************
; Choose font
;**********************************************************************
Func ShowFontDialog($sFont)
	Local $stLogFont = DllStructCreate($sLOGFONTW)
	DllStructSetData($stLogFont, 1, -11)
	DllStructSetData($stLogFont, 2, 0)
	DllStructSetData($stLogFont, 3, 0)
	DllStructSetData($stLogFont, 4, 0)
	DllStructSetData($stLogFont, 5, 400) ; Weight
	DllStructSetData($stLogFont, 6, 0)
	DllStructSetData($stLogFont, 7, 0)
	DllStructSetData($stLogFont, 8, 0)
	DllStructSetData($stLogFont, 9, 1) ; DEFAULT_CHARSET
	DllStructSetData($stLogFont, 10, 0)
	DllStructSetData($stLogFont, 11, 0)
	DllStructSetData($stLogFont, 12, 0)
	DllStructSetData($stLogFont, 13, 0)
	DllStructSetData($stLogFont, 14, $sFont)
	
	Local $stFont = DllStructCreate($sCHOOSEFONT)
	DllStructSetData($stFont, 1, DllStructGetSize($stFont))
	DllStructSetData($stFont, 2, $hMainGUI)
	DllStructSetData($stFont, 4, DllStructGetPtr($stLogFont))
	DllStructSetData($stFont, 6, BitOr(0x00000001, 0x00000040, 0x00001000, 0x00002000, 0x00800000, 0x01000000))
	DllStructSetData($stFont, 14, 8)
	DllStructSetData($stFont, 15, 10)
	; CF_SCREENFONTS, CF_INITTOLOGFONTSTRUCT, CF_NOSIMULATIONS, CF_LIMITSIZE, CF_NOSCRIPTSEL, CF_NOVERTFONTS
	
	Local $nResult = DllCall("comdlg32.dll", "int", "ChooseFontW", _
													"long_ptr", DllStructGetPtr($stFont))
													
	If $nResult[0] Then GUICtrlSetData($nInpFont, DllStructGetData($stLogFont, 14))
EndFunc


;**********************************************************************
; Toggle Cmd ctrls enabled/disabled
;**********************************************************************
Func ToggleCmdCtrls($bEnable, $bSwitch = TRUE)
	If $bEnable Then
		GUICtrlSetState($nComboCMDIPChg, $GUI_ENABLE)
		GUICtrlSetState($nComboRunChgNumber, $GUI_ENABLE)
		GUICtrlSetState($nComboRunChgMode, $GUI_ENABLE)
		GUICtrlSetState($nComboRunChgWait, $GUI_ENABLE)
		SetODBtnState($nBtnCmdChgAdd, $GUI_ENABLE, $bSwitch)
		SetODBtnState($nBtnCmdChgDel, $GUI_ENABLE, $bSwitch)
	Else
		GUICtrlSetState($nComboCMDIPChg, $GUI_DISABLE)
		GUICtrlSetState($nComboRunChgNumber, $GUI_DISABLE)
		GUICtrlSetState($nComboRunChgMode, $GUI_DISABLE)
		GUICtrlSetState($nComboRunChgWait, $GUI_DISABLE)
		SetODBtnState($nBtnCmdChgAdd, $GUI_DISABLE, $bSwitch)
		SetODBtnState($nBtnCmdChgDel, $GUI_DISABLE, $bSwitch)
	EndIf
EndFunc


;**********************************************************************
; CreateAboutGUI()
;**********************************************************************
Func CreateAboutGUI()
	GUISwitch($hAboutGUI)
	
	$bAboutCreated = TRUE
	
	$nIconAbout = CreateCtrlIcon(@AutoItExe, 0, 15, 18, $nIconSizeBig, $nIconSizeBig)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 0, -4, "", FALSE)
		
	$nLblAbout		= CreateCtrlLabel($sMainTitle, 60, 25, 340, 20)
	GUICtrlSetFont(-1, 10, 600, 0, $sGlobalFont)
	
	Local $nW = GetTextSize($hAboutGUI, "2018 Holger Kotsch")
	$nLblAboutAuthor	= CreateCtrlLabel("2018 Holger Kotsch", 60, 50, GetScaled($nW, 2), 20)
	GUICtrlSetTip(-1, $sUrlHome)
	$hLblAboutAuthor = GUICtrlGethandle($nLblAboutAuthor)
	
	CreateCtrlLabel("", 0, 80, 405, 2, $SS_SUNKEN)
	
	$nW = GetTextSize($hAboutGUI, $sLblAboutAI3)
	$nLblAboutAI3	= CreateCtrlLabel($sLblAboutAI3, 340 - GetScaled($nW, 2), 105, GetScaled($nW, 2), 20)
	GUICtrlSetTip(-1, $sUrlAI3)
	$hLblAboutAI3 = GUICtrlGethandle($nLblAboutAI3)
	
	$nIconAboutAI3 = CreateCtrlIcon(@AutoItExe, 0, 355, 97, $nIconSizeBig, $nIconSizeBig)
	GUICtrlSetStyle(-1, BitOr($SS_ICON, $SS_NOTIFY))
	SetIconFrom(-1, 180, -3, "", FALSE)
	
	CreateCtrlLabel("", 0, 145, 405, 2, $SS_SUNKEN)
	
	ApplyCtrlColors(64)
	
	GUISwitch($hMainGUI)
EndFunc


;**********************************************************************
; Show dhcp info message
;**********************************************************************
Func ShowDHCPInfo($sDesc)
	Local $stReqSize = DllStructCreate("ulong")
	DllStructSetData($stReqSize, 1, 0)
	
	Local $bIPv4
	Local $nFlags = 0
	If $bIsVista Then $nFlags = BitOr($GAA_FLAG_INCLUDE_WINS_INFO, $GAA_FLAG_INCLUDE_GATEWAYS, $GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER)
	
	Local $stIP_ADAPTER_ADDRESSES = DllStructCreate($sIP_ADAPTER_ADDRESSES)
	If GetAdaptersAddresses(0, $nFlags, 0, DllStructGetPtr($stIP_ADAPTER_ADDRESSES), DllStructGetPtr($stReqSize), FALSE) = -1 Then
		$stIP_ADAPTER_ADDRESSES = 0
		Return
	EndIf
	
	Local $sFriendly		= ""
	Local $sMAC				= ""
	Local $sIP				= ""
	Local $sSM				= ""
	Local $sDG				= ""
	Local $sDNS 			= ""
	Local $sWINS			= ""
	Local $sIP6				= ""
	Local $sSM6				= ""
	Local $sDG6				= ""
	Local $sDNS6			= ""
	Local $sDHCPSrv			= ""
	Local $nDHCP6IAID		= 0
	Local $sDHCP6DUID		= ""
	Local $nLeaseObt		= 0
	Local $nLeaseExp		= 0
	Local $bNetBiosEnabled = -1
	Local $pAddr
	
	Local $stBuffer = DllStructCreate("byte[" & DllStructGetData($stReqSize, 1) & "]")
	
	If GetAdaptersAddresses(0, $nFlags, 0, DllStructGetPtr($stBuffer), DllStructGetPtr($stReqSize), FALSE) = $ERROR_SUCCESS Then
		Local $stWSAData	= DllStructCreate($sWSADATA)
		WSAStartup(0x0101, DllStructGetPtr($stWSAData))
		
		Local $pIPAA = DllStructGetPtr($stBuffer)
		Local $stDesc
		
		While $pIPAA
			$stIP_ADAPTER_ADDRESSES	= DllStructCreate($sIP_ADAPTER_ADDRESSES, $pIPAA)
			$stDesc = DllStructCreate("wchar[" & ($MAX_ADAPTER_DESCRIPTION_LENGTH + 4) & "]", DllStructGetData($stIP_ADAPTER_ADDRESSES, 10))
			If $sDesc = DllStructGetData($stDesc, 1) Then ; Adapter found
				If $bIsVista Then
					If BitAnd(DllStructGetData($stIP_ADAPTER_ADDRESSES, 14), 0x0040) Then ; IP_ADAPTER_NETBIOS_OVER_TCPIP_ENABLED
						$bNetBiosEnabled = TRUE
					Else
						$bNetBiosEnabled = FALSE
					EndIf
					
					If DllStructGetData($stIP_ADAPTER_ADDRESSES, 41) <> 0 Then $nDHCP6IAID = DllStructGetData($stIP_ADAPTER_ADDRESSES, 41)
				EndIf
				
				$sFriendly = ""
				If DllStructGetData($stIP_ADAPTER_ADDRESSES, 11) <> 0 Then
					$stFriendly = DllStructCreate("wchar[" & ($MAX_ADAPTER_DESCRIPTION_LENGTH + 4) & "]", DllStructGetData($stIP_ADAPTER_ADDRESSES, 11))
					$sFriendly = DllStructGetData($stFriendly, 1)
				Else
					$sFriendly = $sDesc
				EndIf
						
				$sMAC	= ""
				For $c = 1 To DllStructGetData($stIP_ADAPTER_ADDRESSES, 13)
					$sMAC &= Hex(DllStructGetData($stIP_ADAPTER_ADDRESSES, 12, $c), 2) & "-"
				Next
				If StringRight($sMAC, 1) = "-" Then $sMAC = StringTrimRight($sMAC, 1)			
				
				If DllStructGetData($stIP_ADAPTER_ADDRESSES, 5) <> 0 Then ; Pointer to unicast address valid
					$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 5)
					
					While 1
						$stAddr = DllStructCreate($sIP_ADAPTER_UNICAST_ADDRESS, $pAddr)
						If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
							$bIPv4 = FALSE
							$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
							If $bIPv4 Then
								If $bIsVista Then
									$sIP = $sIP & $sAddr & @Tab
									If DllStructGetData($stAddr, 12) > 0 Then ; mask
										$stMask = DllStructCreate("ulong")
										ConvertLengthToIpv4Mask(DllStructGetData($stAddr, 12), DllStructGetPtr($stMask))
										$pMaskAddr = inet_ntoa(DllStructGetData($stMask, 1))
										$stMaskAddr = DllStructCreate("char[16]", $pMaskAddr)
										$sSM = $sSM & DllStructGetData($stMaskAddr, 1) & @Tab
										$stMask = 0
										$stMaskAddr = 0
									Else
										$sSM = $sSM & "" & @Tab
									EndIf
								EndIf
							Else
								$sIP6 = $sIP6 & $sAddr & @Tab
								If $bIsVista And DllStructGetData($stAddr, 12) > 0 Then 
									$sSM6 = $sSM6 & DllStructGetData($stAddr, 12) & @Tab ; mask
								Else
									$sSM6 = $sSM6 & "" & @Tab
								EndIf
							EndIf
						EndIf															
						
						$pAddr = DllStructGetData($stAddr, 3)
						$stAddr = 0								
						If $pAddr = 0 Then ExitLoop								
					WEnd
				EndIf
				
				If StringRight($sIP, 1) = @Tab Then $sIP = StringTrimRight($sIP, 1)
				If StringRight($sSM, 1) = @Tab Then $sSM = StringTrimRight($sSM, 1)
				If StringRight($sIP6, 1) = @Tab Then $sIP6 = StringTrimRight($sIP6, 1)
				If StringRight($sSM6, 1) = @Tab Then $sSM6 = StringTrimRight($sSM6, 1)
			
				$stAddr = 0
				
				If DllStructGetData($stIP_ADAPTER_ADDRESSES, 8) <> 0 Then ; Pointer to DNS address valid
					$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 8)
					
					While 1
						$stAddr = DllStructCreate($sIP_ADAPTER_DNS_SERVER_ADDRESS, $pAddr)
						If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
							$bIPv4 = FALSE
							$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
							If $bIPv4 Then
								$sDNS = $sDNS & $sAddr & @Tab
							Else
								$sDNS6 = $sDNS6 & $sAddr & @Tab
							EndIf
						EndIf															
						
						$pAddr = DllStructGetData($stAddr, 3)
						$stAddr = 0								
						If $pAddr = 0 Then ExitLoop								
					WEnd
				EndIf
				
				If StringRight($sDNS, 1) = @Tab Then $sDNS = StringTrimRight($sDNS, 1)
				If StringRight($sDNS6, 1) = @Tab Then $sDNS6 = StringTrimRight($sDNS6, 1)
								
				$stAddr = 0
				
				If $bIsVista Then
					$sDG = ""
					$sDG6 = ""					
					If DllStructGetData($stIP_ADAPTER_ADDRESSES, 24) <> 0 Then ; Pointer to gateway address valid
						$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 24)
						
						While 1
							$stAddr = DllStructCreate($sIP_ADAPTER_DNS_SERVER_ADDRESS, $pAddr)
							If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
								$bIPv4 = FALSE
								$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
								If $bIPv4 Then
									$sDG = $sDG & $sAddr & @Tab
								Else
									$sDG6 = $sDG6 & $sAddr & @Tab
								EndIf
							EndIf															
							
							$pAddr = DllStructGetData($stAddr, 3)
							$stAddr = 0								
							If $pAddr = 0 Then ExitLoop								
						WEnd
					EndIf
					If $sDG <> "" And StringRight($sDG, 1) = @Tab Then $sDG = StringTrimRight($sDG, 1)
					If $sDG6 <> "" And StringRight($sDG6, 1) = @Tab Then $sDG6 = StringTrimRight($sDG6, 1)
					
					$stAddr = 0
					
					$sWINS = ""					
					If DllStructGetData($stIP_ADAPTER_ADDRESSES, 23) <> 0 Then ; Pointer to DNS address valid
						$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 23)
						
						While 1
							$stAddr = DllStructCreate($sIP_ADAPTER_DNS_SERVER_ADDRESS, $pAddr)
							If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
								$bIPv4 = FALSE
								$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
								If $bIPv4 Then $sWINS = $sWINS & $sAddr & @Tab
							EndIf															
							
							$pAddr = DllStructGetData($stAddr, 3)
							$stAddr = 0								
							If $pAddr = 0 Then ExitLoop								
						WEnd
					EndIf
					If $sWINS <> "" And StringRight($sWINS, 1) = @Tab Then $sWINS = StringTrimRight($sWINS, 1)
					
					$stAddr = 0
				EndIf
				
				ExitLoop
			EndIf
			
			$pIPAA = DllStructGetData($stIP_ADAPTER_ADDRESSES, 3)
			$stIP_ADAPTER_ADDRESSES = 0
		WEnd
		
		WSACleanup()	
	EndIf
	
	$stIP_ADAPTER_ADDRESSES = 0
	$stBuffer = 0	
	
	
	DllStructSetData($stReqSize, 1, 0)
	
	Local $stIP_ADAPTER_INFO = DllStructCreate($sIP_ADAPTER_INFO)
	If GetAdaptersInfo(DllStructGetPtr($stIP_ADAPTER_INFO), DllStructGetPtr($stReqSize)) = -1 Then
		$stIP_ADAPTER_INFO = 0
		Return
	EndIf
	
	$stBuffer = DllStructCreate("byte[" & DllStructGetData($stReqSize, 1) & "]")
	
	If GetAdaptersInfo(DllStructGetPtr($stBuffer), DllStructGetPtr($stReqSize)) = $ERROR_SUCCESS Then	
		Local $pIPAI = DllStructGetPtr($stBuffer)
		
		While $pIPAI
			$stIP_ADAPTER_INFO = DllStructCreate($sIP_ADAPTER_INFO, $pIPAI)
			If $sDesc = DllStructGetData($stIP_ADAPTER_INFO, 4) Then ; Adapter found
				; DG/WINS only XP needed
				If Not $bIsVista Then
					$stAddr = DllStructCreate($sIP_ADDR_STRING)
					DllStructSetData($stAddr, 1, DllStructGetData($stIP_ADAPTER_INFO, 15))
					DllStructSetData($stAddr, 2, DllStructGetData($stIP_ADAPTER_INFO, 16))
					DllStructSetData($stAddr, 3, DllStructGetData($stIP_ADAPTER_INFO, 17))
					DllStructSetData($stAddr, 4, DllStructGetData($stIP_ADAPTER_INFO, 18))
					
					While 1
						$sDG = $sDG & DllStructGetData($stAddr, 2) & @Tab
						
						$pAddr = DllStructGetData($stAddr, 1)
						If $pAddr = 0 Then
							ExitLoop
						Else
							$stAddr = 0
							$stAddr = DllStructCreate($sIP_ADDR_STRING, $pAddr)
						EndIf
					WEnd
					
					$stAddr = 0
					
					If StringRight($sDG, 1) = @Tab Then $sDG = StringTrimRight($sDG, 1)
				
					 ; WINS
					If DllStructGetData($stIP_ADAPTER_INFO, 23) Then
						If DllStructGetData($stIP_ADAPTER_INFO, 25) <> "" Then $sWINS &= DllStructGetData($stIP_ADAPTER_INFO, 25) & @Tab
						If DllStructGetData($stIP_ADAPTER_INFO, 29) <> "" Then $sWINS &= DllStructGetData($stIP_ADAPTER_INFO, 29) & @Tab
					EndIf
			
					If StringRight($sWINS, 1) = @Tab Then $sWINS = StringTrimRight($sWINS, 1)
				EndIf
				
				; DHCP server 
				If DllStructGetData($stIP_ADAPTER_INFO, 20) <> "" Then $sDHCPSrv &= DllStructGetData($stIP_ADAPTER_INFO, 20)
				
				; Lease time
				$nLeaseObt = DllStructGetData($stIP_ADAPTER_INFO, 32)
				$nLeaseExp = DllStructGetData($stIP_ADAPTER_INFO, 33)
				
				ExitLoop
			EndIf
		
			$pIPAI = DllStructGetData($stIP_ADAPTER_INFO, 1)		
		WEnd
	EndIf
	
	$stIP_ADAPTER_INFO	= 0
	$stBuffer = 0
	
	Local $arPos	= WinGetPos($hMainGUI)
	
	$hSubGUI		= CreateGUI($sTTNetConDetails, 393, 330, -1, -1, BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
									BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hMainGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hSubGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	
	If $bIconLib Then
		GUISetIcon($sIconLib, -4)
	Else
		SetWindowIcon($hSubGUI, @AutoItExe, 161)
	EndIf
	
	$nLVNetConDet	= CreateCtrlListView($sLVNetConPropVal, 5, 5, 383, 290, _
							BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_NOSORTHEADER))
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_GRIDLINES, $LVS_EX_GRIDLINES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_LABELTIP, $LVS_EX_LABELTIP)
	
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(150))
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(210))
	
	GUICtrlSetColor($nLVNetConDet, $nClrLProfileTxt)
	GUICtrlSetBkColor($nLVNetConDet, $nClrLProfileBk)
	
	CreateAdvLVItem($sLblDHCPAdapter & @Tab & $sDesc, $nLVNetConDet, @Tab, -1, FALSE)
	If $sMAC <> "" Then CreateAdvLVItem($sLblAdapterMAC & @Tab & $sMAC, $nLVNetConDet, @Tab, -1, FALSE)
	If $sIP <> "" Then CreateAdvLVItem($sLblStaticIP & @Tab & $sIP, $nLVNetConDet, @Tab, -1, FALSE)
	If $sSM <> "" Then CreateAdvLVItem($sLblStaticSM & @Tab & $sSM, $nLVNetConDet, @Tab, -1, FALSE)
	
	Local $arSplit
	
	If $sDG <> "" Then
		$arSplit = StringSplit($sDG, @Tab)
		For $c = 1 To $arSplit[0]
			If $c = 1 Then
				CreateAdvLVItem($sLblStaticDG & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			Else
				CreateAdvLVItem(" " & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			EndIf
		Next
	EndIf

	If $nLeaseObt <> 0 Then CreateAdvLVItem($sLblDHCPLTO & @Tab & ConvertTime($nLeaseObt), $nLVNetConDet, @Tab, -1, FALSE)
	If $nLeaseExp <> 0 Then CreateAdvLVItem($sLblDHCPLTE & @Tab & ConvertTime($nLeaseExp), $nLVNetConDet, @Tab, -1, FALSE)
	If $sDHCPSrv <> "" Then CreateAdvLVItem($sLblDHCPSrv & @Tab & $sDHCPSrv, $nLVNetConDet, @Tab, -1, FALSE)
	
	If $sDNS <> "" Then
		$arSplit = StringSplit($sDNS, @Tab)
		For $c = 1 To $arSplit[0]
			If $c = 1 Then
				CreateAdvLVItem($sLblDHCPDNSSrv & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			Else
				CreateAdvLVItem(" " & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			EndIf
		Next
	EndIf
	
	If $sWINS <> "" Then
		$arSplit = StringSplit($sWINS, @Tab)
		For $c = 1 To $arSplit[0]
			If $c = 1 Then
				CreateAdvLVItem($sLblDHCPWINSSrv & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			Else
				CreateAdvLVItem(" " & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			EndIf
		Next
	EndIf
	
	If $bIsVista Then
		If $bNetBiosEnabled Then
			CreateAdvLVItem($sLblNetbiosEnabled & @Tab & $sLblYes, $nLVNetConDet, @Tab, -1, FALSE)
		Else
			CreateAdvLVItem($sLblNetbiosEnabled & @Tab & $sLblNo, $nLVNetConDet, @Tab, -1, FALSE)
		EndIf
	EndIf
	
	If $sIP6 <> "" Then
		$arSplit = StringSplit($sIP6, @Tab)
		Local $arSplit2 = StringSplit($sSM6, @Tab)
		For $c = 1 To $arSplit[0]
			If $c = 1 Then
				If $arSplit2[$c] <> "" Then
					CreateAdvLVItem($sLblStaticIP & " v6" & @Tab & $arSplit[$c] & "/" & $arSplit2[$c], $nLVNetConDet, @Tab, -1, FALSE)
				Else
					CreateAdvLVItem($sLblStaticIP & " v6" & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
				EndIf
			Else
				If $arSplit2[$c] <> "" Then
					CreateAdvLVItem(" " & @Tab & $arSplit[$c] & "/" & $arSplit2[$c], $nLVNetConDet, @Tab, -1, FALSE)
				Else
					CreateAdvLVItem(" " & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
				EndIf
			EndIf
		Next
	EndIf
	
	If $sDG6 <> "" Then
		$arSplit = StringSplit($sDG6, @Tab)
		For $c = 1 To $arSplit[0]
			If $c = 1 Then
				CreateAdvLVItem($sLblStaticDG & " v6" & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			Else
				CreateAdvLVItem(" " & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			EndIf
		Next
	EndIf
	
	If $sDNS6 <> "" Then
		$arSplit = StringSplit($sDNS6, @Tab)
		For $c = 1 To $arSplit[0]
			If $c = 1 Then
				CreateAdvLVItem($sLblDHCPDNSSrv & " v6" & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			Else
				CreateAdvLVItem(" " & @Tab & $arSplit[$c], $nLVNetConDet, @Tab, -1, FALSE)
			EndIf
		Next
	EndIf
	
	If $nDHCP6IAID <> 0 Then CreateAdvLVItem("DHCP v6 IAID " & @Tab & $nDHCP6IAID, $nLVNetConDet, @Tab, -1, FALSE)	
	
	$nBtnSubOK	= CreateODBtn($sBtnOK, 156, 302, 80, 22, $arODBtnSub)
	SetODBtnState($nBtnSubOK, $GUI_FOCUS)
					
	If IsArray($arPos) Then
		Local $nX = GetScaled(135)
		If $bTabSmall Then $nX = GetScaled(32)
		WinMove($hSubGUI, "", $arPos[0] + $nX, $arPos[1] + GetScaled(80))
	EndIf

	GUISetState()
EndFunc
	

;**********************************************************************
; Copy DHCP details into clipboard
;**********************************************************************
Func DHCPInfos2Clip($bGetAll = FALSE)
	If $hLastGUI <> $hConfGUI Then Return
	If $hLastConfGUI <> $hConfIPGUI Then Return
	
	Local $i = 1
	
	If $bGetAll = FALSE Then
		Local $sDesc = GUICtrlRead($nComboNA)
		If $sDesc = "" Then Return
		$i = GetNetAdapterIndex($sDesc)
		If $i = 0 Then Return
	EndIf
	
	Local $nState = 0
	Local $nSpeed = 0
	Local $sMAC = ""
	Local $sText = ""
	Local $c, $sIP, $sSM, $sDG, $sDNS, $sWINS, $sTmp
	
	While 1
		GetNetInterfaceInfos($arNAList[$i][0], $nState, $nSpeed, $sMAC)
		
		$sText = $sText & $sLblDHCPAdapter & ": " & $arNAList[$i][0] & @CRLF
		$sText = $sText & "MAC: " & $sMAC & @CRLF
		
		If $bUseWMI Then
			$oConfigs	= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
			
			For $oConfItem In $oConfigs
				$oConf = $oConfItem
			Next
		EndIf	
		
		; DHCP state / IP address
		Local $bDHCP = GetAdapterProperty($arNAList[$i][1], 0, $oConf)
		If $bDHCP Then
			$sIP = GetAdapterProperty($arNAList[$i][1], 6, $oConf)
		Else
			$sIP = GetAdapterProperty($arNAList[$i][1], 1, $oConf)
		EndIf
		
		$sText = $sText & $sLblStaticIP & ": "
		
		If StringInStr($sIP, @LF) Then
			$arLine = StringSplit($sIP, @LF)
			For $c = 1 To $arLine[0]
				If $arLine[$c] <> "" Then
					If $c = $arLine[0] Then
						$sText = $sText & $arLine[$c] & @CRLF
					Else
						$sText = $sText & $arLine[$c] & ", "
					EndIf
				EndIf
			Next
		Else
			$sText = $sText & $sIP & @CRLF 
		EndIf
		
		; Subnet mask
		$sText = $sText & $sLblStaticSM & ": "
		
		If $bDHCP Then
			$sSM = GetAdapterProperty($arNAList[$i][1], 7, $oConf)
		Else
			$sSM = GetAdapterProperty($arNAList[$i][1], 2, $oConf)
		EndIf
		
		If StringInStr($sSM, @LF) Then
			$arLine = StringSplit($sSM, @LF)
			For $c = 1 To $arLine[0]
				If $arLine[$c] <> "" Then
					If $c = $arLine[0] Then
						$sText = $sText & $arLine[$c] & @CRLF
					Else
						$sText = $sText & $arLine[$c] & ", "
					EndIf
				EndIf
			Next
		Else
			$sText = $sText & $sSM & @CRLF 
		EndIf
		
		; Default gateway
		$sText = $sText & $sLblStaticDG & ": "
		
		$sDG = GetAdapterProperty($arNAList[$i][1], 3, $oConf)
		If $bDHCP Then $sDG = GetAdapterProperty($arNAList[$i][1], 8, $oConf)
		
		If $sDG = "" Then
			$sText = $sText & @CRLF
		Else
			If StringInStr($sDG, @LF) Then
				$arLine = StringSplit($sDG, @LF)
				For $c = 1 To $arLine[0]
					If $arLine[$c] <> "" Then
						If $c = $arLine[0] Then
							$sText = $sText & $arLine[$c] & @CRLF
						Else
							$sText = $sText & $arLine[$c] & ", "
						EndIf							
					EndIf					
				Next
			Else
				$sText = $sText & $sDG & @CRLF
			EndIf
		EndIf
		
		; DHSP server / IP lease
		If $bDHCP Then 
			$sText = $sText & $sLblDHCPSrv & ": " & GetAdapterProperty($arNAList[$i][1], 11, $oConf) & @CRLF
			$sText = $sText & $sLblDHCPLTO & ": " & ConvertTime(GetAdapterProperty($arNAList[$i][1], 12, $oConf)) & @CRLF
			$sText = $sText & $sLblDHCPLTE & ": " & ConvertTime(GetAdapterProperty($arNAList[$i][1], 13, $oConf)) & @CRLF
		EndIf
		
		; DNS server
		$sText = $sText & $sLblDHCPDNSSrv & ": "
		
		$sDNS = GetAdapterProperty($arNAList[$i][1], 9, $oConf)
		$sTmp = GetAdapterProperty($arNAList[$i][1], 4, $oConf)
		If $sTmp <> "" Then $sDNS = $sTmp
		
		If $sDNS = "" Then
			$sText = $sText & @CRLF	
		Else
			If StringInStr($sDNS, ",") Then
				$arLine = StringSplit($sDNS, ",")
			Else
				$arLine = StringSplit($sDNS, " ")
			EndIf
				
			If $arLine[0] > 1 Then
				For $c = 1 To $arLine[0]
					If $arLine[$c] <> "" Then
						If $c = $arLine[0] Then
							$sText = $sText & $arLine[$c] & @CRLF
						Else
							$sText = $sText & $arLine[$c] & ", "
						EndIf
					EndIf					
				Next
			Else
				$sText = $sText & $sDNS & @CRLF
			EndIf
		EndIf
		
		; WINS server
		$sText = $sText & $sLblDHCPWINSSrv & ": "
		
		$sWINS = GetAdapterProperty($arNAList[$i][1], 10, $oConf)
		$sTmp = GetAdapterProperty($arNAList[$i][1], 5, $oConf)
		If $sTmp <> "" Then $sWINS = $sTmp
		
		If $sWINS = "" Then
			$sText = $sText & @CRLF	
		Else
			If StringInStr($sWINS, @LF) Then
				$arLine = StringSplit($sWINS, @LF)
				For $c = 1 To $arLine[0]
					If $arLine[$c] <> "" Then
						If $c = $arLine[0] Then
							$sText = $sText & $arLine[$c]
						Else
							$sText = $sText & $arLine[$c] & ", "
						EndIf
					EndIf
				Next
			Else
				$sText = $sText & $sWINS
			EndIf
			
			$sText = $sText & @CRLF
		EndIf
		
		If $bGetAll = FALSE Then
			ExitLoop
		Else
			If $i < $arNAList[0][0] Then $sText = $sText & @CRLF
		EndIf
		
		$i += 1
		
		If $i > $arNAList[0][0] Then ExitLoop		
	WEnd
	
	ClipPut($sText)
EndFunc


;**********************************************************************
; Change adapter MAC address GUI
;**********************************************************************
Func ShowChangeMAC($sDesc)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $nAdapterState	= -1
	Local $nAdapterSpeed	= 0
	Local $sAdapterMAC		= ""
	
	If GetNetInterfaceInfos($sDesc, $nAdapterState, $nAdapterSpeed, $sAdapterMAC) <> $NO_ERROR Then Return 0
	
	Local $arPos	= WinGetPos($hMainGUI)
	
	$hSubGUI		= CreateGUI($sTChangeMAC, 350, 85, -1, -1, BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
									BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hMainGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hSubGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBk)
	
	If $bIconLib Then
		GUISetIcon($sIconLib, 35)
	Else
		GUISetIcon(@AutoItExe, 203)
	EndIf
	
	$nLblCurMAC		= CreateCtrlLabel($sLblCurMac & ":", 5, 6, 120, 20)
	$nInpCurMAC		= CreateCtrlInput($sAdapterMAC, 130, 5, 215, 18, $ES_READONLY)
	$hInpCurMAC		= GUICtrlGetHandle($nInpCurMAC)
	
	$nLblNewMAC		= CreateCtrlLabel($sLblNewMac & ":", 5, 31, 120, 20)
	$nInpNewMAC		= CreateCtrlInput("", 130, 30, 215, 18, BitOr($ES_AUTOHSCROLL, $ES_UPPERCASE))
	GUICtrlSetLimit(-1, 17)
	
	$nBtnMACRestore	= CreateODBtn($sBtnRestore, 5, 55, 110, 25, $arODBtnSub, 7)
	$nBtnMACApply	= CreateODBtn($sBtnApply, 120, 55, 110, 25, $arODBtnSub, 4)
	$nBtnMACCancel	= CreateODBtn($sBtnCancel, 235, 55, 110, 25, $arODBtnSub, 3)
	
	If IsArray($arPos) Then
		Local $nX = GetScaled(155)
		If $bTabSmall Then $nX = GetScaled(50)
		WinMove($hSubGUI, "", $arPos[0] + $nX, $arPos[1] + GetScaled(115))
	EndIf
	
	ApplyCtrlColors(1024)
	
	GUISetState()
	
	Return 1
EndFunc


;**********************************************************************
; Writes new MAC to the registry and restarts device
;**********************************************************************
Func ApplyNewMAC($sDesc, $sNewMAC, $bDelMAC = FALSE)
	Debug("IN: ApplyNewMAC: " & $sDesc)

	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $sService			= $arNAList[$i][1]
	Local $nAdapterState	= -1
	Local $nAdapterSpeed	= 0
	Local $sAdapterMAC		= ""
	
	If Not $bDelMAC Then
		If GetNetInterfaceInfos($sDesc, $nAdapterState, $nAdapterSpeed, $sAdapterMAC) <> $NO_ERROR Then Return
		If $sAdapterMAC = $sNewMAC Then Return
		$sNewMAC = StringReplace($sNewMAC, "-", "")
	EndIf

	If GetAdapterProperty($sService, 17) <> $sNewMAC Then
		If SetAdapterProperty($sService, 17, $sNewMAC) Then
			If $bUseWMI And $bIsVista Then
				Local $oConf		= 0	
				Local $oConfigs		= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapter Where Description = """ & $arNAList[$i][2] & """")
				Local $oConfItem	= 0
				For $oConfItem In $oConfigs
					$oConf = $oConfItem
				Next
						
				$oConf.Disable
				$oConf.Enable					
						
				Sleep(2500)
			Else
				RestartNetDevice($sDesc)
			EndIf
			
			RefreshAdapterList()
			
			$i = GetExtNameIdx("NetworkAddress")			
			SetExtVal($sDesc, $arExtVal[$i][4], $sNewMAC)
			If GUICtrlRead($nListExtProp) = $arExtVal[$i][4] Then _
	    		GetExtVal($sDesc, $arExtVal[$i][4], $sNewMAC)
		EndIf
	EndIf	
EndFunc


;**********************************************************************
; Delete tray info resources
;**********************************************************************
Func DeleteTrayInfo()
	Local $i
	
	For $i = 1 To $arStatic[0]
		If $arStatic[$i] <> 0 Then 
			Local $hIcon = SendMessage($arStatic[$i], $STM_GETICON, 0, 0)
			If $hIcon <> 0 Then DestroyIcon($hIcon)
		EndIf
	Next
	
	$arStatic[0] = 0
	GUIDelete($hTrayGUI)
	GUIDelete($hTraySubGUI)
	$hTrayGUI = 0
	$hTraySubGUI = 0
EndFunc


;**********************************************************************
; Show some more informationen as/in tray window
;**********************************************************************
Func ShowTrayInfo()
	If $hTrayGUI <> 0 Then
		DeleteTrayInfo()
		Return
	EndIf
	
	Debug("IN: ShowTrayInfo")
	
	$bTrayWndCreating = TRUE
	
	$arStatic[0] = 0
		
	Local $arPos = WinGetPos("[CLASS:Shell_TrayWnd]")
	If Not IsArray($arPos) Then Return
	
	Local $nMaxDeskH = @Desktopheight
	If $arPos[2] > $arPos[3] Then $nMaxDeskH = @Desktopheight - $arPos[3]

	Local $nW = GetScaled(100), $nH = $nIconSizeBig + 10, $nX = 0, $nY = 0
	
	Local $nMaxH = $nMaxDeskH
	If $bTrayLimitInfo Then
		If $nTrayInfoHeight > $nH And $nTrayInfoHeight <= $nMaxDeskH Then
			$nMaxH = $nTrayInfoHeight
		Else
			$nMaxH = Int($nMaxDeskH / 2)
		EndIf
	EndIf
	
	If $hTrayGUI = 0 Then
		$nTrayCurScrollPos = 0
		
		Local $stIP_ADAPTER_ADDRESSES = DllStructCreate($sIP_ADAPTER_ADDRESSES)
		Local $stReqSizeIAA = DllStructCreate("dword")
		DllStructSetData($stReqSizeIAA, 1, 0)
		
		Local $nFlags = 0
		If $bIsVista Then $nFlags = BitOr($GAA_FLAG_INCLUDE_WINS_INFO, $GAA_FLAG_INCLUDE_GATEWAYS, $GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER)
		
		If GetAdaptersAddresses(0, $nFlags, 0, DllStructGetPtr($stIP_ADAPTER_ADDRESSES), DllStructGetPtr($stReqSizeIAA), FALSE) = -1 Then
			$bTrayWndCreating = FALSE
			Return
		EndIf
			
		Local $stBufferIAA = DllStructCreate("byte[" & DllStructGetData($stReqSizeIAA, 1) & "]")
		$stIP_ADAPTER_ADDRESSES = 0
				
		If (GetAdaptersAddresses(0, $nFlags, 0, DllStructGetPtr($stBufferIAA), DllStructGetPtr($stReqSizeIAA))) <> $ERROR_SUCCESS Then
			$stBufferIAA = 0
			$bTrayWndCreating = FALSE
			Return
		EndIf
		
		Local $stWSAData	= DllStructCreate($sWSADATA)
		WSAStartup(0x0101, DllStructGetPtr($stWSAData))

		Local $i
		Local $pIPAA = DllStructGetPtr($stBufferIAA)
		
		$hTrayGUI = CreateGUI("", $nW, $nH, $nX, $nY, BitOr($WS_POPUP, $WS_BORDER), BitOr($WS_EX_TOPMOST, $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
		GUISetBkColor($nClrTrayBk)
		WinSetTrans($hTrayGUI, "", $nClrTrayTrans)
		GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
		SendMessage($hTrayGUI, $WM_SETFONT, $hGlobalFont, 1)
			
		$nY = 5
		If $bIconLib Then
			CreateCtrlIcon($sIconLib, -105, 5, $nY, $nIconSizeBig, $nIconSizeBig)
		Else
			CreateCtrlIcon(@AutoItExe, 282, 5, $nY, $nIconSizeBig, $nIconSizeBig)
		EndIf
		GUICtrlSetResizing(-1, 802)
		
		$nY = (($nIconSizeBig + (GetScaled(5) * 2)) / 2) - (GetScaled(23) / 2)
		
		Local $nSubX = GetScaled($nIconSizeBig, 2) + 10 ; 5 between border and icon and 5 more to text
		Local $hBigFont = 0

		CreateGlobalFont($hTrayGUI, 10, 600, 0, $sGlobalFont, $hBigFont)
		TrayGUIAddLine($nY, $nW, $sMainTitle, $nSubX, 23, -1, BitOr($SS_LEFT, $SS_LEFTNOWORDWRAP, $SS_CENTERIMAGE), $hBigFont)
		GUICtrlSetFont(-1, 10, 600)
		DeleteObject($hBigFont)
		
		$nY = $nIconSizeBig + (GetScaled(5) * 2) ; 5 before and after PENM icon
		
		Local $nSubY = $nY ; Point to start with sub layered window
		
		$hTraySubGUI = CreateGUI("", $nW, $nH - $nSubY - 1, $nX, $nSubY, BitOr($WS_POPUP, $WS_BORDER, $WS_CHILD), _
									BitOr(0x00080000, $WS_EX_TOPMOST, $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_CONTROLPARENT), $hTrayGUI)
		GUISetBkColor($nClrTrayBk)
		SetLayeredWindowAttributes($hTraySubGUI, GetBGRColor($nClrTrayBk), 0, 0x00000001) ; LWA_COLORKEY
		GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
		SendMessage($hTraySubGUI, $WM_SETFONT, $hGlobalFont, 1)
		
		$nY = 2
		
		Local $a, $b, $c, $sLine = ""
		Local $sIP, $sSM, $sDG, $sDNS, $sWINS, $sIP6, $sDG6, $sDNS6
		Local $sTmp, $sType, $bDHCP, $bIPv4, $sAddr
		Local $arLine, $arLine2, $sDesc, $sFriendly, $sMAC, $sGUID
		Local $nAdapterState, $nAdapterSpeed, $nIcon, $sIconFile, $nIconIdx, $bIsWLANI, $sProfileConnected = "", $sSSID = ""
		
		$nSubX = GetScaled($nIconSizeSmall, 2) + 10 ; 5 between border and icon and 5 more to text
		;$nSubX = $nIconSizeSmall + (GetScaled(5) * 2)
					
		If $bWLAPIOK Then EnumWlanAdapters() ; Get current WiFi adapters
		
		Local $nType
		Local $stName, $stDesc, $stFriendly, $pIAI, $stIP_ADAPTER_INFO, $stBufferIAI
		Local $nIfType, $pAddr, $stAddr, $stIPAddr, $stIPAddrStr, $stName, $stType, $stSocket
		Local $nDHCP6IAID, $sDHCP6DUID
		Local $stMask, $pMaskAddr, $stMaskAddr, $sMaskAddr, $nSize
		Local $sMACAP, $bAdhoc, $nSignal, $nIconIdx
		
		Local $stReqSizeIAI = DllStructCreate("dword")
		Local $nCount = 0
		
		While 1
			$stIP_ADAPTER_ADDRESSES	= DllStructCreate($sIP_ADAPTER_ADDRESSES, $pIPAA)
			$nIfType = DllStructGetData($stIP_ADAPTER_ADDRESSES, 16)
		
			If $nIfType = 6 Or $nIfType = 71 Then ; Ethernet/WiFi
				$stName = DllStructCreate("char[" & ($MAX_ADAPTER_NAME_LENGTH + 4) & "]", DllStructGetData($stIP_ADAPTER_ADDRESSES, 4))
				
				$bIsWLANI = FALSE
				For $i = 1 To $arWLANList[0]
					If DllStructGetData($stName, 1) = $arWLANList[$i] Then
						$bIsWLANI = TRUE
						ExitLoop
					EndIf
				Next
		
				$stDesc = DllStructCreate("wchar[" & ($MAX_ADAPTER_DESCRIPTION_LENGTH + 4) & "]", DllStructGetData($stIP_ADAPTER_ADDRESSES, 10))
				$sDesc = DllStructGetData($stDesc, 1)
				
				$sFriendly = ""
				If DllStructGetData($stIP_ADAPTER_ADDRESSES, 11) <> 0 Then
					$stFriendly = DllStructCreate("wchar[" & ($MAX_ADAPTER_DESCRIPTION_LENGTH + 4) & "]", DllStructGetData($stIP_ADAPTER_ADDRESSES, 11))
					$sFriendly = DllStructGetData($stFriendly, 1)
				Else
					$sFriendly = $sDesc
				EndIf
				
				If $bTrayShowMAC Then
					$sMAC	= ""
					For $c = 1 To DllStructGetData($stIP_ADAPTER_ADDRESSES, 13)
						$sMAC &= Hex(DllStructGetData($stIP_ADAPTER_ADDRESSES, 12, $c), 2) & "-"
					Next
					If StringRight($sMAC, 1) = "-" Then $sMAC = StringTrimRight($sMAC, 1)
				EndIf
				
				$sIP	= ""
				$sSM	= ""
				$sDG	= ""
				$sDNS	= ""
				$sWINS	= ""
				$sIP6	= ""
				$sSM6	= ""
				$sDG6	= ""
				$sDNS6	= ""
				$nAdapterState = DllStructGetData($stIP_ADAPTER_ADDRESSES, 17)
				
				If DllStructGetData($stIP_ADAPTER_ADDRESSES, 5) <> 0 Then ; Pointer to unicast address valid
					$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 5)
					
					While 1
						$stAddr = DllStructCreate($sIP_ADAPTER_UNICAST_ADDRESS, $pAddr)
						If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
							$bIPv4 = FALSE
							$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
							If $bIPv4 Then
								If $bIsVista Then
									$sIP = $sIP & $sAddr & @LF
									If DllStructGetData($stAddr, 12) > 0 Then ; mask
										$stMask = DllStructCreate("ulong")
										ConvertLengthToIpv4Mask(DllStructGetData($stAddr, 12), DllStructGetPtr($stMask))
										$pMaskAddr = inet_ntoa(DllStructGetData($stMask, 1))
										$stMaskAddr = DllStructCreate("char[16]", $pMaskAddr)
										$sSM = $sSM & DllStructGetData($stMaskAddr, 1) & @LF
										$stMask = 0
										$stMaskAddr = 0
									Else
										$sSM = $sSM & "" & @Tab
									EndIf
								EndIf
							Else
								$sIP6 = $sIP6 & $sAddr & @LF
								If $bIsVista And DllStructGetData($stAddr, 12) > 0 Then
									$sSM6 = $sSM6 & DllStructGetData($stAddr, 12) & @LF ; mask
								Else
									$sSM6 = $sSM6 & "" & @LF
								EndIf
							EndIf
						EndIf															
						
						$pAddr = DllStructGetData($stAddr, 3)
						$stAddr = 0								
						If $pAddr = 0 Then ExitLoop								
					WEnd
				EndIf
	
				If StringRight($sIP, 1) = @LF Then $sIP = StringTrimRight($sIP, 1)
				If StringRight($sSM, 1) = @LF Then $sSM = StringTrimRight($sSM, 1)
				If StringRight($sIP6, 1) = @LF Then $sIP6 = StringTrimRight($sIP6, 1)
				If StringRight($sSM6, 1) = @LF Then $sSM6 = StringTrimRight($sSM6, 1)
				
				$stAddr = 0
				
				If DllStructGetData($stIP_ADAPTER_ADDRESSES, 8) <> 0 Then ; Pointer to DNS address valid
					$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 8)
					
					While 1
						$stAddr = DllStructCreate($sIP_ADAPTER_DNS_SERVER_ADDRESS, $pAddr)
						If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
							$bIPv4 = FALSE
							$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
							If $bIPv4 Then
								$sDNS = $sDNS & $sAddr & ","
							Else
								$sDNS6 = $sDNS6 & $sAddr & ","
							EndIf
						EndIf															
						
						$pAddr = DllStructGetData($stAddr, 3)
						$stAddr = 0								
						If $pAddr = 0 Then ExitLoop								
					WEnd
				EndIf
				
				If $sDNS <> "" And StringRight($sDNS, 1) = "," Then $sDNS = StringTrimRight($sDNS, 1)
				If $sDNS6 <> "" And StringRight($sDNS6, 1) = "," Then $sDNS6 = StringTrimRight($sDNS6, 1)

				$stAddr = 0
				
				If $bIsVista Then ; More IPv6 infos only for OS >= Vista
					$sDG = ""
					$sDG6 = ""					
					If DllStructGetData($stIP_ADAPTER_ADDRESSES, 24) <> 0 Then ; Pointer to gateway address valid
						$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 24)
						
						While 1
							$stAddr = DllStructCreate($sIP_ADAPTER_DNS_SERVER_ADDRESS, $pAddr)
							If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
								$bIPv4 = FALSE
								$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
								If $bIPv4 Then
									$sDG = $sDG & $sAddr & @LF
								Else
									$sDG6 = $sDG6 & $sAddr & @LF
								EndIf
							EndIf															
							
							$pAddr = DllStructGetData($stAddr, 3)
							$stAddr = 0								
							If $pAddr = 0 Then ExitLoop								
						WEnd
					EndIf
					If $sDG <> "" And StringRight($sDG, 1) = @LF Then $sDG = StringTrimRight($sDG, 1)
					If $sDG6 <> "" And StringRight($sDG6, 1) = @LF Then $sDG6 = StringTrimRight($sDG6, 1)
					
					$stAddr = 0
					
					$sWINS = ""					
					If DllStructGetData($stIP_ADAPTER_ADDRESSES, 23) <> 0 Then ; Pointer to DNS address valid
						$pAddr = DllStructGetData($stIP_ADAPTER_ADDRESSES, 23)
						
						While 1
							$stAddr = DllStructCreate($sIP_ADAPTER_DNS_SERVER_ADDRESS, $pAddr)
							If DllStructGetData($stAddr, 4) <> 0 Then ; Pointer to socket address valid
								$bIPv4 = FALSE
								$sAddr = GetSocketAddr(DllStructGetData($stAddr, 4), $bIPv4)
								If $bIPv4 Then $sWINS = $sWINS & $sAddr & @LF
							EndIf															
							
							$pAddr = DllStructGetData($stAddr, 3)
							$stAddr = 0								
							If $pAddr = 0 Then ExitLoop								
						WEnd
					EndIf
					If $sWINS <> "" And StringRight($sWINS, 1) = @LF Then $sWINS = StringTrimRight($sWINS, 1)
					
					$stAddr = 0
				Else ; Only needed for XP/2003 which cannot get SM/DG/WINS information from GetAdaptersAddresses
					DllStructSetData($stReqSizeIAI, 1, 0)
					$stIP_ADAPTER_INFO = DllStructCreate($sIP_ADAPTER_INFO)
					GetAdaptersInfo(DllStructGetPtr($stIP_ADAPTER_INFO), DllStructGetPtr($stReqSizeIAI))					
					$stBufferIAI = DllStructCreate("byte[" & DllStructGetData($stReqSizeIAI, 1) & "]")
					
					$stIP_ADAPTER_INFO = 0
					
					If GetAdaptersInfo(DllStructGetPtr($stBufferIAI), DllStructGetPtr($stReqSizeIAI)) = $ERROR_SUCCESS Then
						
						$pIAI = DllStructGetPtr($stBufferIAI)
						
						While 1
							$stIP_ADAPTER_INFO = DllStructCreate($sIP_ADAPTER_INFO, $pIAI)
							If DllStructGetData($stIP_ADAPTER_INFO, 4) = $sDesc Then ; Adapter found
								; IPv4/SM
								$stAddr = DllStructCreate($sIP_ADDR_STRING)
								DllStructSetData($stAddr, 1, DllStructGetData($stIP_ADAPTER_INFO, 11))
								DllStructSetData($stAddr, 2, DllStructGetData($stIP_ADAPTER_INFO, 12))
								DllStructSetData($stAddr, 3, DllStructGetData($stIP_ADAPTER_INFO, 13))
								DllStructSetData($stAddr, 4, DllStructGetData($stIP_ADAPTER_INFO, 14))
								
								While 1
									$sIP &= DllStructGetData($stAddr, 2) & @LF
									$sSM &= DllStructGetData($stAddr, 3) & @LF
									
									$pAddr = DllStructGetData($stAddr, 1)
									If $pAddr = 0 Then
										ExitLoop
									Else
										$stAddr = 0
										$stAddr = DllStructCreate($sIP_ADDR_STRING, $pAddr)
									EndIf
								WEnd
								
								If StringRight($sIP, 1) = @LF Then $sIP = StringTrimRight($sIP, 1)
								If StringRight($sSM, 1) = @LF Then $sSM = StringTrimRight($sSM, 1)
								
								; DG
								$stAddr = DllStructCreate($sIP_ADDR_STRING)
								DllStructSetData($stAddr, 1, DllStructGetData($stIP_ADAPTER_INFO, 15))
								DllStructSetData($stAddr, 2, DllStructGetData($stIP_ADAPTER_INFO, 16))
								DllStructSetData($stAddr, 3, DllStructGetData($stIP_ADAPTER_INFO, 17))
								DllStructSetData($stAddr, 4, DllStructGetData($stIP_ADAPTER_INFO, 18))
								
								While 1
									If DllStructGetData($stAddr, 2) <> "0.0.0.0" Then $sDG = $sDG & DllStructGetData($stAddr, 2) & @LF
									
									$pAddr = DllStructGetData($stAddr, 1)
									If $pAddr = 0 Then
										ExitLoop
									Else
										$stAddr = 0
										$stAddr = DllStructCreate($sIP_ADDR_STRING, $pAddr)
									EndIf
								WEnd
								
								If StringRight($sDG, 1) = @LF Then $sDG = StringTrimRight($sDG, 1)
								
								$stAddr = 0
								
								 ; WINS
								If DllStructGetData($stIP_ADAPTER_INFO, 23) Then ; Have WINS
									If DllStructGetData($stIP_ADAPTER_INFO, 25) <> "0.0.0.0" Then $sWINS &= DllStructGetData($stIP_ADAPTER_INFO, 25) & @LF
									If DllStructGetData($stIP_ADAPTER_INFO, 29) <> "0.0.0.0" Then $sWINS &= DllStructGetData($stIP_ADAPTER_INFO, 29) & @LF
								EndIf
									
								If StringRight($sWINS, 1) = @LF Then $sWINS = StringTrimRight($sWINS, 1)
								
								$stAddr = 0
						
								ExitLoop
							EndIf
							$pIAI = DllStructGetData($stIP_ADAPTER_INFO, 1)
							$stIP_ADAPTER_INFO = 0
							If $pIAI = 0 Then ExitLoop
						WEnd
						
						$stIP_ADAPTER_INFO = 0
						$stBufferIAI = 0
					EndIf
				EndIf
				
				If ($bShowTrayOnlyCon And $nAdapterState = 1) Or $bShowTrayOnlyCon = FALSE Then
					$nCount += 1
					$nWTmp = $nW
					$nW += $nSubX
					$nY += 2
					
					If $nCount > 1 Then TrayGUIAddLine($nY, $nW, "", 0, 2, 3, $SS_SUNKEN)
					
					$nW = $nWTmp
					
					Switch $nAdapterState
						Case 1
							If $bIsWLANI Then
								$sMACAP		= ""
								$bAdhoc		= FALSE
								$nSignal	= 0
								$nIconIdx	= -95
								
								GetWlanCurCon($sDesc, $sProfileConnected, $sSSID, $sMACAP, $bAdhoc, $nSignal)
	
								If $bIconLib Then
									Switch $nSignal
										Case 1 To 20
											$nIconIdx = -96
										Case 21 To 40
											$nIconIdx = -97
										Case 41 To 60
											$nIconIdx = -98
										Case 61 To 80
											$nIconIdx = -99
										Case 81 To 100
											$nIconIdx = -100
									EndSwitch
								Else
									$nIconIdx = -272
									Switch $nSignal
										Case 1 To 20
											$nIconIdx = -273
										Case 21 To 40
											$nIconIdx = -274
										Case 41 To 60
											$nIconIdx = -275
										Case 61 To 80
											$nIconIdx = -276
										Case 81 To 100
											$nIconIdx = -277
									EndSwitch
								EndIf
							Else
								If $bIconLib Then
									$nIconIdx = -107
								Else
									$nIconIdx = -284
								EndIf
							EndIf						
						Case Else
							If $bIsWLANI Then
								If $bIconLib Then
									$nIconIdx = -110
								Else
									$nIconIdx = -287
								EndIf
							Else
								If $bIconLib Then
									$nIconIdx = -108
								Else
									$nIconIdx = -285
								EndIf
							EndIf
					EndSwitch
					
					If $bIconLib Then
						$sIconFile = $sIconLib
					Else
						$sIconFile = @AutoItExe
					EndIf
					
					If $bIsWLANI Then
						$hCtrl = GUICtrlCreateStatic($sIconFile, $nIconIdx, GetScaled(5), $nY - 1, $hTraySubGUI, -1, FALSE) ; Workaround for DPI problem with GUICtrlCreateIcon
					Else
						$hCtrl = GUICtrlCreateStatic($sIconFile, $nIconIdx, GetScaled(5), $nY, $hTraySubGUI, -1, FALSE) ; Workaround for DPI problem with GUICtrlCreateIcon
					EndIf
					$arStatic[0] += 1
					$arStatic[$arStatic[0]] = $hCtrl
					
					$sText = $sDesc
					TrayGUIAddLine($nY, $nW, $sFriendly & ":", $nSubX, 15, 0, -1, $hGlobalBoldFont)
					GUICtrlSetFont(-1, $nGlobalFontSize, 600)
					
					TrayGUIAddLine($nY, $nW, $sDesc, $nSubX, 15, 0, -1, 0, TRUE)

					If $bTrayShowMAC Then TrayGUIAddLine($nY, $nW, "MAC:" & @Tab & $sMAC, $nSubX, 15, 0, -1, 0, TRUE)
															
					If $bIsWLANI And $nAdapterState = 1 Then
						TrayGUIAddLine($nY, $nW, $sWiFiBalConTo & " " & $sSSID & " (" & $nSignal & "%)", $nSubX, 15, 0)
						GUICtrlSetFont(-1, $nGlobalFontSize)
					EndIf
					
					$bDHCP = FALSE
					$sType = ""
					If BitAnd(DllStructGetData($stIP_ADAPTER_ADDRESSES, 14), 0x0004) Then ; IP_ADAPTER_DHCP_ENABLED
						$bDHCP = TRUE
						$sType = " (DHCP)"
					EndIf
							
					;If $sIP = "" Then $sIP = "0.0.0.0"
					;If $sSM = "" Then $sSM = "0.0.0.0"
					
					If $sIP = "" Or $nAdapterState <> 1 Then TrayGUIAddLine($nY, $nW, $sTTDiscon, $nSubX, 15, 2)
					
					If StringInStr($sIP, @LF) Then
						$arLine = StringSplit($sIP, @LF)
						$arLine2 = StringSplit($sSM, @LF)
						For $c = 1 To $arLine[0]
							If $arLine[$c] <> "" Then
								If $c = 1 Then
									If $arLine2[$c] <> "" Then
										TrayGUIAddLine($nY, $nW, "IP:" & @Tab & $arLine[$c] & "  /  " & $arLine2[$c] & $sType, $nSubX, 15, 0)
									Else
										TrayGUIAddLine($nY, $nW, "IP:" & @Tab & $arLine[$c] & $sType, $nSubX, 15, 0)
									EndIf
								Else
									If $arLine2[$c] <> "" Then
										TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c] & "  /  " & $arLine2[$c] & $sType, $nSubX, 15, 0)
									Else
										TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c] & $sType, $nSubX, 15, 0)
									EndIf
								EndIf
							EndIf
						Next
						
						$nY += 2
					Else
						TrayGUIAddLine($nY, $nW, "IP:" & @Tab & $sIP & "  /  " & $sSM & $sType, $nSubX, 15, 2)
					EndIf
				
					If $sDG <> "" Then
						If StringInStr($sDG, @LF) Then
							$arLine = StringSplit($sDG, @LF)
							For $c = 1 To $arLine[0]
								If $arLine[$c] <> "" Then
									If $c = 1 Then
										TrayGUIAddLine($nY, $nW, "DG:" & @Tab & $arLine[$c], $nSubX, 15, 0)
									Else
										TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c], $nSubX, 15, 0)
									EndIf							
								EndIf					
							Next
							
							$nY += 2
						Else
							TrayGUIAddLine($nY, $nW, "DG:" & @Tab & $sDG, $nSubX, 15, 2)
						EndIf
					EndIf
					
					If $sDNS <> "" Then
						If StringRight($sDNS, 1) = "," Then $sDNS = StringTrimRight($sDNS, 1)
						
						If StringInStr($sDNS, ",") Then
							$arLine = StringSplit($sDNS, ",")
						Else
							$arLine = StringSplit($sDNS, " ")
						EndIf
							
						If $arLine[0] > 1 Then
							For $c = 1 To $arLine[0]
								If $arLine[$c] <> "" Then
									If $c = 1 Then
										TrayGUIAddLine($nY, $nW, "DNS:" & @Tab & $arLine[$c], $nSubX, 15, 0)
									Else
										TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c], $nSubX, 15, 0)
									EndIf
								EndIf					
							Next
							
							$nY += 2
						Else
							TrayGUIAddLine($nY, $nW, "DNS:" & @Tab & $sDNS, $nSubX, 15, 2)
						EndIf
					EndIf
					
					If $sWINS <> "" Then
						If StringInStr($sWINS, @LF) Then
							$arLine = StringSplit($sWINS, @LF)
							For $c = 1 To $arLine[0]
								If $arLine[$c] <> "" Then
									If $c = 1 Then
										TrayGUIAddLine($nY, $nW, "WINS:" & @Tab & $arLine[$c], $nSubX, 15, 0)
									Else
										TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c], $nSubX, 15, 0)
									EndIf
								EndIf
							Next
							
							$nY += 2
						Else
							TrayGUIAddLine($nY, $nW, "WINS:" & @Tab & $sWINS, $nSubX, 15, 2)
						EndIf
					EndIf
					
					If $bTrayShowIPv6 Then
						If $sIP6 <> "" Then
							If StringInStr($sIP6, @LF) Then
								$arLine = StringSplit($sIP6, @LF)
								$arLine2 = StringSplit($sSM6, @LF)
								For $c = 1 To $arLine[0]
									If $arLine[$c] <> "" Then
										If $c = 1 Then
											If $arLine2[$c] <> "" Then
												TrayGUIAddLine($nY, $nW, "IPv6:" & @Tab & $arLine[$c] & "/" & $arLine2[$c] & $sType, $nSubX, 15, 0)
											Else
												TrayGUIAddLine($nY, $nW, "IPv6:" & @Tab & $arLine[$c] & $sType, $nSubX, 15, 0)
											EndIf
										Else
											If $arLine2[$c] <> "" Then
												TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c] & "/" & $arLine2[$c] & $sType, $nSubX, 15, 0)
											Else
												TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c] & $sType, $nSubX, 15, 0)
											EndIf
										EndIf
									EndIf
								Next
								
								$nY += 2
							Else
								TrayGUIAddLine($nY, $nW, "IPv6:" & @Tab & $sIP6 & "/" & $sSM6 & $sType, $nSubX, 15, 2)
							EndIf
						EndIf
					
						If $sDG6 <> "" Then
							If StringRight($sDG6, 1) = @LF Then $sDG6 = StringTrimRight($sDG6, 1)
							
							If StringInStr($sDG6, @LF) Then
								$arLine = StringSplit($sDG6, @LF)
								For $c = 1 To $arLine[0]
									If $arLine[$c] <> "" Then
										If $c = 1 Then
											TrayGUIAddLine($nY, $nW, "DGv6:" & @Tab & $arLine[$c], $nSubX, 15, 0)
										Else
											TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c], $nSubX, 15, 0)
										EndIf							
									EndIf					
								Next
								
								$nY += 2
							Else
								TrayGUIAddLine($nY, $nW, "DGv6:" & @Tab & $sDG6, $nSubX, 15, 2)
							EndIf
						EndIf
						
						If $sDNS6 <> "" Then
							If StringRight($sDNS6, 1) = "," Then $sDNS6 = StringTrimRight($sDNS6, 1)
							
							If StringInStr($sDNS6, ",") Then
								$arLine = StringSplit($sDNS6, ",")
							Else
								$arLine = StringSplit($sDNS6, " ")
							EndIf
								
							If $arLine[0] > 1 Then
								For $c = 1 To $arLine[0]
									If $arLine[$c] <> "" Then
										If $c = 1 Then
											TrayGUIAddLine($nY, $nW, "DNSv6:" & @Tab & $arLine[$c], $nSubX, 15, 0)
										Else
											TrayGUIAddLine($nY, $nW, @Tab & $arLine[$c], $nSubX, 15, 0)
										EndIf
									EndIf					
								Next
								
								$nY += 2
							Else
								TrayGUIAddLine($nY, $nW, "DNSv6:" & @Tab & $sDNS6, $nSubX, 15, 2)
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf

			$pIPAA = DllStructGetData($stIP_ADAPTER_ADDRESSES, 3)
			$stName = 0
			$stDesc = 0
			$stFriendly = 0
			$stIP_ADAPTER_ADDRESSES	= 0
			If $pIPAA = 0 Then ExitLoop
		WEnd
		
		WSACleanup()
		
		$stIP_ADAPTER_ADDRESSES	= 0
		$stBufferIAA = 0
		
		TrayGUIAddLine($nY, $nW, "", 0, GetScaled(3), 0) ; Add small space after last label
		
		$nY += $nSubY
		
		Local $hTrayNotifyIconWnd = WinGetHandle("[CLASS:NotifyIconOverflowWindow]")
		Local $bNotifyIconVisable = FALSE
		If $hTrayNotifyIconWnd <> 0 Then $bNotifyIconVisable = IsWindowVisible($hTrayNotifyIconWnd)
		
		Local $arMouse = MouseGetPos()
		$nH = $nY
		$nYTmp = $nY
		
		If $nH < $nMaxH Then
			ShowScrollBar($hTraySubGUI, 1, FALSE)
			$bTraySBVisible = FALSE
		Else
			$nH = $nMaxH
			$nW += GetScaled($nSBSize)		
			$bTraySBVisible = TRUE
		EndIf
			
		If $bNotifyIconVisable Then
			Local $arPos2 = WinGetPos("[CLASS:NotifyIconOverflowWindow]")
			If $arPos[0] <= 0 Then ; top, bottom, left
				If $arPos[1] > 0 Then ; bottom
					$nX = $arPos2[0] - $nW ;- 2
					$nY = $arPos[1] - $nH ;- 2
				Else ; top, left
					If $arPos[2] > $arPos[3] Then ; top
						$nX = $arPos[0] + $arPos[2] - $nW ;- 2
						$nY = $arPos2[1] + $arPos2[3] ;+ 2
					Else ; left
						$nX = $arPos2[0] + $arPos2[2] ;+ 2
						$nY = $arPos[1] + $arPos[3] - $nH ;- 2
					EndIf
				EndIf			
			Else ; right
				$nX = $arPos2[0] - $nW ;- 2
				$nY = $arPos[1] + $arPos[3] - $nH ;- 2
			EndIf			
		Else
			If $arPos[0] <= 0 Then ; top, bottom, left
				If $arPos[1] > 0 Then ; bottom
					$nX = (2 * $arPos[0] + $arPos[2]) - $nW ;- 2
					If $nX > $arMouse[0] Then $nX = $arMouse[0]
				Else ; top, left
					$nX = 2 * $arPos[0] + $arPos[2] ;+ 2 ;3
				EndIf
			Else
				$nX = $arPos[0] - $nW ;- 2
			EndIf
			
			If $arPos[1] > 0 Then ; bottom
				$nY = $arPos[1] - $nH ;- 2 ;3
			Else ; top, left, right
				If $arPos[2] > $arPos[3] Then ; top
					$nX = (2 * $arPos[0] + $arPos[2]) - $nW ;- 2 ;5
					If $nX > $arMouse[0] Then $nX = $arMouse[0]
					$nY = 2 * $arPos[1] + $arPos[3] ;+ 2 ;3
				Else ; left, right
					$nY = 2 * $arPos[1] + $arPos[3] - $nH ;- 2 ;5
					If $nY > $arMouse[1] Then $nY = $arMouse[1]
				EndIf
			EndIf
		EndIf
		
		WinMove($hTrayGUI, "", $nX, $nY, $nW, $nH)
		WinMove($hTraySubGUI, "", $nX, $nY + $nSubY, $nW, $nH - $nSubY)
		
		$nTrayWinHeight = $nYTmp - $nMaxH
		
		If $nH >= $nMaxH Then
			Local $stSI = DllStructCreate($sSCROLLINFO)
			DllStructSetData($stSI, 1, DllStructGetSize($stSI))
			DllStructSetData($stSI, 2, BitOr($SIF_RANGE, $SIF_PAGE))
			DllStructSetData($stSI, 3, 0)
			DllStructSetData($stSI, 4, $nYTmp - $nSubY)
			DllStructSetData($stSI, 5, $nMaxH - $nSubY)
			SetScrollInfo($hTraySubGUI, 1, DllStructGetPtr($stSI), FALSE)
			$arScrollInfo[1][0] = 0
			$arScrollInfo[1][1] = $nTrayWinHeight
			$stSI = 0
		EndIf
		
		GUISetState(@SW_SHOWNOACTIVATE, $hTrayGUI)
		GUISetState(@SW_SHOWNOACTIVATE, $hTraySubGUI)
	EndIf
	
	$bTrayWndCreating = FALSE
EndFunc


;**********************************************************************
; Add label to tray info window
;**********************************************************************
Func TrayGUIAddLine(ByRef $nY, ByRef $nW, $sText, $nX = 5, $nH = 16, $nSpaceY = -1, $nStyle = -1, $hFont = 0, $bGray = FALSE)
	If $nSpaceY = -1 Then $nSpaceY = 5
	If $nStyle = -1 Then $nStyle = BitOr($SS_LEFT, $SS_LEFTNOWORDWRAP)
	If $hFont = 0 Then $hFont = $hGlobalFont
	
	$nX = GetScaled($nX)
	If $nH <> -1 And $sText <> "" Then $nH = GetScaled($nH)
	
	;$nH = GetScaled($nH)
	$nSpaceY = GetScaled($nSpaceY)
	Local $nYTmp = $nY

	; Correct GUI width
	Local $nWidth = $nW
	If $sText <> "" Then
		$nWidth = GetTextSize($hTrayGUI, $sText, $hFont)
		Local $nTmp = $nWidth + $nX + GetScaled(5)
		If $nTmp > $nW Then $nW = $nTmp
	EndIf

	; Because we are working with calculated pixels we must not use our CreateCtrlLabel!
	Local $nID = GUICtrlCreateLabel($sText, $nX, $nY, $nWidth, $nH, $nStyle)
	If $sText = "" Then
		GUICtrlSetResizing(-1, 512 + 32 + 4 + 2)
	Else
		GUICtrlSetResizing(-1, 768 + 32 + 2)
	EndIf
	GUICtrlSetBkColor(-1, $nClrTrayBk)
	If $bGray Then
		GUICtrlSetColor(-1, $nClrTrayTxtGray)
	Else
		GUICtrlSetColor(-1, $nClrTrayTxt)
	EndIf
	
	$nY = $nYTmp + $nH + $nSpaceY ; Absolute pixel to next label
		
	Return $nID
EndFunc


;**********************************************************************
; Return socket address string and type from pointer address
;**********************************************************************
Func GetSocketAddr($pAddr, ByRef $bIPv4)
	Local $stType = DllStructCreate("short", $pAddr)
	Local $stSocket, $stIPAddr, $stIPAddrStr, $nBytes, $nLen, $nType, $sAddr = ""
	Local $nType = DllStructGetData($stType, 1)
	If $nType = 2 Then ; AF_INET
		$bIPv4 = TRUE
		$stSocket = DllStructCreate($sSOCKADDR, $pAddr)
		$stIPAddr = DllStructCreate("byte[4]")
		DllStructSetData($stIPAddr, 1, DllStructGetData($stSocket, 3))
		$nLen = 16
		$nBytes = 4
	Else ; Should be AF_INET6
		$bIPv4 = FALSE
		$stSocket = DllStructCreate($sSOCKADDR_IN6, $pAddr)
		$stIPAddr = DllStructCreate("byte[16]")
		DllStructSetData($stIPAddr, 1, DllStructGetData($stSocket, 4))
		$nLen = 46
	EndIf
	
	$stIPAddrStr = DllStructCreate("wchar[" & $nLen & "]")
	;inet_ntop($nType, DllStructGetPtr($stIPAddr), DllStructGetPtr($stIPAddrStr), $nLen)
	Local $stLen = DllStructCreate("dword")
	DllStructSetData($stLen, 1, $nLen)
	
	WSAAddressToStringW(DllStructGetPtr($stSocket), DllStructGetSize($stSocket), 0, DllStructGetPtr($stIPAddrStr), DllStructGetPtr($stLen))
	$sAddr = DllStructGetData($stIPAddrStr, 1)
	
	$stIPAddr = 0
	$stIPAddrStr = 0
	
	Return $sAddr
EndFunc


;**********************************************************************
; Create wifi popup info/selection window for later using in systray
;**********************************************************************
Func CreateTrayWiFiGUI()
	Local $nW = 330
	Local $nH = 380

	Local $arPos = WinGetPos("[CLASS:Shell_TrayWnd]")
	
	Local $nMaxDeskH = @Desktopheight
	If IsArray($arPos) Then
		If $arPos[2] > $arPos[3] Then $nMaxDeskH = @Desktopheight - $arPos[3]
	EndIf	
		
	If $nTrayWiFiHeight >= 136 And $nTrayWiFiHeight <= GetScaled($nMaxDeskH, 2) Then $nH = $nTrayWiFiHeight ; Min size big icon + 2 entries + buttons below
	If $nTrayWiFiHeight = 0 Then $nTrayWiFiHeight = $nH
		
	Local $nX, $nY
	Local $nIconSize = $nIconSizeBig
	
	$hILLVWLATray	= ImageList_Create($nIconSize, $nIconSize, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	
	AddILIcon($hILLVWLATray, -270, 93, "", "", FALSE) ; Empty		-> 0 ; 2 dummy icons to reflect graphical changes if needed, ie. authenticating
	AddILIcon($hILLVWLATray, -271, 94, "", "", FALSE) ; Empty		-> 1 ; These icons can be anything because they are never drawn
	AddILIcon($hILLVWLATray, -272, 95, "Icon34", "", FALSE, $nIconSize) ; WiFi0			-> 2	
	AddILIcon($hILLVWLATray, -273, 96, "Icon35", "", FALSE, $nIconSize) ; WiFi1-20		-> 3
	AddILIcon($hILLVWLATray, -274, 97, "Icon36", "", FALSE, $nIconSize) ; WiFi21-40		-> 4
	AddILIcon($hILLVWLATray, -275, 98, "Icon37", "", FALSE, $nIconSize) ; WiFi41-60		-> 5
	AddILIcon($hILLVWLATray, -276, 99, "Icon38", "", FALSE, $nIconSize) ; WiFi61-80		-> 6
	AddILIcon($hILLVWLATray, -277, 100, "Icon39", "", FALSE, $nIconSize) ; WiFi81-100	-> 7
	AddILIcon($hILLVWLATray, -278, 101, "Icon40", "", FALSE, $nIconSize) ; Secured		-> 8
	AddILIcon($hILLVWLATray, -279, 102, "Icon44", "", FALSE, $nIconSize) ; Adhoc		-> 9
	AddILIcon($hILLVWLATray, -280, 103, "Icon46", "", FALSE, $nIconSize) ; Preferred	-> 10
	AddILIcon($hILLVWLATray, -281, 104, "Icon87", "", FALSE, $nIconSize) ; No access	-> 11
	
	$hTrayWiFiGUI	= CreateGUI("", $nW, $nH, $nX, $nY, BitOr($WS_POPUP, $WS_BORDER, $WS_TABSTOP), BitOr($WS_EX_TOPMOST, $WS_EX_TOOLWINDOW)) ; WS_CLIPCHILDREN
	GUISetBkColor($nClrTrayBk)
	WinSetTrans($hTrayWiFiGUI, "", $nClrTrayTrans)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hTrayWiFiGUI, $WM_SETFONT, $hGlobalFont, 1)
	
	$nComboNATray	= CreateCtrlCombo("", 5, 5, $nW - 10, 40, $CBS_DROPDOWNLIST)
	GUICtrlSetResizing(-1, 	2 + 32 + 512)
	Local $nDummy	= GUICtrlCreateDummy()
	$nConMenuWiFi	= GUICtrlCreateContextMenu($nDummy)
	$nMIWiFiDel		= GUICtrlCreateMenuItem($sBtnDelete, $nConMenuWiFi)
	
	$nLVWLAvailTray	= CreateCtrlListView("S|S", 5, 33, $nW - 10, $nH - 70, _
		BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_NOCOLUMNHEADER, $LVS_OWNERDRAWFIXED), $LVS_EX_SUBITEMIMAGES)
	GUICtrlSetFont(-1, $nWiFiBigFont, 400)
	GUICtrlSetBkColor(-1, $nClrTrayBk)
	GUICtrlSetColor(-1, $nClrTrayTxt)
	GUICtrlSetResizing(-1, 	2 + 32 + 64)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_SUBITEMIMAGES, $LVS_EX_SUBITEMIMAGES)
	GUICtrlSendMsg(-1, $LVM_SETEXTENDEDLISTVIEWSTYLE, $LVS_EX_FLATSB, $LVS_EX_FLATSB)	
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, 0) ; Signal / Security / Type ; Hide column dummy text
	GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled($nW - 16 - GetScaled($nSBSize))) ; SSID
	GUICtrlSendMsg(-1, $LVM_SETIMAGELIST, $LVSIL_SMALL, $hILLVWLATray)
	
	CreateCtrlLabel("", 0, $nH - 34, $nW + 1, 2, $SS_SUNKEN)
	GUICtrlSetResizing(-1, 	2 + 64 + 512)
	
	$nBtnWLRefTray	= CreateODBtn(">", 5, $nH - 27, 22, 22, $arODBtnTray, 29, TRUE, $nClrTrayBtnTxt, $nClrTrayBtnBk, 9, $nClrTrayBtnGrad)
	GUICtrlSetTip(-1, $sTTWiFiRefresh)
	SetODBtnState($nBtnWLRefTray, $GUI_FOCUS, FALSE)
	GUICtrlSetResizing(-1, 	2 + 64 + 512)
	
	$nBtnWLConTray	= CreateODBtn($sBtnWiFiDisconnect, Int(($nW - 145) / 2), $nH - 27, 145, 22, $arODBtnTray, -1, FALSE, $nClrTrayBtnTxt, $nClrTrayBtnBk, 9, $nClrTrayBtnGrad)
	GUICtrlSetResizing(-1, 	2 + 64 + 512)
	SetODBtnState($nBtnWLConTray, $GUI_DISABLE, FALSE)
	
	ApplyCtrlColors(8192)
	
	GUISwitch($hMainGUI)
EndFunc


;**********************************************************************
; Show wifi popup info/selection window
;**********************************************************************
Func ShowTrayWiFi()
	$bTrayWndCreating = TRUE
	
	Debug("IN: ShowTrayWiFi")
	
	Local $arPos = WinGetPos("[CLASS:Shell_TrayWnd]")
	If Not IsArray($arPos) Then Return
	
	Local $nW, $nH, $nX, $nY
	Local $arGUI = WinGetPos($hTrayWiFiGUI)
	Local $arMouse = MouseGetPos()
	
	If IsArray($arGUI) And IsArray($arMouse) Then
		$nH = $arGUI[3]
		$nW = $arGUI[2]
		
		Local $nMaxDeskH = @Desktopheight
		If $arPos[2] > $arPos[3] Then $nMaxDeskH = @Desktopheight - $arPos[3]
		
		If $nTrayInfoHeight = 0 Then $nTrayInfoHeight = Int($nMaxDeskH / 2)
		If $bTrayAdaptWiFi And $nTrayInfoHeight > 136 And $nTrayInfoHeight <= $nMaxDeskH Then
			$nH = $nTrayInfoHeight
		Else
			$nH = GetScaled($nTrayWiFiHeight)
		EndIf
		
		Local $i
		
		EnumNetworkAdapters()
		If $bWLAPIOK Then EnumWlanAdapters()
		
		Local $sOldDefWiFi = ""
		Local $sDefWiFi = ""
		Local $sNAList = ""
		Local $c = 0
		
		For $a = 1 To $arNAList[0][0]
			If $bSortList Then
				$i = $arNAListSort[$a][0]
			Else
				$i = $a
			EndIf
			
			If IsWLANI($arNAList[$i][0]) Then
				$c += 1
				$sNAList = $sNAList & "|" & $arNAList[$i][0]
				If $arNAList[$i][0] = $sLastWiFiShow Then $sOldDefWiFi = $sLastWiFiShow
				If $c = 1 Then $sDefWiFi = $arNAList[$i][0]
			EndIf
		Next
		
		If $sOldDefWiFi <> "" Then $sDefWiFi = $sOldDefWiFi
		
		GUICtrlSetData($nComboNATray, $sNAList, $sDefWiFi)		
		GUICtrlSetTip($nComboNATray, GetConName($sDefWiFi))
		
		EnumWlanAvailNetworks($sDefWiFi, FALSE, $nLVWLAvailTray)
		
		Local $hTrayNotifyIconWnd = WinGetHandle("[CLASS:NotifyIconOverflowWindow]")
		Local $bNotifyIconVisable = FALSE
		If $hTrayNotifyIconWnd <> 0 Then $bNotifyIconVisable = IsWindowVisible($hTrayNotifyIconWnd)
	
		If $bNotifyIconVisable Then
			Local $arPos2 = WinGetPos("[CLASS:NotifyIconOverflowWindow]")
			If $arPos[0] <= 0 Then ; top, bottom, left
				If $arPos[1] > 0 Then ; bottom
					$nX = $arPos2[0] - $nW ;- 2
					$nY = $arPos[1] - $nH ;- 2	
				Else ; top, left
					If $arPos[2] > $arPos[3] Then ; top
						$nX = $arPos[0] + $arPos[2] - $nW ;- 2
						$nY = $arPos2[1] + $arPos2[3] ;+ 2
					Else ; left
						$nX = $arPos2[0] + $arPos2[2] ;+ 2
						$nY = $arPos[1] + $arPos[3] - $nH ;- 2
					EndIf
				EndIf			
			Else ; right
				$nX = $arPos2[0] - $nW ;- 2
				$nY = $arPos[1] + $arPos[3] - $nH ;- 2
			EndIf			
		Else	
			If $arPos[0] <= 0 Then ; top, bottom, left
				If $arPos[1] > 0 Then ; bottom
					$nX = (2 * $arPos[0] + $arPos[2]) - $nW ;- 2
					If $nX > $arMouse[0] Then $nX = $arMouse[0]
				Else ; top, left
					$nX = 2 * $arPos[0] + $arPos[2] ;+ 2
				EndIf
			Else
				$nX = $arPos[0] - $nW ;- 2
			EndIf
			
			If $arPos[1] > 0 Then ; bottom
				$nY = $arPos[1] - $nH ;- 2
			Else ; top, left, right
				If $arPos[2] > $arPos[3] Then ; top
					$nX = (2 * $arPos[0] + $arPos[2]) - $nW ;- 2
					If $nX > $arMouse[0] Then $nX = $arMouse[0]
					$nY = 2 * $arPos[1] + $arPos[3] ;+ 2
				Else ; left, right
					$nY = 2 * $arPos[1] + $arPos[3] - $nH ;- 2
					If $nY > $arMouse[1] Then $nY = $arMouse[1]
				EndIf
			EndIf
		EndIf
		
		WinMove($hTrayWiFiGUI, "", $nX, $nY, $nW, $nH)
		SetODBtnState($nBtnWLRefTray, $GUI_FOCUS, FALSE)
		GUISetState(@SW_SHOW, $hTrayWiFiGUI)
	EndIf
	
	$bTrayWndCreating = FALSE
EndFunc


;**********************************************************************
; Convert the DHCP time values to FileTime format
;**********************************************************************
Func ConvertTime($nTime)
	If $nTime = 0 Then Return ""
	
	_wsetlocale(5, ".OCP") ; LC_TIME initializing
	
	Local $stTime	= DllStructCreate("int64")
	DllStructSetData($stTime, 1, $nTime)
	
	Local $pTime	= _localtime64(DllStructGetPtr($stTime))
	If $pTime = 0 Then Return ""
	
	Local $stTimeFormat = DllStructCreate("wchar[128]")
	wcsftime(DllStructGetPtr($stTimeFormat), 128, "%A, %d. %B %Y %H:%M:%S", $pTime)

	Return DllStructGetData($stTimeFormat, 1)
EndFunc


;**********************************************************************
; Checks and write settings to registry
;**********************************************************************
Func CheckSettings($sDesc)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	Local $sService = $arNAList[$i][1]
	
	$sAddr = GetAddrInput(1)
	UpdateAddr(1, $sAddr)
	$sAddr = GetAddrInput(3)
	UpdateAddr(3, $sAddr)
	$sAddr = GetAddrInput(4)
	UpdateAddr(4, $sAddr)
	$sAddr = GetAddrInput(5)
	UpdateAddr(5, $sAddr)
	
	Local $oConf = 0	
	If $bUseWMI Then
		Local $oConfigs		= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
		Local $oConfItem	= 0
		For $oConfItem In $oConfigs
			$oConf = $oConfItem
		Next
	EndIf
	
	If GetAdapterProperty($sService, 3, $oConf) <> $sLastDG Then $bGlobalAddrChg = TRUE
	If GetAdapterProperty($sService, 4, $oConf) <> $sLastDNS Then $bGlobalAddrChg = TRUE
	If GetAdapterProperty($sService, 5, $oConf) <> $sLastWINS Then $bGlobalAddrChg = TRUE

	If GUICtrlRead($nInpPCName) <> @ComputerName Then $bGlobalCNChg = TRUE
	If GUICtrlRead($nInpPCWG) <> GetWorkGroup() Then $bGlobalCNChg = TRUE
	If GUICtrlRead($nInpPCDNS) <> GetDNSSuffix() Then $bGlobalCNChg = TRUE
	
	If BitAnd(GUICtrlRead($nRadIPDHCP), $GUI_CHECKED) Then
		; Dynamic IP settings		
		If Not GetAdapterProperty($sService, 0, $oConf) Then
			SetAdapterProperty($sService, 0, 1)
			SetAdapterProperty($sService, 1, "0.0.0.0", "0.0.0.0")
			$bGlobalAddrChg = TRUE
		EndIf

		If BitAnd(GUICtrlRead($nChkDGMode), $GUI_CHECKED) Then
			SetAdapterProperty($sService, 3, $sLastDG)
		Else
			SetAdapterProperty($sService, 3, "")
		EndIf
		
		Local $sTcpipInt = $sCCS & "\Services\Tcpip\Parameters\Interfaces\" & $sService
		Local $bIPAuto = TRUE
		Local $sResult = RegRead($sTcpipInt, "IPAutoconfigurationEnabled")
		If Not @Error Then
			If $sResult <> "1" Then $bIPAuto = FALSE
		EndIf
		
		If BitAnd(GUICtrlRead($nRadIPPrivate), $GUI_CHECKED) Then
			If $bIPAuto = FALSE Then
				$bGlobalAddrChg = TRUE
				;SetAdapterProperty($sService, 16, 1)
				RegDelete($sTcpipInt, "IPAutoconfigurationEnabled") ; Not set but enabled by default
			EndIf
			RegRead($sTcpipInt, "ActiveConfigurations")
			If Not @Error Then
				$bGlobalAddrChg = TRUE
				RegDelete($sTcpipInt, "ActiveConfigurations")
			EndIf
		ElseIf BitAnd(GUICtrlRead($nRadIPNone), $GUI_CHECKED) Then
			If $bIPAuto = TRUE Then
				$bGlobalAddrChg = TRUE
				SetAdapterProperty($sService, 16, 0)
			EndIf
		ElseIf BitAnd(GUICtrlRead($nRadIPUser), $GUI_CHECKED) Then
			If $bIPAuto = FALSE Then
				$bGlobalAddrChg = TRUE
				RegDelete($sTcpipInt, "IPAutoconfigurationEnabled") ; Not set but enabled by default
			EndIf
			
			Local $sOptions = ""
			Local $sNewOptions = ""
			Local $sAltConf	= RegRead($sTcpipInt, "ActiveConfigurations")
			If @Error = 0 Then ; Alternate configs set -> REG_MULTI_SZ
				Local $arConfs = StringSplit($sAltConf, @LF)
				If IsArray($arConfs) Then $sOptions = RegRead($sCCS & "\Services\Dhcp\Configurations\" & $arConfs[1], "Options")
			EndIf
			
			RegWrite($sTcpipInt, "ActiveConfigurations", "REG_MULTI_SZ", "Alternate_" & $sService & @LF)
			$sNewOptions = CreateAltIPStr()
			If $sOptions <> $sNewOptions Then
				RegWrite($sCCS & "\Services\Dhcp\Configurations\Alternate_" & $sService, "Options", "REG_BINARY", $sNewOptions)
				$bGlobalAddrChg = TRUE
			EndIf
		EndIf
	Else
		; Static IP settings
		If GetAdapterProperty($sService, 0, $oConf) Then
			If GetAddrInput(1) = "" Then Return
			SetAdapterProperty($sService, 0, 0)
			$bGlobalAddrChg = TRUE
		EndIf
		
		If GetAdapterProperty($sService, 1, $oConf) <> $sLastIP Then
			If $sLastIP = "" Then Return
			SetAdapterProperty($sService, 1, $sLastIP, $sLastSM)
			$bGlobalAddrChg = TRUE
		EndIf
		
		If GetAdapterProperty($sService, 3, $oConf) <> $sLastDG Then
			SetAdapterProperty($sService, 3, $sLastDG)
			$bGlobalAddrChg = TRUE
		EndIf
	EndIf
	
	If BitAnd(GUICtrlRead($nRadDNSDHCP), $GUI_CHECKED) Then
		SetAdapterProperty($sService, 4, "")
	Else
		SetAdapterProperty($sService, 4, $sLastDNS)
		$sLastDNS = ""
	EndIf
		
	If BitAnd(GUICtrlRead($nRadWINSDHCP), $GUI_CHECKED) Then
		SetAdapterProperty($sService, 5, "")
	Else
		SetAdapterProperty($sService, 5, $sLastWINS)
		$sLastWINS = ""
	EndIf
	
	Local $sKey = GetAdapterProperty($sService, 18, $oConf)
	For $i = 1 To $arExtVal[0][0]
		If $arExtVal[$i][1] <> $arExtVal[$i][2] Then
			RegWrite($sKey, $arExtVal[$i][0], "REG_SZ", $arExtVal[$i][2])			
			$bGlobalAddrChg = TRUE
		EndIf
	Next
EndFunc


;**********************************************************************
; Create a listview item without any ID
;**********************************************************************
Func CreateAdvLVItem($sText, $nLV, $sSep = "", $nIconIdx = -1, $bFL = TRUE, $nL = -1)
	If $sSep = "" Then $sSep = "|"
	Local $arText = StringSplit($sText, $sSep, 1)
	Local $stText = DllStructCreate("wchar[" & (StringLen($arText[1]) + 1) & "]")
	DllStructSetData($stText, 1, $arText[1])
	
	Local $stLVI = DllStructCreate($sLVI)
	Local $nMask	= $LVIF_TEXT
	If $nIconIdx > -1 Then
		$nMask = BitOr($nMask, $LVIF_IMAGE)
		DllStructSetData($stLVI, 8, $nIconIdx)
	EndIf
	
	DllStructSetData($stLVI, 1, $nMask)
	
	If $bFL Then
		DllStructSetData($stLVI, 2, 0)
	Else
		If $nL <> -1 Then
			DllStructSetData($stLVI, 2, $nL)
		Else
			DllStructSetData($stLVI, 2, GUICtrlSendMsg($nLV, $LVM_GETITEMCOUNT, 0, 0))
		EndIf
	EndIf
	
	DllStructSetData($stLVI, 3, 0)
	DllStructSetData($stLVI, 6, DllStructGetPtr($stText))

	Local $nIdx = GUICtrlSendMsg($nLV, $LVM_INSERTITEMW, 0, DllStructGetPtr($stLVI))
	If $nIdx = -1 Then Return -1
	
	Local $i
	
	For $i = 2 To $arText[0]
		If $arText[$i] <> "" Then
			$stText = DllStructCreate("wchar[" & (StringLen($arText[$i]) + 1) & "]")
			DllStructSetData($stText, 1, $arText[$i])
			
			DllStructSetData($stLVI, 1, $LVIF_TEXT)
			DllStructSetData($stLVI, 2, $nIdx)
			DllStructSetData($stLVI, 3, $i - 1)
			DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
			
			GUICtrlSendMsg($nLV, $LVM_SETITEMW, 0, DllStructGetPtr($stLVI))
		EndIf
	Next
	
	Return $nIdx
EndFunc


;**********************************************************************
; Set/change listview item icon
;**********************************************************************
Func SetAdvLVItemIcon($nLV, $nIdx, $nCol, $nIcon)
	Local $stLVI = DllStructCreate($sLVI)
	
	DllStructSetData($stLVI, 1, $LVIF_IMAGE)
	DllStructSetData($stLVI, 2, $nIdx)
	DllStructSetData($stLVI, 3, $nCol)
	DllStructSetData($stLVI, 8, $nIcon)
	
	GUICtrlSendMsg($nLV, $LVM_SETITEMW, 0, DllStructGetPtr($stLVI))
EndFunc


;**********************************************************************
; Listbox: move items
;**********************************************************************
Func MoveListData($nCtrl, $bUp = FALSE, $bLV = FALSE)
	Local $nStep	= -1
	If Not $bUp Then $nStep = 1
	
	Local $nCount = 0, $nCurSel = -1, $sText
	
	If $bLV Then
		$nCount		= GUICtrlSendMsg($nCtrl, $LVM_GETITEMCOUNT, 0, 0)
		$nCurSel	= GUICtrlSendMsg($nCtrl, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	Else
		$nCount		= GUICtrlSendMsg($nCtrl, $LB_GETCOUNT, 0, 0)
		$nCurSel	= GUICtrlSendMsg($nCtrl, $LB_GETCURSEL, 0, 0)
		
	EndIf
	
	If $nCurSel <> -1 And (($nCurSel > 0 And $nStep = -1) Or ($nCurSel < ($nCount - 1) And $nStep = 1)) Then
		If $bLV Then
			Local $sSep = "@@CMD@@"
			$sText = GetLVText($nCtrl, $nCurSel, $sSep, 3)
			;Local $sText2 = GetLVText($nCtrl, $nCurSel + $nStep, $sSep, 3)					
			Local $arText = StringSplit($sText, $sSep, 1)

			If $arText[0] = 3 Then
				GUICtrlSendMsg($nCtrl, $LVM_DELETEITEM, $nCurSel, 0)
				ProfileCMDAdd($nCtrl, $arText[1], $arText[2], $arText[3], 0, $nCurSel + $nStep)
				
				Local $stLVI = DllStructCreate($sLVI)
				DllStructSetData($stLVI, 4, $LVIS_SELECTED)
				DllStructSetData($stLVI, 5, $LVIS_SELECTED)
				
				GUICtrlSendMsg($nCtrl, $LVM_SETITEMSTATE, $nCurSel + $nStep, DllStructGetPtr($stLVI))		
			EndIf
		Else
			$sText	= GUICtrlRead($nCtrl)
			GUICtrlSendMsg($nCtrl, $LB_DELETESTRING, $nCurSel, 0)
			
			Local $stText = DllStructCreate("wchar[" & (StringLen($sText) + 1) & "]")
			DllStructSetData($stText, 1, $sText)
			
			GUICtrlSendMsg($nCtrl, $LB_INSERTSTRING, $nCurSel + $nStep, DllStructGetPtr($stText))
			GUICtrlSendMsg($nCtrl, $LB_SETCURSEL, $nCurSel + $nStep, 0)
			
			;CheckListButton()
			
			$bGlobalAddrChg = TRUE
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Listbox/ListView: delete selected items
;**********************************************************************
Func DeleteListData()
	Local $nCount, $nCurSel, $nItem
	
	If $bIsLV Then
		$nCurSel = GUICtrlSendMsg($nListAddr, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	
		If $nCurSel > -1 Then
			$nItem	= GUICtrlRead($nListAddr)
			If $nItem > 0 Then GUICtrlDelete($nItem)
			$nCount = GUICtrlSendMsg($nListAddr, $LVM_GETITEMCOUNT, 0, 0)
			
			If $nCount > 0 Then
				If $nCurSel = 0 Then $nCurSel = 1
				
				Local $stLVI = DllStructCreate($sLVI)
				DllStructSetData($stLVI, 4, $LVIS_SELECTED)
				DllStructSetData($stLVI, 5, $LVIS_SELECTED)
				
				GUICtrlSendMsg($nListAddr, $LVM_SETITEMSTATE, $nCurSel - 1, DllStructGetPtr($stLVI))
			EndIf
			
			$bGlobalAddrChg = TRUE
		EndIf		
	Else
		$nCurSel	= GUICtrlSendMsg($nListAddr, $LB_GETCURSEL, 0, 0)
		If $nCurSel > -1 Then
			GUICtrlSendMsg($nListAddr, $LB_DELETESTRING, $nCurSel, 0)
			$nCount		= GUICtrlSendMsg($nListAddr, $LB_GETCOUNT, 0, 0)
			
			If $nCount > 0 Then
				If $nCurSel = 0 Then $nCurSel = 1
				GUICtrlSendMsg($nListAddr, $LB_SETCURSEL, $nCurSel - 1, 0)
			EndIf

			CheckListButton()
			
			$bGlobalAddrChg = TRUE
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Listbox/ListView: delete all items
;**********************************************************************
Func DeleteListAll()
	If $bIsLV Then
		GUICtrlSendMsg($nListAddr, $LVM_DELETEALLITEMS, 0, 0)
	Else
		GUICtrlSendMsg($nListAddr, $LB_RESETCONTENT, 0, 0)
	EndIf
EndFunc


;**********************************************************************
; Listbox: change arrow buttons
;**********************************************************************
Func CheckListButton()
	Local $nCount	= GUICtrlSendMsg($nListAddr, $LB_GETCOUNT, 0, 0)
	Local $nCurSel	= GUICtrlSendMsg($nListAddr, $LB_GETCURSEL, 0, 0)
	
	If $nCurSel = -1 Then Return
	
	If $nCurSel > 0 Then
		SetODBtnState($nBtnAddrUp, $GUI_ENABLE)
	Else
		SetODBtnState($nBtnAddrUp, $GUI_DISABLE)
	EndIf
	
	If $nCurSel < ($nCount - 1) Then
		SetODBtnState($nBtnAddrDown, $GUI_ENABLE)
	Else
		SetODBtnState($nBtnAddrDown, $GUI_DISABLE)
	EndIf
EndFunc


Func ChkListBtnCtrl($nCtrl, $nUp, $nDown, $bLV = FALSE, $bFocus = TRUE)
	If $nCtrl = 0 Then Return
	
	Local $nCount	= 0
	
	If $bLV Then
		$nCount		= GUICtrlSendMsg($nCtrl, $LVM_GETITEMCOUNT, 0, 0)
		$nCurSel	= GUICtrlSendMsg($nCtrl, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	Else
		$nCount		= GUICtrlSendMsg($nCtrl, $LB_GETCOUNT, 0, 0)
		$nCurSel	= GUICtrlSendMsg($nCtrl, $LB_GETCURSEL, 0, 0)
	EndIf
	
	;If $nCurSel = -1 Then Return
	
	If $nCurSel > 0 Then
		If BitAnd(GetODBtnState($nUp), $GUI_DISABLE) Then SetODBtnState($nUp, $GUI_ENABLE)
	Else
		If $bFocus Then GUICtrlSetState($nCtrl, $GUI_FOCUS)
		If BitAnd(GetODBtnState($nUp), $GUI_ENABLE) Then SetODBtnState($nUp, $GUI_DISABLE)		
	EndIf
	
	If $nCurSel <> -1 And $nCurSel < ($nCount - 1) Then
		If BitAnd(GetODBtnState($nDown), $GUI_DISABLE) Then SetODBtnState($nDown, $GUI_ENABLE)
	Else
		If $bFocus Then GUICtrlSetState($nCtrl, $GUI_FOCUS)
		If BitAnd(GetODBtnState($nDown), $GUI_ENABLE) Then SetODBtnState($nDown, $GUI_DISABLE)
	EndIf
EndFunc


;**********************************************************************
; Show address GUI
;**********************************************************************
Func SwitchToAddrGUI($sDesc, $nIndex)
	Local $arPos = WinGetPos($hMainGUI)
	
	GUISetState(@SW_DISABLE, $hMainGUI)

	CreateAddrGUI($nIndex)
	UpdateAddrList($sDesc, $nIndex)
	;GetAddrList($nIndex)

	If $nIndex = 1 Then
		SetODBtnState($nBtnAddrUp, $GUI_HIDE)
		SetODBtnState($nBtnAddrDown, $GUI_HIDE)
	Else
		GUICtrlSendMsg($nListAddr, $LB_SETCURSEL, 0, 0)
		Local $nCount = GUICtrlSendMsg($nListAddr, $LB_GETCOUNT, 0, 0)
		If ($nCount - 1) <= 0 Then GUICtrlSetState($nBtnAddrDown, $GUI_DISABLE)
	EndIf
	
	If IsArray($arPos) Then
		Local $nX = GetScaled(190)
		If $bTabSmall Then $nX = GetScaled(90)
		WinMove($hSubGUI, "", $arPos[0] + $nX, $arPos[1] + GetScaled(130))
	EndIf
	
	GUISetState(@SW_SHOW, $hSubGUI)
EndFunc


;**********************************************************************
; Create address sub GUI
;**********************************************************************
Func CreateAddrGUI($nIndex, $nW = 275, $nH = 160)
	Local $sTitle = ""
	
	$bIsLV = FALSE
			
	Switch $nIndex
		Case 1
			$sTitle = $sTAddIP
			;$nW = 290
			$bIsLV = TRUE
		Case 3
			$sTitle = $sTAddDG
		Case 4
			$sTitle = $sTAddDNS
		Case 5
			$sTitle = $sTAddWINS
	EndSwitch
	
	$hSubGUI		= CreateGUI($sTitle, $nW, $nH, -1, -1, BitOr($WS_POPUPWINDOW, $WS_CAPTION), _
									BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hMainGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hSubGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	
	If $bIconLib Then
		GUISetIcon($sIconLib, -4)
	Else
		SetWindowIcon($hSubGUI, @AutoItExe, 161)
	EndIf
		
	If $nIndex = 1 Then
		$nListAddr	= CreateCtrlListView($sLVIPSM, 5, 5, 265, 89, _
							BitOr($LVS_SHOWSELALWAYS, $LVS_SINGLESEL, $LVS_NOSORTHEADER))
		GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 0, GetScaled(110))
		GUICtrlSendMsg(-1, $LVM_SETCOLUMNWIDTH, 1, GetScaled(140))
	Else
		$nListAddr	= CreateCtrlList("", 5, 5, 230, 90, BitOr($WS_TABSTOP, $WS_VSCROLL, $LBS_NOTIFY))
	EndIf
	
	$nBtnAddrUp		= CreateODBtn("^", 245, 5, 22, 40, $arODBtnSub, 0, TRUE)
	SetODBtnState($nBtnAddrUp, $GUI_DISABLE)
	
	$nBtnAddrDown	= CreateODBtn("v", 245, 50, 22, 40, $arODBtnSub, 1, TRUE)
	SetODBtnState($nBtnAddrUp, $GUI_DISABLE)
	
	$nBtnAddrAdd	= CreateODBtn($sBtnAdd, 5, 100, 130, 25, $arODBtnSub, 5)
	$nBtnAddrDel	= CreateODBtn($sBtnDelete, 140, 100, 130, 25, $arODBtnSub, 6)
	$nBtnAddrOK		= CreateODBtn($sBtnOK, 5, 130, 130, 25, $arODBtnSub, 2)
	$nBtnAddrCancel	= CreateODBtn($sBtnCancel, 140, 130, 130, 25, $arODBtnSub, 3)
	SetODBtnState($nBtnAddrCancel, $GUI_FOCUS, FALSE)
	
	$nLastIndex			= $nIndex
EndFunc


;**********************************************************************
; Show add addresses GUI
;**********************************************************************
Func SwitchToAddAddrGUI($sDesc, $nIndex)
	GUISetState(@SW_DISABLE, $hSubGUI)
	CreateAddAddrGUI($nIndex)
	
	Local $arPos = WinGetPos($hSubGUI)
	If IsArray($arPos) Then WinMove($hAddrGUI, "", $arPos[0] + GetScaled(5), $arPos[1] + GetScaled(20))
	
	GUISetState(@SW_SHOW, $hAddrGUI)
EndFunc


;**********************************************************************
; Create add addresses sub GUI
;**********************************************************************
Func CreateAddAddrGUI($nIndex)
	Local $nH = 60
	If $nIndex = 1 Then $nH = 85
	Local $nW = 275
	
	Local $sTitle		= ""
	Local $sLblText		= ""
	
	Switch $nIndex
		Case 1
			$sTitle		= $sTAddIPAddr
			$sLblText	= $sLblStaticIP & ":"
		Case 3
			$sTitle		= $sTAddDGAddr
			$sLblText	= $sLblStaticDG & ":"
		Case 4
			$sTitle		= $sTAddDNSAddr
			$sLblText	= $sLblDNS & ":"
		Case 5
			$sTitle		= $sTAddWINSAddr
			$sLblText	= $sLblWINS & ":"
	EndSwitch
	
	If $hAddrFont = 0 Then CreateGlobalFont(0, $nGlobalFontSize, 400, 0, $sGlobalFont, $hAddrFont)
		
	$hAddrGUI			= CreateGUI($sTitle, $nW, $nH, -1, -1, BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
									BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hSubGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hAddrGUI, $WM_SETFONT, $hAddrFont, 1)
	GUISetBkColor($nClrGUIBkConf)
	
	If $bIconLib Then
		GUISetIcon($sIconLib, -4)
	Else
		SetWindowIcon($hAddrGUI, @AutoItExe, 161)
	EndIf
	
	CreateCtrlLabel($sLblText, 5, 8, 130, 20)
	GUICtrlSetBkColor(-1, $nClrGUIBkConf)
	GUICtrlSetColor(-1, $nClrLblConf)
	
	$hAddr1				= GUICtrlCreateIPAddr(140, 5, 130, 20, $hAddrGUI, $hAddrFont)
	
	If $nIndex = 1 Then
		CreateCtrlLabel($sLblStaticSM & ":", 5, 33, 130, 20)
		GUICtrlSetBkColor(-1, $nClrGUIBkConf)
		GUICtrlSetColor(-1, $nClrLblConf)
	
		$hAddr2			= GUICtrlCreateIPAddr(140, 30, 130, 20, $hAddrGUI, $hAddrFont)
	EndIf
		
	$nBtnAddAddrAdd		= CreateODBtn($sBtnAddShort, 5, $nH - 30, 130, 25, $arODBtnAddr, 5)
	$nBtnAddAddrCancel	= CreateODBtn($sBtnCancel, 140,  $nH - 30, 130, 25, $arODBtnAddr, 3)	
EndFunc


;**********************************************************************
; Ping an IP address or hostname
;**********************************************************************
Func PingAddress()
	Local $sAddr	= GUICtrlRead($nComboPing)
	Debug("IN: Ping address: " & $sAddr)
	
	If $sAddr = "" Then Return
	
	Local $i		= 1
	Local $sPing	= ""
	Local $sIP		= ""
		
	$bLoopPing = TRUE
	
	GUICtrlSetState($nLVTrace, $GUI_HIDE)
	GUICtrlSetState($nLVPing, $GUI_SHOW)
	GUICtrlSendMsg($nLVPing, $LVM_DELETEALLITEMS, 0, 0)
	
	SetODBtnIcon($nBtnPing, 14, FALSE)
	SetODBtnData($nBtnPing, $sBtnPingStop)
	SetODBtnState($nBtnTrace, $GUI_DISABLE)
	
	GUICtrlSetData($nAddrPing, "")
	
	GUICtrlSetColor($nLblState, $nClrStateRed)
			
	TCPStartUp()	

	GUICtrlSetData($nLblState, $sLblTCPtoIP & " """ & $sAddr & """...")
	
	$sPing	= TCPNameToIP($sAddr)
	$sIP	= $sPing
	
	If StringInStr($sAddr, $sPing) Then
		GUICtrlSetData($nLblState, $sLblIPtoTCP & " """ & $sAddr & """...")
		$sPing = TCPIPToName($sAddr)
	EndIf
	
	TCPShutdown()
	
	Local $hICF = IcmpCreateFile()
	If $hICF = $INVALID_HANDLE_VALUE Then
		SetODBtnIcon($nBtnPing, 13, FALSE)
		SetODBtnData($nBtnPing, $sBtnPingStart)
		SetODBtnState($nBtnTrace, $GUI_ENABLE)
		
		Return
	EndIf
	
	Local $stWSAData	= DllStructCreate($sWSADATA)
	If WSAStartup(0x0101, DllStructGetPtr($stWSAData)) <> 0 Then
		IcmpCloseHandle($hICF)
		
		SetODBtnIcon($nBtnPing, 13, FALSE)
		SetODBtnData($nBtnPing, $sBtnPingStart)
		SetODBtnState($nBtnTrace, $GUI_ENABLE)
		
        Return
	EndIf
	
	SavePingList($sAddr)
	
	GUICtrlSetData($nAddrPing, $sPing)
	
	If $sPing = "" Then $sPing = $sAddr

	GUICtrlSetData($nLblState, "Ping """ & GUICtrlRead($nComboPing) & """...")
				
	Local $nCount		= GUICtrlRead($nLimPing)	
	Local $bUnlimited	= FALSE
	If BitAnd(GUICtrlRead($nChkPing), $GUI_CHECKED) Then $bUnlimited = TRUE
	
	GUICtrlSetState($nLimPing, $GUI_DISABLE)
	GUICtrlSetState($nInpTime, $GUI_DISABLE)
	GUICtrlSetState($nChkPing, $GUI_DISABLE)
	
	Local $nResult		= 0
	Local $nRoundTrip	= 0
	Local $nPingRes		= 0
	Local $sReplyAddr	= ""
	Local $sTime		= ""
	Local $nTimeOut		= GUICtrlRead($nInpTime)
	If $nTimeOut <= 0 Then $nTimeOut = 1000
	Local $bReverse		= FALSE
	If BitAnd(GUICtrlRead($nChkReverse), $GUI_CHECKED) Then $bReverse = TRUE
	
	While 1
		If Not $bLoopPing Then ExitLoop
		
		$nResult = PingAddr($hICF, $sPing, $nPingRes, $sReplyAddr, $nTimeOut)
		SetError($nResult)	

		If $bUnlimited And $i > 200 Then
			GUICtrlSendMsg($nLVPing, $LVM_DELETEALLITEMS, 0, 0)
			$i = 1
		EndIf
		
		$sTime = " (" & @Hour & ":" & @Min & ":" & @Sec & ")"
		
		Switch $nResult
			Case 0
				CreateAdvLVItem($sLVIReply & " " & $sIP & ": " & $sLVIReplyTime & "=" & $nPingRes & $sLVIReplyTimeMS & $sTime, $nLVPing, "", -1, $bReverse)
			Case 1
				CreateAdvLVItem($sLVITimeOut & $sTime, $nLVPing, "", -1, $bReverse)
			Case 2
				CreateAdvLVItem($sLVIUnreachable & $sTime, $nLVPing, "", -1, $bReverse)
			Case 3
				CreateAdvLVItem($sLVIInvalid & $sTime, $nLVPing, "", -1, $bReverse)
			Case 4
				CreateAdvLVItem($sLVIGeneral & $sTime, $nLVPing, "", -1, $bReverse)
				ExitLoop
		EndSwitch
		
		Sleep(950)
		
		$i += 1
	
		If Not $bUnlimited And $i > $nCount Then ExitLoop
	WEnd
	
	IcmpCloseHandle($hICF)
	WSACleanup()
	
	$bLoopPing = FALSE
	
	GUICtrlSetState($nLimPing, $GUI_ENABLE)
	GUICtrlSetState($nInpTime, $GUI_ENABLE)
	GUICtrlSetState($nChkPing, $GUI_ENABLE)
	
	SetODBtnIcon($nBtnPing, 13, FALSE)
	SetODBtnData($nBtnPing, $sBtnPingStart)
	SetODBtnState($nBtnTrace, $GUI_ENABLE)
	
	GUICtrlSetColor($nLblState, $nClrStateGreen)
	GUICtrlSetData($nLblState, $sStateReady)
EndFunc


;**********************************************************************
; Converts an IP address into a hostname
;**********************************************************************
Func TCPIPToName($sIP)
	Local $stAddr = DllStructCreate("char[" & (StringLen($sIP) + 1) & "]")
	DllStructSetData($stAddr, 1, $sIP)
	
	Local $iAddr = inet_addr(DllStructGetPtr($stAddr))
	If $iAddr = $INADDR_NONE Then Return ""
	
	Local $pHE = gethostbyaddr($iAddr)
	If $pHE = 0 Then Return ""
	
	Local $stHE		= DllStructCreate("ptr;ptr;short;short;ptr", $pHE)
	Local $stName	= DllStructCreate("char[256]", DllStructGetData($stHE, 1))
	
	Return DllStructGetData($stName, 1)
EndFunc


;**********************************************************************
; Trace address
;**********************************************************************
Func TraceAddress()
	Local $sAddr = GUICtrlRead($nComboPing)
	Debug("IN: Trace address: " & $sAddr)
	
	If $sAddr = "" Then Return
	
	$bLoopPing = TRUE
	
	GUICtrlSetState($nLVPing, $GUI_HIDE)
	GUICtrlSetState($nLVTrace, $GUI_SHOW)
	GUICtrlSendMsg($nLVTrace, $LVM_DELETEALLITEMS, 0, 0)
	
	SetODBtnState($nBtnPing, $GUI_DISABLE)
	
	GUICtrlSetData($nAddrPing, "")
	GUICtrlSetColor($nLblState, $nClrStateRed)
		
	Local $nResult		= 0
	Local $nRoundTrip	= 0
	Local $sReplyAddr	= ""
	Local $sTracert		= ""
	Local $sTmp
	Local $sTime		= ""
	Local $nTimeOut		= GUICtrlRead($nInpTime)
	If $nTimeOut <= 0 Then $nTimeOut = 1000
	Local $bReverse		= FALSE
	If BitAnd(GUICtrlRead($nChkReverse), $GUI_CHECKED) Then $bReverse = TRUE
	
	Local $hICF = IcmpCreateFile()
	If $hICF = $INVALID_HANDLE_VALUE Then
		SetODBtnState($nBtnPing, $GUI_ENABLE)
		GUICtrlSetColor($nLblState, $nClrStateGreen)
		GUICtrlSetData($nLblState, $sStateReady)
		Return
	EndIf
	
	Local $stWSAData = DllStructCreate($sWSADATA)
	If WSAStartup(0x0101, DllStructGetPtr($stWSAData)) <> 0 Then
		IcmpCloseHandle($hICF)
		SetODBtnState($nBtnPing, $GUI_ENABLE)
		GUICtrlSetColor($nLblState, $nClrStateGreen)
		GUICtrlSetData($nLblState, $sStateReady)
        Return
	EndIf
	
	SavePingList($sAddr)
	
	SetODBtnIcon($nBtnTrace, 22, FALSE)
	SetODBtnData($nBtnTrace, $sBtnPingStop)
	
	GUICtrlSetData($nLblState, $sLblTCPtoIP & " """ & $sAddr & """...")
	
	$sTracert = TCPNameToIP($sAddr)
	
	If StringInStr($sAddr, $sTracert) Then
		GUICtrlSetData($nLblState, $sLblIPtoTCP & " """ & $sAddr & """...")
		$sTracert = TCPIPToName($sAddr)
	EndIf
	
	GUICtrlSetData($nAddrPing, $sTracert)
	GUICtrlSetData($nLblState, $sStateTrace & " """ & GUICtrlRead($nComboPing) & """...")
	
	GUICtrlSetState($nInpTime, $GUI_DISABLE)
	GUICtrlSetState($nInpTrace, $GUI_DISABLE)
	GUICtrlSetState($nChkTrace, $GUI_DISABLE)
	
	Local $i = 1
	Local $bResolve = FALSE
	If BitAnd(GUICtrlRead($nChkTrace), $GUI_CHECKED) Then $bResolve = TRUE
	
	For $i = 1 To GUICtrlRead($nInpTrace) ; Max. 30
		If Not $bLoopPing Then ExitLoop
		
		$nResult = PingAddr($hICF, $sAddr, $nRoundTrip, $sReplyAddr, $nTimeOut, TRUE, $i)
		
		Switch $nResult
			Case 0
				If $bResolve Then
					$sTmp = TCPIPToName($sReplyAddr)
					If $sTmp <> "" Then $sReplyAddr = $sTmp & " [" & $sReplyAddr & "]"
				EndIf
				
				CreateAdvLVItem($i & "|" & $nRoundTrip & $sLVIReplyTimeMS & "|  " & $sReplyAddr, $nLVTrace, "", -1, $bReverse)
				ExitLoop
			Case 1
				CreateAdvLVItem($i & "|*|  " & $sLVITimeOut, $nLVTrace, "", -1, $bReverse)
			Case 2
				CreateAdvLVItem($i & "|*|  " & $sLVIUnreachable, $nLVTrace, "", -1, $bReverse)
				ExitLoop
			Case 3
				CreateAdvLVItem($i & "|*|  " & $sLVIInvalid, $nLVTrace, "", -1, $bReverse)
				ExitLoop
			Case 4
				CreateAdvLVItem($i & "|*|  " & $sLVIGeneral, $nLVTrace, "", -1, $bReverse)
				ExitLoop
			Case 5
				If $bResolve Then
					$sTmp = TCPIPToName($sReplyAddr)
					If $sTmp <> "" Then $sReplyAddr = $sTmp & " [" & $sReplyAddr & "]"
				EndIf
				CreateAdvLVItem($i & "|" & $nRoundTrip & $sLVIReplyTimeMS & "|  " & $sReplyAddr, $nLVTrace, "", -1, $bReverse)
		EndSwitch
		
		Sleep(950)
	Next
	
	IcmpCloseHandle($hICF)
	WSACleanup()
	
	$bLoopPing = FALSE
	
	GUICtrlSetState($nInpTime, $GUI_ENABLE)
	GUICtrlSetState($nInpTrace, $GUI_ENABLE)
	GUICtrlSetState($nChkTrace, $GUI_ENABLE)
	
	SetODBtnIcon($nBtnTrace, 21, FALSE)
	SetODBtnData($nBtnTrace, $sBtnTrace)
	SetODBtnState($nBtnPing, $GUI_ENABLE)
	
	GUICtrlSetColor($nLblState, $nClrStateGreen)
	GUICtrlSetData($nLblState, $sStateReady)
EndFunc


;**********************************************************************
; Ping/trace address
;**********************************************************************
Func PingAddr($hICF, $sAddr, ByRef $nRoundTrip, ByRef $sReplyAddr, $nTimeOut, $bTracert = FALSE, $nTTL = 0)
	$nRoundTrip			= 0
	Local $nResult		= 0
	Local $nStatus		= 0
	Local $stAddr		= DllStructCreate("char[" & StringLen($sAddr) + 1 & "]")
	DllStructSetData($stAddr, 1, $sAddr)
	Local $stIpReply	= DllStructCreate($sICMP_ECHO_REPLY)
	Local $stPingBuffer	= DllStructCreate("char[" & DllStructGetSize($stIpReply) + 8 & "]")
	Local $nAddr		= inet_addr(DllStructGetPtr($stAddr))
	Local $pheHost		= gethostbyname(DllStructGetPtr($stAddr))
	Local $stheHost		= DllStructCreate($shostent, $pheHost)
		
	If $pheHost = 0 Then Return 4
	
	Local $stPtr		= DllStructCreate("ptr", DllStructGetData($stheHost, 5))
	Local $stAddrHE		= DllStructCreate("ulong", DllStructGetData($stPtr, 1))
	
	DllStructSetData($stPingBuffer, 1, 0xAA)

	Local $stIER		= DllStructCreate($sICMP_ECHO_REPLY)
	Local $stIpe		= DllStructCreate($sICMP_ECHO_REPLY & ";char[" & DllStructGetSize($stPingBuffer) & "]")
	Local $pIpe			= DllStructGetPtr($stIpe)	

	If $pIpe = 0 Then Return 4
		
	DllStructSetData($stIpe, 4, DllStructGetSize($stPingBuffer))
	DllStructSetData($stIpe, 6, DllStructGetPtr($stPingBuffer))
	
	Local $stIPOI		= 0
	
	; Tracert only - starts with 1 .... normally max. 30
	If $bTracert Then		
		$stIPOI = DllStructCreate($sIP_OPTION_INFORMATION)
		DllStructSetData($stIPOI, 1, $nTTL)
	EndIf
	
	If $nAddr = $INADDR_NONE Then
		$nStatus = IcmpSendEcho($hICF, DllStructGetData($stAddrHE, 1), DllStructGetPtr($stPingBuffer), DllStructGetSize($stPingBuffer), DllStructGetPtr($stIPOI), $pIpe, (DllStructGetSize($stIER) + DllStructGetSize($stPingBuffer)), $nTimeOut)
	Else
		$nStatus = IcmpSendEcho($hICF, $nAddr, DllStructGetPtr($stPingBuffer), DllStructGetSize($stPingBuffer), DllStructGetPtr($stIPOI), $pIpe, (DllStructGetSize($stIER) + DllStructGetSize($stPingBuffer)), $nTimeOut)
	EndIf
		
	Local $pReplyAddr = inet_ntoa(DllStructGetData($stIpe, 1))
	Local $stReplyAddr = DllStructCreate("char[16]", $pReplyAddr)	
	$sReplyAddr = DllStructGetData($stReplyAddr, 1)
	
	If DllStructGetData($stIpe, 2) = 0 Then
		If DllStructGetData($stIpe, 3) = 0 Then
			$nRoundTrip = 1
		Else
			$nRoundTrip = DllStructGetData($stIpe, 3)
		EndIf
	Else
		Switch DllStructGetData($stIpe, 2)
			Case 11002, 11003, 11004, 11005 ; IP_DEST_NET_UNREACHABLE, IP_DEST_HOST_UNREACHABLE, IP_DEST_PROT_UNREACHABLE, IP_DEST_PORT_UNREACHABLE
				$nResult = 2
			Case 11010			; IP_REQ_TIMED_OUT
				$nResult = 1
			Case 11018			; IP_BAD_DESTINATION
				$nResult = 3
			Case 11013			; IP_TTL_EXPIRED_TRANSIT
				$nRoundTrip = DllStructGetData($stIpe, 3)
				If $nRoundTrip = 0 Then $nRoundTrip = 1
				$nResult = 5
			Case Else			; Other errors
				$nResult = 4
		EndSwitch
	EndIf

	$stIpe = 0

	Return $nResult
EndFunc


;**********************************************************************
; Writes used entries for ping/trace to registry MRU
;**********************************************************************
Func SavePingList($sAddr)
	Local $sKey		= "Software\PENetwork\Ping MRU"
	Local $stString	= DllStructCreate("wchar[" & (StringLen($sKey) + 1) & "]")
	DllStructSetData($stString, 1, $sKey)
	
	Local $stMRUI	= DllStructCreate($sMRUINFO)
	DllStructSetData($stMRUI, 1, DllStructGetSize($stMRUI))
	DllStructSetData($stMRUI, 2, 20) ; Max. 20 entries
	DllStructSetData($stMRUI, 3, 0)
	DllStructSetData($stMRUI, 4, $HKEY_CURRENT_USER)
	DllStructSetData($stMRUI, 5, DllStructGetPtr($stString))
	DllStructSetData($stMRUI, 6, 0)
	
	Local $hMRU		= CreateMRUListW(DllStructGetPtr($stMRUI))
	
	If $hMRU <> 0 Then
		$stString	= DllStructCreate("wchar[" & (StringLen($sAddr) + 1) & "]")
		DllStructSetData($stString, 1, $sAddr)
		AddMRUStringW($hMRU, DllStructGetPtr($stString))
		FreeMRUList($hMRU)
	EndIf
EndFunc


;**********************************************************************
; Enum entries for ping/trace from registry MRU
;**********************************************************************
Func EnumPingList()
	Local $i
	Local $sData	= "|"
	Local $sLast	= GUICtrlRead($nComboPing)
	Local $sKey		= "Software\PENetwork\Ping MRU"
	Local $stString	= DllStructCreate("wchar[" & (StringLen($sKey) + 1) & "]")
	DllStructSetData($stString, 1, $sKey)
	
	Local $stMRUI	= DllStructCreate($sMRUINFO)
	DllStructSetData($stMRUI, 1, DllStructGetSize($stMRUI))
	DllStructSetData($stMRUI, 2, 20)
	DllStructSetData($stMRUI, 3, 0)
	DllStructSetData($stMRUI, 4, $HKEY_CURRENT_USER)
	DllStructSetData($stMRUI, 5, DllStructGetPtr($stString))
	DllStructSetData($stMRUI, 6, 0)
	
	Local $hMRU		= CreateMRUListW(DllStructGetPtr($stMRUI))
	
	If $hMRU <> 0 Then
		Local $nCount = EnumMRUListW($hMRU, -1, 0, 0)
		
		For $i = 0 To $nCount - 1
			$stString = DllStructCreate("wchar[" & $MAX_PATH & "]")
			If EnumMRUListW($hMRU, $i, DllStructGetPtr($stString), $MAX_PATH) <> -1 Then _
				$sData = $sData & DllStructGetData($stString, 1) & "|"
		Next

		FreeMRUList($hMRU)
	EndIf
	
	GUICtrlSetData($nComboPing, $sData, $sLast)
EndFunc


;**********************************************************************
; Get the new addr from add address input GUI
;**********************************************************************
Func GetNewAddr($sDesc, $nIndex)
	Local $nIP = 0
	
	GetAddress($hAddr1, $nIP)
	If $nIP = 0 Then Return
	
	GetAddrList($nIndex)
	
	Local $sText	= ""
	Local $sSep		= @LF
	Local $sNewIP	= ""
	Local $nPos		= 0
	Local $nLen		= 0
	
	Switch $nIndex
		Case 1
			$sText = $sLastIP
		Case 3
			$sText = $sLastDG
		Case 4
			$sText = $sLastDNS
			$sSep = ","
		Case 5
			$sText = $sLastWINS
	EndSwitch
	
	$sNewIP = GetStrFromIP($nIP)

	Local $i, $arAddr, $bFound = FALSE
	
	$arAddr = StringSplit($sText, $sSep)
	If IsArray($arAddr) Then
		For $i = 1 To $arAddr[0]
			If $sNewIP == $arAddr[$i] Then
				$bFound = TRUE
				ExitLoop
			EndIf			
		Next
	EndIf
	
	If $bFound Then Return

	If $sText = "" Then
		$sText = $sNewIP
	Else
		$sText = $sText & $sSep & $sNewIP
	EndIf
	
	Switch $nIndex
		Case 1
			$sLastIP = $sText
			Local $nSM
			GetAddress($hAddr2, $nSM)
			If $nSM = 0 Then
				$sNewIP = GetSubnetMask($nIP)
			Else
				$sNewIP = GetStrFromIP($nSM)
			EndIf
			
			If $sLastSM = "" Then
				$sText = $sNewIP
			Else
				$sText = $sLastSM & $sSep & $sNewIP
			EndIf
			
			$sLastSM = $sText
		Case 3
			$sLastDG = $sText
		Case 4
			$sLastDNS = $sText
		Case 5
			$sLastWINS = $sText
	EndSwitch

	GUISwitch($hSubGUI)
	DeleteListAll()
	GUISwitch($hAddrGUI)
	
	UpdateAddrList($sDesc, $nIndex)
	
	$bGlobalAddrChg = TRUE
EndFunc


;**********************************************************************
; Get default subnet mask from ip value
;**********************************************************************
Func GetSubnetMask($nIP)
	If $nIP >= 16777216 And $nIP <= 2147483647 Then
		$sSubnetMask = "255.0.0.0"
	ElseIf $nIP >= 2147483648 And $nIP <= 3221225471 Then
		$sSubnetMask = "255.255.0.0"
	Else
		$sSubnetMask = "255.255.255.0"
	EndIf
	
	Return $sSubnetMask	
EndFunc


;**********************************************************************
; Get the latest list entries
;**********************************************************************
Func GetAddrList($nIndex)
	Local $i, $nItems, $stText, $sText = "", $sTextDef = ""

	Switch $nIndex
		Case 1 ; IP/SM
			$sLastIP = ""
			$sLastIPDef = ""
			$sLastSM = ""
			$sLastSMDef = ""
			
			$nItems = GUICtrlSendMsg($nListAddr, $LVM_GETITEMCOUNT, 0, 0)
			If $nItems > 0 Then
				Local $stLVI = DllStructCreate($sLVI)
				$stText = DllStructCreate("wchar[260]")
				
				For $i = 0 To $nItems
					DllStructSetData($stLVI, 3, 0)
					DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
					DllStructSetData($stLVI, 7, 260)
					
					If GUICtrlSendMsg($nListAddr, $LVM_GETITEMTEXTW, $i, DllStructGetPtr($stLVI)) > 0 Then
						$sText = DllStructGetData($stText, 1)
						DllStructSetData($stLVI, 3, 1)
						DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
						DllStructSetData($stLVI, 7, 260)

						If GUICtrlSendMsg($nListAddr, $LVM_GETITEMTEXTW, $i, DllStructGetPtr($stLVI)) > 0 Then
							If $i = 0 Then $sLastIPDef = $sText
							$sLastIP = $sLastIP & $sText & @LF
							
							$sText = DllStructGetData($stText, 1)
							
							If $i = 0 Then $sLastSMDef = $sText
							$sLastSM = $sLastSM & $sText & @LF
						EndIf
					EndIf
				Next
				
				$sLastIP = StringTrimRight($sLastIP, 1)
				$sLastSM = StringTrimRight($sLastSM, 1)
			EndIf
			
			SetAddress($hIP, $sLastIPDef)
			SetAddress($hSM, $sLastSMDef)

		Case 3, 4, 5 ; DG/DNS/WINS
			Switch $nIndex
				Case 3
					$sLastDG = ""
					$sLastDGDef = ""
				Case 4
					$sLastDNS = ""
					$sLastDNSPref = ""
				Case 5
					$sLastWINS = ""
					$sLastWINSPref = ""
			EndSwitch
			
			$nItems = GUICtrlSendMsg($nListAddr, $LB_GETCOUNT, 0, 0)
			If $nItems > 0 Then
				Local $nLen, $sString
				
				For $i = 0 To $nItems
					$nLen = GUICtrlSendMsg($nListAddr, $LB_GETTEXTLEN, $i, 0)
					If $nLen > 0 Then
						$stText = DllStructCreate("wchar[" & $nLen + 1 & "]")
						If GUICtrlSendMsg($nListAddr, $LB_GETTEXT, $i, DllStructGetPtr($stText)) > 0 Then
							$sString = DllStructGetData($stText, 1)
							
							If $i = 0 Then $sTextDef = $sString
							
							If $nIndex = 4 Then
								$sText = $sText & $sString & ","
							Else
								$sText = $sText & $sString & @LF
							EndIf
						EndIf
					EndIf
				Next
				
				$sText = StringTrimRight($sText, 1)
			EndIf
			
			Switch $nIndex
				Case 3
					$sLastDG = $sText
					$sLastDGDef = $sTextDef
					SetAddress($hDG, $sLastDGDef)
				Case 4
					$sLastDNS = $sText
					$sLastDNSPref = $sTextDef
					SetAddress($hDNS, $sLastDNSPref)
				Case 5
					$sLastWINS = $sText
					$sLastWINSPref = $sTextDef
					SetAddress($hWINS, $sLastWINSPref)
			EndSwitch
	EndSwitch
EndFunc


;**********************************************************************
; Listbox/Listview: create current items
;**********************************************************************
Func UpdateAddrList($sDesc, $nIndex)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $sAddr = "", $sSep = @LF

	; PreCheck address inputs (defaults)
	$sAddr = GetAddrInput($nIndex)
	If $sAddr <> "" Then UpdateAddr($nIndex, $sAddr)

	Switch $nIndex
		Case 1
			$sAddr = $sLastIP
		Case 3
			$sAddr = $sLastDG
		Case 4
			$sAddr = $sLastDNS
			$sSep = ","
		Case 5
			$sAddr = $sLastWINS
	EndSwitch
	
	If $sAddr = "" Then Return
	
	Local $arAddr1, $arAddr2
	
	$arAddr1 = StringSplit($sAddr, $sSep)

	If $nIndex = 1 Then
		$sAddr = $sLastSM
		$arAddr2 = StringSplit($sAddr, $sSep)
	Else
		GUICtrlSetData($nListAddr, "")
	EndIf
	
	For $i = 1 To $arAddr1[0]
		If $nIndex = 1 Then
			GUICtrlCreateListViewItem($arAddr1[$i] & "|" & $arAddr2[$i], $nListAddr)
		Else
			GUICtrlSetData($nListAddr, $arAddr1[$i])
		EndIf
	Next
EndFunc


;**********************************************************************
; Update address string with address input (default)
;**********************************************************************
Func UpdateAddr($nIndex, $sAddrDef)
	Local $i, $nPos = 0
	Local $sAddr = "",  $sAddr2 = "", $sAddrDef2 = ""
	Local $arAddr, $arAddr2
	Local $sSep	= @LF
	Local $bFound = FALSE
	
	Switch $nIndex
		Case 1
			$sAddr = $sLastIP
			$sAddr2 = $sLastSM
		Case 3
			$sAddr = $sLastDG
		Case 4
			$sAddr = $sLastDNS
			$sSep = ","
		Case 5
			$sAddr = $sLastWINS
	EndSwitch

	; If input address already exists then move it to the beginning, otherwise replace the first address
	; For DNS/WINS if only alternate set and no preferred set move to the beginning, otherwise replace the second address
	Local $arAddr = StringSplit($sAddr, $sSep)
	If IsArray($arAddr) Then
		For $i = 1 To $arAddr[0]
			If $sAddrDef == $arAddr[$i] Then
				$bFound = TRUE
				ExitLoop
			EndIf
		Next
	EndIf
	
	If $bFound Then
		$nPos = ChangeAddrPos($sAddr, $sAddrDef, $sSep)
	Else
		ChangeAddrPos($sAddr, $sAddrDef, $sSep, 1)
		$nPos = 1
	EndIf
	
	If $nIndex = 1 Then
		$sAddrDef2 = GetAddrInput(2)
		If $sAddr <> "" Then
			If $sAddrDef2 = "" Then
				$sAddrDef2 = GetSubnetMask(GetIPFromStr($sAddr))
				SetAddress($hSM, $sAddrDef2)
			EndIf
			
			ChangeAddrPos($sAddr2, $sAddrDef2, $sSep, $nPos)
		EndIf
	EndIf
	
	Switch $nIndex
		Case 1
			$sLastIP = $sAddr
			$sLastIPDef = $sAddrDef
			$sLastSM = $sAddr2
			$sLastSMDef = $sAddrDef2
		Case 3
			$sLastDG = $sAddr
			$sLastDGDef = $sAddrDef
		Case 4
			$sLastDNS = $sAddr
			$sLastDNSPref = $sAddrDef
		Case 5
			$sLastWINS = $sAddr
			$sLastWINSPref = $sAddrDef
	EndSwitch
EndFunc


;**********************************************************************
; Change address entry position in address string
;**********************************************************************
Func ChangeAddrPos(ByRef $sAddr, $sAddrDef, $sSep, $nReplPos = 0)
	Local $i, $arAddr, $nPos = 0

	$arAddr = StringSplit($sAddr, $sSep)
	$sAddr = $sAddrDef
	
	If IsArray($arAddr) Then
		If $arAddr[0] > 1 Then
			For $i = 1 To $arAddr[0]
				If $nReplPos > 0 Then
					If $nReplPos = $i Then ExitLoop
				ElseIf $arAddr[$i] = $sAddrDef Then
					ExitLoop
				EndIf
			Next
			
			; 09.03.2008 makes no sense here
			;If $nReplPos > 0 Then $sAddrDef = $arAddr[$i]
			
			$nPos = $i
			$arAddr[$i] = ""
			$sAddr = ""
			
			For $i = 1 To $arAddr[0]
				If $i <> $nPos Then $sAddr = $sAddr & $arAddr[$i] & $sSep
			Next
			
			If $sAddr <> "" And StringRight($sAddr, 1) = $sSep Then $sAddr = StringTrimRight($sAddr, 1)
			
			If $arAddr[0] > 1 Then
				$sAddr = $sAddrDef & $sSep & $sAddr
			Else
				$sAddr = $sAddrDef
			EndIf
		EndIf
	EndIf
	
	Return $nPos
EndFunc


;**********************************************************************
; Get the address from input (default)
;**********************************************************************
Func GetAddrInput($nIndex)
	Local $nAddr = 0, $sAddr = ""
	
	Switch $nIndex
		Case 1
			$hCtrl = $hIP
		Case 2
			$hCtrl = $hSM
		Case 3
			$hCtrl = $hDG
		Case 4
			$hCtrl = $hDNS
		Case 5
			$hCtrl = $hWINS
	EndSwitch
	
	GetAddress($hCtrl, $nAddr)
	$sAddr = GetStrFromIP($nAddr)
	
	Return $sAddr
EndFunc


;**********************************************************************
; Scan for current network interfaces
;**********************************************************************
Func ResetLastAddr()
	$sLastIP		= ""
	$sLastIPDef		= ""
	$sLastSM		= ""
	$sLastSMDef		= ""
	$sLastDG		= ""
	$sLastDGDef		= ""
	$sLastDNS		= ""
	$sLastDNSPref	= ""
	$sLastWINS		= ""
	$sLastWINSPref	= ""
	$nLastIndex		= -1	
EndFunc


;**********************************************************************
; Resets the network adapter list after applying new settings
;**********************************************************************
Func RefreshAdapterList()
	$sLastDefData	= GUICtrlRead($nComboNA)
	$sDefData		= ""
	$sNAList		= ""
	$bGlobalAddrChg = FALSE
	Local $bRef		= TRUE
	Local $nIdx		= 0
	Local $sName	= ""
	
	ResetLastAddr()
	EnumNetworkAdapters()
	If $bWLAPIOK Then EnumWlanAdapters()
	
	For $i = 1 To $arNAList[0][0]
		$sNAList = $sNAList & "|" & $arNAList[$i][0]
		If StringInStr($arNAList[$i][0], $sLastDefData) Then
			$sDefData = $sLastDefData
			$nIdx = $i
		ElseIf $sDefData = "" And _
			(GetAdapterProperty($arNAList[$i][1], 1) <> "" Or _
			GetAdapterProperty($arNAList[$i][1], 6) <> "" Or _
			GetAdapterProperty($arNAList[$i][1], 0)) Then
			$sDefData = $arNAList[$i][0]
			$nIdx = $i
		EndIf
	Next
	
	If $sDefData <> "" Then
		GUICtrlSetData($nComboNA, $sNAList, $sDefData)		
		GUICtrlSetTip($nComboNA, GetConName($sDefData))
		If $sDefData = $sLastDefData Then $bRef = FALSE
		UpdateWiFiTab($sDefData)
		Net2GUI($sDefData, $bRef)
		Infos2GUI($sDefData)
		AltIP2GUI($sDefData)
	EndIf
EndFunc


;**********************************************************************
; Get connection name (if one exists)
;**********************************************************************
Func GetConName($sDesc)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return ""
	
	Local $sName = GetAdapterProperty($arNAList[$i][1], 14)
		
	If $sName <> "" Then
		$sName = $sName & @LF & $sDesc
	Else
		$sName = $sDesc
	EndIf
	
	Return $sName
EndFunc


;**********************************************************************
; Scan for current network interfaces
;**********************************************************************
Func EnumNetworkAdapters($bLog = TRUE)
	Debug("IN: EnumNetworkAdapters")
	
	$arNAList[0][0] = 0
	
	Local $stIP_ADAPTER_INFO	= DllStructCreate($sIP_ADAPTER_INFO)
	Local $stReqSize			= DllStructCreate("dword")

	If GetAdaptersInfo(DllStructGetPtr($stIP_ADAPTER_INFO), DllStructGetPtr($stReqSize)) = -1 Then
		Return FALSE
	EndIf
	
	Local $stBuffer				= DllStructCreate("byte[" & DllStructGetData($stReqSize, 1) & "]")
		
	If GetAdaptersInfo(DllStructGetPtr($stBuffer), DllStructGetPtr($stReqSize)) = $ERROR_SUCCESS Then
		$stIP_ADAPTER_INFO		= DllStructCreate($sIP_ADAPTER_INFO, DllStructGetPtr($stBuffer))
		Local $pIPAI
			
		While 1
			$arNAList[0][0] += 1
			$arNAList[$arNAList[0][0]][0] = DllStructGetData($stIP_ADAPTER_INFO, 4)
			$arNAList[$arNAList[0][0]][1] = DllStructGetData($stIP_ADAPTER_INFO, 3)
			$arNAList[$arNAList[0][0]][2] = DllStructGetData($stIP_ADAPTER_INFO, 4)
			
			If StringInStr($arNAList[$arNAList[0][0]][0], "|") Then $arNAList[$arNAList[0][0]][0] = StringReplace($arNAList[$arNAList[0][0]][0], "|", "/") ; Workaround for network adapter descriptions like "XYZ a|b|g|n" -> "XYZ a/b/g/n"

			If $bLog Then Debug("IN: EnumNetworkAdapters: AdapterGUID " & $arNAList[0][0] & ": " & DllStructGetData($stIP_ADAPTER_INFO, 3))
			If $bLog Then Debug("IN: EnumNetworkAdapters: Description " & $arNAList[0][0] & ": " & DllStructGetData($stIP_ADAPTER_INFO, 4))
			
			$pIPAI = DllStructGetData($stIP_ADAPTER_INFO, 1)
			
			If $pIPAI = 0 Then
				ExitLoop
			Else
				$stIP_ADAPTER_INFO	= 0
				$stIP_ADAPTER_INFO	= DllStructCreate($sIP_ADAPTER_INFO, $pIPAI)
			EndIf
		WEnd
	Else
		If $bLog Then Debug("ER: GetAdaptersInfo")
	EndIf
	
	$stIP_ADAPTER_INFO	= 0
	
	; Sorting
	$arNAListSort[0][0] = 0
	Local $sText, $c, $t
	
	For $i = 1 To $arNAList[0][0]
		$sText = GetAdapterProperty($arNAList[$i][1], 14)
		If $sText = "" Then $sText = $arNAList[$i][0]
		$arNAListSort[0][0] += 1
		$arNAListSort[$i][0] = $i
		$arNAListSort[$i][1] = $sText
	Next
	
	For $i = 1 To $arNAListSort[0][0]
		For $c = 1 To $arNAListSort[0][0] - 1
			If StringUpper($arNAListSort[$c][1]) > StringUpper($arNAListSort[$c + 1][1]) Then
				$t = $arNAListSort[$c + 1][0]
				$sText = $arNAListSort[$c + 1][1]
				$arNAListSort[$c + 1][0] = $arNAListSort[$c][0]
				$arNAListSort[$c + 1][1] = $arNAListSort[$c][1]
				$arNAListSort[$c][0] = $t
				$arNAListSort[$c][1] = $sText			
			EndIf
		Next		
	Next
EndFunc


;**********************************************************************
; Scan for current wireless network interfaces
;**********************************************************************
Func EnumWlanAdapters()
	Debug("IN: EnumWlanAdapters")
	
	Local $i
	
	$arWLANList[0] = 0
	
	If $hWlanapi = -1 Then Return
	
	Local $stVersion = DllStructCreate("dword")
	Local $stHandle = DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)

	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return
	
	Local $hWlan	= DllStructGetData($stHandle, 1)
	Local $stILPtr	= DllStructCreate("dword") ; Get the pointer to the interface list memory address
	
	$nResult = WlanEnumInterfaces($hWlan, 0, DllStructGetPtr($stILPtr))
	If $nResult <> $ERROR_SUCCESS Then Return
	
	Local $pIL			= DllStructGetData($stILPtr, 1)
	Local $stIL			= DllStructCreate("dword", $pIL)
	Local $nInterfaces	= DllStructGetData($stIL, 1, 1)
	
	Debug("IN: WlanEnumInterfaces - count: " & $nInterfaces)
	
	If $nInterfaces > 0 Then
		Local $sIL = "dword;dword;" & $sWLAN_INTERFACE_INFO
			
		; Create the interface list array
		For $i = 1 To $nInterfaces - 1
			$sIL = $sIL & ";" & $sWLAN_INTERFACE_INFO
		Next
			
		$stIL = DllStructCreate($sIL, $pIL)
		
		Local $sNetGUID = ""
		
		For $i = 1 To $nInterfaces
			$sNetGUID = "{" & Hex(DllStructGetData($stIL, $i * 6 - 3), 8) & "-" & _
					Hex(DllStructGetData($stIL, $i * 6 - 2), 4) & "-" & _
					Hex(DllStructGetData($stIL, $i * 6 - 1), 4) & "-" & _
					Hex(DllStructGetData($stIL, $i * 6, 1), 2) & _
					Hex(DllStructGetData($stIL, $i * 6, 2),2) & "-" & _
					Hex(DllStructGetData($stIL, $i * 6, 3), 2) & _
					Hex(DllStructGetData($stIL, $i * 6, 4), 2) & _
					Hex(DllStructGetData($stIL, $i * 6, 5), 2) & _
					Hex(DllStructGetData($stIL, $i * 6, 6), 2) & _
					Hex(DllStructGetData($stIL, $i * 6, 7), 2) & _
					Hex(DllStructGetData($stIL, $i * 6, 8), 2) & "}"

			$arWLANList[0] += 1
			$arWLANList[$arWLANList[0]] = $sNetGUID
		Next
	EndIf

	WlanFreeMemory($pIL)
	WlanCloseHandle($hWlan, 0)
EndFunc


;**********************************************************************
; Update WiFi tab icon
;**********************************************************************
Func UpdateWiFiTab($sAdapter)
	Debug("IN: UpdateWiFiTab")
	
	Local $bIsWLANI = 0
	If $sAdapter <> "" Then $bIsWLANI = IsWLANI($sAdapter)

	Local $nIcon = 8
	If $bIsWLANI Then $nIcon = 7
	If $nIcon <> $nLastAdapterIcon Then
		SetODBtnIcon($nTIWiFi, $nIcon)
		$nLastAdapterIcon = $nIcon
	EndIf
EndFunc


;**********************************************************************
; Update WiFi service state
;**********************************************************************
Func UpdateWiFiInfo($sAdapter, $bSwitchGUI = FALSE)
	Debug("IN: UpdateWiFiInfo")
	
	Local $hWiFiGUI
	
	If $bSwitchGUI And Not $bWiFiCreated Then CreateWiFiGUI()
	
	Local $nPreWiFiShow = UpdateWiFiState()
	
	If $nPreWiFiShow = 2 Then
		SetGUICursor($hCursorWait, $hMainGUI)
		EnumWlanAvailNetworks($sAdapter)
		EnumWlanPrefNetworks($sAdapter)
		SetGUICursor($hCursorArrow, $hMainGUI)
	EndIf
	
	Local $bIsWLANI = IsWLANI($sAdapter)
	
	If $bSwitchGUI Or $hLastConfGUI = $hConfWiFiGUI Or $hLastConfGUI = $hConfPreWiFiGUI Then
		If $nPreWiFiShow = 0 Or $bWLAPIOK = FALSE Or $bIsWLANI = FALSE Then
			$hWiFiGUI = $hConfPreWiFiGUI
			
			If $nPreWiFiShow <> $nLastWiFiSrvState Then
				If Not $bWLAPIOK Then
					GUICtrlSetState($nLblPreWiFiState, $GUI_HIDE)
					GUICtrlSetState($nLblPreWiFiCurState, $GUI_HIDE)
					SetODBtnState($nBtnPreWiFi, $GUI_HIDE)
					
					GUICtrlSetState($nLblWLNot, $GUI_HIDE)
					GUICtrlSetState($nLblWLNoApi, $GUI_SHOW)
				Else
					GUICtrlSetState($nLblPreWiFiState, $GUI_SHOW)
					GUICtrlSetState($nLblPreWiFiCurState, $GUI_SHOW)
					SetODBtnState($nBtnPreWiFi, $GUI_SHOW)
					
					If Not $bIsWLANI Then
						GUICtrlSetState($nLblWLNoApi, $GUI_HIDE)
						GUICtrlSetState($nLblWLNot, $GUI_SHOW)
					EndIf
				EndIf
			EndIf
		Else
			$hWiFiGUI = $hConfWiFiGUI
		EndIf
		
		If $bSwitchGUI Or $hLastConfGUI <> $hWiFiGUI Then SwitchConfGUI($hWiFiGUI)
	EndIf
EndFunc


;**********************************************************************
; Get the current WiFi service state
;**********************************************************************
Func UpdateWiFiState()
	Debug("IN: UpdateWiFiState")
	
	Local $sWiFiSrv = "wzcsvc"
	If $bIsVista Then $sWiFiSrv = "wlansvc"
	
	Local $nState = -1
	
	If Not IsServiceInstalled($sWiFiSrv) Then
		$nState = 0
	ElseIf Not IsServiceRunning($sWiFiSrv) Then
		$nState = 1
	Else
		$nState = 2
	EndIf
	
	If $nState <> $nLastWiFiSrvState Then
		Switch $nState
			Case 0
				GUICtrlSetData($nLblPreWiFiCurState, $sServiceNotInst)
				GUICtrlSetBkColor($nLblPreWiFiCurState, $nClrSvcStop)
				SetODBtnData($nBtnPreWiFi, $sServiceStart, -1, -1, FALSE)
			Case 1
				GUICtrlSetData($nLblPreWiFiCurState, $sServiceStopped)
				GUICtrlSetBkColor($nLblPreWiFiCurState, $nClrSvcStop)
				GUICtrlSetData($nBtnPreWiFi, $sServiceStart)
				SetODBtnData($nBtnPreWiFi, $sServiceStart, -1, -1, FALSE)
				
				GUICtrlSetData($nLblWiFiCurState, $sServiceStopped)
				GUICtrlSetBkColor($nLblWiFiCurState, $nClrSvcStop)
				SetODBtnData($nBtnWifi, $sServiceStart, -1, -1, FALSE)
			Case 2
				GUICtrlSetData($nLblPreWiFiCurState, $sServiceStarted)
				GUICtrlSetBkColor($nLblPreWiFiCurState, $nClrSvcStart)
				SetODBtnData($nBtnPreWiFi, $sServiceStop, -1, -1, FALSE)
				
				GUICtrlSetData($nLblWiFiCurState, $sServiceStarted)
				GUICtrlSetBkColor($nLblWiFiCurState, $nClrSvcStart)
				SetODBtnData($nBtnWifi, $sServiceStop, -1, -1, FALSE)
		EndSwitch
		
		$nLastWiFiSrvState = $nState
	EndIf
	
	Return $nState
EndFunc


;**********************************************************************
; Start/Stop/Install WiFi
;**********************************************************************
Func StartWiFi($bFromGUI = TRUE)
	Debug("IN: StartWiFi")
	
	If Not $bWLAPIOK Then Return
	
	Local $nError			= 0
	Local $nResult			= 0
	Local $sWiFiSrv			= "wzcsvc"
	Local $sWiFiStart		= $sWiFiStartSrv
	Local $sWiFiEnd			= $sWiFiStopSrv
	Local $sWiFiStartErr	= $sWiFiErrStart2
	Local $sWiFiStopErr		= $sWiFiErrStop
	
	If $bIsVista Then
		$sWiFiSrv		= "wlansvc"
		$sWiFiStart		= $sWiFiStartSrv2
		$sWiFiEnd		= $sWiFiStopSrv2
		$sWiFiStartErr	= $sWiFiErrStart4
		$sWiFiStopErr	= $sWiFiErrStop2
	EndIf

	; 1st check if WiFi service is running
	Local $bWiFiRunning = IsServiceRunning($sWiFiSrv)
	If $bWiFiRunning Then
		Debug("IN: WiFi service (" & $sWiFiSrv & ") is running")
	Else
		Debug("IN: WiFi service (" & $sWiFiSrv & ") is stopped")
	EndIf
	
	If $bWiFiRunning Then
		If $bFromGUI Then
			If MsgBoxEx(36 + 256, $sQUESTION, $sWiFiStop, $hMainGUI) = 7 Then
				Return 1
			Else
				GUICtrlSetData($nLblState, $sWiFiEnd)
				$bHelperRun = FALSE
					
				If StopSvc($sWiFiSrv) = 0 Then
					$nError = GetLastError()
					MsgBoxEx(16, $sERROR, $sWiFiStopErr & "!" & @LF & GetErrStr($nError), $hConfGUI)				
					Return 0
				Else
					GUICtrlSetData($nLblState, $sServiceInstFinish)
					Sleep(500)
					
					EnumWlanAdapters()			
					UpdateWiFiInfo(GUICtrlRead($nComboNA), TRUE)			
					UpdateWiFiTab(GUICtrlRead($nComboNA))
					
					Return 1
				EndIf
			EndIf
		EndIf
	Else
		; 2nd check if NDISUIO driver is OK
		If $bIsWinPE Then
			; Sometimes there is a problem it seems preinstalled but is wrong installed
			If IsCompInstalled("nettrans", "ms_ndisuio") Then
				Debug("IN: ""NDIS Usermode I/O"" driver is installed")
			Else
				Debug("IN: ""NDIS Usermode I/O"" driver is not installed")
				If $bIsWinPE Then ; No installation under normal OS should be needed
					If Not FileExists(@WindowsDir & "\inf\ndisuio.inf") Then
						If $hMainGUI <> 0 Then GUISetState(@SW_ENABLE, $hMainGUI)
						If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInf & "!" & @LF & $sWiFiInstSrv & ".", $hConfGUI)
						Return 0
					EndIf
				
					If $bFromGUI Then
						GUICtrlSetData($nLblState, $sWiFiInstSrv)
					Else
						GUICtrlSetData($nLblStartTxt, $sWiFiInstSrv)
					EndIf
				
					Debug("IN: Installing ""NDIS Usermode I/O"" driver...")
					$nResult = RunCMD($sDefNetUtil & " -c p -i ms_ndisuio")
					If $nResult <> 0 Then
						$bHelperRun = FALSE
						If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInst & " (" & $nResult & ")!", $hConfGUI)
						Return 0
					EndIf
				EndIf
			EndIf
		EndIf
		
		; 3rd check if NDISUIO driver is running
		If IsServiceRunning("ndisuio") Then
			Debug("IN: ""NDIS Usermode I/O"" driver is running")
		Else
			Debug("IN: ""NDIS Usermode I/O"" driver is stopped")
			$nResult = StartSvc("ndisuio")
		
			If $nResult = 0 Then
				$nError = GetLastError()
				$bHelperRun = FALSE
				If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrStart & "!" & @LF & GetErrStr($nError), $hConfGUI)				
				Return 0
			EndIf
		EndIf	

		If $bFromGUI Then
			GUICtrlSetData($nLblState, $sWiFiChkDrv)
		Else
			GUICtrlSetData($nLblStartTxt, $sWiFiChkDrv)
		EndIf
			
		; 4th check if Native WiFi filter driver is OK for OS >= Vista, PE2.X
		If $bIsVista Then			
			Local $bWiFiFilterInst	= FALSE
			Local $bWiFiFilterRun	= FALSE
			
			If $bIsWinPE Then
				If IsCompInstalled("netservice", "ms_nativewifip") Then
					Debug("IN: ""Native WiFi Filter"" driver is installed")
				Else
					Debug("IN: ""Native WiFi Filter"" driver is not installed")
					If $bIsWinPE Then
						If Not FileExists(@WindowsDir & "\inf\netnwifi.inf") Then
							If $hMainGUI <> 0 Then GUISetState(@SW_ENABLE, $hMainGUI)
							If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInf2 & "!" & @LF & $sWiFiErrInst2 & ".", $hConfGUI)
							Return 0
						EndIf
						
						If $bFromGUI Then
							GUICtrlSetData($nLblState, $sWiFiInstSrv3)
						Else
							GUICtrlSetData($nLblStartTxt, $sWiFiInstSrv3)
						EndIf
						
						Debug("IN: Installing ""Native WiFi Filter"" driver...")
						$nResult = RunCMD($sDefNetUtil & " -c s -i ms_nativewifip")
						If $nResult <> 0 Then
							If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInst2 & " (" & $nResult & ")!", $hConfGUI)
							Return 0
						EndIf
					EndIf
				EndIf
			EndIf
			
			If IsServiceRunning("nativewifip") Then
				Debug("IN: ""Native WiFi Filter"" driver is running")
			Else
				Debug("IN: ""Native WiFi Filter"" driver is stopped")
				$nResult = StartSvc("nativewifip")
				If $nResult = 0 Then
					$nError = GetLastError()
					$bHelperRun = FALSE	
					If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrStart3 & "!" & @LF & GetErrStr($nError), $hConfGUI)
				
					Return 0
				EndIf
			EndIf			
		EndIf
		
		; 5th check if WiFi service is already installed
		Local $bWiFiInstalled = IsServiceInstalled($sWiFiSrv)
		If $bWiFiInstalled Then
			Debug("IN: WiFi service (" & $sWiFiSrv & ") is installed")
		Else
			Debug("IN: WiFi service (" & $sWiFiSrv & ") is not installed")
			If $bIsWinPE And Not $bIsWinPE20 Then
				If Not FileExists(@WindowsDir & "\inf\netwzc.inf") Then
					If $hMainGUI <> 0 Then GUISetState(@SW_ENABLE, $hMainGUI)
					If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInf2 & "!" & @LF & $sWiFiErrInst & ".", $hConfGUI)
					Return 0
				EndIf
			
				If FileExists(@SystemDir & "\msxml6.dll") Then
					If $bFromGUI Then
						GUICtrlSetData($nLblState, $sWiFiRegXML)
					Else
						GUICtrlSetData($nLblStartTxt, $sWiFiRegXML)
					EndIf
	
					RegisterFile("msxml6.dll")
				EndIf
				
				StartSvc("eventlog")				
				
				If $bFromGUI Then
					GUICtrlSetData($nLblState, $sWiFiInstSrv2)
				Else
					GUICtrlSetData($nLblStartTxt, $sWiFiInstSrv2)
				EndIf
				
				Debug("IN: Installing ""Wireless Zero Configuration"" service...")
				$nResult = RunCMD($sDefNetUtil & " -c s -i ms_wzcsvc")
				If $nResult <> 0 Then
					If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInst & " (" & $nResult & ")!", $hConfGUI)
					Return 0
				EndIf
				
				; ReCheck if service was properly installed
				If $bFromGUI Then
					GUICtrlSetData($nLblState, $sServiceChkSrv)
				Else
					GUICtrlSetData($nLblStartTxt, $sServiceChkSrv)
				EndIf
				
				Debug("IN: Check if WiFi service (" & $sWiFiSrv & ") was installed successfully...")
				If Not IsServiceInstalled($sWiFiSrv) Then
					If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInst & " !", $hConfGUI)
					Return 0
				EndIf
			EndIf
		EndIf	
	EndIf
	
	; 6th check if WiFi service is running now
	Debug("IN: Check if WiFi service (" & $sWiFiSrv & ") is running...")
	If IsServiceRunning($sWiFiSrv) Then
		Debug("IN: WiFi service (" & $sWiFiSrv & ") is running")
		If $bFromGUI Then
			GUICtrlSetData($nLblState, $sWiFiEnd)
			$bHelperRun = FALSE
			
			If StopSvc($sWiFiSrv) = 0 Then
				$nError = GetLastError()
				MsgBoxEx(16, $sERROR, $sWiFiStopErr & "!" & @LF & GetErrStr($nError), $hConfGUI)				
				Return 0
			EndIf
		Else
			If $bIsWinPE And Not $bIsWinPE20 Then
				Debug("IN: Restart WiFi service (" & $sWiFiSrv & ")...") 
				StopSvc($sWiFiSrv)		
				If FileExists(@SystemDir & "\rsaenh.dll") Then RegisterFile(@SystemDir & "\rsaenh.dll")
				StartSvc($sWiFiSrv)
			EndIf
		EndIf		
	Else
		Debug("IN: WiFi service (" & $sWiFiSrv & ") is stopped")
		If $bFromGUI Then
			GUICtrlSetData($nLblState, $sWiFiStart)
		Else
			GUICtrlSetData($nLblStartTxt, $sWiFiStart)
			$bHelperRun = TRUE
		EndIf

		If $bIsWinPE20 Then
			;If StartSvc("nativewifip") = 0 Then
			If StartSvc($sWiFiSrv) = 0 Then
				$nError = GetLastError()
				$bHelperRun = FALSE	
				If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrStart3 & "!" & @LF & GetErrStr($nError), $hConfGUI)
			
				Return 0
			EndIf
		EndIf
		
		$bHelperRun = FALSE
		
		Debug("IN: Next check if WiFi service (" & $sWiFiSrv & ") is running now...")
		If Not IsServiceRunning($sWiFiSrv) Then
			If FileExists(@SystemDir & "\rsaenh.dll") And $bIsWinPE And Not $bIsWinPE20 Then RegisterFile(@SystemDir & "\rsaenh.dll")
			
			If StartSvc($sWiFiSrv) = 0 Then
				$nError = GetLastError()
				If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiStartErr & "!" & @LF & GetErrStr($nError), $hConfGUI)
				
				Return 0
			EndIf		
		EndIf
	EndIf
	
	If $bFromGUI Then
		GUICtrlSetData($nLblState, $sServiceInstFinish)
		Sleep(500)
	EndIf

	EnumWlanAdapters()
	
	If $bFromGUI Then
		If $hLastConfGUI = $hConfWiFiGUI Then
			UpdateWiFiInfo(GUICtrlRead($nComboNA), TRUE)
		Else
			UpdateWiFiInfo(GUICtrlRead($nComboNA))
		EndIf
		UpdateWiFiTab(GUICtrlRead($nComboNA))
	EndIf
	
	Return 1
EndFunc


;**********************************************************************
; Convert multibyte string (ie. SSID) to wide character
;**********************************************************************
Func StringToUni($sString, ByRef $sUnicodeString)
	Local $nCharsNeeded = MultiByteToWideChar(65001, 0, $sString, -1, 0, 0)

	Local $stBuffer = DllStructCreate("wchar[" & $nCharsNeeded & "]")
	
	Local $nResult = MultiByteToWideChar(65001, 0, $sString, -1, DllStructGetPtr($stBuffer), $nCharsNeeded)
	
	$sUnicodeString = ""
	If $nResult > 0 Then $sUnicodeString = DllStructGetData($stBuffer, 1)
	
	$stBuffer = 0
	
	Return $nResult
EndFunc


;**********************************************************************
; Convert wider character string (ie. SSID) to multibyte
;**********************************************************************
Func StringFromUni($sString, ByRef $sMultiByteString)
	Local $stString = DllStructCreate("wchar[" & (StringLen($sString) + 1) & "]")
	DllStructSetData($stString, 1, $sString)
	
	Local $nBytesNeeded = WideCharToMultiByte(65001, 0, DllStructGetPtr($stString), -1, 0, 0, 0, 0)
	
	Local $stBuffer = DLLStructCreate("char[" & $nBytesNeeded & "]")
	
	; CP_UTF8 = 65001
	Local $nResult = WideCharToMultiByte(65001, 0, DllStructGetPtr($stString), -1, DllStructGetPtr($stBuffer), $nBytesNeeded, 0, 0)
	
	$sMultiByteString = ""
	If $nResult > 0 Then $sMultiByteString = DllStructGetData($stBuffer, 1)
	
	$stBuffer = 0
	$stString = 0
	
	Return $nResult
EndFunc


;**********************************************************************
; Scan for available wireless network (bRec = Recursive call)
;**********************************************************************
Func EnumWlanAvailNetworks($sDesc, $bScan = FALSE, $nLV = 0)
	If $hWlanapi = -1 Then Return
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return
	
	Local $bTray = TRUE
	If $nLV = 0 Then
		$nLV = $nLVWLAvail
		$bTray = FALSE
	EndIf
	
	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)

	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return
	
	Local $hWlan	= DllStructGetData($stHandle, 1)
	Local $stGUID	= DllStructCreate($sGUID)

	CreateGUIDFromString($stGUID, $arWLANList[$i])
	Local $pGUID	= DllStructGetPtr($stGUID)
	
	If $bScan Then
		WlanScan($hWlan, $pGUID, 0, 0, 0)
		Sleep(1500)
	EndIf
	
	GUICtrlSendMsg($nLV, $LVM_DELETEALLITEMS, 0, 0)
	
	Local $sProfileConnected	= ""
	Local $sSSID				= ""
	Local $sMAC  				= ""
	Local $stSize				= DllStructCreate("dword")
	Local $stSizeWCA			= DllStructCreate("dword")
	Local $stPtrWCA				= DllStructCreate("ptr")
	Local $stWCA
	Local $bAdhoc				= FALSE
	Local $nSignal				= 0
	$arWLAVNList[0][0]			= 0
	
	; Query current connection
	GetWlanCurCon("", $sProfileConnected, $sSSID, $sMAC, $bAdhoc, $nSignal, $hWlan, $pGUID)
	
	Local $stANLPtr = DllStructCreate("ptr") ; Get the pointer to the profile info list memory address
	Local $nFlags	= 0x00000003
	
	If Not $bTray Then GUISetState(@SW_LOCK, $hConfWiFiGUI)
	If $nLV = $nLVWLAvailTray Then GUISetState(@SW_LOCK, $hTrayWiFiGUI)		
			
	If WlanGetAvailableNetworkList($hWlan, $pGUID, $nFlags, 0, DllStructGetPtr($stANLPtr)) = $ERROR_SUCCESS Then
		Local $pANL		= DllStructGetData($stANLPtr, 1)
		Local $stCount	= DllStructCreate("dword", $pANL)

		If DllStructGetData($stCount, 1) > 0 Then
			Local $sProfile		= ""
			$sSSID				= ""
			$nSignal			= 0
			Local $bSecured		= 0
			Local $nFlags		= 0
			Local $nType		= 0
			Local $sType		= ""
			Local $k, $n, $stANL
			Local $nIdx			= 0
			Local $nIdxFound	= 0
			Local $nPhys, $sPhys, $nPhysNr
			Local $bFound		= FALSE
			Local $sChk			= ""
			Local $bFL			= FALSE
			Local $stLVI
			Local $sText
			Local $nBitType		; (1=0%, 2=20%, 4=40%, 8=60%, 16=80%, 32=100%, 64=secured, 128=adhoc, 256=connected, 512=connectable, 1024/2048=authenticating, 4096=preferred)
			
			$nCurConItem = -1
			
			$pANL += 8 ; -> 8 bytes: dwNumberOfItem + dwIndex
			
			For $i = 1 To DllStructGetData($stCount, 1)
				$stANL = DllStructCreate($sWLAN_AVAILABLE_NETWORK, $pANL)
				$pANL += DllStructGetSize($stANL)
				
				$sProfile	= DllStructGetData($stANL, 1)
				
				$sSSID = DllStructGetData($stANL, 3)
				
				$nType		= DllStructGetData($stANL, 4) ; 1 = Infrastructure, 2 = AdHoc, 3 = Any
				$nPhys		= DllStructGetData($stANL, 9)
				$nSignal	= DllStructGetData($stANL, 11)
				$nFlags		= DllStructGetData($stANL, 15)
				
				$sPhys = ""
				$nPhysNr = 0
				Switch $nPhys
					Case 10
						$sPhys = "AX"
						$nPhysNr = 6
					Case 9
						$sPhys = "AD"
					Case 8
						$sPhys = "AC"
						$nPhysNr = 5
					Case 7
						$sPhys = "N"
						$nPhysNr = 4
					Case 6
						$sPhys = "G"
						$nPhysNr = 3
					Case 5
						$sPhys = "B"
						$nPhysNr = 2
					Case 4
						$sPhys = "A"
						$nPhysNr = 1
				EndSwitch
				
				$nBitType	= 1
				
				If $nType = 2 Then
					If $sProfile <> "" Then
						$sSSID = $sProfile
						If Not $bIsVista Then $sSSID = StringTrimRight($sSSID, 6) ; Remove "-adhoc" from display name for XP/2003 systems
					EndIf
					
				EndIf
				
				If $sProfile <> "" And $sSSID = "" And $nType <> 2 Then
					If $bIsVista Then
						$sSSID = $sProfile
					Else
						ContinueLoop
					EndIf
				EndIf
				
				If $sSSID = "" Then $sSSID = $sWiFiUnnamed
							
				Switch $nSignal
					Case 1 To 20
						$nBitType = 2
					Case 21 To 40
						$nBitType = 4
					Case 41 To 60
						$nBitType = 8
					Case 61 To 80
						$nBitType = 16
					Case 81 To 100
						$nBitType = 32
				EndSwitch
			
				If DllStructGetData($stANL, 6) Then $nBitType = BitOr($nBitType, 512) ; Connectable network		
				$bSecured		= DllStructGetData($stANL, 12)
				
				If BitAnd($nFlags, $WLAN_AVAILABLE_NETWORK_CONNECTED) Then
					$nLastWiFiState = 1
					$nBitType = BitOr($nBitType, 256)
					
					; If connected get correct physical type for which the current connection is made because the AP can support more/faster/newer types
					If WlanQueryInterface($hWlan, $pGUID, 7, 0, DllStructGetPtr($stSizeWCA), DllStructGetPtr($stPtrWCA), 0, FALSE) = $ERROR_SUCCESS Then
						$stWCA = DllStructCreate($sWLAN_CONNECTION_ATTRIBUTES, DllStructGetData($stPtrWCA, 1))
						$nPhysNr = 0
						Switch DllStructGetData($stWCA, 8)
							Case 10
								$sPhys = "AX"
								$nPhysNr = 6
							Case 9
								$sPhys = "AD"
							Case 8
								$sPhys = "AC"
								$nPhysNr = 5
							Case 7
								$sPhys = "N"
								$nPhysNr = 4
							Case 6
								$sPhys = "G"
								$nPhysNr = 3
							Case 5
								$sPhys = "B"
								$nPhysNr = 2
							Case 4
								$sPhys = "A"
								$nPhysNr = 1
						EndSwitch
					EndIf
				EndIf
				
				If BitAnd($nFlags, $WLAN_AVAILABLE_NETWORK_HAS_PROFILE) Then $nBitType = BitOr($nBitType, 4096)
				
				$bFound = FALSE
				For $n = 1 To $arWLAVNList[0][0]
					If ($arWLAVNList[$n][2] = $sProfile And $sProfile <> "") Or ($arWLAVNList[$n][1] = $sSSID And $sProfile = "")  Then
						$bFound = TRUE
						$nIdxFound = $n
						ExitLoop
					EndIf
				Next
				
				If $bFound Then
					If $nSignal > $arWLAVNList[$nIdxFound][0] Then $arWLAVNList[$nIdxFound][0] = $nSignal			
					$arWLAVNList[$nIdxFound][5] = BitOr($arWLAVNList[$nIdxFound][5], $nBitType)
					If $arWLAVNList[$nIdxFound][4] = "" And $sPhys <> "" Then $arWLAVNList[$nIdxFound][4] = $sPhys
				Else
					$nAuth		= 0
					$sAuth		= $sWiFiNone
					$nCiph		= 0
					$sCiph		= $sWiFiNone
				
					If $bSecured Then
						$nAuth = DllStructGetData($stANL, 13)
						$nCiph = DllStructGetData($stANL, 14)						
						GetAuthCiphStr($nAuth - 1, $nCiph, $sAuth, $sCiph)						
						$nBitType = BitOr($nBitType, 64)
					EndIf
					
					If $nType = 2 Then $nBitType = BitOr($nBitType, 128)

					$arWLAVNList[0][0] += 1
					$n = $arWLAVNList[0][0]
					$arWLAVNList[$n][0] = $nSignal
					$arWLAVNList[$n][1] = $sSSID
					$arWLAVNList[$n][2] = $sProfile
					$arWLAVNList[$n][3] = $sAuth
					$arWLAVNList[$n][4] = $sPhys
					$arWLAVNList[$n][5] = $nBitType
					$arWLAVNList[$n][6] = $sSSID
					$arWLAVNList[$n][7] = $sProfile
					
					; If conversion was successfull then this should be filled with the unicode name
					If StringToUni($sSSID, $sText) > 0 Then $arWLAVNList[$n][6] = $sText
					If StringToUni($sProfile, $sText) > 0 Then $arWLAVNList[$n][7] = $sText
				EndIf
			Next			
		EndIf
		
		WlanFreeMemory(DllStructGetData($stANLPtr, 1))
	EndIf
	
	WlanCloseHandle($hWlan, 0)
	
	; Create listview items
	Local $nIcon
	
	For $i = 1 To $arWLAVNList[0][0]
		$nSignal = $arWLAVNList[$i][0]
		Switch $nSignal
			Case 1 To 20
				$nIcon = 1
			Case 21 To 40
				$nIcon = 2
			Case 41 To 60
				$nIcon = 3
			Case 61 To 80
				$nIcon = 4
			Case 81 To 100
				$nIcon = 16
			Case Else
				$nIcon = 0
		EndSwitch
		
		$nSignal	= $nSignal & "%"
		$arWLAVNList[$i][0] = $nSignal
		
		$sText		= $arWLAVNList[$i][1]
		
		If $arWLAVNList[$i][6] <> $arWLAVNList[$i][1] Then $sText = $arWLAVNList[$i][6]
		If $arWLAVNList[$i][6] <> $arWLAVNList[$i][7] And $arWLAVNList[$i][7] <> "" Then $sText = $arWLAVNList[$i][7]		
		
		$sAuth		= $arWLAVNList[$i][3]
		$sPhys		= $arWLAVNList[$i][4]
		$nBitType	= $arWLAVNList[$i][5]
		
		$bFL = FALSE
		If BitAnd($nBitType, 256) Then $bFL = TRUE ; If connected then insert SSID on First Line 
		
		If $nLV = $nLVWLAvailTray Then
			$nIdx = CreateAdvLVItem($nBitType & "|" & $sText, $nLV, "", $nIcon, $bFL)
		Else
			$nIdx = CreateAdvLVItem($nSignal & "|" & $sText & "|" & $sAuth & "||" & $sPhys & "|", $nLV, "", $nIcon, $bFL)
		EndIf
	
		; *** Set icons ***
		If $nLV <> $nLVWLAvailTray Then
			If $sProfileConnected <> "" And $sProfileConnected == $sText Then
				$nCurConItem = $nIdx
				Debug("check2:" & $sProfileConnected)
				If BitAnd($nBitType, 128) Then ; Adhoc network
					SetAdvLVItemIcon($nLV, $nIdx, 3, 10)
				Else
					SetAdvLVItemIcon($nLV, $nIdx, 3, 8)
				EndIf
				SetAdvLVItemIcon($nLV, $nIdx, 5, 11)
			Else
				If BitAnd($nBitType, 128) Then ; Adhoc network
					SetAdvLVItemIcon($nLV, $nIdx, 3, 9)
				Else
					SetAdvLVItemIcon($nLV, $nIdx, 3, 7)
				EndIf
					
				If $arWLAVNList[$i][2] <> "" Then SetAdvLVItemIcon($nLV, $nIdx, 5, 11)
			EndIf
							
			If BitAnd($nBitType, 64) Then ; Secured network
				SetAdvLVItemIcon($nLV, $nIdx, 2, 5)
			Else
				SetAdvLVItemIcon($nLV, $nIdx, 2, 6)
			EndIf
			
			If Not BitAnd($nBitType, 512) Then
				;$stError = DllStructCreate("wchar[260]")
				;WlanReasonCodeToString(DllStructGetData($stANL, 7), 260, DllStructGetPtr($stError), 0)
				SetAdvLVItemIcon($nLV, $nIdx, 0, 18)
			EndIf
		EndIf
	Next
	
	If Not $bTray Then GUISetState(@SW_UNLOCK, $hConfWiFiGUI)
	If $nLV = $nLVWLAvailTray Then GUISetState(@SW_UNLOCK, $hTrayWiFiGUI)
	
	If Not $bTray Then
		SetODBtnState($nBtnWLCon, $GUI_DISABLE)
		$nLVWALast = -1
	EndIf
EndFunc


;**********************************************************************
; Connect to available WiFi network
;**********************************************************************
Func ConnectWlan($sDesc, $bNotRec = TRUE, $nLV = 0, $nCol = 1)
	If $hWlanapi = -1 Then Return -1
	
	Local $c, $k, $i = IsWLANI($sDesc)
	If $i = 0 Then Return -1
	
	If $nLV = 0 Then $nLV = $nLVWLAvail

	Local $nResult = -1
	Local $nCurSel = GUICtrlSendMsg($nLV, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	
	If $nCurSel > -1 Then
		Local $sText	= GetLVIText($nLV, $nCurSel, $nCol)
		Local $stText	= DllStructCreate("wchar[260]")
		Local $bSecure	= FALSE
		Local $bHasProf	= FALSE
		Local $bAdhoc	= FALSE
		Local $bHidden	= FALSE
		Local $bFromTray= FALSE
		Local $nBitType	= 0
		Local $sMbSSID, $sUniSSID
		
		If $nLV = $nLVWLAvailTray Then
			$bFromTray = TRUE
			$nBitType = Number(GetLVIText($nLV, $nCurSel, 0))
		EndIf
		
		If $sText <> "" Then
			Local $nImage = 0
			$sUniSSID = ""			
			
			If StringFromUni($sText, $sMbSSID) > 0 Then
				$sUniSSID = $sText ; Save SSID as it is displayed
				$sText = $sMbSSID
			EndIf
		
			If $nLV = $nLVWLAvailTray Then
				If BitOr($nBitType, 128) Then $bAdhoc = TRUE
				If BitOr($nBitType, 64) Then $bSecure = TRUE
			Else
				$nImage = GetLVIImage($nLV, $nCurSel, 3)
				If $nImage = 9 Or $nImage = 10 Then $bAdhoc = TRUE
				If GetLVIImage($nLV, $nCurSel, 2) = 5 Then $bSecure = TRUE
			EndIf
			
			Local $stVersion	= DllStructCreate("dword")
			Local $stHandle		= DllStructCreate("dword")
			DllStructSetData($stHandle, 1, 0)
			
			Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
			If $nResult <> $ERROR_SUCCESS Then Return $nResult
			
			Local $hWlan	= DllStructGetData($stHandle, 1)
			Local $stGUID	= DllStructCreate($sGUID)
			
			CreateGUIDFromString($stGUID, $arWLANList[$i])
			
			If $bIsWin8 Then ; Profile is saved in unicode
				DllStructSetData($stText, 1, $sUniSSID)
			Else
				DllStructSetData($stText, 1, $sText)
			EndIf
			
			; Try to get data from profile, if none exists then create one
			Local $stPtr = DllStructCreate("ptr")
			If WlanGetProfile($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stText), 0, DllStructGetPtr($stPtr), 0, 0) = $ERROR_SUCCESS Then
				Local $stXML	= DllStructCreate("wchar[" & (wcslen(DllStructGetData($stPtr, 1)) + 1) & "]", DllStructGetData($stPtr, 1))					
				Local $sXML		= DllStructGetData($stXML, 1)
				Local $sSSID	= GetXmlStr($sXML, "name")
				DllStructSetData($stText, 1, $sSSID)
				$bHasProf = TRUE
			EndIf

			; If not recursively called from WiFi connection dialog, otherwise it would result in a loop
			If $bNotRec Then
				If Not $bHasProf Then
					Local $stANLPtr = DllStructCreate("ptr") ; Get the pointer to the profile info list memory address
					Local $nFlags	= 0x00000003 ; All profiles - hidden and adhoc
					
					$nResult = WlanGetAvailableNetworkList($hWlan, DllStructGetPtr($stGUID), $nFlags, 0, DllStructGetPtr($stANLPtr))
					If $nResult = $ERROR_SUCCESS Then
						Local $pANL		= DllStructGetData($stANLPtr, 1)
						Local $stCount	= DllStructCreate("dword", $pANL)
						Local $sSSID = "", $sProfile = "", $sAuth = "", $sCiph = "", $stANL
						
						$pANL += 8
						
						For $c = 1 To DllStructGetData($stCount, 1)
							$stANL = DllStructCreate($sWLAN_AVAILABLE_NETWORK, $pANL)
							$pANL += DllStructGetSize($stANL)
							
							$sProfile	= DllStructGetData($stANL, 1)
							$sSSID		= DllStructGetData($stANL, 3)
							$nType		= DllStructGetData($stANL, 4)
							$bSecure	= DllStructGetData($stANL, 12)
							
							If $nType = 2 And $sProfile <> "" Then $sSSID = $sProfile
							
							$bHidden	= FALSE
							If $sSSID = "" Then
								$sSSID = $sWiFiUnnamed
								$bHidden = TRUE
							EndIf
							
							If $sSSID == $sText Then
								If $nType = 2 Then $bAdhoc = TRUE
								$nAuth = DllStructGetData($stANL, 13)
								$nCiph = DllStructGetData($stANL, 14)
								
								GetAuthCiphStr($nAuth - 1, $nCiph, $sAuth, $sCiph, TRUE)
								
								$arCurConn[0] = $sSSID
								$arCurConn[1] = $sAuth
								$arCurConn[2] = $sCiph
								$arCurConn[3] = $nType
								$arCurConn[4] = $sUniSSID
								
								If $bSecure Then
									CreateConnGUI($bHidden, TRUE, $bFromTray)
									$nResult = -9999
								Else
									If $bHidden Then
										CreateConnGUI($bHidden, FALSE, $bFromTray)
										$nResult = -9999
									Else
										AddWlanProfile($sDesc, "")
									EndIf
								EndIf								
								
								ExitLoop
							EndIf
						Next					
						
						WlanFreeMemory(DllStructGetData($stANLPtr, 1))

						If $nResult = -9999 Then
							WlanCloseHandle($hWlan, 0)
							 Return -9999
						EndIf
					EndIf
				EndIf
			EndIf
				
			If $bAdhoc And Not $bIsVista Then DllStructSetData($stText, 1, DllStructGetData($stText, 1) & "-adhoc")
			
			Local $stConnParams = DllStructCreate($sWLAN_CONNECTION_PARAMETERS)
			DllStructSetData($stConnParams, 1, 0)
			DllStructSetData($stConnParams, 2, DllStructGetPtr($stText))
			DllStructSetData($stConnParams, 3, 0)
			DllStructSetData($stConnParams, 4, 0)
			DllStructSetData($stConnParams, 5, 3)
			DllStructSetData($stConnParams, 6, 0)
			
			$nResult = WlanConnect($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stConnParams), 0)
			
			If $nResult <> $ERROR_SUCCESS Then MsgBoxEx(0, "WlanConnect Error", "Error: " & $nResult & @LF & GetErrStr($nResult), $hConfWiFiGUI)
			
			WlanCloseHandle($hWlan, 0)
		EndIf
	EndIf
	
	Return $nResult
EndFunc


;**********************************************************************
; Disconnect to available WiFi network
;**********************************************************************
Func DisconnectWlan($sDesc)
	If $hWlanapi = -1 Then Return
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return
	
	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)

	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return
	
	Local $hWlan	= DllStructGetData($stHandle, 1)
	Local $stGUID	= DllStructCreate($sGUID)
			
	CreateGUIDFromString($stGUID, $arWLANList[$i])
			
	WlanDisconnect($hWlan, DllStructGetPtr($stGUID), 0)

	WlanCloseHandle($hWlan, 0)
EndFunc


;**********************************************************************
; Get the preferred wireless networks
;**********************************************************************
Func EnumWlanPrefNetworks($sDesc, $bReset = TRUE)
	If $hWlanapi = -1 Then Return
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return

	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)
	
	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return

	Local $hWlan	= DllStructGetData($stHandle, 1)
	Local $stGUID	= DllStructCreate($sGUID)

	CreateGUIDFromString($stGUID, $arWLANList[$i])
	
	Local $sProfileConnected	= ""
	Local $sSSID				= ""
	Local $sMAC					= ""
	Local $stSize				= DllStructCreate("dword")
	Local $stPtr				= DllStructCreate("ptr")
	Local $nLen					= 0
	Local $bAdhoc				= FALSE
	Local $nSignal				= 0
	
	; Query current connection
	GetWlanCurCon("", $sProfileConnected, $sSSID, $sMAC, $bAdhoc, $nSignal, $hWlan, DllStructGetPtr($stGUID))
	
	Local $stPILPtr = DllStructCreate("dword") ; Get the pointer to the profile info list memory address
	
	$nResult = WlanGetProfileList($hWlan, DllStructGetPtr($stGUID), 0, DllStructGetPtr($stPILPtr))
	If $nResult = $ERROR_SUCCESS Then
		GUICtrlSendMsg($nLVWLPref, $LVM_DELETEALLITEMS, 0, 0)
		
		Local $pPIL			= DllStructGetData($stPILPtr, 1)
		Local $stCount		= DllStructCreate("dword", $pPIL)
		Local $stString		= DllStructCreate("wchar[256]")
		
		If DllStructGetData($stCount, 1) > 0 Then
			Local $k, $nIdx, $stPIL
			Local $sProfName, $sUniProfName, $stXML, $sXML, $sSSID, $sType, $sMode
			
			$pPIL += 8
			
			For $i = 1 To DllStructGetData($stCount, 1)
				$stPIL = DllStructCreate($sWLAN_PROFILE_INFO, $pPIL)
				$pPIL += DllStructGetSize($stPIL)
				
				DllStructSetData($stString, 1, DllStructGetData($stPIL, 1))
				
				$stPtr = DllStructCreate("ptr")
				
				If WlanGetProfile($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stString), 0, DllStructGetPtr($stPtr), 0, 0) = $ERROR_SUCCESS Then
					$stXML		= DllStructCreate("wchar[" & (wcslen(DllStructGetData($stPtr, 1)) + 1) & "]", DllStructGetData($stPtr, 1))					
					$sXML		= DllStructGetData($stXML, 1)
					$sProfName	= DllStructGetData($stString, 1)
					$sType		= GetXmlStr($sXML, "connectiontype")
					$sMode		= GetXmlStr($sXML, "connectionMode")
					
					If $sMode = "" Then $sMode = "auto"
					
					WlanFreeMemory(DllStructGetData($stPtr, 1))
					
					If $sType = "IBSS" And Not $bIsVista Then $sProfName = StringTrimRight($sProfName, StringLen("-adhoc"))
					
					; Win8 and higher save profile as unicode string so we just convert it for older OS
					If $bIsWin8 = FALSE Then
						If StringToUni($sProfName, $sUniProfName) > 0 Then $sProfName = $sUniProfName
					EndIf
					
					$nIdx = CreateAdvLVItem("|" & $sProfName & "|" & $sMode, $nLVWLPref, "", -1, FALSE)
					
					If $sType = "ESS" Then
						If $sProfName == $sProfileConnected Then
							SetAdvLVItemIcon($nLVWLPref, $nIdx, 0, 1)
						Else
							SetAdvLVItemIcon($nLVWLPref, $nIdx, 0, 0)
						EndIf
					Else
						If $sProfName == $sProfileConnected Then
							SetAdvLVItemIcon($nLVWLPref, $nIdx, 0, 3)
						Else
							SetAdvLVItemIcon($nLVWLPref, $nIdx, 0, 2)
						EndIf
					EndIf
				EndIf
			Next
		EndIf
			
		WlanFreeMemory(DllStructGetData($stPILPtr, 1))
		
		If $bReset Then
			SetODBtnState($nBtnWLDel, $GUI_DISABLE)
			SetODBtnState($nBtnWLEdit, $GUI_DISABLE)
			SetODBtnState($nBtnWLExport, $GUI_DISABLE)
			SetODBtnState($nBtnWLDown, $GUI_DISABLE)
			SetODBtnState($nBtnWLUp, $GUI_DISABLE)
			$nLVWLast = -1
		EndIf
	EndIf
	
	WlanCloseHandle($hWlan, 0)
EndFunc


;**********************************************************************
; CreateAuthGUI()
;**********************************************************************
Func CreateAuthGUI($bEdit = FALSE, $sProfile = "", $sSSID = "", $sAuth = "", $sEnc = "", $sMode = "manual", $sType = "ESS", $sHidden = "false")
	Local $arPos = WinGetPos($hMainGUI)
	GUISetState(@SW_DISABLE, $hMainGUI)
	
	Local $i, $sAuthData = "|"
	
	For $i = 0 To 8
		If $arAuthType[$i][0] <> "" Then $sAuthData &= $arAuthType[$i][2] & "|"
	Next
	
	Local $sAuthDataDef = $arAuthType[0][2]
	If $sAuth <> "" Then $sAuthDataDef = $sAuth
	
	Local $nH = 240
	Local $nY = 0
	If $bEdit Then
		$nH = 265
		$nY = 25
	EndIf
	
	$hSubGUI	= CreateGUI($sTWiFiProp, 360, $nH, -1, -1, BitOr($WS_POPUPWINDOW, $WS_DLGFRAME), _
									BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME), $hMainGUI)
	GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
	SendMessage($hSubGUI, $WM_SETFONT, $hGlobalFont, 1)
	GUISetBkColor($nClrGUIBkWiFi)
	
	If $bIconLib Then
		GUISetIcon($sIconLib, 45)
	Else
		GUISetIcon(@AutoItExe, 214)
	EndIf

	$nLblProfile	= CreateCtrlLabel($sLblWiFiProfile & ":", 5, 8, 150, 20)
	$nInpProfile	= CreateCtrlInput($sProfile, 185, 5, 170, 20)
	GUICtrlSetStyle(-1, $ES_READONLY)
	$hInpProfile	= GUICtrlGetHandle($nInpProfile)
	
	If Not $bEdit Then
		GUICtrlSetState($nLblProfile, $GUI_HIDE)
		GUICtrlSetState($nInpProfile, $GUI_HIDE)
	EndIf
	
	$nLblSSID	= CreateCtrlLabel($sLblWiFiSSID & ":", 5, $nY + 8, 150, 20)
	$nInpSSID	= CreateCtrlInput($sSSID, 185, $nY + 5, 170, 20)
	$hInpSSID	= GUICtrlGetHandle($nInpSSID)
	
	$nLblAuth	= CreateCtrlLabel($sLblWiFiAuth & ":", 5, $nY + 33, 150, 20)
	$nComboAuth	= CreateCtrlCombo("", 185, $nY + 30, 170, 20, $CBS_DROPDOWNLIST)
	GUICtrlSetData(-1, $sAuthData, $sAuthDataDef)
	
	$nLblEnc	= CreateCtrlLabel($sLblWiFiEnc & ":", 5, $nY + 58, 140, 20)
	$nComboEnc	= CreateCtrlCombo("", 185, $nY + 55, 170, 20, $CBS_DROPDOWNLIST)
	$nLblKey	= CreateCtrlLabel($sLblWiFiKey & ":", 5, $nY + 83, 150, 20)
	$nInpKey	= CreateCtrlInput("", 185, $nY + 80, 170, 20, BitOr($ES_PASSWORD, $ES_AUTOHSCROLL))
	$hInpKey	= GUICtrlGetHandle($nInpKey)
	$nChkKey	= CreateCtrlCheck($sChkWiFiKey, 5, $nY + 105, 350, 20, -1, -1, $hSubGUI)
	
	$nChkAuto	= CreateCtrlCheck($sChkWiFiAuto, 5, $nY + 130, 350, 20, -1, -1, $hSubGUI)
	If $sType = "IBSS" Then
		GUICtrlSetState(-1, $GUI_UNCHECKED)
		GUICtrlSetState(-1, $GUI_DISABLE)
	ElseIf $sMode = "auto" Then
		GUICtrlSetState(-1, $GUI_CHECKED)
	EndIf
	
	$nChkHidden	= CreateCtrlCheck($sChkWiFiHidden, 5, $nY + 155, 350, 20, -1, -1, $hSubGUI)
	If $sType = "IBSS" Then
		GUICtrlSetState(-1, $GUI_UNCHECKED)
		GUICtrlSetState(-1, $GUI_DISABLE)
	ElseIf $sHidden = "true" Then
		GUICtrlSetState(-1, $GUI_CHECKED)
	EndIf	
	
	$nChkAdhoc	= CreateCtrlCheck($sChkWiFiAdhoc, 5, $nY + 180, 350, 20, -1, -1, $hSubGUI)
	If $sType = "IBSS" Then GUICtrlSetState(-1, $GUI_CHECKED)
	If $bEdit Then GUICtrlSetState(-1, $GUI_DISABLE)
	
	$nBtnAuthOK	= CreateODBtn($sBtnOK, 5, $nY + 210, 170, 25, $arODBtnSub, 2)
	$nBtnAuthCancel	= CreateODBtn($sBtnCancel, 185, $nY + 210, 170, 25, $arODBtnSub, 3)
	
	If $bEdit Then
		GUICtrlSetState($nComboAuth, $GUI_FOCUS)
		GUICtrlSetStyle($nInpSSID, $ES_READONLY)
		GUICtrlSetData($nInpKey, $sHiddenInput)
		$bEditAuth = TRUE
	Else
		GUICtrlSetState($nInpSSID, $GUI_FOCUS)
		$bEditAuth = FALSE
	EndIf
	
	If $sEnc <> "" Then
		GetAuthEnc($sAuth, $sEnc)
	Else
		GetAuthEnc("Open-WEP")
	EndIf
	
	If IsArray($arPos) Then
		Local $nX = GetScaled(150)
		IF $bTabSmall Then $nX = GetScaled(47)
		Local $nY = GetScaled(75)
		If $bEdit Then $nY = GetScaled(100)
		WinMove($hSubGUI, "", $arPos[0] + $nX, $arPos[1] + $nY)
	EndIf
	
	GUISetState(@SW_SHOW, $hSubGUI)
EndFunc


;**********************************************************************
; Show WiFi connection dialog for secured or hidden networks
;**********************************************************************
Func CreateConnGUI($bHidden = FALSE, $bSecure = TRUE, $bFromTray = FALSE)
	If $hWiFiConnGUI <> 0 Then
		GUIDelete($hWiFiConnGUI)
		$hWiFiConnGUI = 0
		DelODBtnGrp($arODBtnConn)
	EndIf
	
	Local $arPos, $hWnd
	
	If $bFromTray Then
		$hWnd = $hTrayWifiGUI
		GUISetState(@SW_DISABLE, $hTrayWifiGUI)
		If BitAnd(WinGetState($hMainGUI), 2) Then GUISetState(@SW_DISABLE, $hMainGUI)
	Else
		$hWnd = $hMainGUI
		GUISetState(@SW_DISABLE, $hMainGUI)
	EndIf
	
	$arPos = WinGetPos($hWnd)
	
	Local $sTWiFiSSID = $arCurConn[4]
	If $sTWiFiSSID = "" Then $sTWiFiSSID = $arCurConn[0]
		
	If $hWiFiConnGUI = 0 Then
		
		$hWiFiConnGUI = CreateGUI($sTWiFiConn & ": " & $sTWiFiSSID, 320, 130, -1, -1, BitOr($WS_CHILD, $WS_POPUPWINDOW, $WS_DLGFRAME), _
									BitOr($WS_EX_CONTROLPARENT, $WS_EX_DLGMODALFRAME, $WS_EX_TOPMOST), $hWnd)
		GUISetFont($nGlobalFontSize, 400, 0, $sGlobalFont)
		SendMessage($hWiFiConnGUI, $WM_SETFONT, $hGlobalFont, 1)
		GUISetBkColor($nClrGUIBkWiFi)
		
		If $bIconLib Then
			GUISetIcon($sIconLib, 45)
		Else
			GUISetIcon(@AutoItExe, 214)
		EndIf
		
		$nLblConnSSID = CreateCtrlLabel($sLblWiFiSSID & ":", 5, 8, 150, 20)
		$nInpConnSSID = CreateCtrlInput("", 160, 5, 155, 20)
		$hInpConnSSID = GUICtrlGetHandle($nInpConnSSID)
		
		$nLblConnKey	= CreateCtrlLabel($sLblWiFiKey & ":", 5, 33, 150, 20)
		$nInpConnKey	= CreateCtrlInput("", 160, 30, 155, 20, BitOr($ES_PASSWORD, $ES_AUTOHSCROLL))
		$nChkConnKey	= CreateCtrlCheck($sChkWiFiKey, 5, 55, 310, 20, -1, -1, $hWiFiConnGUI)
		$nChkConnAuto	= CreateCtrlCheck($sChkWiFiAuto, 5, 75, 310, 20, -1, -1, $hWiFiConnGUI)
		
		$nBtnConnOK		= CreateODBtn($sBtnOK, 5, 100, 150, 25, $arODBtnConn, 2)
		$nBtnConnCancel	= CreateODBtn($sBtnCancel, 160, 100, 155, 25, $arODBtnConn, 3)
	Else
		GUICtrlSetData($nInpConnKey, "")
		WinSetTitle($hWiFiConnGUI, "", $sTWiFiConn & ": " & $sTWiFiSSID)
	EndIf
	
	If $bHidden Then
		GUICtrlSetData($nInpConnSSID, "")
		GUICtrlSetState($nInpConnSSID, $GUI_ENABLE)
	Else
		GUICtrlSetData($nInpConnSSID, $sTWiFiSSID)
		GUICtrlSetState($nInpConnSSID, $GUI_DISABLE)
	EndIf
	
	If Not $bSecure And $bHidden Then
		GUICtrlSetState($nInpConnKey, $GUI_DISABLE)
		GUICtrlSetState($nChkConnKey, $GUI_DISABLE)
	Else
		GUICtrlSetState($nInpConnKey, $GUI_ENABLE)
		GUICtrlSetState($nChkConnKey, $GUI_ENABLE)
		GUICtrlSetState($nChkConnAuto, $GUI_CHECKED)
	EndIf
	
	If IsArray($arPos) Then
		Local $nX
		If $bFromTray Then
			$nX = GetScaled(3)
			WinMove($hWiFiConnGUI, "", $arPos[0] + $nX, $arPos[1] + GetScaled(35))
		Else
			$nX = GetScaled(155)
			If $bTabSmall Then $nX = GetScaled(52)
			WinMove($hWiFiConnGUI, "", $arPos[0] + $nX, $arPos[1] + GetScaled(175))
		EndIf
	EndIf

	GUISetState(@SW_SHOW, $hWiFiConnGUI)
EndFunc


;**********************************************************************
; Get auth -> enc mode
;**********************************************************************
Func GetAuthEnc($sAuth, $sEncSet = "")
	If $sAuth = "" Then Return
	Local $i, $k, $sEnc = "|", $sEncDef = "", $nMask
	
	For $i = 0 To 8
		If $sAuth = $arAuthType[$i][2] And $arAuthType[$i][0] <> "" Then
			$nMask = $arAuthType[$i][1]

			For $k = 0 To 5
				If BitAnd($arEncType[$k][1], $nMask) Then
					$sEnc &= $arEncType[$k][0] & "|"
					$sEncDef = $arEncType[$k][0]
				EndIf
			Next
			
			ExitLoop
		EndIf
	Next
	
	If $sEncSet <> "" Then $sEncDef = $sEncSet	
	GUICtrlSetData($nComboEnc, $sEnc, $sEncDef)
	
	SetEncState($sAuth, $sEncDef)
EndFunc


;**********************************************************************
; Set auth and enc states
;**********************************************************************
Func SetEncState($sAuth, $sEnc)
	If $sAuth = "wpa" Or $sAuth = "wpa2" Then
		GUICtrlSetData($nInpKey, "")
		GUICtrlSendMsg($nInpKey, $EM_SETREADONLY, TRUE, 0)
	ElseIf $sEnc = "none" Then
		GUICtrlSetData($nInpKey, "")
		GUICtrlSendMsg($nInpKey, $EM_SETREADONLY, TRUE, 0)
	Else
		GUICtrlSendMsg($nInpKey, $EM_SETREADONLY, FALSE, 0)
	EndIf
EndFunc


;**********************************************************************
; Get profile auth str by auth description
;**********************************************************************
Func GetAuthStr($sDesc, $bByDesc = TRUE)
	Local $i
	
	For $i = 0 To 8
		If $bByDesc Then
			If $sDesc = $arAuthType[$i][2] Then Return $arAuthType[$i][0]
		Else
			If $sDesc = $arAuthType[$i][0] Then Return $arAuthType[$i][2]
		EndIf
	Next

	Return ""
EndFunc


;**********************************************************************
; Read XML data from string
;**********************************************************************
Func GetXmlStr($sString, $sElement)
	If $sString = "" Or $sElement = "" Then Return ""
	
	Local $nStart = StringInStr($sString, "<" & $sElement & ">")
	If $nStart = 0 Then Return ""
	
	Local $nEnd = StringInStr($sString, "</" & $sElement & ">")
	If $nStart = 0 Then Return ""
	
	$nStart = $nStart + StringLen($sElement) + 2
	$nEnd -= $nStart

	Return StringMid($sString, $nStart, $nEnd)
EndFunc


;**********************************************************************
; Write string to XML data
;**********************************************************************
Func SetXmlStr($sString, $sElement, $sData)
	If $sString = "" Or $sElement = "" Then Return 0
	
	Local $nStart = StringInStr($sString, "<" & $sElement & ">")
	If $nStart = 0 Then Return 0
	
	Local $nEnd = StringInStr($sString, "</" & $sElement & ">")
	If $nEnd = 0 Then Return 0
	
	Local $nReplStart	= $nStart + StringLen($sElement) + 2
	Local $sReplStr		= StringMid($sString, $nReplStart, $nEnd - $nReplStart)
	
	$nStart -= 1
	$nEnd += StringLen("</" & $sElement & ">") - 1
	
	Local $sPartStr = StringTrimLeft(StringTrimRight($sString, StringLen($sString) - $nEnd), $nStart)
	Local $sNewStr = StringReplace($sPartStr, $sReplStr, $sData, 1)

	Return StringReplace($sString, $sPartStr, $sNewStr, 1)
EndFunc


;**********************************************************************
; Add WLAN preferred profile
;**********************************************************************
Func GetAuthCiphStr($nAuth, $nCiph, ByRef $sAuth, ByRef $sCiph, $bStr = FALSE)
	If $bStr Then
		$sAuth = $arAuthType[$nAuth][0]
	Else
		$sAuth = $arAuthType[$nAuth][2]
	EndIf

	Switch $nCiph
		Case $DOT11_CIPHER_ALGO_NONE
			$sCiph = $arDot11Enc[0]
		Case $DOT11_CIPHER_ALGO_WEP40
			$sCiph = $arDot11Enc[1]
		Case $DOT11_CIPHER_ALGO_TKIP
			$sCiph = $arDot11Enc[2]
		Case $DOT11_CIPHER_ALGO_CCMP
			$sCiph = $arDot11Enc[3]
		Case $DOT11_CIPHER_ALGO_WEP104
			$sCiph = $arDot11Enc[1]
		Case $DOT11_CIPHER_ALGO_WPA_USE_GROUP
			$sCiph = $arDot11Enc[4]
		Case $DOT11_CIPHER_ALGO_RSN_USE_GROUP
			$sCiph = $arDot11Enc[4]
		Case $DOT11_CIPHER_ALGO_WEP
			$sCiph = $arDot11Enc[1]
	EndSwitch
EndFunc


;**********************************************************************
; Add WLAN profile direct from available networks
;**********************************************************************
Func AddWlanProfile($sDesc, $sInpKey = "", $bAuto = FALSE)
	If $hWlanapi = -1 Then Return 0
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return 0
	
	Local $sSSID = $arCurConn[0]
	If $sSSID = "" Then Return 0
	
	Local $sKeyType	= "passPhrase"
	Local $sKey		= ""
	
	If $sInpKey <> $sHiddenInput Then $sKey = $sInpKey
	
	Local $bAdhoc = FALSE
	If $arCurConn[3] = 2 Then $bAdhoc = TRUE
	
	Local $nCode = 0
	Local $nResult = AddWlanProfileSub($i, $sSSID, $sSSID, $arCurConn[1], $arCurConn[2], $sKeyType, $sKey, $nCode, $bAuto, $bAdhoc)
	
	If $nResult = $ERROR_SUCCESS Then
		$nResult = 1
	Else
		$nResult = 0
	EndIf
	
	Return $nResult
EndFunc


;**********************************************************************
; Add WLAN preferred profile
;**********************************************************************
Func AddWlanProfilePref($sDesc, $sInpKey = "")
	If $hWlanapi = -1 Then Return 0
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return 0
	
	Local $sSSID = GUICtrlRead($nInpSSID)
	If $sSSID = "" Then Return 0
	
	Local $sProfileName = ""
	
	; Convert back the displayed unicode SSID to multibyte for older OS's
	If $bIsWin8 = FALSE Then
		Local $sText
		If StringFromUni($sSSID, $sText) > 0 Then $sSSID = $sText
	EndIf

	Local $sAuth	= GetAuthStr(GUICtrlRead($nComboAuth))
	Local $sEnc		= GUICtrlRead($nComboEnc)
	Local $sKey, $sKeyType
	
	If $bEditAuth Then
		$sKeyType		= $sCurKey[0]
		$sKey			= $sCurKey[1]
		$sProfileName	= GUICtrlRead($nInpProfile)		
	Else
		$sKeyType	= "passPhrase"
		$sKey		= ""
	EndIf
	
	If $sInpKey <> $sHiddenInput Then
		$sKeyType	= "passPhrase"
		$sKey		= $sInpKey
	EndIf

	Local $bAuto	= FALSE
	If BitAnd(GUICtrlRead($nChkAuto), $GUI_CHECKED) Then $bAuto = TRUE
	
	Local $bAdhoc = FALSE
	If BitAnd(GUICtrlRead($nChkAdhoc), $GUI_CHECKED) Then $bAdhoc = TRUE

	Local $bHidden	= FALSE
	If BitAnd(GUICtrlRead($nChkHidden), $GUI_CHECKED) Then $bHidden = TRUE
	
	Local $nCode = 0
	Local $nResult = AddWlanProfileSub($i, $sProfileName, $sSSID, $sAuth, $sEnc, $sKeyType, $sKey, $nCode, $bAuto, $bAdhoc, $bHidden)
	
	If $nResult = $ERROR_SUCCESS Then
		EnumWlanPrefNetworks($sDesc)
		$nResult = 1
	Else
		Local $sResult = GetErrStr($nResult)
		If $nCode <> 0 Then
			Local $stError = DllStructCreate("wchar[260]")
			
			WlanReasonCodeToString($nCode, 260, DllStructGetPtr($stError), 0)
			MsgBoxEx(16, $sError, $sWiFiErrAddProf & " (" & $nResult & "):" & @LF & $sResult & @LF & DllStructGetData($stError, 1), $hSubGUI)
		Else
			MsgBoxEx(16, $sError, $sWiFiErrAddProf & " (" & $nResult & "):" & @LF & $sResult, $hSubGUI)
		EndIf
		
		$nResult = 0
	EndIf
	
	Return $nResult
EndFunc


;**********************************************************************
; Add WLAN profile sub function
;**********************************************************************
Func AddWlanProfileSub($nIdx, $sProfileName, $sSSID, $sAuth, $sEnc, $sKeyType, $sKey, ByRef $nCode, $bAuto = TRUE, $bAdhoc = FALSE, $bHidden = FALSE) 
	Local $sOnexCfg		= "false"		
	Local $sType		= "ESS"
	Local $sNonBcast	= "false"
	Local $sProfName	= $sProfileName
	Local $sProfile		= $sWiFiWPAScheme
	Local $sMode		= "manual"
	
	If Not $bEditAuth Then
		$sProfName = $sSSID
		; Win8 and higher support saving of unicode profile name
		If $bIsWin8 And Not $bEditAuth Then
			If $arCurConn[4] <> "" Then $sProfName = $arCurConn[4]
		EndIf		
	EndIf 
	
	;Local $sText
	;If StringFromUni($sSSID, $sText) > 0 Then $sSSID = $sText
	
	If $sEnc = "none" Then $sProfile = $sWiFiNoneScheme
	If $bAuto Then $sMode = "auto"
	If $bHidden Then $sNonBcast = "true"
	
	If $bAdhoc Then
		If $sEnc = "none" Then
			$sProfile = $sWiFiNoneScheme
		Else
			$sProfile = $sWiFiAdhocScheme
		EndIf
		
		If Not $bIsVista Then $sProfName = $sSSID & "-adhoc"
		$sType			= "IBSS"
		$sNonBcast		= "false"
		;$sOnexCfg		= "true"
	EndIf
	
	If StringInStr($sEnc, "WEP") Then $sKeyType = "networkKey"
	
	#cs
	*** Possible values ***
		Auth:		open / shared / WPA / WPAPSK / WPA2 / WPA2PSK / WPA3 / WPA3SAE
		Enc:		none / WEP / TKIP / AES
		KeyType:	networkKey / passPhrase
		Mode:		auto / manual
		Type:		ESS / IBSS
	#ce

	Local $sKeyIdx		= "0"
	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)
	
	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return $nResult
	
	Local $hWlan	= DllStructGetData($stHandle, 1)
	Local $stGUID	= DllStructCreate($sGUID)
	
	CreateGUIDFromString($stGUID, $arWLANList[$nIdx])

	$sProfile = StringReplace($sProfile, $sWiFiProfName, $sProfName)
	$sProfile = StringReplace($sProfile, $sWiFiSSID, $sSSID)
	$sProfile = StringReplace($sProfile, $sWiFiNonBcast, $sNonBcast)
	$sProfile = StringReplace($sProfile, $sWiFiConnType, $sType)
	$sProfile = StringReplace($sProfile, $sWiFiConnMode, $sMode)
	$sProfile = StringReplace($sProfile, $sWiFiAuthType, $sAuth)
	$sProfile = StringReplace($sProfile, $sWiFiEncType, $sEnc)
	$sProfile = StringReplace($sProfile, $sWiFiKeyType, $sKeyType)
	$sKey = StringReplace($sKey, "&", "&amp;")
	$sKey = StringReplace($sKey, "<", "&lt;")
	$sKey = StringReplace($sKey, ">", "&gt;")
	$sProfile = StringReplace($sProfile, $sWiFiKey, $sKey)
	$sProfile = StringReplace($sProfile, $sWiFiKeyIdx, $sKeyIdx)
	$sProfile = StringReplace($sProfile, $sWiFiOnexCfg, $sOnexCfg)

	If $bEditAuth And $bIsVista And GUICtrlRead($nInpKey) = $sHiddenInput Then
		$sProfile = StringReplace($sProfile, $sWiFiKeyProt, "true")
	Else
		$sProfile = StringReplace($sProfile, $sWiFiKeyProt, "false")
	EndIf
	
	Local $stProfile = DllStructCreate("wchar[" & StringLen($sProfile) + 1 & "]")
	DllStructSetData($stProfile, 1, $sProfile)
	
	Local $stCode = DllStructCreate("int")
	$nResult = WlanSetProfile($hWlan, DllStructGetPtr($stGUID), 0, DllStructGetPtr($stProfile), 0, 1, 0, DllStructGetPtr($stCode))

	WlanCloseHandle($hWlan, 0)
	
	Return $nResult
EndFunc


;**********************************************************************
; Delete WLAN preferred profile
;**********************************************************************
Func DelWlanProfile($sDesc, $nLV = -1, $hGUI = 0)
	If $hWlanapi = -1 Then Return
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return
	
	If $nLV = -1 Then $nLV = $nLVWLPref
	If $hGUI = 0 Then $hGUI = $hMainGUI
	
	Local $nCurSel = GUICtrlSendMsg($nLV, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
		
	If $nCurSel > -1 Then
		Local $stProfile	= DllStructCreate("wchar[260]")
		Local $stLVI		= DllStructCreate($sLVI)
		
		DllStructSetData($stLVI, 1, $LVIF_TEXT)
		DllStructSetData($stLVI, 2, $nCurSel)
		DllStructSetData($stLVI, 3, 1)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stProfile))
		DllStructSetData($stLVI, 7, 260)
		
		If GUICtrlSendMsg($nLV, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then
			If MsgBoxEx(308, $sWiFiDelProf, $sWiFiDelTxt & " """ & _
					DllStructGetData($stProfile, 1) & """ ?" & @LF & _
					$sWiFiDelWarn, $hGUI) = 6 Then
				If $nLV = $nLVWLPref Then
					Local $nImage = GetLVIImage($nLVWLPref, $nCurSel, 0)
					If ($nImage = 2 Or $nImage = 3) And Not $bIsVista Then _
						DllStructSetData($stProfile, 1, DllStructGetData($stProfile, 1) & "-adhoc")
				ElseIf $nLV = $nLVWLAvailTray Then
					Local $nBitType = Number(GetLVIText($nLVWLAvailTray, $nCurSel, 0))
					If BitAnd($nBitType, 128) And Not $bIsVista Then _
						DllStructSetData($stProfile, 1, DllStructGetData($stProfile, 1) & "-adhoc")
				EndIf
				
				Local $stVersion	= DllStructCreate("dword")
				Local $stHandle		= DllStructCreate("dword")
				DllStructSetData($stHandle, 1, 0)
				
				Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
				If $nResult <> $ERROR_SUCCESS Then Return
				
				Local $hWlan	= DllStructGetData($stHandle, 1)
				Local $stGUID	= DllStructCreate($sGUID)
				
				CreateGUIDFromString($stGUID, $arWLANList[$i])
				
				; Win8 and higher save profile as unicode string, other as multibyte so lets get correct profile name
				If $bIsWin8 = FALSE Then
					Local $sText
					If StringFromUni(DllStructGetData($stProfile, 1), $sText) > 0 Then DllStructSetData($stProfile, 1, $sText)
				EndIf
				
				If WlanDeleteProfile($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stProfile), 0) = $ERROR_SUCCESS Then
					GUICtrlSendMsg($nLV, $LVM_DELETEITEM, $nCurSel, 0)
				EndIf
			
				WlanCloseHandle($hWlan, 0)
			EndIf
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Edit WLAN preferred profile
;**********************************************************************
Func EditWlanProfile($sDesc)
	If $hWlanapi = -1 Then Return
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return
	
	Local $nCurSel = GUICtrlSendMsg($nLVWLPref, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
		
	If $nCurSel > -1 Then
		Local $stProfile	= DllStructCreate("wchar[260]")
		Local $stLVI		= DllStructCreate($sLVI)
		
		DllStructSetData($stLVI, 1, $LVIF_TEXT)
		DllStructSetData($stLVI, 2, $nCurSel)
		DllStructSetData($stLVI, 3, 1)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stProfile))
		DllStructSetData($stLVI, 7, 260)
		
		If GUICtrlSendMsg($nLVWLPref, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then
			Local $nImage = GetLVIImage($nLVWLPref, $nCurSel, 0)
			If ($nImage = 2 Or $nImage = 3) And Not $bIsVista Then _
				DllStructSetData($stProfile, 1, DllStructGetData($stProfile, 1) & "-adhoc")			
			
			Local $stVersion	= DllStructCreate("dword")
			Local $stHandle		= DllStructCreate("dword")
			DllStructSetData($stHandle, 1, 0)
			
			Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
			If $nResult <> $ERROR_SUCCESS Then Return
			
			Local $hWlan	= DllStructGetData($stHandle, 1)
			Local $stGUID	= DllStructCreate($sGUID)
			
			CreateGUIDFromString($stGUID, $arWLANList[$i])
			
			; Win8 and higher save profile as unicode string, other as multibyte so lets get correct profile name
			If $bIsWin8 = FALSE Then
				Local $sText
				If StringFromUni(DllStructGetData($stProfile, 1), $sText) > 0 Then DllStructSetData($stProfile, 1, $sText)
			EndIf
			
			Local $stCode = DllStructCreate("dword")
			If $bIsVista And GUICtrlRead($nChkWLEditUI) = $GUI_CHECKED Then
				If WlanUIEditProfile(1, DllStructGetPtr($stProfile), DllStructGetPtr($stGUID), $hConfWiFiGUI, 0, 0, DllStructGetPtr($stCode)) <> $ERROR_SUCCESS Then
					Local $stError = DllStructCreate("wchar[260]")
					WlanReasonCodeToString(DllStructGetData($stCode, 1), 260, DllStructGetPtr($stError), 0)
					MsgBoxEx(16, $sERROR, DllStructGetData($stError, 1), $hConfWiFiGUI)
				EndIf
			Else
				Local $stPtr = DllStructCreate("ptr")
				
				If WlanGetProfile($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stProfile), 0, DllStructGetPtr($stPtr), 0, 0) = $ERROR_SUCCESS Then
					Local $pBuffer	= DllStructGetData($stPtr, 1)
					Local $stBuffer	= DllStructCreate("wchar[" & wcslen($pBuffer) & "]", $pBuffer)
					Local $sXML		= DllStructGetData($stBuffer, 1)

					Local $sProfile	= GetXmlStr($sXML, "name")
					Local $sSSID	= GetXmlStr(GetXmlStr($sXML, "ssid"), "name")
					Local $sAuth	= GetAuthStr(GetXmlStr($sXML, "authentication"), FALSE)
					Local $sEnc		= GetXmlStr($sXML, "encryption")
					Local $sType	= GetXmlStr($sXML, "connectiontype")
					Local $sMode	= GetXmlStr($sXML, "connectionMode")
					Local $sHidden	= GetXmlStr($sXML, "nonBroadcast")
					Local $sKeyType	= GetXmlStr($sXML, "keyType")
					Local $sKey		= GetXmlStr($sXML, "keymaterial")

					If $bIsWin8 = FALSE Then
						Local $sText
						If StringToUni($sProfile, $sText) > 0 Then $sProfile = $sText
						If StringToUni($sSSID, $sText) > 0 Then $sSSID = $sText
					EndIf
					
					$sCurKey[0] = $sKeyType
					$sCurKey[1] = $sKey
					
					If $sMode = "" Then $sMode = "auto"
					If $sHidden = "" Then $sHidden = "false"
					If $sType = "IBSS" And Not $bIsVista Then $sSSID = StringTrimRight($sSSID, 6)
					If $sSSID <> "" And $sAuth <> "" Then CreateAuthGUI(TRUE, $sProfile, $sSSID, $sAuth, $sEnc, $sMode, $sType, $sHidden)
					
					WlanFreeMemory($pBuffer)
				EndIf
			EndIf
			
			WlanCloseHandle($hWlan, 0)
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Import XML file to preferred WLAN profile
;**********************************************************************
Func ImportWlanProfile($sDesc)
	If $hWlanapi = -1 Then Return
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return
	
	Local $sFile		= FileOpenDialog($sTTWiFiImport, "", $sTTWiFiXMLFiles, 0, "", $hWiFiPrefGUI)
	If @Error <> 0 Then Return
	
	Local $sProfile		= FileRead($sFile)
	If @Error <> 0 Then Return
	
	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)
	
	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return
	
	Local $stProfile	= DllStructCreate("wchar[" & StringLen($sProfile) + 1 & "]")
	Local $hWlan		= DllStructGetData($stHandle, 1)
	Local $stGUID		= DllStructCreate($sGUID)
	Local $stPtr		= DllStructCreate("ptr")
	Local $stCode		= DllStructCreate("int")
	
	CreateGUIDFromString($stGUID, $arWLANList[$i])
		
	DllStructSetData($stProfile, 1, $sProfile)
	
	If WlanSetProfile($hWlan, DllStructGetPtr($stGUID), 0, DllStructGetPtr($stProfile), _
		0, 1, 0, DllStructGetPtr($stCode)) = $ERROR_SUCCESS Then
		MsgBoxEx(64, $sINFO, $sWiFiImportOK)
		EnumWlanPrefNetworks($sDesc)
	Else
		Local $stError = DllStructCreate("wchar[260]")
		WlanReasonCodeToString(DllStructGetData($stCode, 1), 260, DllStructGetPtr($stError), 0)
		MsgBoxEx(16, $sERROR, $sWiFiErrImport & @LF & _
			DllStructGetData($stError, 1), $hConfWiFiGUI)
	EndIf
	
	WlanCloseHandle($hWlan, 0)	
EndFunc


;**********************************************************************
; Export selected preferred WLAN profile as XML
;**********************************************************************
Func ExportWlanProfile($sDesc, $sInitDir = "")
	If $hWlanapi = -1 Then Return
	
	Local $i = IsWLANI($sDesc)
	If $i = 0 Then Return
	
	Local $nCurSel = GUICtrlSendMsg($nLVWLPref, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	
	If $nCurSel > -1 Then
		Local $stProfile	= DllStructCreate("wchar[260]")
		Local $stLVI		= DllStructCreate($sLVI)
		
		DllStructSetData($stLVI, 1, $LVIF_TEXT)
		DllStructSetData($stLVI, 2, $nCurSel)
		DllStructSetData($stLVI, 3, 1)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stProfile))
		DllStructSetData($stLVI, 7, 260)
		
		If GUICtrlSendMsg($nLVWLPref, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then
			Local $sProfile = DllStructGetData($stProfile, 1)
			Local $nImage = GetLVIImage($nLVWLPref, $nCurSel, 0)
			If ($nImage = 2 Or $nImage = 3) And Not $bIsVista Then _
				DllStructSetData($stProfile, 1, DllStructGetData($stProfile, 1) & "-adhoc")
			
			Local $stVersion	= DllStructCreate("dword")
			Local $stHandle		= DllStructCreate("dword")
			DllStructSetData($stHandle, 1, 0)
			
			Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
			If $nResult <> $ERROR_SUCCESS Then Return
			
			Local $hWlan	= DllStructGetData($stHandle, 1)
			Local $stGUID	= DllStructCreate($sGUID)
			
			CreateGUIDFromString($stGUID, $arWLANList[$i])
			
			Local $stPtr = DllStructCreate("ptr")
			Local $stFlags = DllStructCreate("dword")
			
			If $bOSCanEncKey Then
				DllStructSetData($stFlags, 1, $WLAN_PROFILE_GET_PLAINTEXT_KEY)
			Else
				DllStructSetData($stFlags, 1, 0)
			EndIf
			
			; Win8 and higher save profile as unicode string, other as multibyte so lets get correct profile name
			If $bIsWin8 = FALSE Then
				Local $sText
				If StringFromUni(DllStructGetData($stProfile, 1), $sText) > 0 Then DllStructSetData($stProfile, 1, $sText)
			EndIf
			
			If WlanGetProfile($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stProfile), 0, DllStructGetPtr($stPtr), DllStructGetPtr($stFlags), 0) = $ERROR_SUCCESS Then
				Local $pBuffer	= DllStructGetData($stPtr, 1)
				Local $stBuffer	= DllStructCreate("wchar[" & wcslen($pBuffer) & "]", $pBuffer)
				Local $sXML		= DllStructGetData($stBuffer, 1)
				
				WlanFreeMemory($pBuffer)
				
				;OneX not possbile at the moment under PE
				$sXML = SetXmlStr($sXML, "useOneX", "false")
				
				Local $sFile = FileSaveDialog($sTTWiFiExport, $sInitDir, $sTTWiFiXMLFiles, 16, $sProfile & ".xml", $hWiFiPrefGUI)
				If @Error = 0 Then
					If StringRight($sFile, 4) <> ".xml" Then $sFile &= ".xml"
					
					Local $hFile = FileOpen($sFile, 2)
					
					If FileWrite($hFile, $sXML) Then
						MsgBoxEx(64, $sINFO, $sWiFiExportOK & " """ & $sProfile & """ .", $hConfWiFiGUI)
					Else
						MsgBoxEx(16, $sERROR, $sWiFiErrExport & " """ & $sProfile & """ !", $hConfWiFiGUI)
					EndIf
					
					FileClose($hFile)
				EndIf
			EndIf
			
			WlanCloseHandle($hWlan, 0)
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Query current WLAN connection
;**********************************************************************
Func GetWlanCurCon($sDesc, ByRef $sProfileConnected, ByRef $sSSIDConnected, ByRef $sMAC, ByRef $bAdhoc, ByRef $nSignal, $hWlan = 0, $pGUID = 0, $bLog = TRUE)
	If $hWlanapi = -1 Then Return 0
	
	Local $hWlanLoc = $hWlan
	Local $pGUIDLoc = $pGUID
	
	If $hWlanLoc = 0 Then
		Local $i = IsWLANI($sDesc)
		If $i = 0 Then Return 0
	
		Local $stVersion	= DllStructCreate("dword")
		Local $stHandle		= DllStructCreate("dword")
		DllStructSetData($stHandle, 1, 0)

		Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
		If $nResult <> $ERROR_SUCCESS Then Return 0
	
		$hWlanLoc = DllStructGetData($stHandle, 1)
		Local $stGUID = DllStructCreate($sGUID)

		CreateGUIDFromString($stGUID, $arWLANList[$i])
		$pGUIDLoc	= DllStructGetPtr($stGUID)
	EndIf
	
	Local $stPtr = DllStructCreate("ptr")
	Local $stSize = DllStructCreate("dword")
	
	If WlanQueryInterface($hWlanLoc, $pGUIDLoc, 7, 0, DllStructGetPtr($stSize), DllStructGetPtr($stPtr), 0, $bLog) = $ERROR_SUCCESS Then
		Local $stWCA = DllStructCreate($sWLAN_CONNECTION_ATTRIBUTES, DllStructGetData($stPtr, 1))
		If DllStructGetData($stWCA, 6) = 2 Then $bAdhoc = TRUE
		$sProfileConnected = DllStructGetData($stWCA, 3)
		$sSSIDConnected	= DllStructGetData($stWCA, 5)
		;If $bIsVista And $sProfile <> $sSSIDCon And $sProfile <> "" Then $sSSIDCon = $sProfile
		$sMAC = StringFormat("%02X-%02X-%02X-%02X-%02X-%02X", _
							DllStructGetData($stWCA, 7, 1), _
							DllStructGetData($stWCA, 7, 2), _
							DllStructGetData($stWCA, 7, 3), _
							DllStructGetData($stWCA, 7, 4), _
							DllStructGetData($stWCA, 7, 5), _
							DllStructGetData($stWCA, 7, 6))
		$nSignal	= DllStructGetData($stWCA, 10)
		
		;consolewrite("connection-type:" & DllStructGetData($stWCA, 8) & @LF)

		WlanFreeMemory(DllStructGetData($stPtr, 1))
		If $hWlan = 0 Then WlanCloseHandle($hWlanLoc, 0)
		
		If $bIsWin8 = FALSE Then
			Local $sText
			If StringToUni($sProfileConnected, $sText) > 0 Then $sProfileConnected = $sText
			If StringToUni($sSSIDConnected, $sText) > 0 Then $sSSIDConnected = $sText
		EndIf
				
		;Debug("IN: GetWlanCurCon: SSID: " & $sSSIDCon & "; AP-MAC: " & $sMAC & "; Signal: " & $nSignal & "%") ; 20.12.2017
		
		Return 1
	EndIf
	
	If $hWlan = 0 Then WlanCloseHandle($hWlanLoc, 0)
	
	Return 0
EndFunc


;**********************************************************************
; OS >= Win7/2008 support open WiFi key as plain text key
;**********************************************************************
Func GetWlanKey()
	Local $sKey = ""
	
	Local $sSSID = GUICtrlRead($nInpSSID)
	; Convert back the displayed unicode SSID to multibyte for older OS's
	If $bIsWin8 = FALSE Then
		Local $sText
		If StringFromUni($sSSID, $sText) > 0 Then $sSSID = $sText
	EndIf
	
	Local $stProfile = DllStructCreate("wchar[260]")
	DllStructSetData($stProfile, 1, $sSSID)
	
	If Not $bIsVista Then DllStructSetData($stProfile, 1, DllStructGetData($stProfile, 1) & "-adhoc")			

	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)
	
	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult = $ERROR_SUCCESS Then
		Local $i = IsWLANI(GUICtrlRead($nComboNA))
		If $i > 0 Then
			Local $hWlan	= DllStructGetData($stHandle, 1)
			Local $stGUID	= DllStructCreate($sGUID)
			
			CreateGUIDFromString($stGUID, $arWLANList[$i])
			
			Local $stCode = DllStructCreate("dword")
			Local $stPtr = DllStructCreate("ptr")
			Local $stFlags = DllStructCreate("dword")
			DllStructSetData($stFlags, 1, $WLAN_PROFILE_GET_PLAINTEXT_KEY)
			
			If WlanGetProfile($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stProfile), 0, DllStructGetPtr($stPtr), DllStructGetPtr($stFlags), 0) = $ERROR_SUCCESS Then
				Local $stXML	= DllStructCreate("wchar[" & wcslen(DllStructGetData($stPtr, 1)) & "]", DllStructGetData($stPtr, 1))
				Local $sXML		= DllStructGetData($stXML, 1)
				Local $sKey		= GetXmlStr($sXML, "keymaterial")
				$sKey = StringReplace($sKey, "&amp;", "&")
				$sKey = StringReplace($sKey, "&lt;", "<")
				$sKey = StringReplace($sKey, "&gt;", ">")
				WlanFreeMemory(DllStructGetData($stPtr, 1))
				$stBuffer = 0
			EndIf
		EndIf
		
		WlanCloseHandle($hWlan, 0)
	EndIf
	
	Return $sKey
EndFunc


;**********************************************************************
; Change position in Wlan profile list
;**********************************************************************
Func ChangeWlanProfilePos($nID)
	Debug("IN: ChangeWlanProfilePos")	
	
	Local $nIdx = GUICtrlSendMsg($nLVWLPref, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	If $nIdx < 0 Then Return
	
	Local $sProfile = GetLVText($nLVWLPref, $nIdx, "|", 2, TRUE)
	If $sProfile = "" Then Return
	
	Local $sAdapter = GUICtrlRead($nComboNA)
	Local $i = IsWLANI($sAdapter)
	If $i = 0 Then Return
	
	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)

	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return
	
	Local $hWlan	= DllStructGetData($stHandle, 1)
	Local $stGUID	= DllStructCreate($sGUID)
	CreateGUIDFromString($stGUID, $arWLANList[$i])
	
	Local $nImage = GetLVIImage($nLVWLPref, $nIdx, 0)
	If $nImage = 2 Or $nImage = 3 And Not $bIsVista Then $sProfile &= "-adhoc"

	Local $stProfile = DllStructCreate("wchar[" & StringLen($sProfile) + 1 & "]")	
	DllStructSetData($stProfile, 1, $sProfile)
	
	Local $nOldIdx = $nIdx	
	
	If $nID = $nBtnWLUp Then
		$nIdx -= 1
	Else
		$nIdx += 1
	EndIf
	
	If WlanSetProfilePosition($hWlan, DllStructGetPtr($stGUID), DllStructGetPtr($stProfile), $nIdx, 0) = $ERROR_SUCCESS Then
		Local $hCompareItems = DllCallbackRegister("CompareItems", "int", "long_ptr;long_ptr;long_ptr")
		
		Local $stCompare = DllStructCreate("int;int")
		DllStructSetData($stCompare, 1, $nOldIdx)
		DllStructSetData($stCompare, 2, $nIdx)
				
		GUICtrlSendMsg($nLVWLPref, $LVM_SORTITEMSEX, DllStructGetPtr($stCompare), DllCallbackGetPtr($hCompareItems))
		
		DllCallbackFree($hCompareItems)
		
		If $bIsVista Then
			ChkListBtnCtrl($nLVWLPref, $nBtnWLUp, $nBtnWLDown, TRUE, FALSE)
		Else
			 ChkWiFiPrefListBtnCtrlXP()								
		EndIf
	EndIf
	
	WlanCloseHandle($hWlan, 0)
EndFunc


Func CompareItems($lParam1, $lParam2, $lParamSort)
	Local $stCompare	= DllStructCreate("int;int", $lParamSort)
	Local $nResult		= 0
	
	Local $nOldIdx = DllStructGetData($stCompare, 1)
	Local $nNewIdx = DllStructGetData($stCompare, 2)
	
	If $lParam1 = $nOldIdx Then
		If $lParam2 = $nNewIdx Then
			$nResult = 1
		EndIf
	ElseIf $lParam2 = $nOldIdx Then
		If $lParam1 = $nNewIdx Then
			$nResult = 1
		EndIf
	EndIf
	
	Return $nResult
EndFunc


Func ChkWiFiPrefListBtnCtrlXP()
	Local $nLVCur	= GUICtrlSendMsg($nLVWLPref, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	Local $nCount 	= GUICtrlSendMsg($nLVWLPref, $LVM_GETITEMCOUNT, 0, 0)
	Local $nImage	= GetLVIImage($nLVWLPref, $nLVCur, 0)
	Local $bAdhoc	= FALSE
	If $nImage = 2 Or $nImage = 3 Then $bAdhoc = TRUE
	
	If $nLVCur > 0 Then
		$nImage = GetLVIImage($nLVWLPref, $nLVCur - 1, 0)
		If $bAdhoc And ($nImage = 0 Or $nImage = 1) Then
			If BitAnd(GetODBtnState($nBtnWLUp), $GUI_ENABLE) Then SetODBtnState($nBtnWLUp, $GUI_DISABLE)
		Else
			If BitAnd(GetODBtnState($nBtnWLUp), $GUI_DISABLE) Then SetODBtnState($nBtnWLUp, $GUI_ENABLE)
		EndIf
	Else
		If BitAnd(GetODBtnState($nBtnWLUp), $GUI_ENABLE) Then SetODBtnState($nBtnWLUp, $GUI_DISABLE)		
	EndIf
	
	If $nLVCur <> -1 And $nLVCur < ($nCount - 1) Then
		$nImage = GetLVIImage($nLVWLPref, $nLVCur + 1, 0)
		If $bAdhoc = FALSE And ($nImage = 2 Or $nImage = 3) Then
			If BitAnd(GetODBtnState($nBtnWLDown), $GUI_ENABLE) Then SetODBtnState($nBtnWLDown, $GUI_DISABLE)
		Else
			If BitAnd(GetODBtnState($nBtnWLDown), $GUI_DISABLE) Then SetODBtnState($nBtnWLDown, $GUI_ENABLE)
		EndIf
	Else
		If BitAnd(GetODBtnState($nBtnWLDown), $GUI_ENABLE) Then SetODBtnState($nBtnWLDown, $GUI_DISABLE)
	EndIf
EndFunc


;**********************************************************************
; Create GUID from string
;**********************************************************************
Func CreateGUIDFromString(ByRef $stGUID, $sNetGUID)
	If $sNetGUID = "" Then Return 0
		
	Local $i, $c
	Local $sNewGUID	= StringTrimLeft(StringTrimRight($sNetGUID, 1), 1) ; Trims out {}
	Local $arGUID	= StringSplit($sNewGUID, "-")
	
	If IsArray($arGUID) And $arGUID[0] = 5 Then
		DllStructSetData($stGUID, 1, Dec($arGUID[1]))
		DllStructSetData($stGUID, 2, Dec($arGUID[2]))
		DllStructSetData($stGUID, 3, Dec($arGUID[3]))
		
		DllStructSetData($stGUID, 4, Dec(StringMid($arGUID[4], 1, 2)), 1)
		DllStructSetData($stGUID, 4, Dec(StringMid($arGUID[4], 3, 2)), 2)

		$c = 3
		For $i = 1 To 12 Step 2
			DllStructSetData($stGUID, 4, Dec(StringMid($arGUID[5], $i, 2)), $c)
			$c += 1
		Next
	
		Return 1
	EndIf
	
	Return 0
EndFunc


;**********************************************************************
; Get network interface infos
; Reading values from registry is easier to use
; than GetInterfaceInfo(), GetAdaptersInfo() and
; GetPerAdapterInfo()
;
; Addiotional Info: GetAdaptersInfo() will return
; 0.0.0.0 for addresses if network cable is unplugged
;**********************************************************************
Func GetAdapterProperty($sService, $nIndex, $oConf = 0)
	Local $Property		= ""
	Local $sNetbtInt	= $sCCS & "\Services\NetBT\Parameters\Interfaces\Tcpip_" & $sService
	Local $sTcpipInt	= $sCCS & "\Services\Tcpip\Parameters\Interfaces\" & $sService
	Local $sConnection	= $sCCS & "\Control\Network\" & $sClassNet & "\" & $sService & "\Connection"
	Local $sClassKey	= $sCCS & "\Control\Class\" & $sClassNet

	If $bUseWMI Then
		If $oConf <> 0 Then
			Switch $nIndex
				Case 0
					$Property	= Int($oConf.DHCPEnabled)
					Return $Property
				Case 1
					If UBound($oConf.IPAddress) > 0 Then
						For $oAddr In $oConf.IPAddress
							If StringInStr($oAddr, ".") Then $Property &= $oAddr & @LF
						Next
					Else
						$Property = RegRead($sTcpipInt, "IPAddress")
					EndIf
					
				Case 6
					If UBound($oConf.IPAddress) > 0 Then
						For $oAddr In $oConf.IPAddress
							If StringInStr($oAddr, ".") Then $Property &= $oAddr & @LF
						Next
					Else
						If $nIndex = 1 Then
							$Property = RegRead($sTcpipInt, "IPAddress")
						Else
							$Property = RegRead($sTcpipInt, "DhcpIPAddress")
						EndIf
					EndIf
				Case 2, 7
					If UBound($oConf.IPSubnet) > 0 Then
						For $oAddr In $oConf.IPSubnet
							If StringInStr($oAddr, ".") Then $Property &= $oAddr & @LF
						Next
					Else
						If $nIndex = 2 Then
							$Property = RegRead($sTcpipInt, "SubnetMask")
						Else
							$Property = RegRead($sTcpipInt, "DhcpSubnetMask")
						EndIf
					EndIf
				Case 3
					If $oConf.DHCPEnabled Then
						$Property = ""
					Else
						If UBound($oConf.DefaultIPGateway) > 0 Then
							For $oAddr In $oConf.DefaultIPGateway
								$Property &= $oAddr & @LF
							Next
						Else
							$Property = RegRead($sTcpipInt, "DefaultGateway")
						EndIf
					EndIf
				Case 8
					If UBound($oConf.DefaultIPGateway) > 0 Then
						For $oAddr In $oConf.DefaultIPGateway
							$Property &= $oAddr & @LF
						Next
					Else
						$Property = RegRead($sTcpipInt, "DhcpDefaultGateway")
					EndIf
				Case 11
					$Property = $oConf.DHCPServer			
			EndSwitch
		EndIf
	Else	
		Switch $nIndex
			Case 0
				$Property	= Int(RegRead($sTcpipInt, "EnableDHCP"))
				Return $Property ; If no directly return 0
			Case 1, 2, 6, 7, 12, 13 ; IP, SM, DHCP-IP, DHCP-SM, DHCP-LeaseObt, DHCP-LeaseExp
				Local $stIP_ADAPTER_INFO	= DllStructCreate($sIP_ADAPTER_INFO)
				Local $stReqSize			= DllStructCreate("dword")
			
				; First get needed buffersize
				GetAdaptersInfo(DllStructGetPtr($stIP_ADAPTER_INFO), DllStructGetPtr($stReqSize))
				Local $stBuffer				= DllStructCreate("byte[" & DllStructGetData($stReqSize, 1) & "]")
					
				If GetAdaptersInfo(DllStructGetPtr($stBuffer), DllStructGetPtr($stReqSize)) = $ERROR_SUCCESS Then
					$stIP_ADAPTER_INFO		= DllStructCreate($sIP_ADAPTER_INFO, DllStructGetPtr($stBuffer))
					Local $pIPAI, $pIPAS, $stIPAS
					
					While 1
						If $sService = DllStructGetData($stIP_ADAPTER_INFO, 3) Then
							If $nIndex < 12 Then
								; Get addresses								
								$stIPAS =  DllStructCreate($sIP_ADDR_STRING)
								DllStructSetData($stIPAS, 1, DllStructGetData($stIP_ADAPTER_INFO, 11))
								DllStructSetData($stIPAS, 2, DllStructGetData($stIP_ADAPTER_INFO, 12))
								DllStructSetData($stIPAS, 3, DllStructGetData($stIP_ADAPTER_INFO, 13))
								DllStructSetData($stIPAS, 4, DllStructGetData($stIP_ADAPTER_INFO, 14))
								
								While 1
									If $nIndex = 1 Or $nIndex = 6 Then
										$Property = $Property & DllStructGetData($stIPAS, 2) & @LF
									Else
										$Property = $Property & DllStructGetData($stIPAS, 3) & @LF
									EndIf
									
									$pIPAS = DllStructGetData($stIPAS, 1)
									If $pIPAS = 0 Then
										ExitLoop
									Else
										$stIPAS	= 0
										$stIPAS	= DllStructCreate($sIP_ADDR_STRING, $pIPAS)
									EndIf
								WEnd
								
								$stIPAS = 0
							Else
								If $nIndex = 12 Then
									$Property = DllStructGetData($stIP_ADAPTER_INFO, 32)
								Else
									$Property = DllStructGetData($stIP_ADAPTER_INFO, 33)
								EndIf
								Debug("Test-Lease:" & DllStructGetData($stIP_ADAPTER_INFO, 4) & ";" & DllStructGetData($stIP_ADAPTER_INFO, 32))
							EndIf
											
							ExitLoop
						EndIf
						
						; Get next adapter info structure
						$pIPAI = DllStructGetData($stIP_ADAPTER_INFO, 1)
						If $pIPAI = 0 Then
							ExitLoop
						Else
							$stIP_ADAPTER_INFO	= 0
							$stIP_ADAPTER_INFO	= DllStructCreate($sIP_ADAPTER_INFO, $pIPAI)
						EndIf
					WEnd
					
					If StringRight($Property, 1) = @LF Then $Property = StringTrimRight($Property, 1)
				EndIf

				$stIP_ADAPTER_INFO	= 0
				$stBuffer = 0
				
				If $Property = "0.0.0.0" Then
					Switch $nIndex
						Case 1
							$Property	= RegRead($sTcpipInt, "IPAddress")
						Case 2
							$Property	= RegRead($sTcpipInt, "SubnetMask")
						Case 6
							$Property	= RegRead($sTcpipInt, "DhcpIPAddress")
						Case 7
							$Property	= RegRead($sTcpipInt, "DhcpSubnetMask")
					EndSwitch
				EndIf
			Case 3
				$Property	= RegRead($sTcpipInt, "DefaultGateway")
			Case 8
				$Property	= RegRead($sTcpipInt, "DhcpDefaultGateway")
			Case 11
				$Property	= RegRead($sTcpipInt, "DhcpServer")
		EndSwitch		
	EndIf
				
	Switch $nIndex
		Case 4
			$Property	= RegRead($sTcpipInt, "NameServer")
		Case 5
			$Property	= RegRead($sNetbtInt, "NameServerList")
		Case 9
			$Property	= RegRead($sTcpipInt, "DhcpNameServer")
		Case 10
			$Property	= RegRead($sNetbtInt, "DhcpNameServerList")
		;Case 12
		;	$Property	= Int(RegRead($sTcpipInt, "LeaseObtainedTime"))
		;Case 13
		;	$Property	= Int(RegRead($sTcpipInt, "LeaseTerminatesTime"))
		Case 14
			$Property	= RegRead($sConnection, "Name")
		Case 15
			$Property	= Int(RegRead($sConnection, "ShowIcon"))
			Return $Property ; If no directly return 0
		Case 16
			$Property	= RegRead($sTcpipInt, "IPAutoconfigurationEnabled")
			If StringLen($Property) = 0 Or $Property = "1" Then
				$Property = 1
			Else
				$Property = 0
			EndIf
			Return $Property
		Case 17
			Local $i = 1
			Local $sSrvKey, $sSrvVal
			$Property = ""
			
			While 1
				$sSrvKey = RegEnumKey($sClassKey, $i)
				If @Error <> 0 Then ExitLoop
				
				$sSrvVal = RegRead($sClassKey & "\" & $sSrvKey, "NetCfgInstanceId")
				If $sSrvVal <> "" And $sSrvVal = $sService Then
					$Property = RegRead($sClassKey & "\" & $sSrvKey, "NetworkAddress")
					Return $Property
				EndIf
				
				$i += 1
			WEnd
		Case 18
			Local $i = 1
			Local $sSrvKey, $sSrvVal
			$Property = ""
			
			While 1
				$sSrvKey = RegEnumKey($sClassKey, $i)
				If @Error <> 0 Then ExitLoop
				
				$sSrvVal = RegRead($sClassKey & "\" & $sSrvKey, "NetCfgInstanceId")
				If $sSrvVal <> "" And $sSrvVal = $sService Then
					$Property = $sClassKey & "\" & $sSrvKey
					Return $Property
				EndIf
				
				$i += 1
			WEnd
	EndSwitch
	
	$Property = StringStripWS($Property, 3)
	If $Property = "0.0.0.0" Then $Property = ""		
		
	Return $Property
EndFunc


;**********************************************************************
; Write adapter settings to registry
;**********************************************************************		
Func SetAdapterProperty($sService, $nIndex, $Val, $Val2 = "")
	Local $nResult		= ""
	Local $sNetbtInt	= $sCCS & "\Services\NetBT\Parameters\Interfaces\Tcpip_" & $sService
	Local $sTcpipInt	= $sCCS & "\Services\Tcpip\Parameters\Interfaces\" & $sService
	Local $sConnection	= $sCCS & "\Control\Network\" & $sClassNet & "\" & $sService & "\Connection"
	Local $sClassKey	= $sCCS & "\Control\Class\" & $sClassNet
	Local $nResult		= 0
	Local $oSrv			= 0
	Local $i, $nWMIRes	= 0
	
	If $bUseWMI Then
		$i					= GetNetAdapterIndexByGUID($sService)		
		Local $oConfigs		= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
		Local $oConfItem	= 0
		Local $oConf		= 0
		Local $oAddr		= 0
		
		For $oConfItem In $oConfigs
			$oConf = $oConfItem
		Next
	
		If $oConf = 0 Then Return 0
	EndIf
		
	Switch $nIndex
		Case 0
			$nResult = RegWrite($sTcpipInt, "EnableDHCP", "REG_DWORD", $Val)
			If $bUseWMI And $Val = 1 Then
				$nWMIRes = $oConf.EnableDHCP()
				Debug("IN: SetAdapterProperty WMI - EnableDHCP: " & $nWMIRes)
			EndIf
		Case 1
			If $Val = "" Then
				RegWriteEmptyMulti($sTcpipInt, "IPAddress")
				RegWriteEmptyMulti($sTcpipInt, "SubnetMask")
			Else
				$nResult = RegWrite($sTcpipInt, "IPAddress", "REG_MULTI_SZ", $Val)
				RegWrite($sTcpipInt, "SubnetMask", "REG_MULTI_SZ", $Val2)
				If $bUseWMI And $Val <> "0.0.0.0" Then
					Local $arStr = StringSplit($Val, @LF)
					Local $arStr2 = StringSplit($Val2, @LF)
					
					Local $arIP[$arStr[0]]
					Local $arSM[$arStr2[0]]
					
					For $i = 1 To $arStr[0]
						$arIP[$i - 1] = $arStr[$i]
						$arSM[$i - 1] = $arStr2[$i]
					Next
	
					$nWMIRes = $oConf.EnableStatic($arIP, $arSM)					
					Debug("IN: SetAdapterProperty WMI - EnableStatic (" & $Val & "," & $Val2 & "): " & $nWMIRes)
				EndIf
			EndIf
		Case 3
			If $Val = "" Or $Val= "0.0.0.0" Then
				RegWriteEmptyMulti($sTcpipInt, "DefaultGateway")
				RegWriteEmptyMulti($sTcpipInt, "DefaultGatewayMetric")
				If $bUseWMI Then
					;Local $arDG[1]
					;Local $arGM[1]
					$nWMIRes = $oConf.SetGateways
					Debug("IN: SetAdapterProperty WMI - SetGateways: " & $nWMIRes)
				EndIf
			Else
				$nResult = RegWrite($sTcpipInt, "DefaultGateway", "REG_MULTI_SZ", $Val)
				If $bUseWMI Then
					Local $arStr = StringSplit($Val, @LF)
					Local $arDG[$arStr[0]]
					Local $arGM[$arStr[0]]
					
					For $i = 1 To $arStr[0]
						$arDG[$i - 1] = $arStr[$i]
						$arGM[$i - 1] = 1
					Next
					
					$nWMIRes = $oConf.SetGateways($arDG, $arGM)
					Debug("IN: SetAdapterProperty WMI - SetGateways (" & $Val & "): " & $nWMIRes)
				EndIf
			EndIf
		Case 4
			$nResult = RegWrite($sTcpipInt, "NameServer", "REG_SZ", $Val)
			If $bUseWMI Then
				If $Val = "" Or $Val = "0.0.0.0" Then
					$nWMIRes = $oConf.SetDNSServerSearchOrder
					Debug("IN: SetAdapterProperty WMI - SetDNSServerSearchOrder to ZERO: " & $nWMIRes)	
				Else
					Local $arStr = StringSplit($Val, ",")
					Local $arDNS[$arStr[0]]
									
					For $i = 1 To $arStr[0]
						$arDNS[$i - 1] = $arStr[$i]
					Next
					
					$nWMIRes = $oConf.SetDNSServerSearchOrder($arDNS)
					Debug("IN: SetAdapterProperty WMI - SetDNSServerSearchOrder (" & $Val & "): " & $nWMIRes)
				EndIf
			EndIf
		Case 5
			If $Val = "" Then
				RegWriteEmptyMulti($sNetbtInt, "NameServerList")
				If $bUseWMI Then
					$nWMIRes = $oConf.SetWINSServer("", "")
					Debug("IN: SetAdapterProperty WMI - SetWINSServer to ZERO: " & $nWMIRes)	
				EndIf
			Else
				$nResult = RegWrite($sNetbtInt, "NameServerList", "REG_MULTI_SZ", $Val)
				If $bUseWMI Then
					Local $arStr = StringSplit($Val, @LF)
					Local $sPrimary = ""
					Local $sSecondary = ""
						
					For $i = 1 To $arStr[0]
						If $i = 1 Then
							$sPrimary = $arStr[$i]
						ElseIf $i = 2 Then
							$sSecondary = $arStr[$i]
						EndIf
					Next
					
					$nWMIRes = $oConf.SetWINSServer($sPrimary, $sSecondary)
					Debug("IN: SetAdapterProperty WMI - SetWINSServer (" & $sPrimary & ", " & $sSecondary & "): " & $nWMIRes)	
				EndIf
			EndIf
		Case 6
			; Nothing to do
		Case 7
			; Nothing to do
		Case 8
			; Nothing to do
		Case 9
			; Nothing to do
		Case 10
			; Nothing to do
		Case 11
			; Nothing to do
		Case 12
			; Nothing to do
		Case 13
			; Nothing to do
		Case 14
			; Nothing to do
		Case 15
			$nResult = RegWrite($sConnection, "ShowIcon", "REG_DWORD", $Val)
		Case 16
			$nResult = RegWrite($sTcpipInt, "IPAutoconfigurationEnabled", "REG_DWORD", $Val)
		Case 17
			$i = 1
			Local $sSrvKey, $sSrvVal
	
			While 1
				$sSrvKey = RegEnumKey($sClassKey, $i)
				If @Error <> 0 Then ExitLoop
				
				$sSrvVal = RegRead($sClassKey & "\" & $sSrvKey, "NetCfgInstanceId")
				If $sSrvVal <> "" And $sSrvVal = $sService Then
					If $Val = "" Then
						RegDelete($sClassKey & "\" & $sSrvKey, "NetworkAddress")
					Else
						RegWrite($sClassKey & "\" & $sSrvKey, "NetworkAddress", "REG_SZ", StringReplace(StringUpper($Val), "-", ""))
					EndIf
					
					$nResult = 1
					
					ExitLoop
				EndIf
				
				$i += 1
			WEnd
	EndSwitch
	
	Return $nResult
EndFunc


;**********************************************************************
; RegWrite doesn't work correctly with empty REG_MULTI_SZ
;**********************************************************************		
Func RegWriteEmptyMulti($sKey, $sValue)
	$sKey = StringReplace($sKey, "HKLM\", "")
	
	Local $hKey = RegOpenKeyExA($HKEY_LOCAL_MACHINE, $sKey, 0, $KEY_WRITE)
	RegSetValueExA($hKey, $sValue, 0, $REG_MULTI_SZ, "", 1)
	RegCloseKey($hKey)
EndFunc


;**********************************************************************
; Write network infos/dependies to the GUI
;**********************************************************************			
Func Net2GUI($sDesc, $bRefExtConf = TRUE, $bRefIPMode = TRUE)
	Debug("IN: Net2GUI")
	
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $oConf = 0	
	If $bUseWMI Then
		Local $oConfigs		= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
		Local $oConfItem	= 0
		For $oConfItem In $oConfigs
			$oConf = $oConfItem
		Next
	EndIf
	
	Local $bIsDHCP = GetAdapterProperty($arNAList[$i][1], 0, $oConf)
	
	If $bIsDHCP Then
		If $bRefIPMode Then DHCPIPMode(1)
		$sLastIP = ""
		$sLastSM = ""
	Else
		If $bRefIPMode Then DHCPIPMode(0)
		;EnableDNSChange(1)
		;EnableWINSChange(1)
		$sLastIP = GetAdapterProperty($arNAList[$i][1], 1, $oConf)
		$sLastSM = GetAdapterProperty($arNAList[$i][1], 2, $oConf)
	EndIf
	
	$sLastDG	= GetAdapterProperty($arNAList[$i][1], 3, $oConf)	
	$sLastDNS	= GetAdapterProperty($arNAList[$i][1], 4, $oConf)
	$sLastWINS	= GetAdapterProperty($arNAList[$i][1], 5, $oConf)
	
	If $bIsDHCP Then
		If $bRefIPMode Then
			If $sLastDG = "" Then
				EnableDGChange(0)
			Else
				EnableDGChange(1)
			EndIf
			
			If $sLastDNS = "" Then
				EnableDNSChange(0)
			Else
				EnableDNSChange(1)
			EndIf
			
			If $sLastWINS = "" Then
				EnableWINSChange(0)
			Else
				EnableWINSChange(1)
			EndIf
		EndIf
	EndIf
	
	$sLastIPDef = GetFirstAddrEntry($sLastIP, @LF)
	$sLastSMDef = GetFirstAddrEntry($sLastSM, @LF)
	$sLastDGDef = GetFirstAddrEntry($sLastDG, @LF)
	$sLastDNSPref = GetFirstAddrEntry($sLastDNS, ",")
	$sLastWINSPref = GetFirstAddrEntry($sLastWINS, @LF)
		
	SetAddress($hIP, $sLastIPDef)
	SetAddress($hSM, $sLastSMDef)
	SetAddress($hDG, $sLastDGDef)
	SetAddress($hDNS, $sLastDNSPref)
	SetAddress($hWINS, $sLastWINSPref)

	If $hLastConfGUI = $hConfExtGUI Then UpdateExtConf($sDesc, FALSE, $bRefExtConf)
	
	If CreateSpeedMenu($sDesc) = 0 Then
		If Not BitAnd(GetODBtnState($nBtnSpeed), $GUI_DISABLE) Then _
			SetODBtnState($nBtnSpeed, $GUI_DISABLE)
	ElseIf Not BitAnd(GetODBtnState($nBtnSpeed), $GUI_ENABLE) Then
		SetODBtnState($nBtnSpeed, $GUI_ENABLE)
	EndIf
EndFunc


;**********************************************************************
; Write alternate IP config to the GUI
;**********************************************************************	
Func AltIP2GUI($sDesc, $bBtnSelect = FALSE, $bResetOnly = FALSE)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $sIP		= ""
	Local $sSM		= ""
	Local $sDG		= ""
	Local $sDNS1	= ""
	Local $sDNS2	= ""
	Local $sWINS1	= ""
	Local $sWINS2	= ""
	Local $bAltIP	= FALSE
	Local $sService	= $arNAList[$i][1]
	Local $sOptions	= ""

	If Not $bResetOnly Then
		Local $sAltConf	= RegRead($sCCS & "\Services\Tcpip\Parameters\Interfaces\" & $sService, "ActiveConfigurations")
		If @Error = 0 Then ; Alternate configs set -> REG_MULTI_SZ
			Local $arConfs = StringSplit($sAltConf, @LF)
			If IsArray($arConfs) Then
				$sOptions = RegRead($sCCS & "\Services\Dhcp\Configurations\" & $arConfs[1], "Options")
				$bAltIP = TRUE
			EndIf
		Else
			; Look for older config
			If $bBtnSelect Then
				$sOptions = RegRead($sCCS & "\Services\Dhcp\Configurations\Alternate_" & $sService, "Options")
				$bAltIP = TRUE
			EndIf
		EndIf
	EndIf
	
	If $sOptions <> "" Then
		; 50d/32h = IP, 01 = SM, 03 = DG, 06 = DNS1+2, 44d/2Ch = WINS1+2
		; If primary DNS or WINS empty -> secondary will become primary
		; If IP empty then delete only ActiveConfigurations
		$sOptions = StringTrimLeft($sOptions, 2) ; remove 0x from String
		
		Local $nBytes = StringLen($sOptions) / 2
		Local $c, $sData, $d, $e, $nBlock, $nBlocks
		
		Local $sStruct = ""
		For $c = 1 To StringLen($sOptions) / 8
			$sStruct &= "ubyte[4];"
			$nBlocks += 1
		Next
		$sStruct = StringTrimRight($sStruct, 1)				
		Local $stOptions = DllStructCreate($sStruct)
		
		$e = 1
		For $c = 1 To StringLen($sOptions) Step 8
			For $d = 0 To 3
				$sData = "0x" & StringMid($sOptions, $c, 8)
				DllStructSetData($stOptions, $e, $sData)
			Next
			$e += 1
		Next
		
		;First 2 blocks are always defined: IP/SM
		$sIP = DllStructGetData($stOptions, 6, 1) & "." & _
						DllStructGetData($stOptions, 6, 2) & "." & _
						DllStructGetData($stOptions, 6, 3) & "." & _
						DllStructGetData($stOptions, 6, 4)
		
		$sSM = DllStructGetData($stOptions, 12, 1) & "." & _
				DllStructGetData($stOptions, 12, 2) & "." & _
				DllStructGetData($stOptions, 12, 3) & "." & _
				DllStructGetData($stOptions, 12, 4)
				
		Local $nCnt = 1
		Local $nBlock = 13
			
		If $nBlock < $nBlocks And DllStructGetData($stOptions, $nBlock, 1) = 3 Then
			$sDG = DllStructGetData($stOptions, $nBlock + 5, 1) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 2) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 3) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 4)
			$nBlock += 6
		EndIf
		
		If $nBlock < $nBlocks And DllStructGetData($stOptions, $nBlock, 1) = 6 Then
			$sDNS1 = DllStructGetData($stOptions, $nBlock + 5, 1) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 2) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 3) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 4)
			
			If DllStructGetData($stOptions, $nBlock + 2, 1) > 4 Then
				$sDNS2 = DllStructGetData($stOptions, $nBlock + 6, 1) & "." & _
						DllStructGetData($stOptions, $nBlock + 6, 2) & "." & _
						DllStructGetData($stOptions, $nBlock + 6, 3) & "." & _
						DllStructGetData($stOptions, $nBlock + 6, 4)
				$nBlock += 7
			Else
				$nBlock += 6
			EndIf
		EndIf
		
		If $nBlock < $nBlocks And DllStructGetData($stOptions, $nBlock, 1) = 44 Then
			$sWINS1 = DllStructGetData($stOptions, $nBlock + 5, 1) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 2) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 3) & "." & _
					DllStructGetData($stOptions, $nBlock + 5, 4)
			If DllStructGetData($stOptions, $nBlock + 2, 1) > 4 Then
				$sWINS2 = DllStructGetData($stOptions, $nBlock + 6, 1) & "." & _
						DllStructGetData($stOptions, $nBlock + 6, 2) & "." & _
						DllStructGetData($stOptions, $nBlock + 6, 3) & "." & _
						DllStructGetData($stOptions, $nBlock + 6, 4)
			EndIf
		EndIf
	EndIf
	
	SetAddress($hAltIP, $sIP)
	SetAddress($hAltSM, $sSM)
	SetAddress($hAltDG, $sDG)
	SetAddress($hAltDNS1, $sDNS1)
	SetAddress($hAltDNS2, $sDNS2)
	SetAddress($hAltWINS1, $sWINS1)
	SetAddress($hAltWINS2, $sWINS2)
	
	If $bAltIP Then	
		GUICtrlSetState($nRadIPPrivate, $GUI_UNCHECKED)
		GUICtrlSetState($nRadIPNone, $GUI_UNCHECKED)
		If Not $bBtnSelect Then GUICtrlSetState($nRadIPUser, $GUI_CHECKED)
		
		SetCtrlState($hAltIP, @SW_ENABLE)
		SetCtrlState($hAltSM, @SW_ENABLE)
		SetCtrlState($hAltDG, @SW_ENABLE)
		SetCtrlState($hAltDNS1, @SW_ENABLE)
		SetCtrlState($hAltDNS2, @SW_ENABLE)
		SetCtrlState($hAltWINS1, @SW_ENABLE)
		SetCtrlState($hAltWINS2, @SW_ENABLE)
	Else
		GUICtrlSetState($nRadIPUser, $GUI_UNCHECKED)
		If Not $bResetOnly Then
			If GetAdapterProperty($arNAList[$i][1], 16) = 0 Then
				GUICtrlSetState($nRadIPPrivate, $GUI_UNCHECKED)
				GUICtrlSetState($nRadIPNone, $GUI_CHECKED)
			Else
				GUICtrlSetState($nRadIPNone, $GUI_UNCHECKED)
				GUICtrlSetState($nRadIPPrivate, $GUI_CHECKED)
			EndIf
		EndIf
		
		SetCtrlState($hAltIP, @SW_DISABLE)
		SetCtrlState($hAltSM, @SW_DISABLE)
		SetCtrlState($hAltDG, @SW_DISABLE)
		SetCtrlState($hAltDNS1, @SW_DISABLE)
		SetCtrlState($hAltDNS2, @SW_DISABLE)
		SetCtrlState($hAltWINS1, @SW_DISABLE)
		SetCtrlState($hAltWINS2, @SW_DISABLE)
	EndIf
EndFunc


;**********************************************************************
; Create alternate IP config string in hex format
;**********************************************************************	
Func CreateAltIPStr()
	Local $nIP		= 0
	Local $nSM		= 0
	Local $nDG		= 0
	Local $nDNS1	= 0
	Local $nDNS2	= 0
	Local $nWINS1	= 0
	Local $nWINS2	= 0
	Local $sBlock	= ""
	
	If GetAddress($hAltIP, $nIP) > 0 And GetAddress($hAltSM, $nSM) > 0 Then
		GetAddress($hAltDG, $nDG)
		GetAddress($hAltDNS1, $nDNS1)
		GetAddress($hAltDNS2, $nDNS2)
		GetAddress($hAltWINS1, $nWINS1)
		GetAddress($hAltWINS2, $nWINS2)
		
		$sBlock = "0x32000000000000000400000000000000FFFFFF7F" & GetStrFromIP($nIP, TRUE) & _
						"01000000000000000400000000000000FFFFFF7F" & GetStrFromIP($nSM, TRUE)
						
		If $nDG <> 0 Then $sBlock &= "03000000000000000400000000000000FFFFFF7F" & GetStrFromIP($nDG, TRUE)
	
		If $nDNS1 <> 0 Then
			$sBlock &= "0600000000000000"
			
			If $nDNS2 = 0 Then
				$sBlock &= "0400000000000000FFFFFF7F" & GetStrFromIP($nDNS1, TRUE)
			Else
				$sBlock &= "0800000000000000FFFFFF7F" & GetStrFromIP($nDNS1, TRUE)
			EndIf
		EndIf
		
		If $nDNS2 <> 0 Then
			If $nDNS1 = 0 Then
				$sBlock &= "06000000000000000400000000000000FFFFFF7F" & GetStrFromIP($nDNS2, TRUE)
			Else
				$sBlock &= GetStrFromIP($nDNS2, TRUE)
			EndIf
		EndIf
		
		If $nWINS1 <> 0 Then
			$sBlock &= "2C00000000000000"
			
			If $nWINS2 = 0 Then
				$sBlock &= "0400000000000000FFFFFF7F" & GetStrFromIP($nWINS1, TRUE)
			Else
				$sBlock &= "0800000000000000FFFFFF7F" & GetStrFromIP($nWINS1, TRUE)
			EndIf
		EndIf
		
		If $nWINS2 <> 0 Then
			If $nWINS1 = 0 Then
				$sBlock &= "2C000000000000000400000000000000FFFFFF7F" & GetStrFromIP($nWINS2, TRUE)
			Else
				$sBlock &= GetStrFromIP($nWINS2, TRUE)
			EndIf
		EndIf							
	EndIf

	Return $sBlock	
EndFunc


;**********************************************************************
; Get index of network adapter
;**********************************************************************
Func GetNetAdapterIndex($sDesc)
	Local $i
	
	For $i = 1 To $arNAList[0][0]
		If $arNAList[$i][0] = $sDesc Then Return $i
	Next
	
	Return 0
EndFunc


Func GetNetAdapterIndexByGUID($sNetGUID)
	Local $i
	
	For $i = 1 To $arNAList[0][0]
		If $arNAList[$i][1] = $sNetGUID Then Return $i
	Next
	
	Return 0
EndFunc


Func GetWlanAdapterIndexByGUID($sNetGUID)
	Local $i
	
	For $i = 1 To $arWLANList[0]
		If $arWLANList[$i] = $sNetGUID Then Return $i
	Next
	
	Return 0
EndFunc


;**********************************************************************
; Set/clear address
;**********************************************************************
Func SetAddress($hCtrl, $sAddress)
	If $sAddress = "" Then
		SendMessage($hCtrl, $IPM_CLEARADDRESS, 0, 0)
	Else
		SendMessage($hCtrl, $IPM_SETADDRESS, 0, GetIPFromStr($sAddress))
	EndIf
EndFunc


;**********************************************************************
; Get address
;**********************************************************************
Func GetAddress($hCtrl, ByRef $nIP)
	Local $stIP = DllStructCreate("dword")
	Local $nResult = SendMessage($hCtrl, $IPM_GETADDRESS, 0, DllStructGetPtr($stIP))
	
	$nIP = DllStructGetData($stIP, 1)
	
	Return $nResult
EndFunc


;**********************************************************************
; Get first address entry for address controls
;**********************************************************************
Func GetFirstAddrEntry($sAddr, $sSep)
	Local $arText
	
	$arText = StringSplit($sAddr, $sSep)
	If IsArray($arText) Then Return $arText[1]
	
	Return ""
EndFunc


;**********************************************************************
; Get address from string
;**********************************************************************
Func GetIPFromStr($sIP)
	If $sIP = "" Then Return 0

	Local $arIPS = StringSplit($sIP, ".")
	Local $nIPF1, $nIPF2, $nIPF3, $nIPF4
	
	If IsArray($arIPS) Then
		$nIPF4 = $arIPS[4]
		$nIPF3 = BitShift(Number($arIPS[3]), -8)
		$nIPF2 = BitShift(Number($arIPS[2]), -16)
		$nIPF1 = BitShift(Number($arIPS[1]), -24)
		
		Local $nNewIP = BitOr($nIPF1, $nIPF2, $nIPF3, $nIPF4)
		If $nNewIP < 0 Then $nNewIP = $nNewIP + 4294967296
		
		Return $nNewIP
	EndIf
	
	Return 0
EndFunc
	

;**********************************************************************
; Get string from address
;**********************************************************************
Func GetStrFromIP($nIP, $bHex = FALSE)
	If $nIP = 0 Then Return ""
	
	Local $sIP = ""
	Local $sIPF1, $sIPF2, $sIPF3, $sIPF4
	
	$sIPF4 = BitAnd($nIP, 0xFF)
	$sIPF3 = BitAnd(BitShift($nIP, 8), 0xFF)
	$sIPF2 = BitAnd(BitShift($nIP, 16), 0xFF)
	$sIPF1 = BitAnd(BitShift($nIP, 24), 0xFF)
	
	If $bHex Then
		$sIP = Hex($sIPF1, 2) & Hex($sIPF2, 2) & Hex($sIPF3, 2) & Hex($sIPF4, 2)
	Else
		$sIP = $sIPF1 & "." & $sIPF2 & "." & $sIPF3 & "." & $sIPF4
	EndIf
	
	Return $sIP
EndFunc


;**********************************************************************
; Get string from address
;**********************************************************************
Func CheckAddress($hCtrl, $nField, $nValue)
	; Exclude: 127.X.X.X
	; IP-A: 1.0.0.0 - 127.255.255.255 ; SM: 255.0.0.0
	; IP-B: 128.0.0.0 - 191.255.255.255 ; SM: 255.255.0.0
	; IP-C: 192.0.0.0 - 223.255.255.255 ; SM: 255.255.255.0
	; The allowed values for segments 2, 3, 4 are 0-254
	
	Local $nIP = 0
	Local $nFieldFilled = GetAddress($hCtrl, $nIP)

	If $hCtrl = $hSM Or ($hCtrl = $hAddr2 And $hAddr2 <> 0) Then
		Local $nIPF = 0
		GetAddress($hCtrl, $nIPF)		
	ElseIf $nField = 0 Then
		If $nValue = 0 Or $nValue > 223 Then
			If $nValue = 0 Then
				$nIP = BitOr($nIP, BitShift(1, -24))
			Else
				$nIP = BitOr(BitAnd($nIP, 0xFFFFFF), BitShift(223, -24))
			EndIf

			SetAddress($hCtrl, GetStrFromIP($nIP))
		EndIf
	EndIf
	
	If $nIP = 0 Then SetAddress($hCtrl, "")
EndFunc


;**********************************************************************
; Check for DHCP
;**********************************************************************
Func IsDHCP($sDesc)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return 0
	
	Return GetAdapterProperty($arNAList[$i][1], 0)
EndFunc


;**********************************************************************
; Switch DHCP mode
;**********************************************************************
Func DHCPIPMode($bIsDHCP, $bBtn = FALSE)
	If $bIsDHCP Then
		GUICtrlSetState($nRadIPStatic, $GUI_UNCHECKED)
		GUICtrlSetState($nRadIPDHCP, $GUI_CHECKED)
		
		If Not BitAnd(GetODBtnState($nBtnDhcpInfo), $GUI_ENABLE) Then _
			SetODBtnState($nBtnDhcpInfo, $GUI_ENABLE, FALSE)
		If Not BitAnd(GetODBtnState($nBtnDhcpRelease), $GUI_ENABLE) Then _
			SetODBtnState($nBtnDhcpRelease, $GUI_ENABLE, FALSE)
		If Not BitAnd(GetODBtnState($nBtnDhcpRenew), $GUI_ENABLE) Then _
			SetODBtnState($nBtnDhcpRenew, $GUI_ENABLE, FALSE)
		If Not BitAnd(GetODBtnState($nBtnIPAltShow), $GUI_ENABLE) Then
			SetODBtnState($nBtnIPAltShow, $GUI_ENABLE, FALSE)
		EndIf
		
		SetAddress($hIP, "")
		$sLastIP = ""
		SetAddress($hSM, "")
		$sLastSM = ""
		
		SetCtrlState($hIP, @SW_DISABLE)
		SetCtrlState($hSM, @SW_DISABLE)
		
		If Not BitAnd(GetODBtnState($nBtnIP), $GUI_DISABLE) Then
			SetODBtnState($nBtnIP, $GUI_DISABLE)
			GUICtrlSetCursor($nBtnIP, 0)
		EndIf
				
		GUICtrlSetColor($nLblStaticIP, GetSysColor($COLOR_GRAYTEXT))
		GUICtrlSetColor($nLblStaticSM, GetSysColor($COLOR_GRAYTEXT))
		GUICtrlSetColor($nLblStaticDG, GetSysColor($COLOR_GRAYTEXT))
		
		GUICtrlSetState($nChkDGMode, $GUI_SHOW)
		GUICtrlSetState($nRadDNSDHCP, $GUI_ENABLE)
		GUICtrlSetState($nRadWINSDHCP, $GUI_ENABLE)
	
		If $bBtn Then
			SetAddress($hDG, "")
			$sLastDG = ""
			SetCtrlState($hDG, @SW_DISABLE)
			GUICtrlSetState($nChkDGMode, $GUI_CHECKED)
			EnableDGChange(0)
		Else
			If $sLastDG = "" Then
				GUICtrlSetState($nChkDGMode, $GUI_CHECKED)
				EnableDGChange(0)
			EndIf
		EndIf		
	Else
		GUICtrlSetState($nRadIPDHCP, $GUI_UNCHECKED)
		GUICtrlSetState($nRadIPStatic, $GUI_CHECKED)
		
		If Not BitAnd(GetODBtnState($nBtnDhcpInfo), $GUI_DISABLE) Then _
			SetODBtnState($nBtnDhcpInfo, $GUI_DISABLE, FALSE)
		If Not BitAnd(GetODBtnState($nBtnDhcpRelease), $GUI_DISABLE) Then _
			SetODBtnState($nBtnDhcpRelease, $GUI_DISABLE, FALSE)
		If Not BitAnd(GetODBtnState($nBtnDhcpRenew), $GUI_DISABLE) Then _
			SetODBtnState($nBtnDhcpRenew, $GUI_DISABLE, FALSE)
		If Not BitAnd(GetODBtnState($nBtnIPAltShow), $GUI_DISABLE) Then
			SetODBtnState($nBtnIPAltShow, $GUI_DISABLE, FALSE)
		EndIf
		
		SetCtrlState($hIP, @SW_ENABLE)		
		SetCtrlState($hSM, @SW_ENABLE)	
		SetCtrlState($hDG, @SW_ENABLE)		
				
		GUICtrlSetColor($nLblStaticIP, $nClrLblConf)
		GUICtrlSetColor($nLblStaticSM, $nClrLblConf)
		GUICtrlSetColor($nLblStaticDG, $nClrLblConf)
		
		GUICtrlSetState($nChkDGMode, BitOr($GUI_HIDE, $GUI_UNCHECKED))
		GUICtrlSetState($nRadDNSDHCP, $GUI_DISABLE)
		GUICtrlSetState($nRadWINSDHCP, $GUI_DISABLE)
		
		If Not BitAnd(GetODBtnState($nBtnIP), $GUI_ENABLE) Then
			SetODBtnState($nBtnIP, $GUI_ENABLE)
			GUICtrlSetCursor($nBtnDG, -1)
		EndIf
		
		SetODBtnState($nBtnDG, $GUI_ENABLE)
		If Not BitAnd(GetODBtnState($nBtnDG), $GUI_SHOW) Then _
			SetODBtnState($nBtnDG, $GUI_SHOW)
		GUICtrlSetCursor($nBtnDG, 0)
		
		EnableDNSChange(1)
		EnableWINSChange(1)		
	EndIf
EndFunc


;**********************************************************************
; Enable/Disable DG address
;**********************************************************************
Func EnableDGChange($bEnable)
	If $bEnable Then
		If Not BitAnd(GetODBtnState($nBtnDG), $GUI_ENABLE) Then _	
			SetODBtnState($nBtnDG, $GUI_ENABLE)
					
		SetCtrlState($hDG, @SW_ENABLE)
		
		GUICtrlSetColor($nLblStaticDG, $nClrLblConf)
		
		GUICtrlSetCursor($nBtnDG, 0)
	Else
		If Not BitAnd(GetODBtnState($nBtnDG), $GUI_DISABLE) Then _
			SetODBtnState($nBtnDG, $GUI_DISABLE)
			
		SetCtrlState($hDG, @SW_DISABLE)
		
		GUICtrlSetColor($nLblStaticDG, GetSysColor($COLOR_GRAYTEXT))
		
		GUICtrlSetCursor($nBtnDG, -1)
	EndIf
EndFunc


;**********************************************************************
; Enable/Disable DNS address
;**********************************************************************
Func EnableDNSChange($bEnable)
	If $bEnable Then
		If Not BitAnd(GUICtrlRead($nRadDNSStatic), $GUI_CHECKED) Then GUICtrlSetState($nRadDNSStatic, $GUI_CHECKED)
		If Not BitAnd(GetODBtnState($nBtnDNS), $GUI_ENABLE) Then _
			SetODBtnState($nBtnDNS, $GUI_ENABLE)
		
		SetCtrlState($hDNS, @SW_ENABLE)
		GUICtrlSetColor($nLblDNS, $nClrLblConf)

		GUICtrlSetCursor($nBtnDNS, 0)		
	Else
		If Not BitAnd(GUICtrlRead($nRadDNSDHCP), $GUI_CHECKED) Then GUICtrlSetState($nRadDNSDHCP, $GUI_CHECKED)
		If Not BitAnd(GetODBtnState($nBtnDNS), $GUI_DISABLE) Then _
			SetODBtnState($nBtnDNS, $GUI_DISABLE)
			
		SetCtrlState($hDNS, @SW_DISABLE)
		SetAddress($hDNS, "")
		$sLastDNS = ""
		
		GUICtrlSetColor($nLblDNS, GetSysColor($COLOR_GRAYTEXT))
		
		GUICtrlSetCursor($nBtnDNS, -1)
	EndIf
EndFunc


;**********************************************************************
; Enable/Disable WINS address
;**********************************************************************
Func EnableWINSChange($bEnable)
	If $bEnable Then
		If Not BitAnd(GUICtrlRead($nRadWINSStatic), $GUI_CHECKED) Then GUICtrlSetState($nRadWINSStatic, $GUI_CHECKED)
		If Not BitAnd(GetODBtnState($nBtnWINS), $GUI_ENABLE) Then _
			SetODBtnState($nBtnWINS, $GUI_ENABLE)
			
		SetCtrlState($hWINS, @SW_ENABLE)
		GUICtrlSetColor($nLblWINS, $nClrLblConf)
		
		GUICtrlSetCursor($nBtnWINS, 0)
	Else
		If Not BitAnd(GUICtrlRead($nRadWINSDHCP), $GUI_CHECKED) Then GUICtrlSetState($nRadWINSDHCP, $GUI_CHECKED)
		If Not BitAnd(GetODBtnState($nBtnWINS), $GUI_DISABLE) Then _
			SetODBtnState($nBtnWINS, $GUI_DISABLE)
		
		SetCtrlState($hWINS, @SW_DISABLE)
		SetAddress($hWINS, "")
		$sLastWINS = ""
		
		GUICtrlSetColor($nLblWINS, GetSysColor($COLOR_GRAYTEXT))
		
		GUICtrlSetCursor($nBtnWINS, -1)
	EndIf
EndFunc


;**********************************************************************
; Set state of address controls
;**********************************************************************
Func SetCtrlState($hCtrl, $nState)
	If $nState = @SW_ENABLE Then
		EnableWindow($hCtrl, 1)
		Return
	EndIf
	
	If $nState = @SW_DISABLE Then
		EnableWindow($hCtrl, 0)
		Return
	EndIf
	
	ShowWindow($hCtrl, $nState)
EndFunc


;**********************************************************************
; Create address control
;**********************************************************************
Func GUICtrlCreateIPAddr($nX, $nY, $nW, $nH, $hParent, $hFont)
	Local $nID = GUICtrlCreateDummy()
	
	$nX = GetScaled($nX)
	$nY = GetScaled($nY)
	$nW = GetScaled($nW)
	$nH = GetScaled($nH)
	
	$hCtrl = CreateWindowExW(0, "SysIPAddress32", "", BitOr($WS_VISIBLE, $WS_CHILD, $WS_TABSTOP), $nX, $nY, $nW, $nH, $hParent, $nID, 0, 0)
	If $hCtrl <> 0 Then SendMessage($hCtrl, $WM_SETFONT, $hFont, 1)
	
	Return $hCtrl
EndFunc


;**********************************************************************
; Create icon control
;**********************************************************************
Func GUICtrlCreateStatic($sIconFile, $nIdx, $nX, $nY, $hParent, $nSize = -1, $bScaled = TRUE)
	If $bScaled Then
		$nX = GetScaled($nX)
		$nY = GetScaled($nY)
	EndIf
	
	If $nSize = -1 Then
		$nSize = $nIconSizeSmall
	Else
		$nSize = $nIconSizeBig
	EndIf
	
	$hCtrl = CreateWindowExW(0, "static", "", BitOr($WS_VISIBLE, $WS_CHILD, $SS_ICON), $nX, $nY, 0, 0, $hParent, 0, 0, 0)
	
	If $hCtrl <> 0 Then
		Local $hIcon
		Local $stIcon = DllStructCreate("hwnd")

		If $nSize > $nIconSizeSmall Then
			ExtractIconExW($sIconFile, $nIdx, DllStructGetPtr($stIcon), 0, 1)
		Else
			ExtractIconExW($sIconFile, $nIdx, 0, DllStructGetPtr($stIcon), 1)
		EndIf
		
		$hIcon = DllStructGetData($stIcon, 1)		
		SendMessage($hCtrl, $STM_SETICON, $hIcon, 0)
	EndIf
	
	Return $hCtrl
EndFunc


;**********************************************************************
; Create a new OD button ID
;**********************************************************************
Func CreateNewODBtnIdx()
	Local $i, $bFreeFound = FALSE
	
	For $i = 1 To $ODBUTTONS[0][0]
		If $ODBUTTONS[$i][0] = 0 Then
			$bFreeFound = TRUE
			ExitLoop
		EndIf
	Next
	
	If Not $bFreeFound Then
		$ODBUTTONS[0][0] += 1
		Local $nSize = UBound($ODBUTTONS)

		If $ODBUTTONS[0][0] >= $nSize Then _
			Redim $ODBUTTONS[$nSize + 1][10]
		$i = $ODBUTTONS[0][0]
	EndIf
	
	Return $i
EndFunc


;**********************************************************************
; Destroy the imagelist if deleting a GUI
;**********************************************************************
Func DelODBtnGrp(ByRef $arButtons)
	If IsArray($arButtons) Then
		Local $i
		
		For $i = 1 To $arButtons[0]
			DelODBtnIdx($arButtons[$i])
		Next
	EndIf
	
	$arButtons[0] = 0
EndFunc


;**********************************************************************
; Delete a OD button ID
;**********************************************************************
Func DelODBtnIdx($nIdx)
	If $nIdx = 0 Or $nIdx > $ODBUTTONS[0][0] Then Return 0

	$ODBUTTONS[$nIdx][0] = 0
	$ODBUTTONS[$nIdx][1] = ""
	$ODBUTTONS[$nIdx][2] = FALSE
	$ODBUTTONS[$nIdx][3] = -1
	$ODBUTTONS[$nIdx][4] = -1
	$ODBUTTONS[$nIdx][5] = -1
	$ODBUTTONS[$nIdx][6] = 0
	$ODBUTTONS[$nIdx][7] = -1
	$ODBUTTONS[$nIdx][8] = -1
	
	Return 1
EndFunc


;**********************************************************************
; Get OD button index
;**********************************************************************
Func GetODBtnIdx($nID)
	Local $i, $nIdx = 0
	
	For $i = 1 To $ODBUTTONS[0][0]
		If $nID = $ODBUTTONS[$i][0] Then
			$nIdx = $i
			ExitLoop
		EndIf
	Next
	
	Return $nIdx
EndFunc


;**********************************************************************
; Create a new OD button
;**********************************************************************
Func CreateODBtn($sText, $nX, $nY, $nW, $nH, ByRef $arButtons, $nIconIdx = -1, $bIcon = FALSE, $nClr = -1, $nBkClr = -1, $nMode = -1, $nGridClr = -1, $bScale = TRUE)
	Local $nStyle	= -1
	
	If $bScale Then
		$nX = GetScaled($nX)
		$nY = GetScaled($nY)
		$nW = GetScaled($nW)
		$nH = GetScaled($nH)
	EndIf
	
	Local $nID		= GUICtrlCreateButton($sText, $nX, $nY, $nW, $nH, $nStyle)	
	Local $nIdx		= CreateNewODBtnIdx()
	
	If $nIdx > 0 Then
		$nStyle	= BitOr($WS_VISIBLE, $WS_TABSTOP, $BS_NOTIFY, $BS_OWNERDRAW)
		
		$ODBUTTONS[$nIdx][0] = $nID
		$ODBUTTONS[$nIdx][1] = $sText
		$ODBUTTONS[$nIdx][2] = $bIcon
		$ODBUTTONS[$nIdx][3] = GetBGRColor($nClr)
		$ODBUTTONS[$nIdx][4] = GetBGRColor($nBkClr)
		$ODBUTTONS[$nIdx][5] = $nIconIdx
		$ODBUTTONS[$nIdx][6] = 0
		$ODBUTTONS[$nIdx][7] = $nMode
		$ODBUTTONS[$nIdx][8] = GetBGRColor($nGridClr)
		$ODBUTTONS[$nIdx][9] = GUICtrlGetHandle($nID)
		
		SaveODBtnIdx($nIdx, $arButtons)
		
		GUICtrlSetStyle(-1, $nStyle)
		GUICtrlSetCursor(-1, 0)
	EndIf
	
	Return $nID
EndFunc


;**********************************************************************
; Create a new OD tab
;**********************************************************************
Func CreateODTab($hParent, $sText, $nX, $nY, $nW, $nH, ByRef $arButtons, $nIconIdx = -1, $bIcon = FALSE, $nClr = -1, $nBkClr = -1, $nMode = -1, $nGridClr = -1)
	Local $nID = CreateODBtn($sText, $nX, $nY, $nW, $nH, $arButtons, $nIconIdx, $bIcon, $nClr, $nBkClr, $nMode, $nGridClr, FALSE)
	
	; Cause of wrong calculation in GUI functions we have to resize it to the right values
	GUICtrlSetPos($nID, $nX, $nY, $nW, $nH)
	
	Return $nID
EndFunc


;**********************************************************************
; Save OD button index
;**********************************************************************
Func SaveODBtnIdx($nIdx, ByRef $arButtons)
	$arButtons[0] += 1
	$arButtons[$arButtons[0]] = $nIdx
EndFunc


;**********************************************************************
; Set OD button state
;**********************************************************************
Func SetODBtnState($nID, $nState, $bSwitch = TRUE)
	Local $i = GetODBtnIdx($nID)
	If $i = 0 Then Return 0
	
	Local $nTmpState = $ODBUTTONS[$i][6]
	Local $nC 	= 0
	Local $nU	= 0
	Local $nS	= 0
	Local $nH	= 0
	Local $nE	= 0
	Local $nD	= 0
	
	If BitAnd($nState, $GUI_CHECKED) Then
		$nC = $GUI_CHECKED
		$nU = 0
	ElseIf BitAnd($nState, $GUI_UNCHECKED) Then
		$nC = 0
		$nU = $GUI_UNCHECKED		
	Else
		$nC = BitAnd($nTmpState, $GUI_CHECKED)
		$nU = BitAnd($nTmpState, $GUI_UNCHECKED)
	EndIf
	
	Local $nStyle = BitOr($BS_NOTIFY, $WS_TABSTOP)
	
	If BitAnd($nState, $GUI_SHOW) Then
		$nStyle = BitOr($nStyle, $WS_VISIBLE)
		$nS = $GUI_SHOW
		$nH = 0
	ElseIf BitAnd($nState, $GUI_HIDE) Then
		$nS = 0
		$nH = $GUI_HIDE
	Else
		$nS = BitAnd($nTmpState, $GUI_SHOW)
		$nH = BitAnd($nTmpState, $GUI_HIDE)
	EndIf
	
	If BitAnd($nState, $GUI_ENABLE) Then
		$nE = $GUI_ENABLE
		$nD = 0
	ElseIf BitAnd($nState, $GUI_DISABLE) Then
		$nStyle = BitOr($nStyle, $WS_DISABLED)
		$nE = 0
		$nD = $GUI_DISABLE
	Else
		$nE = BitAnd($nTmpState, $GUI_ENABLE)
		$nD = BitAnd($nTmpState, $GUI_DISABLE)
	EndIf
	
	$ODBUTTONS[$i][6] = BitOr($nC, $nU, $nS, $nH, $nE, $nD)

	Local $hCtrl = GUICtrlGetHandle($nID)

	If BitAnd($nState, $GUI_ENABLE) Then
		EnableWindow($hCtrl, TRUE)
	ElseIf BitAnd($nState, $GUI_DISABLE) Then
		EnableWindow($hCtrl, FALSE)
	EndIf
	
	If BitAnd($nState, $GUI_HIDE) Then
		ShowWindow($hCtrl, @SW_HIDE)
	ElseIf BitAnd($nState, $GUI_SHOW) Then
		ShowWindow($hCtrl, @SW_SHOWNOACTIVATE)
	EndIf
	
	If BitAnd($nState, $GUI_FOCUS) Then
		PostMessage(GetParent($hCtrl), $WM_NEXTDLGCTL, $hCtrl, TRUE)
	EndIf
	
	If $bSwitch And BitAnd($nState, $GUI_FOCUS) Then
		GUICtrlSetStyle($nID, $nStyle)
		GUICtrlSetStyle($nID, BitOr($nStyle, $BS_OWNERDRAW))
	EndIf
		
	Return 1
EndFunc


;**********************************************************************
; Get OD button state
;**********************************************************************
Func GetODBtnState($nID)
	Local $i = GetODBtnIdx($nID)
	If $i = 0 Then Return -1 ;0
	
	Return $ODBUTTONS[$i][6]
EndFunc


;**********************************************************************
; Set OD button data (text, color)
;**********************************************************************
Func SetODBtnData($nID, $sText, $nTxtClr = -1, $nBkClr = -1, $bSwitch = TRUE, $nGridClr = -1)
	Local $i = GetODBtnIdx($nID)
	If $i = 0 Then Return 0
	
	If $sText <> "" Then
		$ODBUTTONS[$i][1] = $sText
		GUICtrlSetData($nID, $sText)
	EndIf
	
	If $nTxtClr <> -1 Then $ODBUTTONS[$i][3] = GetBGRColor($nTxtClr)
	If $nBkClr <> -1 Then $ODBUTTONS[$i][4] = GetBGRColor($nBkClr)
	If $nGridClr <> -1 Then $ODBUTTONS[$i][8] = GetBGRColor($nGridClr)
	
	
	Local $nStyle = GetWindowLongW(GUICtrlGetHandle($nID), $GWL_STYLE)
	$nStyle = BitXor($nStyle, $BS_OWNERDRAW)
	
	If $bSwitch Then
		If BitAnd(GetODBtnState($nID), $GUI_HIDE) = 0 Then
			GUICtrlSetStyle($nID, $nStyle)
			GUICtrlSetStyle($nID, BitOr($nStyle, $BS_OWNERDRAW))
		EndIf
	EndIf
	
	Return 1
EndFunc


;**********************************************************************
; Set OD button icon
;**********************************************************************
Func SetODBtnIcon($nID, $nIconIdx = -1, $bSwitch = TRUE)
	Local $i = GetODBtnIdx($nID)
	If $i = 0 Then Return 0
	
	$ODBUTTONS[$i][5] = $nIconIdx
	
	Local $nStyle = GetWindowLongW(GUICtrlGetHandle($nID), $GWL_STYLE)
	$nStyle = BitXor($nStyle, $BS_OWNERDRAW)
	
	If $bSwitch Then
		GUICtrlSetStyle($nID, $nStyle)
		GUICtrlSetStyle($nID, BitOr($nStyle, $BS_OWNERDRAW))
	EndIf
	
	Return 1
EndFunc


;**********************************************************************
; Set OD button size
;**********************************************************************
Func SetODBtnSize($hGUI, $nID, $sText, ByRef $nX, $nY, $bIcon = TRUE, $bExtWidth = TRUE, $bFromRight = FALSE)
	If $nID <= 0 Then $nX = 0
	
	Local $nW = GetTextSize($hGUI, $sText)
	
	If $bExtWidth Then
		If $bIcon Then
			$nW += GetScaled(32) ; Icon + 3 * Space -> 6 + 16 + 6 + Text + 6
		Else
			$nW += GetScaled(12)
		EndIf
	EndIf
	
	If $nID > 0 Then
		If $bFromRight Then
			If ($nX - $nW) < 0 Then $nX = 0
			GUICtrlSetPos($nID, $nX - $nW, $nY, $nW)
			ControlMove($hGUI, "", $nID, $nX - $nW, $nY, $nW)
		Else
			GUICtrlSetPos($nID, $nX, $nY, $nW)
			ControlMove($hGUI, "", $nID, $nX, $nY, $nW)
		EndIf
	EndIf
	
	$nX += $nW
EndFunc


;**********************************************************************
; Calculate text size by device/font
;**********************************************************************
Func GetTextSize($hGUI, $sText, $hFont = 0)
	Local $nW = 0
	
	;Local $uFlags = BitOr($DT_NOCLIP, $DT_SINGLELINE, $DT_CENTER, $DT_VCENTER, $DT_CALCRECT, $DT_EXPANDTABS)
	Local $uFlags = BitOr($DT_NOCLIP, $DT_SINGLELINE, $DT_VCENTER, $DT_CALCRECT, $DT_EXPANDTABS)
	Local $stRect = DllStructCreate("int;int;int;int")
	DllStructSetData($stRect, 1, 0)
	DllStructSetData($stRect, 2, 0)
	DllStructSetData($stRect, 3, 0)
	DllStructSetData($stRect, 4, 0)
	
	Local $stText = DllStructCreate("wchar[" & (StringLen($sText) + 1) & "]")
	DllStructSetData($stText, 1, $sText)

	If $hFont = 0 Then $hFont = $hGlobalFont
	Local $hDC = GetDC($hGUI)
	Local $hOldFont = SelectObject($hDC, $hFont)
	
	DrawTextW($hDC, DllStructGetPtr($stText), StringLen($sText), DllStructGetPtr($stRect), $uFlags)

	$nW = DllStructGetData($stRect, 3) - DllStructGetData($stRect, 1)
	
	SelectObject($hDC, $hOldFont)
	ReleaseDC($hGUI, $hDC)
	
	Return $nW
EndFunc


;**********************************************************************
; Create balloon info tip
;**********************************************************************
Func CreateBalloonTip($hParent, $sText, $sTitle = "", $nIcon = 0)
	Local $TTM_SETDELAYTIME		= $WM_USER + 3
	Local $TTM_SETMAXTIPWIDTH	= $WM_USER + 24
	Local $TTM_SETTITLEW		= $WM_USER + 33
		
	$hLVTT = CreateWindowExW(0, _
							"tooltips_class32", _
							"", _
							BitOr(0x01, $TTS_NOPREFIX), _
							$CW_USEDEFAULT, _
							$CW_USEDEFAULT, _
							$CW_USEDEFAULT, _
							$CW_USEDEFAULT, _
							$hParent, _
							0, _
							0, _
							0)
	
	If $hLVTT = 0 Then Return 0
	
	Local $stTI = DllStructCreate("uint;uint;hwnd;ptr;int[4];hwnd;ptr;dword")
	DllStructSetData($stTI, 2, BitOr($TTF_IDISHWND, $TTF_SUBCLASS))
	DllStructSetData($stTI, 3, $hParent)
	DllStructSetData($stTI, 4, $hParent)
	DllStructSetData($stTI, 5, 0)
	DllStructSetData($stTI, 6, 0)
	
	Local $stTTT = DllStructCreate("wchar[" & StringLen($sText) + 1 & "]")
	DllStructSetData($stTTT, 1, $sText)
	
	DllStructSetData($stTI, 7, DllStructGetPtr($stTTT))
	DllStructSetData($stTI, 1, DllStructGetSize($stTI))
	
	SendMessage($hLVTT, $TTM_ADDTOOLW, 0, DllStructGetPtr($stTI))
	
	If $sTitle <> "" Then
		Local $stTitle = DllStructCreate("wchar[" & StringLen($sTitle) + 1 & "]")
		DllStructSetData($stTitle, 1, $sTitle)
		SendMessage($hLVTT, $TTM_SETTITLEW, $nIcon, DllStructGetPtr($stTitle))
	EndIf

	SendMessage($hLVTT, $TTM_SETMAXTIPWIDTH, 0, 200)	
	SendMessage($hLVTT, $TTM_SETDELAYTIME, 1, 100)	; TTDT_RESHOW
	SendMessage($hLVTT, $TTM_SETDELAYTIME, 2, 7000)	; TTDT_AUTOPOP
	SendMessage($hLVTT, $TTM_SETDELAYTIME, 3, 200)	; TTDT_INITIAL
EndFunc


;**********************************************************************
; Create global font with right size
;**********************************************************************
Func CreateGlobalFont($hWnd, $nSize, $nWeight, $nAtrribute, $sFont, ByRef $hFont)
	If $hFont = 0 Then
        Local $nHeight	= 0 - ($nSize * 10 * $nLogPixelX / 720)
        Local $stFont	= DllStructCreate("wchar[" & StringLen($sFont) + 1 & "]")
        DllStructSetData($stFont, 1, $sFont)
        $hFont			= CreateFontW($nHeight, 0, 0, 0, $nWeight, _
        								BitAnd($nAtrribute, 2), BitAnd($nAtrribute, 4), BitAnd($nAtrribute, 8), _
        								1, 4, 0, 2, 0, DllStructGetPtr($stFont))
    EndIf
    
    
    If $hFont = 0 Then $hFont = GetStockObject(17) ; 13 -> Get "SYSTEM_FONT" ; 17 -> Get "DEFAULT_GUI_FONT"
		;
		;    -> font numbers can be :
		;    OEM_FIXED_FONT      10
		;    ANSI_FIXED_FONT     11
		;    ANSI_VAR_FONT       12
		;    SYSTEM_FONT         13
		;    DEVICE_DEFAULT_FONT 14
		;    DEFAULT_PALETTE     15
		;    SYSTEM_FIXED_FONT   16
		;    DEFAULT_GUI_FONT    17
		;
		;
EndFunc


;**********************************************************************
; Detect hardware devices
;**********************************************************************
Func DetectDevices($bIsGUIShown, $nLabel)
	Local $nResult	= 0, $nError = 0
	If $hSetupapi = -1 Then Return 1
	
	Debug("IN: DetectDevices")
	
	Local $hDIS		= SetupDiGetClassDevsA(0, 0, 0, BitOr($DIGCF_ALLCLASSES, $DIGCF_PRESENT))
	
	If $hDIS = $INVALID_HANDLE_VALUE Then
		$nResult = GetLastError()
		Return $nResult
	EndIf
	
	Local $stDID = DllStructCreate($sSP_DEVINFO_DATA)
	DllStructSetData($stDID, 1, DllStructGetSize($stDID))

	Local $i = 0, $k = 0, $nLen, $z, $sKey, $sVal
	Local $stBuffer
	Local $stSize		= DllStructCreate("dword")
	Local $stProblem	= DllStructCreate("dword")
	Local $stStatus		= DllStructCreate("dword")
	Local $stReboot		= DllStructCreate("int")
	Local $stGUID		= DllStructCreate($sGUID)
	
	Local $stInstanceID, $stDIP, $stDrvID, $stDrvIDetail, $stClassName, $bInstOK
	Local $sInfFile, $sDrvDesc, $hInfFile, $sSection, $stSection, $sCopyFiles, $arCopyFiles
	Local $hSCM, $stRegBuffer

	If SetupDiEnumDeviceInfo($hDIS, $i, DllStructGetPtr($stDID)) = 0 Then
		$nResult = GetLastError()
		Return $nResult
	EndIf
	
	Local $sProcArch = @ProcessorArch
	If $sProcArch = "x64" Then $sProcArch = "AMD64"
	
	While GetLastError() <> $ERROR_NO_MORE_ITEMS
		$stInstanceID	= DllStructCreate("wchar[" & $_MAX_PATH & "]")
	
		If SetupDiGetDeviceInstanceIdW($hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stInstanceID), $_MAX_PATH, DllStructGetPtr($stSize)) Then
			If CM_Get_DevNode_Status(DllStructGetPtr($stStatus), DllStructGetPtr($stProblem), DllStructGetData($stDID, 6), 0) = 0 Then
				Debug("IN: DeviceInstanceID: " & DllStructGetData($stInstanceID, 1))
				
				If Not StringInStr(DllStructGetData($stInstanceID, 1), "ACPI") And BitAnd(DllStructGetData($stStatus, 1), $DN_HAS_PROBLEM) Then
					$stDIP = DllStructCreate($sSP_DEVINSTALL_PARAMS_W)
					DllStructSetData($stDIP, 1, DllStructGetSize($stDIP))
					
					If SetupDiGetDeviceInstallParamsW($hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stDIP)) Then
						DllStructSetData($stDIP, 2, BitOr(DllStructGetData($stDIP, 2), $DI_QUIETINSTALL, $DI_NOFILECOPY))
						;DI_INSTALLDISABLED          0x00040000L
						DllStructSetData($stDIP, 10, $sPEInfDir)
						Debug("IN: INF search path: " & DllStructGetData($stDIP, 10))
						
						If SetupDiSetDeviceInstallParamsW($hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stDIP)) Then
							If SetupDiBuildDriverInfoList($hDIS, DllStructGetPtr($stDID), $SPDIT_COMPATDRIVER) Then
								If $bIsGUIShown Then GUICtrlSetData($nLabel, $sLblSearchDevice)
								
								$k = 0
								$bInstOK = FALSE
								
								While 1
									$stDrvID = DllStructCreate($sSP_DRVINFO_DATA_W)
									DllStructSetData($stDrvID, 1, DllStructGetSize($stDrvID))
									
									If SetupDiEnumDriverInfoW($hDIS, DllStructGetPtr($stDID), $SPDIT_COMPATDRIVER, $k, DllStructGetPtr($stDrvID)) Then
										SetupDiGetDriverInfoDetailW($hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stDrvID), 0, 0, DllStructGetPtr($stSize))
										Debug("OK: SetupDiGetDriverInfoDetailW - Buffersize needed: " & DllStructGetData($stSize, 1))
										
										$stBuffer		= DllStructCreate("byte[" & DllStructGetData($stSize, 1) & "]")
										$stDrvIDetail	= DllStructCreate($sSP_DRVINFO_DETAIL_DATA_W, DllStructGetPtr($stBuffer))
										DllStructSetData($stDrvIDetail, 1, DllStructGetSize($stDrvIDetail))
										
										If SetupDiGetDriverInfoDetailW($hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stDrvID), DllStructGetPtr($stDrvIDetail), DllStructGetSize($stBuffer), DllStructGetPtr($stSize)) Then
											$nLen = DllStructGetData($stSize, 1) - DllStructGetSize($stDrvIDetail)
											
											$stDrvIDetail = DllStructCreate("dword;dword[2];dword;dword;ulong_ptr;wchar[" & $LINE_LEN & "];" & _
															"wchar[" & $_MAX_PATH & "];wchar[" & $LINE_LEN & "];wchar[" & $nLen & "]", _
															DllStructGetPtr($stBuffer))
															
											$sSection = DllStructGetData($stDrvIDetail, 6)
											$sInfFile = DllStructGetData($stDrvIDetail, 7)
											$sDrvDesc = DllStructGetData($stDrvIDetail, 8)
												
											Debug("IN: SectionName: " & $sSection)
												
											$stClassName = DllStructCreate("wchar[32]")
											If SetupDiGetINFClassW($sInfFile, DllStructGetPtr($stGUID), DllStructGetPtr($stClassName), 32, DllStructGetPtr($stSize)) Then
												If DllStructGetData($stClassName, 1) = "Net" Or StringInStr($sInfFile, "Bus") Then
													DllStructSetData($stReboot, 1, 0)

													If $bIsGUIShown Then GUICtrlSetData($nLabel, $sDeviceFound & ": " & @LF & $sDrvDesc)

													Debug("IN: DeviceFound: " & $sDrvDesc)
													Debug("IN: DeviceDriverFile: " & $sInfFile)
													
													If $bIsWinPE20 Then
														;First try without inf patching
														If DiInstallDevice(0, $hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stDrvID), 0, DllStructGetPtr($stReboot)) Then
														;If UpdateDriverForPlugAndPlayDevicesW(0, DllStructGetData($stDrvIDetail, 9), $sInfFile, BitOr($INSTALLFLAG_FORCE, $INSTALLFLAG_READONLY), DllStructGetPtr($stReboot)) Then
															$nResult = 0
															$bInstOK = TRUE
																														
															If $bIsGUIShown Then
																GUICtrlSetData($nLabel, $sDeviceSucces & ": " & @LF & $sDrvDesc)
																Sleep(100)
															EndIf
															
															ExitLoop
														Else
															;Second try with inf patching
															Debug("IN: Prepare Start DriverFile: " & $sInfFile)
															
															$sCopyFiles = IniRead($sInfFile, $sSection, "CopyFiles", "")
															If $sCopyFiles = "" Then $sCopyFiles = IniRead($sInfFile, $sSection & ".NT", "CopyFiles", "")
															If $sCopyFiles = "" Then $sCopyFiles = IniRead($sInfFile, $sSection & ".NT" & $sProcArch, "CopyFiles", "")
															
															If $sCopyFiles <> "" Then
																$arCopyFiles = StringSplit($sCopyFiles, ",")
																For $z = 1 To $arCopyFiles[0]
																	If $arCopyFiles[$z] <> "" Then IniDelete($sInfFile, $arCopyFiles[$z])
																Next
															EndIf
															
															$sCopyFiles = IniRead($sInfFile, $sSection & ".CoInstallers", "CopyFiles", "")
															If $sCopyFiles = "" Then $sCopyFiles = IniRead($sInfFile, $sSection & ".CoInstallers.NT", "CopyFiles", "")
															If $sCopyFiles = "" Then $sCopyFiles = IniRead($sInfFile, $sSection & ".CoInstallers.NT" & $sProcArch, "CopyFiles", "")
															
															If $sCopyFiles <> "" Then
																$arCopyFiles = StringSplit($sCopyFiles, ",")
																For $z = 1 To $arCopyFiles[0]
																	If $arCopyFiles[$z] <> "" Then IniDelete($sInfFile, $arCopyFiles[$z])
																Next
															EndIf
															
															$sCopyFiles = IniRead($sInfFile, $sSection & ".NT.CoInstallers", "CopyFiles", "")
															If $sCopyFiles = "" Then $sCopyFiles = IniRead($sInfFile, $sSection & ".NT" & $sProcArch & ".CoInstallers", "CopyFiles", "")
															
															If $sCopyFiles <> "" Then
																$arCopyFiles = StringSplit($sCopyFiles, ",")
																For $z = 1 To $arCopyFiles[0]
																	If $arCopyFiles[$z] <> "" Then IniDelete($sInfFile, $arCopyFiles[$z])
																Next
															EndIf
															
															;IniDelete($sInfFile, "Version", "CatalogFile")
															;IniDelete($sInfFile, "Version", "CatalogFile.NT")
															;IniDelete($sInfFile, "Version", "CatalogFile.NT" & $sProcArch)
															
															IniDelete($sInfFile, $sSection, "CopyFiles")
															IniDelete($sInfFile, $sSection & ".NT", "CopyFiles")
															IniDelete($sInfFile, $sSection & ".NT" & $sProcArch, "CopyFiles")
															IniDelete($sInfFile, $sSection, "Include")
															IniDelete($sInfFile, $sSection & ".NT", "Include")
															IniDelete($sInfFile, $sSection & ".NT" & $sProcArch, "Include")
															IniDelete($sInfFile, $sSection, "Needs")
															IniDelete($sInfFile, $sSection & ".NT", "Needs")
															IniDelete($sInfFile, $sSection & ".NT" & $sProcArch, "Needs")
															
															IniDelete($sInfFile, $sSection & ".CoInstallers", "CopyFiles")
															IniDelete($sInfFile, $sSection & ".CoInstallers.NT", "CopyFiles")
															IniDelete($sInfFile, $sSection & ".CoInstallers.NT" & $sProcArch, "CopyFiles")
															IniDelete($sInfFile, $sSection & ".CoInstallers", "Include")
															IniDelete($sInfFile, $sSection & ".CoInstallers.NT", "Include")
															IniDelete($sInfFile, $sSection & ".CoInstallers.NT" & $sProcArch, "Include")
															IniDelete($sInfFile, $sSection & ".CoInstallers", "Needs")
															IniDelete($sInfFile, $sSection & ".CoInstallers.NT", "Needs")
															IniDelete($sInfFile, $sSection & ".CoInstallers.NT" & $sProcArch, "Needs")
															
															IniDelete($sInfFile, $sSection & ".NT.CoInstallers", "CopyFiles")
															IniDelete($sInfFile, $sSection & ".NT" & $sProcArch & ".CoInstallers", "CopyFiles")
															IniDelete($sInfFile, $sSection & ".NT.CoInstallers", "Include")
															IniDelete($sInfFile, $sSection & ".NT" & $sProcArch & ".CoInstallers", "Include")
															IniDelete($sInfFile, $sSection & ".NT.CoInstallers", "Needs")
															IniDelete($sInfFile, $sSection & ".NT" & $sProcArch & ".CoInstallers", "Needs")															
															
															Debug("IN: Prepare End DriverFile: " & $sInfFile)
															
															If DiInstallDevice(0, $hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stDrvID), 0, DllStructGetPtr($stReboot)) Then
																$nResult = 0
																$bInstOK = TRUE
																															
																If $bIsGUIShown Then
																	GUICtrlSetData($nLabel, $sDeviceSucces & ": " & @LF & $sDrvDesc)
																	Sleep(100)
																EndIf
																
																ExitLoop
															EndIf
														EndIf
													Else
														If UpdateDriverForPlugAndPlayDevicesW(0, DllStructGetData($stDrvIDetail, 9), $sInfFile, BitOr($INSTALLFLAG_FORCE, $INSTALLFLAG_READONLY), DllStructGetPtr($stReboot)) Then
															$nResult = 0
															$bInstOK = TRUE
																														
															If $bIsGUIShown Then
																GUICtrlSetData($nLabel, $sDeviceSucces & ": " & @LF & $sDrvDesc)
																Sleep(100)
															EndIf
															
															ExitLoop
														EndIf
													EndIf
												EndIf
											EndIf
										EndIf
											
										$stDrvIDetail = 0
										$stBuffer = 0
									ElseIf GetLastError() = $ERROR_NO_MORE_ITEMS Then
										ExitLoop
									EndIf
									
									$k += 1
								WEnd
								
								If $bInstOK Then
									SetupDiGetDeviceRegistryPropertyW($hDIS, DllStructGetPtr($stDID), $SPDRP_DRIVER, 0, 0, DllStructGetPtr($stSize))
									$stRegBuffer = DllStructCreate("wchar[" & DllStructGetData($stSize, 1) / 2 & "]")
									SetupDiGetDeviceRegistryPropertyW($hDIS, DllStructGetPtr($stDID), $SPDRP_DRIVER, DllStructGetPtr($stRegBuffer), _
																		DllStructGetData($stSize, 1), DllStructGetPtr($stSize))
									$sKey = DllStructGetData($stRegBuffer, 1)
									Debug("IN: Ndi Key: " & $sKey)
									If $sKey <> "" Then
										$sVal = RegRead($sCCS & "\Control\Class\" & $sKey & "\Ndi\Interfaces", "LowerRange")
										Debug("IN: Ndi LowerRange: " & $sVal)
										If StringInStr($sVal, "wlan") Or StringInStr($sVal, "wifi") Then
											$nWiFiCard += 1
										Else
											$sVal = RegRead($sCCS & "\Control\Class\" & $sKey & "\Ndi\Interfaces", "UpperRange")
											Debug("IN: Ndi UpperRange: " & $sVal)
											If StringInStr($sVal, "wlan") Or StringInStr($sVal, "wifi") Then
												$nWiFiCard += 1
											Else
												$sVal = RegRead($sCCS & "\Control\Class\" & $sKey, "*IfType")
												Debug("IN: IfType: " & $sVal)
												If $sVal = 71 Then
													$nWiFiCard += 1
												EndIf											
											EndIf											
										EndIf
									EndIf
								EndIf
								
								SetupDiDestroyDriverInfoList($hDIS, DllStructGetPtr($stDID), $SPDIT_COMPATDRIVER)
							EndIf
						EndIf
					EndIf
					
					$stDIP = 0
				EndIf
			EndIf
		EndIf
		
		$i+= 1
		SetupDiEnumDeviceInfo($hDIS, $i, DllStructGetPtr($stDID))
	WEnd

	SetupDiDestroyDeviceInfoList($hDIS)
	
	If $nResult = $ERROR_NO_MORE_ITEMS Then $nResult = 0
	
	Return $nResult
EndFunc


;**********************************************************************
; Enum WiFi devices count through setupapi
;**********************************************************************
Func EnumWlanDevices()
	Local $nCount = 0
	
	Local $hDIS = SetupDiGetClassDevsA(DllStructGetPtr($stNetGUID), 0, 0, $DIGCF_PRESENT)
	If $hDIS = $INVALID_HANDLE_VALUE Then Return 0
	
	Local $stDID = DllStructCreate($sSP_DEVINFO_DATA)
	DllStructSetData($stDID, 1, DllStructGetSize($stDID))
	Local $stSize = DllStructCreate("dword")
	
	$i = 0
	Local $stBuffer
	Local $sVal
	
	While 1
		SetupDiEnumDeviceInfo($hDIS, $i, DllStructGetPtr($stDID), FALSE)
		If GetLastError() = $ERROR_NO_MORE_ITEMS Then ExitLoop
		
		SetupDiGetDeviceRegistryPropertyW($hDIS, DllStructGetPtr($stDID), $SPDRP_DRIVER, 0, 0, DllStructGetPtr($stSize), FALSE)
		$stBuffer = DllStructCreate("wchar[" & DllStructGetData($stSize, 1) / 2 & "]")
		SetupDiGetDeviceRegistryPropertyW($hDIS, DllStructGetPtr($stDID), $SPDRP_DRIVER, DllStructGetPtr($stBuffer), _
											DllStructGetData($stSize, 1), DllStructGetPtr($stSize), FALSE)
		$sKey = DllStructGetData($stBuffer, 1)
		If $sKey <> "" Then
			$sVal = RegRead($sCCS & "\Control\Class\" & $sKey & "\Ndi\Interfaces", "LowerRange")
			If StringInStr($sVal, "wlan") Or StringInStr($sVal, "wifi") Then
				$nCount += 1
			Else
				$sVal = RegRead($sCCS & "\Control\Class\" & $sKey & "\Ndi\Interfaces", "UpperRange")
				If StringInStr($sVal, "wlan") Or StringInStr($sVal, "wifi") Then
					$nCount += 1
				Else
					$sVal = RegRead($sCCS & "\Control\Class\" & $sKey, "*IfType")
					If $sVal = 71 Then
						$nCount += 1
					Else
						$sVal = RegRead($sCCS & "\Control\Class\" & $sKey, "DriverDesc")
						If StringInStr($sVal, "wireless") Then $nCount += 1
					EndIf
				EndIf
			EndIf
		EndIf
		
		$i += 1
	WEnd
	    
	SetupDiDestroyDeviceInfoList($hDIS)

	$stBuffer = 0
	
	Debug("IN: EnumWlanDevices: Active WiFi devices found: " & $nCount)
	
	Return $nCount
EndFunc


;**********************************************************************
; Restart hardware device after network changes
;**********************************************************************
Func RestartNetDevice($sDesc, $sNetGUID = "")
	Debug("IN: RestartNetDevice: " & $sDesc & "; " & $sNetGUID)
	Local $i
	
	If $sDesc = "" Then
		EnumNetworkAdapters()
		$i = GetNetAdapterIndexByGUID($sNetGUID)
		If $i > 0 Then $sDesc = $arNAList[$i][0]
	Else
		$i = GetNetAdapterIndex($sDesc)
	EndIf
	
	If $i = 0 Then Return
	
	Local $stAdapter = DllStructCreate("wchar[260]")
	DllStructSetData($stAdapter, 1, $arNAList[$i][1])
	
	
	Local $sService = $arNAList[$i][1]
	
	Local $hDIS = SetupDiGetClassDevsA(DllStructGetPtr($stNetGUID), 0, 0, $DIGCF_PRESENT)

	If $hDIS = $INVALID_HANDLE_VALUE Then Return
	
	Local $stDID = DllStructCreate($sSP_DEVINFO_DATA)
	DllStructSetData($stDID, 1, DllStructGetSize($stDID))
	
	Local $stReqSize = DllStructCreate("dword")
	
	$i = 0
	Local $stBuffer, $sVal, $stDIP
	
	While 1
		SetupDiEnumDeviceInfo($hDIS, $i, DllStructGetPtr($stDID))
		If GetLastError() = $ERROR_NO_MORE_ITEMS Then ExitLoop
	
		SetupDiGetDeviceRegistryPropertyW($hDIS, DllStructGetPtr($stDID), $SPDRP_DRIVER, 0, 0, DllStructGetPtr($stReqSize))
		$stBuffer = DllStructCreate("wchar[" & DllStructGetData($stReqSize, 1) / 2 & "]")
		SetupDiGetDeviceRegistryPropertyW($hDIS, DllStructGetPtr($stDID), $SPDRP_DRIVER, DllStructGetPtr($stBuffer), _
											DllStructGetData($stReqSize, 1), DllStructGetPtr($stReqSize))
		$sVal = DllStructGetData($stBuffer, 1)
		If $sVal <> "" Then
			$sVal = RegRead($sCCS & "\Control\Class\" & $sVal, "NetCfgInstanceId")
			If $sVal <> "" And $sVal = $sService Then
				Debug("IN: RestartNetDevice - Found device GUID: " & $sVal)
			
				Local $stSPCH	= DllStructCreate("dword;dword")
				Local $stSPPP	= DllStructCreate("dword;dword;dword;dword;dword")
				Local $stDIP	= DllStructCreate($sSP_DEVINSTALL_PARAMS_W)
				DllStructSetData($stDIP, 1, DllStructGetSize($stDIP))
					
				DllStructSetData($stSPPP, 1, DllStructGetSize($stSPCH))
				DllStructSetData($stSPPP, 2, $DIF_PROPERTYCHANGE)
				;DllStructSetData($stSPPP, 3, $DICS_PROPCHANGE)
				DllStructSetData($stSPPP, 3, 0x00000002)
				DllStructSetData($stSPPP, 4, $DICS_FLAG_CONFIGSPECIFIC)
				DllStructSetData($stSPPP, 5, 0)
				
				Debug("IN: Disable NetDevice")
				SetupDiSetClassInstallParamsW($hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stSPPP), DllStructGetSize($stSPPP))
				SetupDiCallClassInstaller($DIF_PROPERTYCHANGE, $hDIS, DllStructGetPtr($stDID))
				
				Sleep(2000)
				
				Debug("IN: Enable NetDevice")				
				DllStructSetData($stSPPP, 3, 0x00000001)
				SetupDiSetClassInstallParamsW($hDIS, DllStructGetPtr($stDID), DllStructGetPtr($stSPPP), DllStructGetSize($stSPPP))
				SetupDiCallClassInstaller($DIF_PROPERTYCHANGE, $hDIS, DllStructGetPtr($stDID))
				
				Debug("IN: RestartNetDevice - Finished for device GUID: " & $sVal)
				
				ExitLoop
			EndIf
		EndIf
		
		$i += 1
	WEnd
	    
	SetupDiDestroyDeviceInfoList($hDIS)
	
	Sleep($nWaitRestart)
EndFunc


;**********************************************************************
; Release/Renew IP address
;**********************************************************************
Func RenewAdapter($sDesc, $bRenew)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return -1

	If Not GetAdapterProperty($arNAList[$i][1], 0) Then Return -1

	Local $sDeviceName = "\DEVICE\TCPIP_" & $arNAList[$i][1]
	
	Local $stName = DllStructCreate("wchar[" & $MAX_ADAPTER_NAME_LENGTH & "]")
	DllStructSetData($stName, 1, $sDeviceName)

	Local $stIndex = DllStructCreate("dword")
	Local $nIndex = -1

	If GetAdapterIndex(DllStructGetPtr($stName), DllStructGetPtr($stIndex)) = $NO_ERROR Then
		$nIndex = DllStructGetData($stIndex, 1)
		
		Local $stAdapter = DllStructCreate($sIP_ADAPTER_INDEX_MAP)
		DllStructSetData($stAdapter, 1, $nIndex)
		DllStructSetData($stAdapter, 2, $sDeviceName)

		If $bRenew Then
			Debug("IN: RenewAdapter: " & $sDeviceName)
			Return IpRenewAddress(DllStructGetPtr($stAdapter))
		Else
			Debug("IN: ReleaseAdapter: " & $sDeviceName)
			Return IpReleaseAddress(DllStructGetPtr($stAdapter))
		EndIf
	EndIf

	Return 0
EndFunc


;**********************************************************************
; Set current adapter infos
;**********************************************************************
Func Infos2GUI($sDesc)
	Local $bLog = FALSE
	If $sDesc <> $sLastAdapterShow Then $bLog = TRUE
	
	Local $nAdapterState	= -1
	Local $nAdapterSpeed	= 0
	Local $sAdapterMAC		= ""
	
#cs
	MIB_IF_OPER_STATUS_NON_OPERATIONAL      0
	MIB_IF_OPER_STATUS_UNREACHABLE          1
	MIB_IF_OPER_STATUS_DISCONNECTED         2
	MIB_IF_OPER_STATUS_CONNECTING           3
	MIB_IF_OPER_STATUS_CONNECTED            4
	MIB_IF_OPER_STATUS_OPERATIONAL          5
#ce

	If GetNetInterfaceInfos($sDesc, $nAdapterState, $nAdapterSpeed, $sAdapterMAC) = $NO_ERROR Then
		If $bLog Then Debug("OK: GetNetInterfaceInfos: " & $sDesc)
	Else
		If $bLog Then Debug("ER: GetNetInterfaceInfos: " & $sDesc)
		Return -1
	EndIf
	
	Local $bIsWLANI = IsWlanI($sDesc)

	If $nAdapterState <> $nLastAdapterState Or $sDesc <> $sLastAdapterShow Then
		$nLastAdapterState = $nAdapterState
		Switch $nAdapterState
			Case 4, 5 ; Connected
				If $bIsWLANI Then
					SetIconFrom($nIconState, 195, -27, "Icon81")
				Else
					SetIconFrom($nIconState, 185, -9, "Icon79")
				EndIf
				GUICtrlSetTip($nIconState, $sTTCon)
				
			Case Else ; Disconnected
				If $bIsWLANI Then
					SetIconFrom($nIconState, 235, -65, "Icon82")
				ELse
					SetIconFrom($nIconState, 179, -19, "Icon80")
				EndIf
				GUICtrlSetTip($nIconState, $sTTDiscon)
		EndSwitch
		
		If $bIsWLANI Then
			EnumWlanAvailNetworks($sDesc)
		Else
			UpdateWiFiInfo($sDesc)
		EndIf
	EndIf
	
	If $nAdapterSpeed <> $nLastAdapterSpeed Or $sDesc <> $sLastAdapterShow Then
		If ($nAdapterSpeed > $nLastAdapterSpeed + 9) Or _
			($nAdapterSpeed < $nLastAdapterSpeed - 9) Or _
			$sDesc <> $sLastAdapterShow Then Debug("IN: Interface info - Changed speed: " & $nAdapterSpeed)
		SetODBtnData($nBtnSpeed, $nAdapterSpeed & " " & $sAdapterSpeed)
		$nLastAdapterSpeed = $nAdapterSpeed
	EndIf
	
	If Not StringInStr($sAdapterMAC, $nLastAdapterMAC) Then
		Debug("IN: Interface info - Changed MAC: " & $sAdapterMAC)
		GUICtrlSetData($nLblMac, $sAdapterMAC)
		$nLastAdapterMAC = $sAdapterMAC
	EndIf
	
	$sLastAdapterShow = $sDesc
	
	Return $NO_ERROR
EndFunc


;**********************************************************************
; Set current adapter infos
;**********************************************************************
Func UpdateTrayGUI($sDesc)
#cs
	wlan_interface_state_not_ready               = 0,
	wlan_interface_state_connected               = 1,
	wlan_interface_state_ad_hoc_network_formed   = 2,
	wlan_interface_state_disconnecting           = 3,
	wlan_interface_state_disconnected            = 4,
	wlan_interface_state_associating             = 5,
	wlan_interface_state_discovering             = 6,
	wlan_interface_state_authenticating          = 7 
#ce
 
	Local $i = IsWLANI($sDesc)
		
	Local $stVersion	= DllStructCreate("dword")
	Local $stHandle		= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)

	Local $nResult = WlanOpenHandle(1, 0, DllStructGetPtr($stVersion), DllStructGetPtr($stHandle))
	If $nResult <> $ERROR_SUCCESS Then Return
	
	Local $hWlan = DllStructGetData($stHandle, 1)
	Local $stGUID = DllStructCreate($sGUID)

	CreateGUIDFromString($stGUID, $arWLANList[$i])		
	
	Local $stPtr = DllStructCreate("ptr")
	Local $stSize = DllStructCreate("dword")
	Local $sText = ""
	Local $nState = $nLastWiFiState
	
	;Get current interface status
	If WlanQueryInterface($hWlan, DllStructGetPtr($stGUID), 6, 0, DllStructGetPtr($stSize), DllStructGetPtr($stPtr), 0, FALSE) = $ERROR_SUCCESS Then
		Local $stState = DllStructCreate("dword", DllStructGetData($stPtr, 1))
		Local $nState = DllStructGetData($stState, 1)
		WlanFreeMemory(DllStructGetData($stPtr, 1))
		
		If $nState = 1 Or $nState = 2 Or ($nState >=5 And $nState <= 7) Then ; connected or connecting
			If WlanQueryInterface($hWlan, DllStructGetPtr($stGUID), 7, 0, DllStructGetPtr($stSize), DllStructGetPtr($stPtr), 0, FALSE) = $ERROR_SUCCESS Then
				Local $stWCA	= DllStructCreate($sWLAN_CONNECTION_ATTRIBUTES, DllStructGetData($stPtr, 1))
				Local $nLen		= DllStructGetData($stWCA, 4)
				Local $bAdhoc	= FALSE
				If $nLen < StringLen(DllStructGetData($stWCA, 3)) Then $bAdhoc = TRUE
				Local $sSSIDCon	= DllStructGetData($stWCA, 5)
				Local $nSignal	= DllStructGetData($stWCA, 10)
				Local $nIdx		= -1
				
				For $i = 0 To (GUICtrlSendMsg($nLVWLAvailTray, $LVM_GETITEMCOUNT, 0, 0) - 1)
					$sText = GetLVIText($nLVWLAvailTray, $i, 1)
					If $sText = $sSSIDCon Then
						$nIdx = $i
						ExitLoop
					EndIf
				Next
				
				Local $nIcon = 0
				Local $nBitType = 0
					
				If $nIdx > -1 Then
					For $i = 1 To $arWLAVNList[0][0]
						If $sText = $arWLAVNList[$i][1] Then
							$nEntry = $i
							$nBitType = $arWLAVNList[$i][5]; (1=0%, 2=20%, 4=40%, 8=60%, 16=80%, 32=100%, 64=secured, 128=adhoc, 256=connected, 512=connectable, 1024/2048=authenticating, 4096=prefered)
							ExitLoop
						EndIf
					Next
					
					Switch $nState
						Case 5, 6, 7
							; Authenticating
							$arWLAVNList[$nEntry][5] = BitOr($nBitType, 1024)
							
							If $nLastWiFiIcon = 0 Then
								$nIcon = 1
							Else
								$nIcon = 0
							EndIf
							
							$arWLAVNList[$nEntry][5] = BitXor($arWLAVNList[$nEntry][5], 2048)
							SetLVIText($nLVWLAvailTray, $nIdx, 0, $arWLAVNList[$nEntry][5])
						Case Else
							If BitAnd($nBitType, 1024) Or BitAnd($nBitType, 2048) Then
								If BitAnd($nBitType, 1024) Then $arWLAVNList[$nEntry][5] = BitXor($nBitType, 1024)
								If BitAnd($nBitType, 2048) Then $arWLAVNList[$nEntry][5] = BitXor($nBitType, 2048)
								SetLVIText($nLVWLAvailTray, $nIdx, 0, $nBitType)
							EndIf
					EndSwitch
					
					If ($sLastWiFiSSID <> $sSSIDCon) Or ($sLastWiFiShow <> $sDesc) Or ($nLastWiFiState <> $nState) Or ($nLastWiFiIcon <> $nIcon) Then
						SetAdvLVItemIcon($nLVWLAvailTray, $nIdx, 0, $nLastWiFiIcon)
						SetLVIText($nLVWLAvailTray, $nIdx, 1, $sSSIDCon) ; Refresh
						$nLastWiFiIcon = BitXor($nLastWiFiIcon, 1)
					EndIf
				EndIf
				
				$sLastWiFiSSID = $sSSIDCon
				
				WlanFreeMemory(DllStructGetData($stPtr, 1))
			EndIf
		Else
			If ($sLastWiFiSSID <> "") Or ($sLastWiFiShow <> $sDesc) Then
				Local $nIdx = -1
				For $i = 0 To (GUICtrlSendMsg($nLVWLAvailTray, $LVM_GETITEMCOUNT, 0, 0) - 1)
					$sText = GetLVIText($nLVWLAvailTray, $i, 1)
					If $sText = $sLastWiFiSSID Then
						$nIdx = $i
						ExitLoop
					EndIf
				Next
				
				If $nIdx > -1 Then
					For $i = 1 To $arWLAVNList[0][0]
						If $sText = $arWLAVNList[$i][1] Then
							$nEntry = $i
							$nBitType = $arWLAVNList[$i][5]
							ExitLoop
						EndIf
					Next
				
					If BitAnd($nBitType, 128) Then
						$arWLAVNList[$nEntry][5] = BitOr(1, 128)
						If BitAnd($nBitType, 64) Then $arWLAVNList[$nEntry][5] = BitOr($arWLAVNList[$nEntry][5], 64)
						If BitAnd($nBitType, 512) Then $arWLAVNList[$nEntry][5] = BitOr($arWLAVNList[$nEntry][5], 512)
						If BitAnd($nBitType, 4096) Then $arWLAVNList[$nEntry][5] = BitOr($arWLAVNList[$nEntry][5], 4096)
					Else
						If BitAnd($nBitType, 256) Then $arWLAVNList[$nEntry][5] = BitXor($arWLAVNList[$nEntry][5], 256) ; Not connected anymore
						If BitAnd($nBitType, 1024) Then $arWLAVNList[$nEntry][5] = BitXor($arWLAVNList[$nEntry][5], 1024) ; Not authenticating anymore
						If BitAnd($nBitType, 2048) Then $arWLAVNList[$nEntry][5] = BitXor($arWLAVNList[$nEntry][5], 2048) ; Not authenticating anymore
					EndIf
					
					SetLVIText($nLVWLAvailTray, $nIdx, 0, $arWLAVNList[$nEntry][5])
					SetAdvLVItemIcon($nLVWLAvailTray, $nIdx, 0, $nLastWiFiIcon)
					SetLVIText($nLVWLAvailTray, $nIdx, 1, $sLastWiFiSSID)
					$nLastWiFiIcon = BitXor($nLastWiFiIcon, 1)
				EndIf
			
			EndIf
			
			$sLastWiFiSSID = ""
		EndIf
	EndIf
	
	WlanCloseHandle($hWlan, 0)
	
	If ($nState <> $nLastWiFiState) And (($nState = 1 Or $nState = 2) And $nLastWiFiState <> 1) Then ;Or ($nState = 4 And $nLastWiFiState <> 4)) Then
		Sleep(250)
		EnumWlanAvailNetworks($sDesc, FALSE, $nLVWLAvailTray)
		SetODBtnState($nBtnWLConTray, $GUI_DISABLE, FALSE)
		SetODBtnData($nBtnWLConTray, $sBtnWiFiDisconnect, FALSE)
	EndIf
	
	$sLastWiFiShow = $sDesc
	$nLastWiFiState = $nState
EndFunc


;**********************************************************************
; Reload only static infos to GUI
;**********************************************************************
Func Static2GUI($sDesc)
	Debug("IN: Static2GUI")

	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $oConf = 0	
	If $bUseWMI Then
		Local $oConfigs		= $oWMISrv.ExecQuery("SELECT * FROM Win32_NetworkAdapterConfiguration Where Description = """ & $arNAList[$i][2] & """")
		Local $oConfItem	= 0
		For $oConfItem In $oConfigs
			$oConf = $oConfItem
		Next
	EndIf
	
	Local $bIsDHCP = GetAdapterProperty($arNAList[$i][1], 0, $oConf)
	If $bIsDHCP Then Return
	
	$sLastIP = GetAdapterProperty($arNAList[$i][1], 1, $oConf)
	$sLastSM = GetAdapterProperty($arNAList[$i][1], 2, $oConf)	
	$sLastDG	= GetAdapterProperty($arNAList[$i][1], 3, $oConf)	
	$sLastDNS	= GetAdapterProperty($arNAList[$i][1], 4, $oConf)
	$sLastWINS	= GetAdapterProperty($arNAList[$i][1], 5, $oConf)
	
	$sLastIPDef = GetFirstAddrEntry($sLastIP, @LF)
	$sLastSMDef = GetFirstAddrEntry($sLastSM, @LF)
	$sLastDGDef = GetFirstAddrEntry($sLastDG, @LF)
	$sLastDNSPref = GetFirstAddrEntry($sLastDNS, ",")
	$sLastWINSPref = GetFirstAddrEntry($sLastWINS, @LF)
		
	SetAddress($hIP, $sLastIPDef)
	SetAddress($hSM, $sLastSMDef)
	SetAddress($hDG, $sLastDGDef)
	SetAddress($hDNS, $sLastDNSPref)
	SetAddress($hWINS, $sLastWINSPref)
EndFunc


;**********************************************************************
; Get adapter infos
;**********************************************************************
Func GetNetInterfaceInfos($sDesc, ByRef $nAdapterState, ByRef $nAdapterSpeed, ByRef $sAdapterMAC)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return -1
	
	Local $sService		= $arNAList[$i][1]
	Local $stIFEntry	= DllStructCreate($sMIB_IFROW)
	Local $stName		= DllStructCreate("wchar[" & $MAX_ADAPTER_NAME_LENGTH & "]")
	DllStructSetData($stName, 1, "\DEVICE\TCPIP_" & $sService)
	
	Local $stIndex		= DllStructCreate("dword")
	Local $nIndex		= -1
	
	If GetAdapterIndex(DllStructGetPtr($stName), DllStructGetPtr($stIndex)) = $NO_ERROR Then
		$nIndex = DllStructGetData($stIndex, 1)
		DllStructSetData($stIFEntry, 2, $nIndex)
		
		If GetIfEntry(DllStructGetPtr($stIFEntry)) = $NO_ERROR Then
			$nAdapterSpeed	= DllStructGetData($stIFEntry, 5)
			
			If $nAdapterSpeed < 0 Or $nAdapterSpeed > 4294967294 Then
				$nAdapterSpeed = 0
			Else
				$nAdapterSpeed = Round($nAdapterSpeed / 1000000)
			EndIf
			
			$nLen			= DllStructGetData($stIFEntry, 6)
			$sAdapterMAC	= ""
			
			For $c = 1 To $nLen - 1
				$sAdapterMAC = $sAdapterMAC & Hex(DllStructGetData($stIFEntry, 7, $c), 2) & "-"
			Next
			$sAdapterMAC = $sAdapterMAC & Hex(DllStructGetData($stIFEntry, 7, $nLen), 2)
			
			$nAdapterState = DllStructGetData($stIFEntry, 9)
			
			Return $NO_ERROR
		Else
			Return -1
		EndIf
	Else
		Return -1
	EndIf
	
	Return -1
EndFunc


;**********************************************************************
; Checks adapter activity
;**********************************************************************
Func CheckAdapterActivity()
	Local $stIP_ADAPTER_INFO	= DllStructCreate($sIP_ADAPTER_INFO)
	Local $stReqSize			= DllStructCreate("dword")
	Local $nIndex				= 0
	Local $stIFEntry			= DllStructCreate($sMIB_IFROW)
	Local $nState				= 0
	Local $bSend				= FALSE
	Local $bReceive				= FALSE
	Local $bOperStateChange		= FALSE
	Local $nConnected			= 0
	Local $nWiFiConnected		= 0
	Local $nNetDevices			= 0 ; Count conncted network devices
	Local $nWiFiDevices			= 0 ; Count only wifi devices
	Local $nWiFiSignal			= 0
	Local $pIPAI
	
	#cs
	typedef enum _INTERNAL_IF_OPER_STATUS {
    IF_OPER_STATUS_NON_OPERATIONAL = 0,
    IF_OPER_STATUS_UNREACHABLE     = 1,
    IF_OPER_STATUS_DISCONNECTED    = 2,
    IF_OPER_STATUS_CONNECTING      = 3,
    IF_OPER_STATUS_CONNECTED       = 4,
    IF_OPER_STATUS_OPERATIONAL     = 5,
	} INTERNAL_IF_OPER_STATUS;
	#ce
	
	If GetAdaptersInfo(DllStructGetPtr($stIP_ADAPTER_INFO), DllStructGetPtr($stReqSize), FALSE) = -1 Then Return
		
	Local $stBuffer				= DllStructCreate("byte[" & DllStructGetData($stReqSize, 1) & "]")

	If GetAdaptersInfo(DllStructGetPtr($stBuffer), DllStructGetPtr($stReqSize), FALSE) = $ERROR_SUCCESS Then
		$stIP_ADAPTER_INFO		= DllStructCreate($sIP_ADAPTER_INFO, DllStructGetPtr($stBuffer))
		Local $nOctetIn			= 0
		Local $nOctetOut		= 0
		Local $i				= 0
		Local $bFound			= FALSE
		Local $nOperState		= 0
		Local $nSignal			= 0
		
		Local $sProfileConnected, $sSSID, $sMAC, $bAdhoc, $bWiFiDevice, $sGUID, $i, $n, $c, $sKey, $bIsPhys, $sServiceName
		
		While 1
			$nIndex = DllStructGetData($stIP_ADAPTER_INFO, 7)
			DllStructSetData($stIFEntry, 2, $nIndex)
			
			;Check if the adapter is physical or virtual with easy method, correctly would be to check "Characteristics" for OR values: NCF_VIRTUAL = 0x1, NCF_PHYSICAL = 0x4
			$sGUID = DllStructGetData($stIP_ADAPTER_INFO, 3)
			$c = 1
			$bIsPhys = FALSE
			While 1
				$sServiceName = ""
				$sKey = RegEnumKey("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards", $c)
				If @Error <> 0 Then ExitLoop
				
				$sServiceName = RegRead("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\" & $sKey, "ServiceName")
				If $sServiceName = $sGUID Then
					$bIsPhys = TRUE
					ExitLoop
				EndIf
				
				$c += 1
			WEnd
			
			If $bIsPhys Then			
				If GetIfEntry(DllStructGetPtr($stIFEntry)) = $NO_Error Then				
					$nOctetIn	= Number(DllStructGetData($stIFEntry, 11))
					$nOctetOut	= Number(DllStructGetData($stIFEntry, 17))
					$nOperState	= Number(DllStructGetData($stIFEntry, 9))
					
					$bWiFiDevice = FALSE
					For $n = 1 To $arWLANList[0]
						If $arWLANList[$n] = $sGUID Then
							$nWiFiDevices += 1
							$bWiFiDevice = TRUE
							
							GetWlanCurCon(DllStructGetData($stIP_ADAPTER_INFO, 4), $sProfileConnected, $sSSID, $sMAC, $bAdhoc, $nSignal, 0, 0, FALSE)
							
							Switch $nSignal
								Case 1 To 20
									$nWiFiSignal = 1
								Case 21 To 40
									$nWiFiSignal = 2
								Case 41 To 60
									$nWiFiSignal = 3
								Case 61 To 80
									$nWiFiSignal = 4
								Case 81 To 100
									$nWiFiSignal = 5
							EndSwitch
						EndIf
					Next
					
					If $nOperState > 2 Then
						If $bWiFiDevice Then
							$nWiFiConnected += 1
						Else
							$nConnected += 1
						EndIf
						
						$bFound		= FALSE
						
						For $i = 1 To $arOctets[0][0]
							If $arOctets[$i][0] = $nIndex Then
								$bFound = TRUE
								
								; Recieve	
								If $arOctets[$i][1] <> $nOctetIn Then
									$arOctets[$i][1] = $nOctetIn
									$bReceive = TRUE
								EndIf
								
								; Send
								If $arOctets[$i][2] <> $nOctetOut Then
									$arOctets[$i][2] = $nOctetOut
									$bSend = TRUE
								EndIf
								
								; State
								If $arOctets[$i][3] <> $nOperState Then
									$arOctets[$i][3] = $nOperState
									$bOperStateChange = TRUE
								EndIf
								
								ExitLoop
							EndIf
						Next
						
						If $bReceive Or $bSend Or $bOperStateChange Then
							;Debug("IN: New adapter activity: ") ; Deactivated 22.01.2012 Holger too much debug lines
							;ExitLoop
						EndIf
						
						If Not $bFound Then
							$arOctets[0][0] += 1
							$arOctets[$arOctets[0][0]][0] = $nIndex
							$arOctets[$arOctets[0][0]][1] = $nOctetIn
							$arOctets[$arOctets[0][0]][2] = $nOctetOut
							$arOctets[$arOctets[0][0]][3] = $nOperState
						EndIf					
					EndIf
				EndIf
			EndIf
			
			$pIPAI = DllStructGetData($stIP_ADAPTER_INFO, 1)
			If $pIPAI = 0 Then
				ExitLoop
			Else
				$stIP_ADAPTER_INFO = 0
				$stIP_ADAPTER_INFO = DllStructCreate($sIP_ADAPTER_INFO, $pIPAI)
			EndIf
		WEnd
	Else
		Debug("ER: GetAdaptersInfo")
	EndIf
	
	$stIP_ADAPTER_INFO = 0
	
	If $nConnected = 0 And $nWiFiDevices = 0 Then
		$nState = 4
	Else
		;If $nWiFiConnected >= $nConnected Or ($nConnected = 0 And $nWiFiDevices > 0) Then
		;If $nWiFiConnected > 0 Or ($nConnected = 0 And $nWiFiDevices > 0) Then
		If ($nWiFiDevices > 0 And ($nConnected = 0 Or $nWiFiConnected > 0)) Then
		;If ($nWiFiDevices > 0 And $nConnected = 0) Then  ; Changed back to previous 22.12.2018
			$nState = 5
			If $nWiFiDevices > 0 And $nWiFiConnected > 0 Then				
				If $bSend And $bReceive Then
					Switch $nWiFiSignal
						Case 1
							$nState = 7
						Case 2
							$nState = 8
						Case 3
							$nState = 9
						Case 4
							$nState = 10
						Case 5
							$nState = 11
					EndSwitch
				Else
					If $bSend Then
						Switch $nWiFiSignal
							Case 1
								$nState = 12
							Case 2
								$nState = 13
							Case 3
								$nState = 14
							Case 4
								$nState = 15
							Case 5
								$nState = 16
						EndSwitch
					ElseIf $bReceive Then
						Switch $nWiFiSignal
							Case 1
								$nState = 17
							Case 2
								$nState = 18
							Case 3
								$nState = 19
							Case 4
								$nState = 20
							Case 5
								$nState = 21
						EndSwitch
					Else
						Switch $nWiFiSignal
							Case 1
								$nState = 22
							Case 2
								$nState = 23
							Case 3
								$nState = 24
							Case 4
								$nState = 25
							Case 5
								$nState = 26
						EndSwitch
					EndIf
				EndIf
			EndIf
		Else
			If $bSend And $bReceive Then
				$nState = 1
			Else
				If $bSend Then
					$nState = 2
				ElseIf $bReceive Then
					$nState = 3
				EndIf
			EndIf
		EndIf
	EndIf
	
	Return $nState
EndFunc


;**********************************************************************
; Set the computername
;**********************************************************************
Func SetCN($sPCName)
	Local $stCN = DllStructCreate("wchar[" & ($MAX_COMPUTERNAME_LENGTH + 1) & "]")
	DllstructSetData($stCN, 1, $sPCName)
	
	RegDelete($sCCS & "\Services\Tcpip\Parameters", "Hostname")
	RegDelete($sCCS & "\Services\Tcpip\Parameters", "NV Hostname")
		
	Local $nResult = SetComputerNameExW(5, DllStructGetPtr($stCN))
	
	If $nResult = 0 Then
		Debug("ER: SetComputerNameExW: " & $sPCName & "; Error: " & GetLastError())
	Else
		RegWrite($sCCS & "\Control\ComputerName\ActiveComputerName", "ComputerName", "REG_SZ", $sPCName)
		RegWrite($sCCS & "\Control\Session Manager\Environment", "COMPUTERNAME", "REG_SZ", $sPCName)
		RegWrite($sCCS & "\Services\Tcpip\Parameters", "Hostname", "REG_SZ", $sPCName)
		RegWrite($sCCS & "\Services\Tcpip\Parameters", "NV Hostname", "REG_SZ", $sPCName)
		Debug("OK: SetComputerNameExW: " & $sPCName)
	EndIf
	
	Return $nResult
EndFunc


;**********************************************************************
; Get the workgroup
;**********************************************************************
Func GetWorkGroup()
	Local $stPtr = DllStructCreate("ptr")
	
	Local $nResult = NetWkstaGetInfo(0, 100, DllStructGetPtr($stPtr))

	Local $stWKSTA_Info	= DllStructCreate($sWKSTA_INFO_100, DllStructGetData($stPtr, 1))
	Local $stString		= DllStructCreate("wchar[" & (wcslen(DllStructGetData($stWKSTA_Info, 3)) + 1) & "]", DllStructGetData($stWKSTA_Info, 3))
	Local $sString		= DllStructGetData($stString, 1)

	NetApiBufferFree(DllStructGetData($stPtr, 1))
	
	Return StringUpper($sString)
EndFunc


;**********************************************************************
; Set the workgroup
;**********************************************************************
Func SetWorkGroup($sWG)
	Local $sUWG = StringUpper($sWG)
	Local $stWG = DllStructCreate("wchar[" & ($MAX_COMPUTERNAME_LENGTH + 1) & "]")
	DllStructSetData($stWG, 1, $sUWG)

	Local $nResult = NetJoinDomain(0, DllStructGetPtr($stWG), 0, 0, 0, 0)
	If $nResult = $NERR_Success Then
		GUICtrlSetData($nInpPCWG, $sUWG)
		Debug("OK: NetJoinDomain: " & $sUWG)
	Else
		Debug("ER: NetJoinDomain: " & $sUWG & "; Error: " & $nResult)
	EndIf
	
	Return $nResult
EndFunc


;**********************************************************************
; Get the DNS suffix
;**********************************************************************
Func GetDNSSuffix()
	Local $sDNSSuffix = ""
	Local $stSize = DllStructCreate("dword")
	DllStructSetData($stSize, 1, "0")
	
	GetComputerNameExW(6, 0, DllStructGetPtr($stSize)) ; Get needed buffer size
	Local $stDNS = DllStructCreate("wchar[" & DllStructGetData($stSize, 1) & "]")
	
	If GetComputerNameExW(6, DllStructGetPtr($stDNS), DllStructGetPtr($stSize)) = 0 Then
		$sDNSSuffix = RegRead($sCCS & "\Services\Tcpip\Parameters", "NV Domain")
	Else
		$sDNSSuffix = DllStructGetData($stDNS, 1)
	EndIf
	
	Return $sDNSSuffix
EndFunc


;**********************************************************************
; Set the DNS suffix
;**********************************************************************
Func SetDNSSuffix($sDNSSuffix)
	; FQDN - Max. 255 chars, 63 for every label: 63chars.63chars.63chars.63chars
	Local $stDNS	= DllStructCreate("wchar[" & (255 - $MAX_COMPUTERNAME_LENGTH + 1) & "]")
	DllstructSetData($stDNS, 1, $sDNSSuffix)
		
	Local $nResult = SetComputerNameExW(6, DllStructGetPtr($stDNS))
	
	If $nResult = 0 Then
		Debug("ER: SetComputerNameExW: " & $sDNSSuffix & "; Error: " & GetLastError())
	Else
		RegWrite($sCCS & "\Services\Tcpip\Parameters", "Domain", "REG_SZ", $sDNSSuffix)
		RegWrite($sCCS & "\Services\Tcpip\Parameters", "NV Domain", "REG_SZ", $sDNSSuffix)
		Debug("OK: SetComputerNameExW: " & $sDNSSuffix)
	EndIf
	
	Return $nResult
EndFunc


;**********************************************************************
; Gets the current shared folders
;**********************************************************************
Func EnumShares()
	Local $i, $pBuffer, $nResult, $stSI2, $stFolder, $sFolder, $stPath, $sPath, $nConn
	Local $nIconIdx	= -1
	Local $stBuffer = DllStructCreate($sSHARE_INFO_2)
	Local $stRead	= DllStructCreate("dword")
	DllStructSetData($stRead, 1, 0)
	Local $stTotal	= DllStructCreate("dword")
	DllStructSetData($stTotal, 1, 0)
	Local $stHandle	= DllStructCreate("dword")
	DllStructSetData($stHandle, 1, 0)
	
	GUICtrlSendMsg($nLVShares, $LVM_DELETEALLITEMS, 0, 0)	
	
	Do
		$nResult = NetShareEnum(0, 2, DllStructGetPtr($stBuffer), $MAX_PREFERRED_LENGTH, DllStructGetPtr($stRead), _
			DllStructGetPtr($stTotal), DllStructGetPtr($stHandle))
		If $nResult = $NERR_Success Or $nResult = $ERROR_MORE_DATA Then
			$pBuffer = DllStructGetData($stBuffer, 1)
		
			For $i = 1 To DllStructGetData($stRead, 1)
				$stSI2		= DllStructCreate($sSHARE_INFO_2, $pBuffer)
				
				If DllStructGetData($stSI2, 2) <> $STYPE_PRINTQ Then
					$stFolder	= DllStructCreate("wchar[" & (wcslen(DllStructGetData($stSI2, 1)) + 1) & "]", DllStructGetData($stSI2, 1))
					$sFolder	= DllStructGetData($stFolder, 1)
					$nConn		= DllStructGetData($stSI2, 6)
					$sPath		= ""
					
					If DllStructGetData($stSI2, 7) <> 0 Then
						$stPath	= DllStructCreate("wchar[" & (wcslen(DllStructGetData($stSI2, 7)) + 1) & "]", DllStructGetData($stSI2, 7))
						$sPath	= DllStructGetData($stPath, 1)
					EndIf
					
					If $sPath = "0" Then $sPath = ""
					
					$nIconIdx = 0
					If StringRight($sFolder, 1) = "$" Then $nIconIdx = 1
	
					CreateAdvLVItem($sFolder & "|" & $sPath & "|" & $nConn, $nLVShares, "", $nIconIdx)
				EndIf
				
				$pBuffer += DllStructGetSize($stSI2)
			Next
			
			NetApiBufferFree(DllStructGetData($stBuffer, 1))
		EndIf
	Until $nResult <> $ERROR_MORE_DATA
	
	SetODBtnState($nBtnShrDel, $GUI_DISABLE)
	$nLVShrLast = -1
EndFunc


;**********************************************************************
; Shares a folder
;**********************************************************************
Func AddShare($nMsg)
	Local $arPos, $i
	
	If Not $bShareShowInp Then
		$arPos = ControlGetPos($hSharesGUI, "", $nLVShares)
		If IsArray($arPos) Then
			If ControlMove($hSharesGUI, "", $nLVShares, GetScaled(5), GetScaled(237), GetScaled(394), GetScaled(140)) Then
				SetODBtnState($nBtnShrAddShow, $GUI_HIDE)
				GUICtrlSetState($nLblShrName, $GUI_SHOW)
				GUICtrlSetState($nInpShrName, $GUI_SHOW)
				GUICtrlSetState($nLblShrPath, $GUI_SHOW)
				GUICtrlSetState($nInpShrPath, $GUI_SHOW)
				SetODBtnState($nBtnShrPath, $GUI_SHOW)
				SetODBtnState($nBtnShrAdd, $GUI_SHOW + $GUI_FOCUS)
				
				$bShareShowInp = TRUE
			EndIf
		EndIf
	ElseIf $nMsg = $nBtnShrAdd Then
		Local $sName = GUICtrlRead($nInpShrName)
		Local $sPath = GUICtrlRead($nInpShrPath)
		Local $sDrive = StringLeft($sPath, 2)
	
		ShareFolder($sName, $sPath, $sDrive)
		
		GUICtrlSetData($nInpShrName, "")
		GUICtrlSetData($nInpShrPath, "")
		
		$arPos = ControlGetPos($hSharesGUI, "", $nLVShares)
		If IsArray($arPos) Then
			SetODBtnState($nBtnShrAdd, $GUI_HIDE)
			GUICtrlSetState($nLblShrName, $GUI_HIDE)
			GUICtrlSetState($nInpShrName, $GUI_HIDE)
			GUICtrlSetState($nLblShrPath, $GUI_HIDE)
			GUICtrlSetState($nInpShrPath, $GUI_HIDE)
			SetODBtnState($nBtnShrPath, $GUI_HIDE)
			GUICtrlSetState($nBtnShrAddShow, $GUI_SHOW)
			SetODBtnState($nBtnShrAddShow, $GUI_SHOW + $GUI_FOCUS)
			ControlMove($hSharesGUI, "", $nLVShares, GetScaled(5), GetScaled(186), GetScaled(394), GetScaled(191))

			$bShareShowInp = FALSE
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Share a folder
;**********************************************************************
Func ShareFolder($sName, $sPath, $sDrive, $sComment = "", $bSilent = FALSE)
	If $sDrive <> "" And DriveGetType($sDrive) = "NETWORK" Then
		If Not $bSilent Then MsgBoxEx(16, $sERROR, $sErrorNetShared, $hSharesGUI)
	ElseIf $sName <> "" And $sPath <> "" Then
		Local $stName = DllStructCreate("wchar[" & $_MAX_PATH & "]")
		DlLStructSetData($stName, 1, $sName)
		
		Local $stPath = DllStructCreate("wchar[" & $_MAX_PATH & "]")
		DlLStructSetData($stPath, 1, $sPath)
		
		Local $stSH2 = DllStructCreate($sSHARE_INFO_2)
		DllStructSetData($stSH2, 1, DllStructGetPtr($stName))
		DllStructSetData($stSH2, 2, 0)
		If $sComment = "" Then
			DllStructSetData($stSH2, 3, 0)
		Else
			Local $stComment = DllStructCreate("wchar[" & $_MAX_PATH & "]")
			DlLStructSetData($stComment, 1, $sComment)
			DllStructSetData($stSH2, 3, DllStructGetPtr($stComment))
		EndIf
		
		DllStructSetData($stSH2, 4, 0)
		DllStructSetData($stSH2, 5, -1)
		DllStructSetData($stSH2, 6, 0)
		DllStructSetData($stSH2, 7, DllStructGetPtr($stPath))
		DllStructSetData($stSH2, 8, 0)
		
		Local $stError = DllStructCreate("dword")
		
		Local $nResult = NetShareAdd(0, 2, DllStructGetPtr($stSH2), DllStructGetPtr($stError))

		If Not $bSilent Then
			If $nResult = $NERR_Success Then
				EnumShares()
				MsgBoxEx(64, $sInfo, $sNetShareOK & " """ & $sPath & """ " & $sNetShareOKAs & " """ & $sName & """ .", $hSharesGUI)
			Else
				Switch $nResult
					Case 2
						$nResult = "2 - " & $sNetShrNotExist
					Case 5
						$nResult = "5 - " & $sNetShrAccDen
					Case 123
						$nResult = "123 - " & $sNetShrInvName
					Case 2116
						$nResult = "2116 - " & $sNetShrPNE
					Case 2118
						$nResult = "2118 - " & $sNetShrNameDup
				EndSwitch
								
				MsgBoxEx(16, $sERROR, $sErrorNetSharing & " """ & $sPath & """ " & $sNetShareOKAs & " """ & $sName & """ !" & @LF & _
									"(" & $nResult & ")", $hSharesGUI)
			EndIf
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Select a folder to share
;**********************************************************************
Func SelectFolderShare()
	Local $sFolder = FileSelectFolder($sShareSelFolder, "", 0, GUICtrlRead($nInpShrPath), $hSharesGUI)
	If $sFolder = "" Then Return
	
	Local $sDrive = StringLeft($sFolder, 2)
	If DriveGetType($sDrive) = "NETWORK" Then
		MsgBoxEx(16, $sERROR, $sErrorNetShared, $hSharesGUI)
		Return
	EndIf
	
	GUICtrlSetData($nInpShrPath, $sFolder)
EndFunc


;**********************************************************************
; Removes a sharing
;**********************************************************************
Func DelShare()
	Local $nCurSel = GUICtrlSendMsg($nLVShares, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	
	If $nCurSel > -1 Then
		Local $nCount	= 0
		Local $stText	= DllStructCreate("wchar[260]")
		Local $stLVI	= DllStructCreate($sLVI)
		
		DllStructSetData($stLVI, 1, $LVIF_TEXT)
		DllStructSetData($stLVI, 2, $nCurSel)
		DllStructSetData($stLVI, 3, 2)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
		DllStructSetData($stLVI, 7, 260)
				
		If GUICtrlSendMsg($nLVShares, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then $nCount = Number(DllStructGetData($stText, 1))
		
		If $nCount > 0 And MsgBoxEx(52 + 256, $sWARNING, $sShareMsgOpen & @LF & @LF & _
									$sShareMsgRemove, $hSharesGUI) = 7 Then Return
				
		Local $sShare	= ""

		DllStructSetData($stLVI, 3, 0)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
		DllStructSetData($stLVI, 7, 260)
		
		If GUICtrlSendMsg($nLVShares, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then
			$sShare = DllStructGetData($stText, 1)
			If $sShare <> "" Then
				Local $stShare = DllStructCreate("wchar[" & StringLen($sShare) + 1 & "]")
				DllStructSetData($stShare, 1, $sShare)
				
				Local $stPtr = DllStructCreate("ptr")
				
				
				Local $nResult = NetShareGetInfo(0, DllStructGetPtr($stShare), 1, DllStructGetPtr($stPtr))
				If $nResult <> $NERR_Success Then
					Switch $nResult
						Case 5
							$nResult = "5 - " & $sNetShrAccDen
						Case 2310
							$nResult = "2310 - " & $sNetShrNameNotEx
					EndSwitch
					
					MsgBoxEx(16, $sERROR, $sNetErrShareInfo & " """ & $sShare & """ !" & @LF & _
								"(" & $nResult & ")", $hSharesGUI)
								
					NetApiBufferFree(DllStructGetData($stPtr, 1))
					
					Return
				EndIf
				
				Local $stSI1 = DllStructCreate("ptr;dword;ptr", DllStructGetData($stPtr, 1))
				Local $nType = DllStructGetData($stSI1, 2)
				
				NetApiBufferFree(DllStructGetPtr($stSI1))
				
				If BitAnd($nType, $STYPE_SPECIAL) Then
					If BitAnd($nType, $STYPE_IPC) Then
						MsgBoxEx(16, $sERROR, $sShareMsgSpecial & " """ & $sShare & """ " & $sShareMsgDel1, $hSharesGUI)
						Return
					Else
						If MsgBoxEx(52 + 256, $sWARNING, $sShareMsgSpecial & " """ & $sShare & """ " & $sShareMsgDel2 & @LF & @LF & _
														$sShareMsgDel3 & @LF & @LF & _
														$sShareMsgDel4, $hSharesGUI) = 7 Then Return
					EndIf					
				Else
					If MsgBoxEx(36 + 256, $sQUESTION, $sShareMsgDel5 & " """ & $sShare & """ ?", $hSharesGUI) = 7 Then Return
				EndIf
				
				GUICtrlSetData($nLblState, $sLblShareRemove)
				GUICtrlSetColor($nLblState, $nClrStateRed)
				SetGUICursor($hCursorWait, $hMainGUI)
				GUISetState(@SW_DISABLE, $hMainGUI)
				
				$nResult = NetShareDel(0, DllStructGetPtr($stShare), 0)
	
				GUISetState(@SW_ENABLE, $hMainGUI)
				SetGUICursor($hCursorArrow, $hMainGUI)
				GUICtrlSetColor($nLblState, $nClrStateGreen)
				GUICtrlSetData($nLblState, $sStateReady)
								
				If $nResult = $NERR_Success Then
					EnumShares()
					MsgBoxEx(64, $sInfo, $sNetShareRemSucc & " """ & $sShare & """ .", $hSharesGUI)
				Else
					Switch $nResult
						Case 5
							$nResult = "5 - " & $sNetShrAccDen
						Case 2310
							$nResult = "2310 - " & $sNetShrNameNotEx
					EndSwitch
				
					MsgBoxEx(16, $sERROR, $sNetShareRemErr & " """ & $sShare & """ !" & @LF & _
								"(" & $nResult & ")", $hSharesGUI)
				EndIf
			EndIf
		EndIf
	EndIf
EndFunc


;**********************************************************************
; Gets the current connected network drives
;**********************************************************************
Func EnumDrives()
	GUICtrlSendMsg($nLVDrives, $LVM_DELETEALLITEMS, 0, 0)	
	
	Local $stNetResEnum = DllStructCreate($sNETRESOURCE)
			                    
	DllStructSetData($stNetResEnum, 1, $RESOURCE_CONNECTED)
	DllStructSetData($stNetResEnum, 2, 0)
	DllStructSetData($stNetResEnum, 3, 0)
	DllStructSetData($stNetResEnum, 4, 0)
	DllStructSetData($stNetResEnum, 5, 0)
	DllStructSetData($stNetResEnum, 6, 0)
	DllStructSetData($stNetResEnum, 7, 0)
	DllStructSetData($stNetResEnum, 8, 0)
	
	Local $stEnum = DllStructCreate("long_ptr")
	If WNetOpenEnumW(0x00000001, 0, 0, DllStructGetPtr($stNetResEnum), DllStructGetPtr($stEnum)) <> $NO_ERROR Then Return
		
	Local $stCount = DllStructCreate("dword")
	DllStructSetData($stCount, 1, -1)
	
	Local $stSize = DllStructCreate("dword")
	DllStructSetData($stSize, 1, 16384)
	
	Local $stBuffer, $stNetRes, $pWNER, $pNUGI = DllStructCreate("ptr")
    Local $i, $sLocal, $sRemote, $stUI1, $stRemote, $stLocal, $nState, $nCount, $nResult	
    
	Do
		$stBuffer = DllStructCreate("byte[16384]")
		
		$nResult = WNetEnumResourceW(DllStructGetData($stEnum, 1), DllStructGetPtr($stCount), DllStructGetPtr($stBuffer), DllStructGetPtr($stSize))
		$pWNER = DllStructGetPtr($stBuffer)
		
		If $nResult = $NO_ERROR Or $nResult = $ERROR_MORE_DATA Then
			For $i = 1 To DllStructGetData($stCount, 1)
				$sLocal = ""
				$nState = 7 ; "-"
				$nCount = 0
				
				$stNetRes = DllStructCreate($sNETRESOURCE, $pWNER)
				
				$stRemote = DllStructCreate("wchar[" & (wcslen(DllStructGetData($stNetRes, 6)) + 1) & "]", DllStructGetData($stNetRes, 6))
				$sRemote = DllStructGetData($stRemote, 1)
				
				If DllStructGetData($stNetRes, 5) <> 0 Then ; Has local drive letter
					$stLocal = DllStructCreate("wchar[" & (wcslen(DllStructGetData($stNetRes, 5))) & "]", DllStructGetData($stNetRes, 5))
					$sLocal = DllStructGetData($stLocal, 1)
				Else
					$stLocal = DllStructCreate("wchar[" & (wcslen(DllStructGetData($stNetRes, 6))) & "]", DllStructGetData($stNetRes, 6))
				EndIf
				
				If NetUseGetInfo(0, DllStructGetPtr($stLocal), 1, DllStructGetPtr($pNUGI)) = $NERR_Success Then
					$stUI1 = DllStructCreate($sUSE_INFO_1, DllStructGetData($pNUGI, 1))
					$nState = DllStructGetData($stUI1, 4)
					$nCount = DllStructGetData($stUI1, 7)
					
					NetApiBufferFree(DllStructGetData($pNUGI, 1))
				EndIf
				
				CreateAdvLVItem($sLocal & "|" & $sRemote & "|" & $arConState[$nState] & "|" & $nCount, $nLVDrives)
				
				$pWNER += DllStructGetSize($stNetRes)
			Next
		EndIf
		
		$stBuffer  = 0
	Until $nResult <> $ERROR_MORE_DATA
        
	WNetCloseEnum(DllStructGetData($stEnum, 1))

	$stNetResEnum = 0
	
	SetODBtnState($nBtnDrvDel, $GUI_DISABLE)
	$nLVDrvLast = -1
EndFunc


;**********************************************************************
; Gets free local drive letters
;**********************************************************************
Func EnumDriveLetters()
	Local $sLetters = "|*| |"
	Local $i, $nType, $nCount = 0
	Local $sDrvLetters = "A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z"
	Local $arDrvLetters = StringSplit($sDrvLetters, "|")
	If Not IsArray($arDrvLetters) Then Return
	
	For $i = 1 To $arDrvLetters[0]
		$sType = DriveGetType($arDrvLetters[$i] & ":")
		If @Error Then
			$nCount += 1
			$sLetters = $sLetters & $arDrvLetters[$i] & ":|"
		EndIf
	Next
	
	If $nCount = 0 Then
		$sLetters = "|"
		GUICtrlSetTip($nComboDrv, $sTTDriveNoFree1 & @LF & _
									$sTTDriveNoFree2)
		GUICtrlSetData($nComboDrv, $sLetters, "")
	Else
		GUICtrlSetTip($nComboDrv, "<*> - " & $sTTDriveLetter & @LF & "<  > - " & $sTTDriveLetterNo)
		GUICtrlSetData($nComboDrv, $sLetters, "*")
	EndIf	
	
EndFunc


;**********************************************************************
; Gets last used network drives
;**********************************************************************
Func EnumLastUsedPath()
	Local $i
	Local $sData	= "|"
	Local $sLast	= GUICtrlRead($nComboDrvPath)
	Local $sKey		= "Software\Microsoft\Windows\CurrentVersion\Explorer\Map Network Drive MRU"
	Local $stString	= DllStructCreate("wchar[" & (StringLen($sKey) + 1) & "]")
	DllStructSetData($stString, 1, $sKey)
	
	Local $stMRUI	= DllStructCreate($sMRUINFO)
	DllStructSetData($stMRUI, 1, DllStructGetSize($stMRUI))
	DllStructSetData($stMRUI, 2, 30)
	DllStructSetData($stMRUI, 3, 0)
	DllStructSetData($stMRUI, 4, $HKEY_CURRENT_USER)
	DllStructSetData($stMRUI, 5, DllStructGetPtr($stString))
	DllStructSetData($stMRUI, 6, 0)
	
	Local $hMRU		= CreateMRUListW(DllStructGetPtr($stMRUI))
	
	If $hMRU <> 0 Then
		Local $nCount = EnumMRUListW($hMRU, -1, 0, 0)
		
		For $i = 0 To $nCount - 1
			$stString = DllStructCreate("wchar[" & $MAX_PATH & "]")
			If EnumMRUListW($hMRU, $i, DllStructGetPtr($stString), $MAX_PATH) <> -1 Then _
				$sData = $sData & DllStructGetData($stString, 1) & "|"
		Next

		FreeMRUList($hMRU)
	EndIf
	
	GUICtrlSetData($nComboDrvPath, $sData, $sLast)
EndFunc

;**********************************************************************
; Maps a drive to a remote share
;**********************************************************************
Func MapDrive($sDevice, $sRemote, $sUser = "", $sPW = "", $bShowGUI = TRUE)
	If $sRemote = "" Then Return
	If $sDevice = " " Then $sDevice = ""
	
	If $bShowGUI Then
		GUICtrlSetData($nLblState, $sLblDriveConnect)
		GUICtrlSetColor($nLblState, $nClrStateRed)
		SetGUICursor($hCursorWait, $hMainGUI)
		GUISetState(@SW_DISABLE, $hMainGUI)
	EndIf
	
	Local $nResult	= 0
	Local $sErrMsg	= ""
	Local $nError	= 0
	Local $nErrExt	= 0
	
	Local $bIsUNC = PathIsUNCW($sRemote)
	If $bIsUNC Then
		Local $i, $c = 0
		Local $arUNC = StringSplit($sRemote, "\")
		If IsArray($arUNC) Then
			For $i = 1 To $arUNC[0]
				If $arUNC[$i] <> "" Then $c += 1
			Next
							
			If $c < 2 Then $bIsUNC = FALSE ; UNC path had to be \\server\share, so min. 2 strings
		Else
			$bIsUNC = FALSE
		EndIf
	EndIf
	
	If Not $bIsUNC Then
		$nError = 5
	Else	
		If $sUser = "" Then
			$nResult = DriveMapAdd($sDevice, $sRemote, 8)
		Else
			$nResult = DriveMapAdd($sDevice, $sRemote, 8, $sUser, $sPW)
		EndIf
		
		$nError 	= @Error
		$nErrExt	= @Extended
		
		; On error try to connect with domain\user
		If $nError And $sUser <> "" And Not StringInStr($sUser, "\") Then
			Local $stRemote = DllStructCreate("wchar[" & $MAX_PATH & "]")
			_wsplitpath($sRemote, 0, DllStructGetPtr($stRemote), 0, 0)
			Local $sSrv = StringTrimLeft(StringTrimRight(DllStructGetData($stRemote, 1), 1), 2)
			If $sSrv <> "" Then
				$nResult = DriveMapAdd($sDevice, $sRemote, 8, $sSrv & "\" & $sUser, $sPW)
				$nError = @Error
			EndIf
		EndIf
	EndIf
	
	If $bShowGUI Then
		GUISetState(@SW_ENABLE, $hMainGUI)
		SetGUICursor($hCursorArrow, $hMainGUI)
		GUICtrlSetColor($nLblState, $nClrStateGreen)
		GUICtrlSetData($nLblState, $sStateReady)
	EndIf
	
	If $nError = 0 Then
		MapDriveSave($sRemote)
		
		If $sDevice = "*" Then $sDevice = $nResult
		
		Debug("OK: MapDrive: """ & $sRemote & """ to drive letter: " & $sDevice)
		
		If $bShowGUI Then
			EnumDrives()
			EnumDriveLetters()
			
			If $sDevice = "" Then
				MsgBoxEx(64, $sInfo, $sNetDriveSucc1 & " """ & $sRemote & """ .", $hDrivesGUI)
			Else
				MsgBoxEx(64, $sInfo, $sNetDriveSucc1 & " """ & $sRemote & """ " & $sNetDriveSucc2 & " """ & $sDevice & """ .", $hDrivesGUI)
			EndIf
			
			EnumLastUsedPath()
			
			GUICtrlSetData($nInpDrvUsr, "")
			GUICtrlSetData($nInpDrvPW, "")
		EndIf
	Else
		Switch $nError
			Case 1
				If $nErrExt > 0 Then $sErrMsg = GetErrStr($nErrExt)
				
				If $sErrMsg = "" Then
					If $nErrExt = 53 Then
						$sErrMsg = $sNetDriveAddErr7
					Else
						$sErrMsg = $sNetDriveAddErr1
					EndIf
				EndIf
			Case 2
		 		$sErrMsg = $sNetDriveAddErr2
		 	Case 3
				$sErrMsg = $sNetDriveAddErr3
			Case 4
 				$sErrMsg = $sNetDriveAddErr4
 			Case 5
 				$sErrMsg = $sNetDriveAddErr5
 			Case 6
				$sErrMsg = $sNetDriveAddErr6
		EndSwitch
		
		Debug("ER: MapDrive: """ & $sRemote & """ to drive letter: " & $sDevice & "; Error: " & $sErrMsg)
		
		If $bShowGUI Then MsgBoxEx(16, $sERROR, $sErrMsg, $hDrivesGUI)
	EndIf
EndFunc


;**********************************************************************
; Writes mapped drive to registry MRU
;**********************************************************************
Func MapDriveSave($sRemotePath)
	Local $sKey		= "Software\Microsoft\Windows\CurrentVersion\Explorer\Map Network Drive MRU"
	Local $stString	= DllStructCreate("wchar[" & (StringLen($sKey) + 1) & "]")
	DllStructSetData($stString, 1, $sKey)
	
	Local $stMRUI	= DllStructCreate($sMRUINFO)
	DllStructSetData($stMRUI, 1, DllStructGetSize($stMRUI))
	DllStructSetData($stMRUI, 2, 30) ; Max. 30 entries
	DllStructSetData($stMRUI, 3, 0)
	DllStructSetData($stMRUI, 4, $HKEY_CURRENT_USER)
	DllStructSetData($stMRUI, 5, DllStructGetPtr($stString))
	DllStructSetData($stMRUI, 6, 0)
	
	Local $hMRU		= CreateMRUListW(DllStructGetPtr($stMRUI))
	
	If $hMRU <> 0 Then
		$stString	= DllStructCreate("wchar[" & (StringLen($sRemotePath) + 1) & "]")
		DllStructSetData($stString, 1, $sRemotePath)
		AddMRUStringW($hMRU, DllStructGetPtr($stString))
		FreeMRUList($hMRU)
	EndIf
EndFunc
	
	
;**********************************************************************
; Dels a mapped remote share
;**********************************************************************
Func DelDrive()
	Local $nCurSel = GUICtrlSendMsg($nLVDrives, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	
	If $nCurSel > -1 Then
		Local $nCount	= 0
		Local $stText	= DllStructCreate("wchar[260]")
		Local $stLVI	= DllStructCreate($sLVI)
		
		DllStructSetData($stLVI, 1, $LVIF_TEXT)
		DllStructSetData($stLVI, 2, $nCurSel)
		DllStructSetData($stLVI, 3, 3)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
		DllStructSetData($stLVI, 7, 260)
				
		If GUICtrlSendMsg($nLVDrives, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then $nCount = Number(DllStructGetData($stText, 1))
		
		If $nCount > 0 And MsgBoxEx(52 + 256, $sWARNING, $sNetDriveMsgDel1 & @LF & @LF & _
									$sNetDriveMsgDel2, $hDrivesGUI) = 7 Then Return
		
		GUICtrlSetData($nLblState, $sLblDriveDel)
		GUICtrlSetColor($nLblState, $nClrStateRed)
		SetGUICursor($hCursorWait, $hMainGUI)
		GUISetState(@SW_DISABLE, $hMainGUI)
		
		Local $sDrive = ""

		DllStructSetData($stLVI, 3, 0)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
		DllStructSetData($stLVI, 7, 260)
		
		If GUICtrlSendMsg($nLVDrives, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then
			$sDrive = DllStructGetData($stText, 1)
			If $sDrive = "" Then ; maybe IPC connection
				DllStructSetData($stLVI, 3, 1)
				DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
				DllStructSetData($stLVI, 7, 260)
				If GUICtrlSendMsg($nLVDrives, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then $sDrive = DllStructGetData($stText, 1)
			EndIf
			
			If $sDrive <> "" Then
				If DriveMapDel($sDrive) Then
					GUICtrlSendMsg($nLVDrives, $LVM_DELETEITEM, $nCurSel, 0)
					EnumDrives()
					EnumDriveLetters()
				Else
					GUISetState(@SW_ENABLE, $hMainGUI)
					SetGUICursor($hCursorArrow, $hMainGUI)
					GUICtrlSetColor($nLblState, $nClrStateGreen)
					GUICtrlSetData($nLblState, $sStateReady)
					MsgBoxEx(16, $sERROR, $sNetDriveDelErr, $hDrivesGUI)
					Return
				EndIf
			EndIf
		EndIf
		
		GUISetState(@SW_ENABLE, $hMainGUI)
		SetGUICursor($hCursorArrow, $hMainGUI)
		GUICtrlSetColor($nLblState, $nClrStateGreen)
		GUICtrlSetData($nLblState, $sStateReady)
	EndIf
EndFunc


;**********************************************************************
; Disconnect all connected drive letters
;**********************************************************************
Func DelDriveAll()
	Debug("IN: DelDriveAll")
	
	Local $sDrvLetters = "A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z"
	Local $arDrvLetters = StringSplit($sDrvLetters, "|")
	If Not IsArray($arDrvLetters) Then Return
	
	Local $i
		
	For $i = 1 To $arDrvLetters[0]
		If DriveGetType($arDrvLetters[$i] & ":") = "Network" Then
			DriveMapDel($arDrvLetters[$i] & ":")
		EndIf
	Next
EndFunc


;**********************************************************************
; Browse a specified path
;**********************************************************************
Func BrowseDrive($nLV)
	If $nLV = 0 Then Return
	
	Local $nSub = 0
	If $nLV = $nLVShares Then $nSub = 1
	
	Local $nCurSel = GUICtrlSendMsg($nLV, $LVM_GETNEXTITEM, -1, $LVNI_SELECTED)
	
	If $nCurSel > -1 Then
		Local $stText	= DllStructCreate("wchar[260]")
		Local $stLVI	= DllStructCreate($sLVI)
		
		DllStructSetData($stLVI, 1, $LVIF_TEXT)
		DllStructSetData($stLVI, 2, $nCurSel)
		DllStructSetData($stLVI, 3, $nSub)
		DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
		DllStructSetData($stLVI, 7, 260)
				
		If GUICtrlSendMsg($nLV, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then
			Local $sParam = ""
			Local $sCMD = RegRead("HKCR\Folder\shell\open\command", "")
			If StringInStr($sCMD, "explorer.exe") Then
				$sCMD = @WindowsDir & "\explorer.exe"
				$sParam = "/e,"
			EndIf
			
			Local $nOld = Opt("ExpandEnvStrings", 1)
			ShellExecute($sCMD, $sParam & DllStructGetData($stText, 1))
			Opt("ExpandEnvStrings", $nOld)
		EndIF
	EndIf
EndFunc


;**********************************************************************
; MsgBoxEx - MsgBox with possible parent window handle
;**********************************************************************
Func MsgBoxEx($nType, $sTitle, $sText, $hWnd = 0)
	$nType = BitOr($nType, $MB_SETFOREGROUND)

	Local $nResult = MessageBoxW($hWnd, $sText, $sTitle, $nType)
	
	Return $nResult
EndFunc


;**********************************************************************
; Debug - just simple logging
;**********************************************************************
Func Debug($sLine)
	If $bDebug Then FileWriteLine($sDebugFile, @MDay & "." & @Mon & "." & @Year & ";" & @Hour & ":" & @Min & ":" & @Sec & " -> " & $sLine)
	;If $bDebug Then ConsoleWrite(@MDay & "." & @Mon & "." & @Year & ";" & @Hour & ":" & @Min & ":" & @Sec & " -> " & $sLine & @LF)
EndFunc


;**********************************************************************
; EnumCopyDrv - Sub functions for driver copying
;**********************************************************************
Func EnumCopyDrv($sSrc, $sTgt, $nCtrl, $sLogFile, $nOSMaj, $nOSMin, $sOSType, $sRoot, $bChkOS)
	Local $hSearch, $sFile
	
	$hSearch = FileFindFirstFile($sSrc & "*.*")
		
	If $hSearch <> -1 Then
		While 1
			$sFile = FileFindNextFile($hSearch) 
			If @Error Then ExitLoop
			
			If StringInStr(FileGetAttrib($sSrc & $sFile), "D") Then
				EnumCopyDrv($sSrc & $sFile & "\", $sTgt, $nCtrl, $sLogFile, $nOSMaj, $nOSMin, $sOSType, $sRoot, $bChkOS)
			ElseIf StringRight($sFile, 4) = ".inf" Then
				SubCopyDrv($sFile, $sSrc, $sTgt, $nCtrl, $nOSMaj, $nOSMin, $sOSType, $sRoot, $bChkOS)
			EndIf
		WEnd
		
		FileClose($hSearch)
	EndIf				
EndFunc


Func SubCopyDrv($sInfFile, $sSrc, $sTgt, $nCtrl, $nOSMaj, $nOSMin, $sOSType, $sRoot, $bChkOS)
	Local $sFile = $sSrc & $sInfFile
	Local $sClass = IniRead($sFile, "Version", "Class", "")
	
	If $bClassNetOnly And $sClass <> "Net" And IniRead($sFile, "Version", "ClassGUID", "") <> $sClassNet Then
		If Not StringInStr($sFile, "Bus") Then _
		Return 0
	EndIf

	If IniRead($sFile, "Version", "Signature", "$WINDOWS 95$") = "$WINDOWS 95$" Then Return 0

	$arSec[0] = 0
				
	Local $sProvStr = GetDrvString($sFile, IniRead($sFile, "Version", "Provider", ""))

	Local $hInf = SetupOpenInfFileW($sFile, 0, 0x00000002, 0)
	If $hInf <> 0xFFFFFFFF Then
		Local $stSection = DllStructCreate("wchar[256]")
		DllStructSetData($stSection, 1, "Manufacturer")
		
		Local $stDrvSec		= DllStructCreate("wchar[256]")
		Local $stInstSec	= DllStructCreate("wchar[256]")
		Local $stCopySec	= DllStructCreate("wchar[256]")
		DllStructSetData($stCopySec, 1, "CopyFiles")
		
		Local $stCtx		= DllStructCreate($sINFCONTEXT)
		Local $stCtx2		= DllStructCreate($sINFCONTEXT)
		Local $stCtx3		= DllStructCreate($sINFCONTEXT)
		
		Local $sNdi, $sCopyFile, $sDrvSec, $sSearchSec = ""
		Local $nCopyFiles = 0
		
		If SetupFindFirstLineW($hInf, DllStructGetPtr($stSection), 0, DllStructGetPtr($stCtx)) <> 0 Then
			While 1
				$sManu = GetDrvLine(DllStructGetPtr($stCtx))
				
				$nCount = SetupGetFieldCount(DllStructGetPtr($stCtx))
				
				If $nCount < 1 Then
					ExitLoop
				ElseIf $nCount = 1 Then
					$sSearchSec = $sManu
				Else				
					For $i = 2 To $nCount
						$sSearchSec &= GetDrvField(DllStructGetPtr($stCtx), $i) & "|"
					Next
				EndIf
				
				Local $arTgt = StringSplit($sSearchSec, "|")				
				For $i = 1 To $arTgt[0]
					If $arTgt[$i] = "" Then ContinueLoop
		
					Local $arOS		= StringSplit($arTgt[$i], ".")
					Local $sArch	= $arOS[1]
					
					If StringInStr($sArch, $sOSType) Or ($sOSType <> "AMD64" And (($arOS[0] = 1 And Not StringInStr($sArch, "NT")) Or ($sArch = "NT" And $arOS[0] > 1))) Then
						$sDrvSec =  ""
						
						If $bChkOS = FALSE Then
							$sDrvSec = $arTgt[$i]
						Else				
							If $arOS[0] > 2 Then
								If ($arOS[2] < $nOSMaj) Or ($arOS[2] = $nOSMaj And $arOS[3] <= $nOSMin) Then
									$sDrvSec = $arTgt[$i]
								EndIf
							ElseIf $arOS[0] > 1 Then
								If $arOS[2] = $nOSMaj Then
									$sDrvSec = $arTgt[$i]
								EndIf
							ElseIf $arOS[0] = 1 Then
								$sDrvSec = $arTgt[$i]
							EndIf
						EndIf
				
						$sManuSec	= GetDrvField(DllStructGetPtr($stCtx), 1)
		
						If $sDrvSec = "" Then
							ContinueLoop
						ElseIf $nCount = 1 Then
							$sDrvSec = $sManuSec
						Else
							$sDrvSec = $sManuSec & "." & $sDrvSec
						EndIf
						
						DllStructSetData($stDrvSec, 1, $sDrvSec)
						
						If SetupFindFirstLineW($hInf, DllStructGetPtr($stDrvSec), 0, DllStructGetPtr($stCtx2)) <> 0 Then
							While 1
								$sNdi = GetDrvField(DllStructGetPtr($stCtx2), 1)
								If $sNdi <> "" Then
									$sInstSec = $sNdi & ".NT" & $sOSType
									DllStructSetData($stInstSec, 1, $sInstSec)
									
									If SetupFindFirstLineW($hInf, DllStructGetPtr($stInstSec), DllStructGetPtr($stCopySec), DllStructGetPtr($stCtx3)) = 0 Then
										$sInstSec = $sNdi & ".NT"
										
										DllStructSetData($stInstSec, 1, $sInstSec)
										If SetupFindFirstLineW($hInf, DllStructGetPtr($stInstSec), DllStructGetPtr($stCopySec), DllStructGetPtr($stCtx3)) = 0 Then
											$sInstSec = $sNdi
										EndIf
									EndIf
								
									CopyDrvSecToList($hInf, $sInstSec)
									CopyDrvSecToList($hInf, $sInstSec & ".CoInstallers")														
								EndIf
													
								If Not SetupFindNextLine(DllStructGetPtr($stCtx2), DllStructGetPtr($stCtx2)) Then ExitLoop						
							WEnd					
						EndIf
					EndIf
				Next
				
				If Not SetupFindNextLine(DllStructGetPtr($stCtx), DllStructGetPtr($stCtx)) Then ExitLoop
			WEnd		
		EndIf
		
		Local $sDest = "", $sDirStr = "", $sDestDir = ""
		
		For $i = 1 To $arSec[0]
			$sDest = IniRead($sFile, "DestinationDirs", $arSec[$i], "")
			If $sDest = "" Then $sDest = IniRead($sFile, "DestinationDirs", "DefaultDestDir", "")
			$sDirStr = ""
			
			$sDest = StringStripWS($sDest, 8)
			
			If StringInStr($sDest, ";") Then
				$sDest = StringLeft($sDest, StringInStr($sDest, ";") - 1) 
			EndIf
			
			If StringInStr($sDest, ",") Then
				$sDirStr = StringTrimLeft($sDest, StringInStr($sDest, ","))
				$sDest = StringLeft($sDest, StringInStr($sDest, ",") - 1)
			EndIf
			
			Switch $sDest
				Case 11
					$sDestDir = $sRoot & "system32"
				Case 12
					$sDestDir = $sRoot & "system32\drivers"
				Case 17
					$sDestDir = $sRoot & "inf"
				Case 18
					$sDestDir = $sRoot & "help"
				Case 18
					$sDestDir = $sRoot & "fonts"
				Case Else
					$sDestDir = $sRoot
			EndSwitch
			
			If $sDirStr <> "" Then
				If $sDestDir = "" Then
					$sDestDir = $sDirStr
				Else
					$sDestDir &= "\" & $sDirStr
				EndIf
			EndIf
			
			If StringRight($sDestDir, 1) <> "\" Then $sDestDir &= "\"
			
			DllStructSetData($stSection, 1, $arSec[$i])
			
			$stCtx = 0
			$stCtx = DllStructCreate($sINFCONTEXT)
			
			If SetupFindFirstLineW($hInf, DllStructGetPtr($stSection), 0, DllStructGetPtr($stCtx)) <> 0 Then
				While 1
					$sCopyFile = GetDrvLine(DllStructGetPtr($stCtx))
					If CopyDrvFile($sCopyFile, $sSrc, $sTgt & $sDestDir, $nCtrl) Then $nCopyFiles += 1
					If Not SetupFindNextLine(DllStructGetPtr($stCtx), DllStructGetPtr($stCtx)) Then ExitLoop
				WEnd
			EndIf
		Next
		
		SetupCloseInfFile($hInf)
		
		If $nCopyFiles > 0 Then CopyDrvFile($sInfFile, $sSrc, $sTgt & $sRoot & "inf\", $nCtrl)
	EndIf
	
	Return $arSec[0]
EndFunc


Func CopyDrvFile($sFile, $sSrc, $sTgt, $nCtrl)
	Local $i, $bAdded = FALSE
	Local $arFile = StringSplit($sFile, ",")
	Local $sSrcFile = $arFile[1]
	Local $sTgtFile = $arFile[1]
	
	If $arFile[0] > 1 Then
		If $arFile[2] <> "" Then
			$sTgtFile = $arFile[1]
			$sSrcFile = $arFile[2]
		EndIf			
	EndIf
	
	If FileExists($sSrc & $sSrcFile) Then
		Local $bFound = FALSE
		
		For $i = 1 To $arFileQueue[0][0]
			If $arFileQueue[$i][0] = ($sSrc & $sSrcFile) And $arFileQueue[$i][1] = ($sTgt & $sTgtFile) Then
				CopyDrvLog("IN: Skipping file """ & $sSrc & $sSrcFile & """ -> already copied")
				$bFound = TRUE
				ExitLoop
			EndIf
		Next
		
		If Not $bFound Then
			GUICtrlSetData($nCtrl, "Copying """ & $sSrcFile & """...")
			Local $nResult = FileCopy($sSrc & $sSrcFile, $sTgt & $sTgtFile, 9)
			If $nResult = 1 Then
				$arFileQueue[0][0] += 1
				ReDim $arFileQueue[$arFileQueue[0][0] + 1][2]
				$arFileQueue[$arFileQueue[0][0]][0] = $sSrc & $sSrcFile
				$arFileQueue[$arFileQueue[0][0]][1] = $sTgt & $sTgtFile
				CopyDrvLog("OK: Copying: " & $sSrc & $sSrcFile & " -> " & $sTgt & $sTgtFile)
			Else
				CopyDrvLog("ER: Error " & GetLastError() & " while copying: " & $sSrc & $sSrcFile & " -> " & $sTgt & $sTgtFile)
			EndIf
		EndIf
		
		$bAdded = TRUE
	Else
		CopyDrvLog("ER: Error 2 cause of non existing source file: " & $sSrc & $sSrcFile)
	EndIf
	
	Return $bAdded
EndFunc


Func CopyDrvLog($sLine)
	FileWriteLine($sLogFile, @MDay & "." & @Mon & "." & @Year & ";" & @Hour & ":" & @Min & ":" & @Sec & " -> " & $sLine)
EndFunc


Func GetDrvString($sFile, $sString)
	If $sString = "" Then Return ""
	If Not (StringLeft($sString, 1) = "%" And StringRight($sString, 1) = "%") Then Return $sString
	
	Return IniRead($sFile, "Strings", StringTrimLeft(StringTrimRight($sString, 1), 1), "")
EndFunc


Func GetDrvLine($pCtx)
	Local $stSize = DllStructCreate("dword")
	
	SetupGetLineTextW($pCtx, 0, 0, 0, 0, 0, DllStructGetPtr($stSize))
	Local $stBuffer = DllStructCreate("wchar[" & DllStructGetData($stSize, 1) & "]")
				
	If SetupGetLineTextW($pCtx, 0, 0, 0, DllStructGetPtr($stBuffer), DllStructGetSize($stBuffer), DllStructGetPtr($stSize)) Then _
		Return DllStructGetData($stBuffer, 1)

	Return ""
EndFunc


Func GetDrvField($pCtx, $nIdx)
	Local $stSize = DllStructCreate("dword")
	
	SetupGetStringFieldW($pCtx, $nIdx, 0, 0, DllStructGetPtr($stSize))
	Local $stBuffer = DllStructCreate("wchar[" & DllStructGetData($stSize, 1) & "]")
				
	If SetupGetStringFieldW($pCtx, $nIdx, DllStructGetPtr($stBuffer), DllStructGetSize($stBuffer), DllStructGetPtr($stSize)) Then _
		Return DllStructGetData($stBuffer, 1)

	Return ""
EndFunc


Func CopyDrvSecToList($hInf, $sSec)
	Local $stInstSec = DllStructCreate("wchar[256]")
	DllStructSetData($stInstSec, 1, $sSec)
	
	Local $stCopySec = DllStructCreate("wchar[256]")
	DllStructSetData($stCopySec, 1, "CopyFiles")
	
	Local $stCtx = DllStructCreate($sINFCONTEXT)
	Local $bFound, $c, $i, $k, $sField, $nSize
	
	If SetupFindFirstLineW($hInf, DllStructGetPtr($stInstSec), DllStructGetPtr($stCopySec), DllStructGetPtr($stCtx)) <> 0 Then
		$c = SetupGetFieldCount(DllStructGetPtr($stCtx))
	
		For $i = 1 To $c
			$sField = GetDrvField(DllStructGetPtr($stCtx), $i)
			If $sField <> "" Then		
				$bFound = FALSE
				For $k = 1 To $arSec[0]
					If $sField = $arSec[$k] Then
						$bFound = TRUE
						ExitLoop
					EndIf
				Next
				
				If Not $bFound Then
					$nSize = UBound($arSec)
					If $nSize < ($arSec[0] + 10) Then ReDim $arSec[$nSize + 100]
					
					$arSec[0] += 1
					$arSec[$arSec[0]] = $sField
				EndIF
			EndIf
		Next
	EndIf
EndFunc


;**********************************************************************
; Create adapter speed config menu
;**********************************************************************
Func CreateSpeedMenu($sDesc)
	Local $k, $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return 0

	Local $sKey = GetAdapterProperty($arNAList[$i][1], 18)
	If $sKey = "" Then Return 0
	
	For $i = 1 To $arSpeedItems[0][0]
		GUICtrlDelete($arSpeedItems[$i][0])
	Next
	
	$arSpeedItems[0][0] = 0
	
	Local $sSub = "", $sDef = ""
	Local $arSpeedKey = StringSplit($sSpeedKeyStr, "|")
	
	For $k = 1 To $arSpeedKey[0]
		For $i = 1 To $arExtVal[0][0]
			;If StringInStr($arExtVal[$i][0], $arSpeedKey[$k]) Or _ ; Disabled 08.11.2010
			If	$arExtVal[$i][0] = $arSpeedKey[$k] Then
				$sSub = $arExtVal[$i][0]
				$sDef = RegRead($sKey & "\Ndi\params\" & $sSub & "\enum", $arExtVal[$i][2])
				ExitLoop
			EndIf
		Next
	Next
	
	If $sSub = "" Then Return 0

	Debug("IN: CreateSpeedMenu: " & $sDesc)
	
	Local $sEnum, $sVal
		
	$i = 1
		
	While 1
		$sEnum = RegEnumVal($sKey & "\Ndi\params\" & $sSub & "\enum", $i)
		If @Error <> 0 Then ExitLoop
		
		$sVal = RegRead($sKey & "\Ndi\params\" & $sSub & "\enum", $sEnum)
	
		If $sVal <> "" Then
			$arSpeedItems[0][0] += 1
			$nSize = UBound($arSpeedItems)
			If $arSpeedItems[0][0] >= $nSize Then Redim $arSpeedItems[$nSize + 5][3]
			
			$arSpeedItems[$arSpeedItems[0][0]][0] = GUICtrlCreateMenuItem($sVal, $nMenuSpeed, -1, 1)
			$arSpeedItems[$arSpeedItems[0][0]][1] = $sVal
			$arSpeedItems[$arSpeedItems[0][0]][2] = $sEnum
			;If $sVal = $sDef Then GUICtrlSetState($arSpeedItems[$arSpeedItems[0][0]][0], $GUI_CHECKED)
		EndIf
		
		$i += 1
	WEnd
	
	If $arSpeedItems[0][0] > 0 Then $arSpeedItems[0][1] = RegRead($sKey & "\Ndi\params\" & $sSub, "paramdesc")

	Return $arSpeedItems[0][0]
EndFunc


;**********************************************************************
; Show adapter speed config menu
;**********************************************************************
Func ShowSpeedMenu($sDesc)
	If $arSpeedItems[0][0] > 0 Then
		Local $hMenu = GUICtrlGetHandle($nMenuSpeed)
		Local $stPoint = DllStructCreate("int;int")
		Local $arPos = ControlGetPos($hMainGUI, "", $nBtnSpeed)
    
		Local $x = $arPos[0]; + $arPos[2]
		Local $y = $arPos[1] + $arPos[3]
			
		DllStructSetData($stPoint, 1, $x)
		DllStructSetData($stPoint, 2, $y)
			
		ClientToScreen($hMainGUI, DllStructGetPtr($stPoint))
		TrackPopupMenuEx($hMenu, 0, DllStructGetData($stPoint, 1), DllStructGetData($stPoint, 2), $hMainGUI, 0)
	EndIf
EndFunc


;**********************************************************************
; Return string to error number
;**********************************************************************
Func GetErrStr($nErr)
	Local $sStr		= ""
	Local $stPtr	= DllStructCreate("ptr")
	Local $nLen		= FormatMessageW(BitOr(0x00000100, 0x00001000), 0, $nErr, 0, DllStructGetPtr($stPtr), 1, 0)
	If $nLen > 0 Then
		Local $pBuffer = DllStructCreate("wchar[" & $nLen + 1 & "]", DllStructGetData($stPtr, 1))
		$sStr = DllStructGetData($pBuffer, 1)		
		LocalFree(DllStructGetData($stPtr, 1))
	EndIf
	
	Return $sStr
EndFunc


;**********************************************************************
; Get listview item text by idx
;**********************************************************************
Func GetLVText($nCtrl, $nIdx, $sSep = "", $nCol = 1, $bColOnly = FALSE)
	Local $i, $sText = ""
	Local $stText	= DllStructCreate("wchar[4096]")
	Local $stLVI	= DllStructCreate($sLVI)
	
	If $sSep = "" Then $sSep = "|"
	
	DllStructSetData($stLVI, 1, $LVIF_TEXT)
	DllStructSetData($stLVI, 2, $nIdx)
	DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
	DllStructSetData($stLVI, 7, 4096)
	
	For $i = 1 To $nCol
		DllStructSetData($stLVI, 3, $i - 1)
		DllStructSetData($stLVI, 7, 4096)
		
		If GUICtrlSendMsg($nCtrl, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then
			If $bColOnly And ($i = $nCol) Then
				$sText = DllStructGetData($stText, 1) 
				ExitLoop
			Else
				$sText = $sText & DllStructGetData($stText, 1) & $sSep
			EndIf
		EndIf
	Next
	
	If StringRight($sText, StringLen($sSep)) = $sSep Then $sText = StringTrimRight($sText, StringLen($sSep))
	
	$stText = 0
	
	Return $sText
EndFunc


;**********************************************************************
; Set listview item text by idx and column
;**********************************************************************
Func SetLVIText($nCtrl, $nIdx, $nCol, $sText)
	Local $stText	= DllStructCreate("wchar[" & (StringLen($sText) + 1) & "]")
	DllStructSetData($stText, 1, $sText)
	Local $stLVI	= DllStructCreate($sLVI)
	
	DllStructSetData($stLVI, 1, $LVIF_TEXT)
	DllStructSetData($stLVI, 2, $nIdx)
	DllStructSetData($stLVI, 3, $nCol)
	DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
	DllStructSetData($stLVI, 7, DllStructGetSize($stText))
	
	If GUICtrlSendMsg($nCtrl, $LVM_SETITEMW, 0, DllStructGetPtr($stLVI)) Then
		Return TRUE
	Else
		Return FALSE
	EndIf
EndFunc


;**********************************************************************
; Get listview item text by idx and column
;**********************************************************************
Func GetLVIText($nCtrl, $nIdx, $nCol)
	Local $sText = ""
	Local $stText	= DllStructCreate("wchar[4096]")
	Local $stLVI	= DllStructCreate($sLVI)
	
	DllStructSetData($stLVI, 1, $LVIF_TEXT)
	DllStructSetData($stLVI, 2, $nIdx)
	DllStructSetData($stLVI, 3, $nCol)
	DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
	DllStructSetData($stLVI, 7, 4096)
	
	If GUICtrlSendMsg($nCtrl, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then _
		$sText = DllStructGetData($stText, 1)
	
	Return $sText
EndFunc


;**********************************************************************
; Get listview item image by idx and column
;**********************************************************************
Func GetLVIImage($nCtrl, $nIdx, $nCol)
	Local $nImage = -1
	Local $stLVI	= DllStructCreate($sLVI)
	
	DllStructSetData($stLVI, 1, $LVIF_IMAGE)
	DllStructSetData($stLVI, 2, $nIdx)
	DllStructSetData($stLVI, 3, $nCol)
	
	
	If GUICtrlSendMsg($nCtrl, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then _
		$nImage = DllStructGetData($stLVI, 8)
	
	Return $nImage
EndFunc


;**********************************************************************
; Get listview item text and icons by idx for wifi functions
;**********************************************************************
Func GetLVIData($nCtrl, $nIdx, ByRef $nSignal, ByRef $nSecure, ByRef $nType)
	Local $sText = ""
	Local $stText	= DllStructCreate("wchar[260]")
	Local $stLVI	= DllStructCreate($sLVI)
	
	DllStructSetData($stLVI, 1, $LVIF_TEXT)
	DllStructSetData($stLVI, 2, $nIdx)
	DllStructSetData($stLVI, 3, 3)
	DllStructSetData($stLVI, 6, DllStructGetPtr($stText))
	DllStructSetData($stLVI, 7, 260)
	
	If GUICtrlSendMsg($nCtrl, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then $sText = DllStructGetData($stText, 1)
	
	DllStructSetData($stLVI, 1, $LVIF_IMAGE)
	DllStructSetData($stLVI, 3, 0)
	If GUICtrlSendMsg($nCtrl, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then $nSignal = DllStructGetData($stLVI, 8)
		
	DllStructSetData($stLVI, 3, 1)
	If GUICtrlSendMsg($nCtrl, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then $nSecure = DllStructGetData($stLVI, 8)
	
	DllStructSetData($stLVI, 3, 2)
	If GUICtrlSendMsg($nCtrl, $LVM_GETITEMW, 0, DllStructGetPtr($stLVI)) Then $nType = DllStructGetData($stLVI, 8)
	
	Return $sText
EndFunc


;**********************************************************************
; Get treeview item infos
;**********************************************************************
Func GetTVItem($nCtrl, $hItem, ByRef $sText, ByRef $nState, ByRef $nChilds)
	$sText = ""
	$nState = 0
	$nChilds = 0
	
	Local $stText = DllStructCreate("wchar[" & $_MAX_PATH & "]")
	Local $stTVI = DllStructCreate($sTVI)
	
	DllStructSetData($stTVI, 1, BitOr($TVIF_TEXT, $TVIF_STATE, $TVIF_CHILDREN))
	DllStructSetData($stTVI, 2, $hItem)
	DllStructSetData($stTVI, 5, DllStructGetPtr($stText))
	DllStructSetData($stTVI, 6, $_MAX_PATH)
	
	If GUICtrlSendMsg($nCtrl, $TVM_GETITEMW, 0, DllStructGetPtr($stTVI)) Then
		$sText = DllStructGetData($stText, 1)
		$nState = DllStructGetData($stTVI, 3)
		$nChilds = DllStructGetData($stTVI, 9)
		Return 1
	EndIf
	
	Return 0
EndFunc


;**********************************************************************
; Get treeview item image
;**********************************************************************
Func GetTVIImage($nCtrl, $hItem)
	Local $nImage = -1
	Local $stTVI	= DllStructCreate($sTVI)
	
	DllStructSetData($stTVI, 1, $TVIF_IMAGE)
	DllStructSetData($stTVI, 2, $hItem)
	
	
	If GUICtrlSendMsg($nCtrl, $TVM_GETITEMW, 0, DllStructGetPtr($stTVI)) Then _
		$nImage = DllStructGetData($stTVI, 7)
	
	Return $nImage
EndFunc


;**********************************************************************
; Get treeview item tree
;**********************************************************************
Func GetTVITree($nCtrl, $hItem, ByRef $sText)
	$sText = ""
	
	Local $nImage = GetTVIImage($nCtrl, $hItem)
	Local $nState, $nChilds
	
	Switch $nImage
		Case 0
			Return 1
		Case 1
			If GetTVItem($nCtrl, $hItem, $sText, $nState, $nChilds) Then
				If StringLeft($sText, 2) <> "\\" Then $sText = "\\" & $sText
				Return 1
			EndIf
		Case 2, 3
			Local $hParent = GUICtrlSendMsg($nCtrl, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem)
			If $hParent > 0 Then
				If GetTVItem($nCtrl, $hItem, $sText, $nState, $nChilds) Then
					Local $sParent = ""
					If GetTVItem($nCtrl, $hParent, $sParent, $nState, $nChilds) Then
						If StringLeft($sParent, 2) <> "\\" Then $sParent = "\\" & $sParent
						$sText = $sParent & "\" & $sText
						Return 1
					EndIf					
				EndIf			
			EndIf
	EndSwitch
	
	Return 0
EndFunc


;**********************************************************************
; Update extended configuration window
;**********************************************************************
Func UpdateExtConf($sDesc, $bSwitch = FALSE, $bNew = FALSE)
	Local $nCurSel = 0
	
	If $bExtCreated Then
		If Not $bNew Then $nCurSel = GUICtrlSendMsg($nListExtProp, $LB_GETCURSEL, 0, 0)
		If $nCurSel < 0 Then $nCurSel = 0
	Else
		CreateExtGUI()
	EndIf	
		
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $sKey = GetAdapterProperty($arNAList[$i][1], 18)
	
	Local $c = 1, $sType
	Local $sSub, $sVal, $sParamDesc, $sParams = "|", $sParamDef = ""
	
	$arExtVal[0][0] = 0
			
	While 1
		$sSub = RegEnumKey($sKey & "\ndi\params", $c)
		If @Error <> 0 Then ExitLoop
		
		$sParamDesc = RegRead($sKey & "\ndi\params\" & $sSub, "paramdesc")
		If $sParamDesc = "" Then $sParamDesc = $sSub
		
		$sVal = RegRead($sKey, $sSub)
		
		$arExtVal[0][0] += 1
		$arExtVal[$arExtVal[0][0]][0] = $sSub
		$arExtVal[$arExtVal[0][0]][1] = $sVal
		
		$arExtVal[$arExtVal[0][0]][2] = $sVal
		
		; 1=Combo, 2=Input, 4=UpDown
		$sType = RegRead($sKey & "\ndi\params\" & $sSub, "type")
		
		Switch $sType
			Case "dword", "int"
				$arExtVal[$arExtVal[0][0]][3] = 4
			Case "edit"
				$arExtVal[$arExtVal[0][0]][3] = 2
			Case Else
				$arExtVal[$arExtVal[0][0]][3] = 1
		EndSwitch
		
		$arExtVal[$arExtVal[0][0]][4] = $sParamDesc
		
		Debug("IN: UpdateExtConf: " & $sParamDesc & ": " & $sVal)
		
		$sParams &= $sParamDesc & "|"
		$c += 1
	WEnd
	
	If $sParams <> "|" Then
		GUICtrlSetData($nLblExtProp, $sLblExtProp)
		
		GUICtrlSetData($nListExtProp, $sParams)
		GUICtrlSendMsg($nListExtProp, $LB_SETCURSEL, $nCurSel, 0)
		
		GUICtrlSetState($nListExtProp, $GUI_ENABLE)		
		GUICtrlSetState($nComboExtVal, $GUI_ENABLE)
		GUICtrlSetState($nInpExtVal, $GUI_ENABLE)
		GUICtrlSetState($nInpExtNumVal, $GUI_ENABLE)
		
		GetExtVal($sDesc, GUICtrlRead($nListExtProp))
	Else
		GUICtrlSetData($nLblExtProp, $sLblExtNoProp)
		
		GUICtrlSetData($nListExtProp, "|")
		GUICtrlSetData($nComboExtVal, "|")
		GUICtrlSetData($nInpExtVal, "")
		GUICtrlSetData($nInpExtNumVal, "")
	
		GUICtrlSetState($nListExtProp, $GUI_DISABLE)
		GUICtrlSetState($nComboExtVal, $GUI_DISABLE)
		GUICtrlSetState($nInpExtVal, $GUI_DISABLE)			
		GUICtrlSetState($nInpExtNumVal, $GUI_DISABLE)
	EndIf
	
	If $bSwitch Then SwitchConfGUI($hConfExtGUI)	
EndFunc


;**********************************************************************
; Get index of advanced settings param
;**********************************************************************
Func GetExtIdx($sParam)
	If $sParam = "" Then Return 0

	Local $i
	
	For $i = 1 To $arExtVal[0][0]
		If $arExtVal[$i][4] = $sParam Then Return $i
	Next
	
	Return 0
EndFunc


;**********************************************************************
; Get index of advanced settings param
;**********************************************************************
Func GetExtNameIdx($sParam)
	If $sParam = "" Then Return 0

	Local $i
	
	For $i = 1 To $arExtVal[0][0]
		If $arExtVal[$i][0] = $sParam Then Return $i
	Next
	
	Return 0
EndFunc


;**********************************************************************
; Get value to selected list param
;**********************************************************************
Func GetExtVal($sDesc, $sParam, $sParamDef = "")
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $k = GetExtIdx($sParam)
	If $k = 0 Then Return
	
	Local $sKey = GetAdapterProperty($arNAList[$i][1], 18)
	Local $sSub = $arExtVal[$k][0]
	Local $sData = "", $sVal, $sDef = ""
		
	Switch $arExtVal[$k][3]
		Case 1 ; enum
			Local $sEnum
			$sData = "|"
			$i = 1
			
			While 1
				$sEnum = RegEnumVal($sKey & "\ndi\params\" & $sSub & "\enum", $i)
				If @Error <> 0 Then ExitLoop
				$sVal = RegRead($sKey & "\ndi\params\" & $sSub & "\enum", $sEnum)
				
				$sData &= $sVal & "|"
				
				$i += 1
			WEnd
			
			If $sParamDef = "" Then
				$sDef = RegRead($sKey & "\ndi\params\" & $sSub & "\enum", $arExtVal[$k][2])
			Else
				$sDef = $sParamDef
			EndIf
		
		Case 2, 4 ; edit, dword, int
			$sData = $arExtVal[$k][2]
	EndSwitch
	
	Local $nStateCombo	= $GUI_HIDE
	Local $nStateInp	= $GUI_HIDE
	Local $nStateRS		= $GUI_HIDE
	Local $nStateRNS	= $GUI_HIDE
	Local $nStateRSC	= $GUI_UNCHECKED
	Local $nStateRNSC	= $GUI_UNCHECKED
	Local $nStateInpNum	= $GUI_HIDE
	Local $nStateUD		= $GUI_HIDE
	
	Switch $arExtVal[$k][3]
		Case 1
			$nStateCombo 	= $GUI_SHOW
			GUICtrlSetData($nComboExtVal, $sData, $sDef)
			
		Case 2
			$nStateInp		= $GUI_SHOW
			$nStateRS		= $GUI_SHOW
			$nStateRNS		= $GUI_SHOW
			GUICtrlSetData($nInpExtVal, $sData)
			
			If $sData = "" Then
				$nStateRNSC = $GUI_CHECKED
			Else
				$nStateRSC = $GUI_CHECKED
			EndIf
			
			Local $nLimit = Number(RegRead($sKey & "\ndi\params\" & $sSub, "limittext"))
			Local $nUpper = Number(RegRead($sKey & "\ndi\params\" & $sSub, "uppercase"))
			
			If $nLimit Then GUICtrlSetLimit($nInpExtVal, $nLimit)
			If $nUpper Then
				GUICtrlSetStyle($nInpExtVal, BitOr($ES_AUTOHSCROLL, $ES_UPPERCASE, $WS_TABSTOP))
			Else
				GUICtrlSetStyle($nInpExtVal, BitOr($ES_AUTOHSCROLL, $WS_TABSTOP))
			EndIf
			
		Case 4
			$nStateInpNum	= $GUI_SHOW	
			$nStateUD		= $GUI_SHOW	
			GUICtrlSetData($nInpExtNumVal, $sData)
			
			Local $nMax = Number(RegRead($sKey & "\ndi\params\" & $sSub, "max"))
			Local $nMin = Number(RegRead($sKey & "\ndi\params\" & $sSub, "min"))
			
			GUICtrlSetLimit($nUDInpExtVal, $nMax, $nMin)
	EndSwitch
	
	If Not BitAnd(GUICtrlGetState($nComboExtVal), $nStateCombo) Then GUICtrlSetState($nComboExtVal, $nStateCombo)
	If Not BitAnd(GUICtrlGetState($nInpExtVal), $nStateInp) Then GUICtrlSetState($nInpExtVal, $nStateInp)
	If Not BitAnd(GUICtrlGetState($nRadioExtSet), $nStateRS) Then GUICtrlSetState($nRadioExtSet, $nStateRS)
	If Not BitAnd(GUICtrlGetState($nRadioExtNotSet), $nStateRNS) Then GUICtrlSetState($nRadioExtNotSet, $nStateRNS)
	If Not BitAnd(GUICtrlRead($nRadioExtSet), $nStateRSC) Then GUICtrlSetState($nRadioExtSet, $nStateRSC)
	If Not BitAnd(GUICtrlRead($nRadioExtNotSet), $nStateRNSC) Then GUICtrlSetState($nRadioExtNotSet, $nStateRNSC)
	If Not BitAnd(GUICtrlGetState($nInpExtNumVal), $nStateInpNum) Then GUICtrlSetState($nInpExtNumVal, $nStateInpNum)
	If Not BitAnd(GUICtrlGetState($nUDInpExtVal), $nStateUD) Then GUICtrlSetState($nUDInpExtVal, $nStateUD)
EndFunc


;**********************************************************************
; Set value to selected list param
;**********************************************************************
Func SetExtVal($sDesc, $sParam, $sVal)
	Local $i = GetNetAdapterIndex($sDesc)
	If $i = 0 Then Return
	
	Local $k = GetExtIdx($sParam)
	If $k = 0 Then Return

	Local $sKey = GetAdapterProperty($arNAList[$i][1], 18)
	Local $sSub = $arExtVal[$k][0]
	Local $sEnum
	
	Switch $arExtVal[$k][3]
		Case 1 ; enum
			$i = 1
			
			While 1
				$sEnum = RegEnumVal($sKey & "\ndi\params\" & $sSub & "\enum", $i)
				If @Error <> 0 Then ExitLoop
				If $sVal = RegRead($sKey & "\ndi\params\" & $sSub & "\enum", $sEnum) Then
					$arExtVal[$k][2] = $sEnum
					ExitLoop
				EndIf
				
				$i += 1
			WEnd
		
		Case 2 ; edit
			$arExtVal[$k][2] = GUICtrlRead($nInpExtVal)
			
		Case 4 ; dword,int
			$arExtVal[$k][2] = GUICtrlRead($nInpExtNumVal)
	EndSwitch	
EndFunc


;**********************************************************************
; Get control handle
;**********************************************************************
Func GetCtrlHandle($nID, $nMode = 1)
	Local $hCtrl = GUICtrlGetHandle($nID)
	Local $stCBI = DllStructCreate("dword;long[4];long[4];dword;hwnd;hwnd;hwnd")
	DllStructSetData($stCBI, 1, DllStructGetSize($stCBI))
	GetComboBoxInfo($hCtrl, DllStructGetPtr($stCBI))
	
	Switch $nMode
		Case 1
			Return DllStructGetData($stCBI, 6)
		Case 2
			Return DllStructGetData($stCBI, 7)
	EndSwitch
EndFunc


;**********************************************************************
; Update FW service state GUI
;**********************************************************************
Func UpdateFWGUI()
	Local $sFWSrv = "SharedAccess"
	;If $bIsVista Then $sFWSrv = "MpsSvc"
	
	Local $bFWEnabled = FALSE
	
	If Number(RegRead("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile", "EnableFirewall")) = 1 Then $bFWEnabled = TRUE
	
	If $bFWEnabled Then
		GUICtrlSetData($nLblFWCurState, $sServiceStarted)
		GUICtrlSetBkColor($nLblFWCurState, $nClrSvcStart)
		SetODBtnData($nBtnFW, $sServiceStop, -1, -1, FALSE)
	Else
		GUICtrlSetData($nLblFWCurState, $sServiceStopped)
		GUICtrlSetBkColor($nLblFWCurState, $nClrSvcStop)
		SetODBtnData($nBtnFW, $sServiceStart, -1, -1, FALSE)
	EndIf
	
	SwitchConfGUI($hConfFWGUI)
EndFunc


;**********************************************************************
; Start/Stop firewall service
;**********************************************************************
Func StartFW($bFromGUI = TRUE)
	Debug("IN: StartFW()")
	
	Local $nError			= 0
	Local $nResult			= 0
	Local $sFWSrv			= "SharedAccess"	
	If $bIsVista Then $sFWSrv = "MpsSvc"
	
	Debug("IN: Check if Firewall service (" & $sFWSrv & ") is enabled")
	;If Not IsServiceInstalled($sFWSrv) Then
	;	If $bFromGUI Then MsgBoxEx(16, $sERROR, $sWiFiErrInst & " !", $hConfGUI)
	;	Return 0
	;EndIf
		
	;Local $bFWRunning = IsServiceRunning($sFWSrv)
	Local $bFWRunning = FALSE
	If Number(RegRead("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile", "EnableFirewall")) = 1 Then $bFWRunning = TRUE
	
	GUICtrlSetColor($nLblState, $nClrStateRed)
	
	If $bFWRunning Then
		Debug("IN: Firewall service (" & $sFWSrv & ") is running")
		GUICtrlSetData($nLblState, $sFWStopSrv)
		RegWrite("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\DomainProfile", "EnableFirewall" , "REG_DWORD", 0x0)
		RegWrite("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\PublicProfile", "EnableFirewall" , "REG_DWORD", 0x0)
		RegWrite("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile", "EnableFirewall" , "REG_DWORD", 0x0)
		If StopSvc($sFWSrv) <> 0 Then StartSvc($sFWSrv)
		;If StopSvc($sFWSrv) = 0 Then
		;	$nError = GetLastError()
		;	If $bFromGUI Then MsgBoxEx(16, $sERROR, $sFWErrStop & "!" & @LF & GetErrStr($nError), $hConfGUI)				
		;	Return 0
		;EndIf
	Else
		Debug("IN: Firewall service (" & $sFWSrv & ") is stopped")
		GUICtrlSetData($nLblState, $sFWStartSrv)
		RegWrite("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\DomainProfile", "EnableFirewall" , "REG_DWORD", 0x1)
		RegWrite("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\PublicProfile", "EnableFirewall" , "REG_DWORD", 0x1)
		RegWrite("HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile", "EnableFirewall" , "REG_DWORD", 0x1)
		If StopSvc($sFWSrv) <> 0 Then StartSvc($sFWSrv)
		;If StartSvc($sFWSrv) = 0 Then
		;	$nError = GetLastError()
		;	If $bFromGUI Then MsgBoxEx(16, $sERROR, $sFWErrStart & "!" & @LF & GetErrStr($nError), $hConfGUI)				
		;	Return 0
		;EndIf	
	EndIf
	
	UpdateFWGUI()
	GUICtrlSetColor($nLblState, $nClrStateGreen)
	GUICtrlSetData($nLblState, $sStateReady)
EndFunc


;**********************************************************************
; TrayInit()
;**********************************************************************
Func TrayInit()
	TrayInitIcons()
	
	$hTrayMsgWnd= GUICreate("TrayMsgWnd", 1, 1, 9999, 9999, $WS_POPUP, $WS_EX_TOOLWINDOW)
	;GUISetState()
	;ShowWindow($hTrayMsgWnd, @SW_HIDE)
	
	Local $nID	= GUICtrlCreateDummy()
	$nTrayMenu = GUICtrlCreateContextMenu($nID)
	$hTrayMenu	= GUICtrlGetHandle($nTrayMenu)

	$nTIShoGUI	= GUICtrlCreateMenuItem($sTrayShowGUI, $nTrayMenu)
	GUICtrlSetState(-1, $GUI_DEFBUTTON)
	GUICtrlCreateMenuItem("", $nTrayMenu)
	$nTIShoAct	= GUICtrlCreateMenuItem($sTrayShowAni, $nTrayMenu)
	If $bShowTrayAct Then GUICtrlSetState(-1, $GUI_CHECKED)
	GUICtrlCreateMenuItem("", $nTrayMenu)
	$nTIExit	= GUICtrlCreateMenuItem($sTrayExit, $nTrayMenu)
	
	CreateTrayWiFiGUI()
	
	Local $stMsg = DllStructCreate("wchar[" & (StringLen("TaskbarCreated") + 1) & "]")
	DllStructSetData($stMsg, 1, "TaskbarCreated")	
	
	$nTaskbarCreatedMsg = RegisterWindowMessageW(DllStructGetPtr($stMsg))
	If $nTaskbarCreatedMsg <> 0 Then GUIRegisterMsg($nTaskbarCreatedMsg, "WndProc")
EndFunc


;**********************************************************************
; TrayInitIcons()
;**********************************************************************
Func TrayInitIcons()
	Local $stIcon = DllStructCreate("hwnd")
	
	; Default icon
	If $bIconLib Then
		ExtractIconExW($sIconLib, -105, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, -282, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	$hTrayIcon = DllStructGetData($stIcon, 1)
	
	; Data transfer icon
	If $bIconLib Then
		ExtractIconExW($sIconLib, -18, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, -178, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	$hTrayIconData = DllStructGetData($stIcon, 1)
	
	; No transfer icon
	If $bIconLib Then
		ExtractIconExW($sIconLib, -24, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, -192, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	$hTrayIconNoData = DllStructGetData($stIcon, 1)
	
	; Send data icon
	If $bIconLib Then
		ExtractIconExW($sIconLib, -75, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, -244, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	$hTrayIconSendData = DllStructGetData($stIcon, 1)
	
	; Recieve data icon
	If $bIconLib Then
		ExtractIconExW($sIconLib, -76, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, -245, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	$hTrayIconRecData = DllStructGetData($stIcon, 1)
	
	; No connection icon
	If $bIconLib Then
		ExtractIconExW($sIconLib, -80, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, -258, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	$hTrayIconNoConnect = DllStructGetData($stIcon, 1)
	
	; Tray WiFi icons
	If $bIconLib Then
		ExtractIconExW($sIconLib, -92, 0, DllStructGetPtr($stIcon), 1)
	Else
		ExtractIconExW(@AutoItExe, -269, 0, DllStructGetPtr($stIcon), 1)
	EndIf
	$hTrayIconWiFiAvail = DllStructGetData($stIcon, 1)
	
	; Create image lists to easy merge icons
	$hILTrayWiFi = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	AddILIcon($hILTrayWiFi, -259, 82, "Icon88") ;  0 - WiFi 0
	AddILIcon($hILTrayWiFi, -260, 83, "Icon89") ;  1 - WiFi 1-20
	AddILIcon($hILTrayWiFi, -261, 84, "Icon90") ;  2 - WiFi 21-40
	AddILIcon($hILTrayWiFi, -262, 85, "Icon91") ;  3 - WiFi 41-60
	AddILIcon($hILTrayWiFi, -263, 86, "Icon92") ;  4 - WiFi 61-80
	AddILIcon($hILTrayWiFi, -264, 87, "Icon93") ;  5 - WiFi 81-100
	
	$hILTrayRS = ImageList_Create($nIconSizeSmall, $nIconSizeSmall, BitOr($ILC_MASK, $ILC_COLOR32), 0, 1)
	AddILIcon($hILTrayRS, -265, 88, "Icon94") ;  0 - Recieve and send
	AddILIcon($hILTrayRS, -266, 89, "Icon95") ;  1 - Send
	AddILIcon($hILTrayRS, -267, 90, "Icon96") ;  2 - Recieve
	AddILIcon($hILTrayRS, -268, 91, "Icon97") ;  3 - No recieve no send
	
	$hTrayIconWiFiNull	= MergeIcons(0, 3)
	$hTrayIconWiFiSR1	= MergeIcons(1, 0)
	$hTrayIconWiFiSR2	= MergeIcons(2, 0)
	$hTrayIconWiFiSR3	= MergeIcons(3, 0)
	$hTrayIconWiFiSR4	= MergeIcons(4, 0)
	$hTrayIconWiFiSR5	= MergeIcons(5, 0)
	$hTrayIconWiFiS1	= MergeIcons(1, 1)
	$hTrayIconWiFiS2	= MergeIcons(2, 1)
	$hTrayIconWiFiS3	= MergeIcons(3, 1)
	$hTrayIconWiFiS4	= MergeIcons(4, 1)
	$hTrayIconWiFiS5	= MergeIcons(5, 1)
	$hTrayIconWiFiR1	= MergeIcons(1, 2)
	$hTrayIconWiFiR2	= MergeIcons(2, 2)
	$hTrayIconWiFiR3	= MergeIcons(3, 2)
	$hTrayIconWiFiR4	= MergeIcons(4, 2)
	$hTrayIconWiFiR5	= MergeIcons(5, 2)
	$hTrayIconWiFiND1	= MergeIcons(1, 3)
	$hTrayIconWiFiND2	= MergeIcons(2, 3)
	$hTrayIconWiFiND3	= MergeIcons(3, 3)
	$hTrayIconWiFiND4	= MergeIcons(4, 3)
	$hTrayIconWiFiND5	= MergeIcons(5, 3)
EndFunc


;**********************************************************************
; Merge 2 icons into 1
;**********************************************************************
Func MergeIcons($nIdx1, $nIdx2)
	Local $hIL = ImageList_Merge($hILTrayWiFi, $nIdx1, $hILTrayRS, $nIdx2, 0, 0)
	
	Local $hIcon = 0
	If $hIL <> 0 Then	
		$hIcon = ImageList_GetIcon($hIL, 0, 1)
		ImageList_Destroy($hIL)
	EndIf

	Return $hIcon
EndFunc


;**********************************************************************
; Shows/Removes tray icon
;**********************************************************************
Func TrayIconSetState($nState = 1)
	If $nState = 0 Then Return ; No change
	If $hTrayMsgWnd = 0 Then Return
	
	Local $stNID = DllStructCreate($sNOTIFYICONDATAW)
	
	If BitAnd($nState, 1) Then
		DllStructSetData($stNID, 1, DllStructGetSize($stNID))
		DllStructSetData($stNID, 2, $hTrayMsgWnd)
		DllStructSetData($stNID, 3, $nTrayNotifyID)
		DllStructSetData($stNID, 4, BitOr($NIF_ICON, $NIF_MESSAGE))
		DllStructSetData($stNID, 5, $TRAYMSGID)
		DllStructSetData($stNID, 6, $hTrayIcon)
		
		Shell_NotifyIconW($NIM_ADD, DllStructGetPtr($stNID))
		
		$bTrayIconCreated = TRUE
		$bTrayTrackMouse = TRUE
	ElseIf BitAnd($nState, 2) Then
		DllStructSetData($stNID, 1, DllStructGetSize($stNID))
		DllStructSetData($stNID, 2, $hTrayMsgWnd)
		DllStructSetData($stNID, 3, $nTrayNotifyID)
		
		Shell_NotifyIconW($NIM_DELETE, DllStructGetPtr($stNID))
		
		$bTrayIconCreated = FALSE
		$bTrayTrackMouse = FALSE
	EndIf
EndFunc


;**********************************************************************
; Change tray icon
;**********************************************************************
Func TrayIconSetIcon($hIcon = 0)
	If $hTrayMsgWnd = 0 Then Return
	If $hIcon = 0 Then $hIcon = $hTrayIcon
	
	Local $stNID	= DllStructCreate($sNOTIFYICONDATAW)
	DllStructSetData($stNID, 1, DllStructGetSize($stNID))
	DllStructSetData($stNID, 2, $hTrayMsgWnd)
	DllStructSetData($stNID, 3, $nTrayNotifyID)
	DllStructSetData($stNID, 6, $hIcon)
	
	If $bTrayIconCreated Then
		DllStructSetData($stNID, 4, $NIF_ICON)
		Shell_NotifyIconW($NIM_MODIFY, DllStructGetPtr($stNID))
	Else
		DllStructSetData($stNID, 4, BitOr($NIF_ICON, $NIF_MESSAGE))
		DllStructSetData($stNID, 5, $TRAYMSGID)
		Shell_NotifyIconW($NIM_ADD, DllStructGetPtr($stNID))
		$bTrayIconCreated = TRUE
		$bTrayTrackMouse = TRUE
	EndIf
EndFunc


;**********************************************************************
; Change tray tooltip
;**********************************************************************
Func TrayIconSetToolTip($sText)
	If Not $bTrayIconCreated Then Return
	If $hTrayMsgWnd = 0 Then Return
	
	If StringLen($sText) > 127 Then $sText = StringLeft($sText, 127)
	
	Local $stNID	= DllStructCreate($sNOTIFYICONDATAW)
	DllStructSetData($stNID, 1, DllStructGetSize($stNID))
	DllStructSetData($stNID, 2, $hTrayMsgWnd)
	DllStructSetData($stNID, 3, $nTrayNotifyID)
	DllStructSetData($stNID, 4, $NIF_TIP)
	DllStructSetData($stNID, 7, $sText)
	
	Shell_NotifyIconW($NIM_MODIFY, DllStructGetPtr($stNID))
EndFunc


;**********************************************************************
; Check for specific text in CMD line
;**********************************************************************
Func ChkCmdParam($sText)
	Local $bParamExists = FALSE
	Local $i
	
	For $i = 1 To $CmdLine[0]
		If StringUpper($sText) == StringUpper($CmdLine[$i]) Then
			$bParamExists = True
			ExitLoop
		EndIf
	Next

	Return $bParamExists
EndFunc


;**********************************************************************
; Check for specific text in CMD line
;**********************************************************************
Func SetGUICursor($hCursor, $hWnd)
	$hCursorCurrent = $hCursor
	PostMessage($hWnd, $WM_SETCURSOR, $hWnd, 0)
EndFunc


;**********************************************************************
; SETUPAPI.DLL
;**********************************************************************
Func SetupDiGetClassDevsA($pClassGUID, $pFilter, $hWnd, $nFlags)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiGetClassDevsA", _
												"ptr", $pClassGUID, _
												"ptr", $pFilter, _
												"hwnd", $hWnd, _
												"dword", $nFlags)

	If $nResult[0] = $INVALID_HANDLE_VALUE Then
		Local $nError = GetLastError()
		Debug("ER: SetupDiGetClassDevsA: " & $nError)
		SetLastError($nError)
	Else
		Debug("OK: SetupDiGetClassDevsA: " &  $nResult[0])
	EndIf	
	
	Return $nResult[0]
EndFunc


Func SetupDiEnumDeviceInfo($hDeviceInfoSet, $nIndex, $pDeviceInfoData, $bDebug = TRUE)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiEnumDeviceInfo", _
											"hwnd", $hDeviceInfoSet, _
											"int", $nIndex, _
											"ptr", $pDeviceInfoData)

	If $bDebug Then
		If $nResult[0] Then
			Debug("OK: SetupDiEnumDeviceInfo")
		Else
			Local $nError = GetLastError()
			Debug("ER: SetupDiEnumDeviceInfo: " & $nError)
			SetLastError($nError)
		EndIf
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupDiDestroyDeviceInfoList($hDeviceInfoSet)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiDestroyDeviceInfoList", _
											"hwnd", $hDeviceInfoSet)

	
	If $nResult[0] Then
		Debug("OK: SetupDiDestroyDeviceInfoList")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiDestroyDeviceInfoList: " & $nError)
		SetLastError($nError)
	EndIf

	Return $nResult[0]
EndFunc


Func SetupDiGetDeviceRegistryPropertyW($hDeviceInfoSet, $pDeviceInfoData, $nProperty, $pPropertyBuffer, $nSize, $pReqSize, $bDebug = TRUE)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiGetDeviceRegistryPropertyW", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"dword", $nProperty, _
											"dword*", 0, _
											"ptr", $pPropertyBuffer, _
											"dword", $nSize, _
											"ptr", $pReqSize)
	
	If $bDebug Then
		If $nResult[0] Then
			Debug("OK: SetupDiGetDeviceRegistryPropertyW")
		Else
			Local $nError = GetLastError()
			If $nError <> $ERROR_INSUFFICIENT_BUFFER Then Debug("ER: SetupDiGetDeviceRegistryPropertyW: " & $nError)
			SetLastError($nError)
		EndIf
	EndIf
						
	Return $nResult[0]
EndFunc


Func SetupDiCallClassInstaller($nInstallFunction, $hDeviceInfoSet, $pDeviceInfoData)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiCallClassInstaller", _
											"int", $nInstallFunction, _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData)
											
	If $nResult[0] Then
		Debug("OK: SetupDiCallClassInstaller")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiCallClassInstaller: " & $nError)
		SetLastError($nError)
	EndIf	
	
	Return $nResult[0]
EndFunc


Func SetupDiSetClassInstallParamsW($hDeviceInfoSet, $pDeviceInfoData, $pInstallParams, $nSize)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiSetClassInstallParamsW", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"ptr", $pInstallParams, _
											"dword", $nSize)

	If $nResult[0] Then
		Debug("OK: SetupDiSetClassInstallParamsW")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiSetClassInstallParamsW: " & $nError)
		SetLastError($nError)
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupDiGetDeviceInstanceIdW($hDeviceInfoSet, $pDeviceInfoData, $pInstanceID, $nSize, $pReqSize)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiGetDeviceInstanceIdW", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"ptr", $pInstanceID, _
											"int", $nSize, _
											"ptr", $pReqSize)

	If $nResult[0] Then
		Debug("OK: SetupDiGetDeviceInstanceIdW")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiGetDeviceInstanceIdW: " & $nError)
		SetLastError($nError)
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupDiGetDeviceInstallParamsW($hDeviceInfoSet, $pDeviceInfoData, $pDeviceInstallParams)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiGetDeviceInstallParamsW", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"ptr", $pDeviceInstallParams)

	Local $nError = GetLastError()
	If $nResult[0] Then
		Debug("OK: SetupDiGetDeviceInstallParamsW")
	Else
		Debug("ER: SetupDiGetDeviceInstallParamsW: " & $nError)
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc


Func SetupDiSetDeviceInstallParamsW($hDeviceInfoSet, $pDeviceInfoData, $pDeviceInstallParams)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiSetDeviceInstallParamsW", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"ptr", $pDeviceInstallParams)

	If $nResult[0] Then
		Debug("OK: SetupDiSetDeviceInstallParamsW")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiSetDeviceInstallParamsW: " & $nError)
		SetLastError($nError)
	EndIf
													
	Return $nResult[0]
EndFunc


Func SetupDiBuildDriverInfoList($hDeviceInfoSet, $pDeviceInfoData, $nDriverType)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiBuildDriverInfoList", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"dword", $nDriverType)
	
	If $nResult[0] Then
		Debug("OK: SetupDiBuildDriverInfoList")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiBuildDriverInfoList: " & $nError)
		SetLastError($nError)
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupDiDestroyDriverInfoList($hDeviceInfoSet, $pDeviceInfoData, $nDriverType)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiDestroyDriverInfoList", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"dword", $nDriverType)

	If $nResult[0] Then
		Debug("OK: SetupDiDestroyDriverInfoList")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiDestroyDriverInfoList: " & $nError)
		SetLastError($nError)
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupDiEnumDriverInfoW($hDeviceInfoSet, $pDeviceInfoData, $nDriverType, $nIndex, $pDriverInfoData)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiEnumDriverInfoW", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"dword", $nDriverType, _
											"dword", $nIndex, _
											"ptr", $pDriverInfoData)

	If $nResult[0] Then
		Debug("OK: SetupDiEnumDriverInfoW")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiEnumDriverInfoW: " & $nError)
		SetLastError($nError)
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupDiGetDriverInfoDetailW($hDeviceInfoSet, $pDeviceInfoData, $pDriverInfoData, $pDriverInfoDetailData, $nSize, $pReqSize)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiGetDriverInfoDetailW", _
											"hwnd", $hDeviceInfoSet, _
											"ptr", $pDeviceInfoData, _
											"ptr", $pDriverInfoData, _
											"ptr", $pDriverInfoDetailData, _
											"dword", $nSize, _
											"ptr", $pReqSize)
	
	If $nResult[0] Then
		Debug("OK: SetupDiGetDriverInfoDetailW")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiGetDriverInfoDetailW: " & $nError)
		SetLastError($nError)
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupDiGetINFClassW($sFile, $pGUID, $pClass, $nSize, $pReqSize)
	Local $nResult = DllCall($hSetupapi, "int", "SetupDiGetINFClassW", _
											"wstr", $sFile, _
											"ptr", $pGUID, _
											"ptr", $pClass, _
											"dword", $nSize, _
											"ptr", $pReqSize)
	
	If $nResult[0] Then
		Debug("OK: SetupDiGetINFClassW")
	Else
		Local $nError = GetLastError()
		Debug("ER: SetupDiGetINFClassW: " & $nError)
		SetLastError($nError)
	EndIf
		
	Return $nResult[0]
EndFunc


Func CM_Get_DevNode_Status($pStatus, $pProblem, $nDevInst, $nFLags)
	Local $nResult = DllCall($hSetupapi, "int", "CM_Get_DevNode_Status", _
											"ptr", $pStatus, _
											"ptr", $pProblem, _
											"dword", $nDevInst, _
											"dword", $nFLags)

	If $nResult[0] = 0 Then
		Debug("OK: CM_Get_DevNode_Status")
	Else
		Debug("ER: CM_Get_DevNode_Status: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func SetupOpenInfFileW($sFile, $pClass, $nStyle, $pError)
	Local $hResult = DllCall($hSetupapi, "hwnd", "SetupOpenInfFileW", _
											"wstr", $sFile, _
											"ptr", $pClass, _
											"dword", $nStyle, _
											"ptr", $pError)
	
	If $hResult[0] = $INVALID_HANDLE_VALUE Then
		Local $nError = GetLastError()
		;Debug("ER: SetupOpenInfFileW: " & $nError)
		SetLastError($nError)
	Else
		;Debug("OK: SetupOpenInfFileW")		
	EndIf	
	
	Return $hResult[0]
EndFunc


Func SetupCloseInfFile($hInf)
	DllCall($hSetupapi, "none", "SetupCloseInfFile", _
						"hwnd", $hInf)
EndFunc


Func SetupFindFirstLineW($hInf, $pSection, $pKey, $pCtx)
	Local $nResult = DllCall($hSetupapi, "int", "SetupFindFirstLineW", _
											"hwnd", $hInf, _
											"ptr", $pSection, _
											"ptr", $pKey, _
											"ptr", $pCtx)
	Return $nResult[0]
EndFunc


Func SetupFindNextLine($pCtxIn, $pCtxOut)
	Local $nResult = DllCall($hSetupapi, "int", "SetupFindNextLine", _
											"ptr", $pCtxIn, _
											"ptr", $pCtxOut)
	Return $nResult[0]
EndFunc


Func SetupGetLineTextW($pCtx, $hInf, $sSec, $sKey, $pBuffer, $nSize, $pSize)
	Local $nResult = DllCall($hSetupapi, "int", "SetupGetLineTextW", _
											"ptr", $pCtx, _
											"hwnd", $hInf, _
											"wstr", $sSec, _
											"wstr", $sKey, _
											"ptr", $pBuffer, _
											"dword", $nSize, _
											"ptr", $pSize)
	Return $nResult[0]
EndFunc


Func SetupGetFieldCount($pCtx)
	Local $nResult = DllCall($hSetupapi, "dword", "SetupGetFieldCount", _
											"ptr", $pCtx)
	Return $nResult[0]
EndFunc


Func SetupGetStringFieldW($pCtx, $nField, $pBuffer, $nSize, $pSize)
	Local $nResult = DllCall($hSetupapi, "int", "SetupGetStringFieldW", _
											"ptr", $pCtx, _
											"dword", $nField, _
											"ptr", $pBuffer, _
											"dword", $nSize, _
											"ptr", $pSize)
	Return $nResult[0]
EndFunc


;**********************************************************************
; KERNEL32.DLL
;**********************************************************************
Func LoadLibraryExW($lpFile, $hFile, $nFlags)
	Local $hResult = DllCall($hKernel32, "hwnd", "LoadLibraryExW", _
										"long_ptr", $lpFile, _
										"hwnd", $hFile, _
										"dword", $nFlags)
	Return $hResult[0]
EndFunc


Func FreeLibrary($hModule)
	Local $nResult = DllCall($hKernel32, "int", "FreeLibrary", _
										"hwnd", $hModule)
	Return $nResult[0]
EndFunc


Func MulDiv($nInt1, $nInt2, $nInt3)
	Local $nResult = DllCall($hKernel32, "int", "MulDiv", _
											"int", $nInt1, _
											"int", $nInt2, _
											"int", $nInt3)
	Return $nResult[0]
EndFunc


Func GetLastError()
	Local $nError = DllCall($hKernel32, "dword", "GetLastError")
	Return $nError[0]
EndFunc


Func SetLastError($nError)
	DllCall($hKernel32, "none", "SetLastError", _
						"dword", $nError)
EndFunc


Func GetComputerNameExW($nNameType, $pBuffer, $pSize)
	Local $nResult	= DllCall($hKernel32, "int", "GetComputerNameExW", _
											"int", $nNameType, _
											"ptr", $pBuffer, _
											"ptr", $pSize)
	Return $nResult[0]
EndFunc


Func SetComputerNameExW($nNameType, $pBuffer)
	Local $nResult	= DllCall($hKernel32, "int", "SetComputerNameExW", _
											"int", $nNameType, _
											"ptr", $pBuffer)
	Return $nResult[0]
EndFunc


Func FormatMessageW($nFlags, $pSrc, $nMsg, $nLang, $pBuffer, $nSize, $pArg)
	Local $nResult = DllCall($hKernel32, "dword", "FormatMessageW", _
											"dword", $nFlags, _
											"ptr", $pSrc, _
											"dword", $nMsg, _
											"dword", $nLang, _
											"ptr", $pBuffer, _
											"dword", $nSize, _
											"ptr", $pArg)
	Return $nResult[0]
EndFunc


Func LocalFree($pBuf)
	Local $nResult = DllCall($hKernel32, "dword", "LocalFree", "ptr", $pBuf)
	Return $nResult[0]
EndFunc


Func GetVersionExW($pOVIEx)
	Local $nResult = DllCall($hKernel32, "int", "GetVersionExW", "ptr", $pOVIEx)
	Return $nResult[0]
EndFunc


Func CreateFileW($sFileName, $nAcc, $nShare, $pSec, $nCreate, $nFlags, $hTemp)
	Local $hResult = DllCall($hKernel32, "hwnd", "CreateFileW", _
											"wstr", $sFileName, _
											"dword", $nAcc, _
											"dword", $nShare, _
											"ptr", $pSec, _
											"dword", $nCreate, _
											"dword", $nFlags, _
											"hwnd", $hTemp)	
	Return $hResult[0]
EndFunc


Func DeviceIoControl($hDevice, $nCode, $pIn, $nIn, $pOut, $nOut, $pBytes, $pOver)
	Local $nResult = DllCall($hKernel32, "int", "DeviceIoControl", _
											"hwnd", $hDevice, _
											"ptr", $nCode, _
											"ptr", $pIn, _
											"dword", $nIn, _
											"ptr", $pOut, _
											"dword", $nOut, _
											"ptr", $pBytes, _
											"ptr", $pOver)
	Return $nResult[0]
EndFunc


Func CloseHandle($hHandle)
	Local $nResult = DllCall($hKernel32, "int", "CloseHandle", _
											"hwnd", $hHandle)	
	Return $nResult[0]
EndFunc


Func MultiByteToWideChar($nCP, $nFlags, $sString, $nBytes, $pWStr, $nBufferSze)
	Local $nResult	= DllCall($hKernel32, "int", "MultiByteToWideChar", _
													"int", $nCP, _
													"int", $nFlags, _
													"str", $sString, _
													"int", $nBytes, _
													"long_ptr", $pWStr, _
													"int", $nBufferSze)
	Return $nResult[0]
EndFunc


Func WideCharToMultiByte($nCP, $nFlags, $pWStr, $nChrWStr, $pMBStr, $nBufferSze, $pDefChr, $pUsedDefChr)
	Local $nResult	= DllCall($hKernel32, "int", "WideCharToMultiByte", _
													"int", $nCP, _
													"int", $nFlags, _
													"long_ptr", $pWStr, _
													"int", $nChrWStr, _
													"long_ptr", $pMBStr, _
													"int", $nBufferSze, _
													"long_ptr", $pDefChr, _
													"long_ptr", $pUsedDefChr)
	Return $nResult[0]
EndFunc


;**********************************************************************
; IPHLPAPI.DLL
;**********************************************************************
Func GetAdapterIndex($pName, $pIndex)
	Local $nResult = DllCall($hIphlpapi, "dword", "GetAdapterIndex", _
											"ptr", $pName, _
											"ptr", $pIndex)
	Return $nResult[0]
EndFunc


Func GetAdaptersInfo($pAdapterInfo, $pBufferSize, $bDbg = TRUE)
	Local $nResult = DllCall($hIphlpapi, "dword", "GetAdaptersInfo", _
											"ptr", $pAdapterInfo, _
											"long_ptr", $pBufferSize)
											
	If @Error = 0 Then
		If $bDbg Then Debug("OK: GetAdaptersInfo: " & $nResult[0])
		Return $nResult[0]
	Else
		If $bDbg Then Debug("ER: GetAdaptersInfo")
		Return -1
	EndIf
EndFunc


Func GetPerAdapterInfo($nIndex, $pPerAdapterInfo, $pBufferSize, $bDbg = TRUE)
	Local $nResult = DllCall($hIphlpapi, "dword", "GetPerAdapterInfo", _
											"ulong", $nIndex, _
											"ptr", $pPerAdapterInfo, _
											"long_ptr", $pBufferSize)
											
	If @Error = 0 Then
		If $bDbg Then Debug("OK: GetPerAdapterInfo: " & $nResult[0])
		Return $nResult[0]
	Else
		If $bDbg Then Debug("ER: GetPerAdapterInfo")
		Return -1
	EndIf
EndFunc


Func GetIfEntry($pIFRow)
	Local $nResult = DllCall($hIphlpapi, "dword", "GetIfEntry", _
											"ptr", $pIFRow)
	Return $nResult[0]
EndFunc


Func GetNumberOfInterfaces($pCount)
	Local $nResult = DllCall($hIphlpapi, "dword", "GetNumberOfInterfaces", _
											"ptr", $pCount)
	Return $nResult[0]
EndFunc


Func IpReleaseAddress($pAdapterInfo)
	Local $nResult = DllCall($hIphlpapi, "dword", "IpReleaseAddress", _
											"ptr", $pAdapterInfo)
	If $nResult[0] = $NO_ERROR Then
		Debug("OK: IpReleaseAddress")
	Else
		Debug("ER: IpReleaseAddress: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func IpRenewAddress($pAdapterInfo)
	Local $nResult = DllCall($hIphlpapi, "dword", "IpRenewAddress", _
											"ptr", $pAdapterInfo)
	If $nResult[0] = $NO_ERROR Then
		Debug("OK: IpRenewAddress")
	Else
		Debug("ER: IpRenewAddress: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func IcmpCreateFile()
	Local $hResult = DllCall($hIphlpapi, "hwnd", "IcmpCreateFile")
	
	Return $hResult[0]
EndFunc


Func IcmpSendEcho($hIcmp, $nIPAddr, $pData, $nSize, $pIPOption, $pReply, $nReplySize, $nTimeOut)
	Local $nResult = DllCall($hIphlpapi, "dword", "IcmpSendEcho", _
										"hwnd", $hIcmp, _
										"ulong", $nIPAddr, _
										"long_ptr", $pData, _
										"ushort", $nSize, _
										"ptr", $pIPOption, _
										"long_ptr", $pReply, _
										"dword", $nReplySize, _
										"dword", $nTimeOut)	
	Return $nResult[0]
EndFunc


Func IcmpCloseHandle($hIcmp)
	Local $nResult = DllCall($hIphlpapi, "int", "IcmpCloseHandle", _
										"hwnd", $hIcmp)
	
	Return $nResult[0]
EndFunc


Func GetAdaptersAddresses($nFamily, $nFlags, $pReserverd, $pAdapterAddresses, $pBufferSize, $bDbg = TRUE)
	Local $nResult = DllCall($hIphlpapi, "ulong", "GetAdaptersAddresses", _
											"ulong", $nFamily, _
											"ulong", $nFlags, _
											"ptr", $pReserverd, _
											"ptr", $pAdapterAddresses, _
											"long_ptr", $pBufferSize)
											
	If @Error = 0 Then
		If $bDbg Then Debug("OK: GetAdaptersAddresses: " & $nResult[0])
		Return $nResult[0]
	Else
		If $bDbg Then Debug("ER: GetAdaptersAddresses")
		Return -1
	EndIf
EndFunc


Func ConvertLengthToIpv4Mask($nLen, $pMask)
	Local $nResult = DllCall($hIphlpapi, "dword", "ConvertLengthToIpv4Mask", _
										"ulong", $nLen, _
										"ulong_ptr", $pMask)
	
	Return $nResult[0]
EndFunc


;**********************************************************************
; USER32.DLL
;**********************************************************************
Func GetDesktopWindow()
	Local $hResult = DllCall($hUser32, "hwnd", "GetDesktopWindow")
	Return $hResult[0]
EndFunc


Func GetDpiForWindow($hWnd)
	Local $hResult = DllCall($hUser32, "int", "GetDpiForWindow", _
										"hwnd", $hWnd)
	If @Error = 0 Then
		Return $hResult[0]
	Else
		Return 0
	EndIf
EndFunc


Func IsWindowVisible($hWnd)
	Local $nResult = DllCall($hUser32, "int", "IsWindowVisible", _
										"hwnd", $hWnd)
	Return $nResult[0]
EndFunc


Func CreateIconIndirect($pII)
	Local $hResult = DllCall($hUser32, "int", "CreateIconIndirect", _
										"ptr", $pII)
	Return $hResult[0]
EndFunc


Func LoadImageW($hModule, $lpIdx, $nType, $nSizeX, $nSizeY, $nMask)
	Local $hResult = DllCall($hUser32, "hwnd", "LoadImageW", _
										"hwnd", $hModule, _
										"long_ptr", $lpIdx, _
										"uint", $nType, _
										"int", $nSizeX, _
										"int", $nSizeY, _
										"uint", $nMask)
	Return $hResult[0]
EndFunc

			
Func GetScrollInfo($hWnd, $nBar, $lpSI)
	Local $nResult = DllCall($hUser32, "int", "GetScrollInfo", _
										"hwnd", $hWnd, _
										"int", $nBar, _
										"long_ptr", $lpSI)
	Return $nResult[0]
EndFunc


Func SetScrollInfo($hWnd, $nBar, $lpSI, $bRepaint)
	Local $nResult = DllCall($hUser32, "int", "SetScrollInfo", _
										"hwnd", $hWnd, _
										"int", $nBar, _
										"long_ptr", $lpSI, _
										"int", $bRepaint)
	Return $nResult[0]
EndFunc


Func ScrollWindow($hWnd, $nX, $nY, $lpRect, $lpClip)
	Local $nResult = DllCall($hUser32, "int", "ScrollWindow", _
										"hwnd", $hWnd, _
										"int", $nX, _
										"int", $nY, _
										"long_ptr", $lpRect, _
										"long_ptr", $lpClip)
	Return $nResult[0]
EndFunc


Func SetProcessDPIAware()
	Local $nResult = DllCall($hUser32, "int", "SetProcessDPIAware")
	Return $nResult[0]
EndFunc


Func UpdateWindow($hWnd)
	Local $nResult = DllCall($hUser32, "int", "UpdateWindow", _
										"hwnd", $hWnd)
	Return $nResult[0]
EndFunc


Func BeginPaint($hWnd, $lpPS)
	Local $hResult = DllCall($hUser32, "hwnd", "BeginPaint", _
										"hwnd", $hWnd, _
										"long_ptr", $lpPS)
	Return $hResult[0]
EndFunc


Func EndPaint($hWnd, $lpPS)
	Local $nResult = DllCall($hUser32, "int", "EndPaint", _
										"hwnd", $hWnd, _
										"long_ptr", $lpPS)
	Return $nResult[0]
EndFunc


Func GetDlgItem($hWnd, $nID)
	Local $hResult = DllCall($hUser32, "hwnd", "GetDlgItem", _
										"hwnd", $hWnd, _
										"int", $nID)
	Return $hResult[0]
EndFunc


Func GetWindowRect($hWnd, $lpRect)
	Local $nResult = DllCall($hUser32, "int", "GetWindowRect", _
										"hwnd", $hWnd, _
										"long_ptr", $lpRect)
	Return $nResult[0]
EndFunc


Func LoadCursor($hInstance, $lpCursor)
	Local $hResult = DllCall($hUser32, "hwnd", "LoadCursor", _
										"hwnd", $hInstance, _
										"long_ptr", $lpCursor)
	Return $hResult[0]
EndFunc


Func SetCursor($hCursor)
	Local $hResult = DllCall($hUser32, "hwnd", "SetCursor", _
										"hwnd", $hCursor)
	Return $hResult[0]
EndFunc


Func DestroyCursor($hCursor)
	Local $nResult = DllCall($hUser32, "int", "DestroyCursor", _
										"hwnd", $hCursor)
	Return $nResult[0]
EndFunc


Func SetWindowTextW($hWnd, $sText)
	Local $nResult = DllCall($hUser32, "hwnd", "SetWindowTextW", _
										"hwnd", $hWnd, _
										"wstr", $sText)
	Return $nResult[0]
EndFunc


Func GetSystemMetrics($nIndex)
	Local $nResult = DllCall($hUser32, "int", "GetSystemMetrics", _
										"int", $nIndex)
	Return $nResult[0]
EndFunc


Func CreateWindowExW($nExStyle, $sClassName, $sWndName, $nStyle, $nX, $nY, $nW, $nH, $hWndParent, $hMenu, $hInstance, $pParam)
	Local $nResult = DllCall($hUser32, "hwnd", "CreateWindowExW", _
										"int", $nExStyle, _
										"wstr", $sClassName, _
										"wstr", $sWndName, _
										"int", $nStyle, _
										"int", $nX, _
										"int", $nY, _
										"int", $nW, _
										"int", $nH, _
										"hwnd", $hWndParent, _
										"hwnd", $hMenu, _
										"hwnd", $hInstance, _
										"ptr", $pParam)													
	Return $nResult[0]
EndFunc


Func SendMessage($hWnd, $Msg, $wParam = 0, $lParam = 0)
    Local $nResult = DllCall($hUser32, "int", "SendMessage", _
					                     "hwnd", $hWnd, _
					                     "uint", $Msg, _
					                     "wparam", $wParam, _
					                     "lparam", $lParam)
	Return $nResult[0]
EndFunc


Func PostMessage($hWnd, $Msg, $wParam = 0, $lParam = 0)
    Local $nResult = DllCall($hUser32, "int", "PostMessage", _
					                     "hwnd", $hWnd, _
					                     "int", $Msg, _
					                     "wparam", $wParam, _
					                     "lparam", $lParam)
	Return $nResult[0]
EndFunc


Func GetParent($hWnd)
    Local $hResult = DllCall($hUser32, "hwnd", "GetParent", _
										"hwnd", $hWnd)
	Return $hResult[0]
EndFunc


Func GetDC($hWnd)
	Local $hResult = DllCall($hUser32, "hwnd", "GetDC", _
										"hwnd", $hWnd)
	Return $hResult[0]
EndFunc


Func ReleaseDC($hWnd, $hDC)
	Local $nResult = DllCall($hUser32, "int", "ReleaseDC", _
										"hwnd", $hWnd, _
										"hwnd", $hDC)
	Return $nResult[0]
EndFunc


Func SystemParametersInfoW($nIndex, $nParam, $ptrData, $nFlag)
	Local $nResult = DllCall($hUser32, "int", "SystemParametersInfoW", _
										"int", $nIndex, _
										"int", $nParam, _
										"ptr", $ptrData, _
										"int", $nFlag)
	Return $nResult[0]
EndFunc


Func EnableWindow($hWnd, $bEnable)
	DllCall($hUser32, "int", "EnableWindow", _
						"hwnd", $hWnd, _
						"int", $bEnable)
EndFunc
									

Func ShowWindow($hWnd, $nState)
	DllCall($hUser32, "int", "ShowWindow", _
						"hwnd", $hWnd, _
						"int", $nState)
EndFunc

								
Func DestroyWindow($hWnd)
	DllCall($hUser32, "int", "DestroyWindow", _
						"hwnd", $hWnd)
EndFunc


Func DestroyIcon($hIcon)
	Local $bResult = DllCall($hUser32, "int", "DestroyIcon", _
										"hwnd", $hIcon)
	Return $bResult[0]
EndFunc


Func MessageBoxW($hWnd, $sText, $sTitle, $nType)
	Local $nResult = DllCall($hUser32, "dword", "MessageBoxW", _
										"hwnd", $hWnd, _
										"wstr", $sText, _
										"wstr", $sTitle, _
										"int", $nType)
	Return $nResult[0]
EndFunc


Func ClientToScreen($hWnd, $pPoint)
	Local $nResult = DllCall($hUser32, "int", "ClientToScreen", _
										"hwnd", $hWnd, _
										"ptr", $pPoint)
    Return $nResult[0]
EndFunc


Func TrackPopupMenuEx($hMenu, $nFlags, $nX, $nY, $hWnd, $pTPM)
    DllCall($hUser32, "int", "TrackPopupMenuEx", _
						"hwnd", $hMenu, _
						"int", $nFlags, _
						"int", $nX, _
						"int", $nY, _
						"hwnd", $hWnd, _
						"ptr", $pTPM)
EndFunc


Func GetCursorPos($pPoint)
	Local $nResult = DllCall($hUser32, "int", "GetCursorPos", _
										"ptr", $pPoint)
	Return $nResult[0]
EndFunc


Func ScreenToClient($hWnd, $pPoint)
	Local $nResult = DllCall($hUser32, "int", "ScreenToClient", _
										"hwnd", $hWnd, _
										"ptr", $pPoint)
	Return $nResult[0]
EndFunc


Func SetTimer($hWnd, $nID, $nTimeOut, $pFunc)
	Local $nResult = DllCall($hUser32, "uint", "SetTimer", _
										"hwnd", $hWnd, _
										"uint", $nID, _
										"uint", $nTimeOut, _
										"ptr", $pFunc)
	Return $nResult[0]
EndFunc


Func KillTimer($hWnd, $nID)
	Local $bResult = DllCall($hUser32, "int", "KillTimer", _
										"hwnd", $hWnd, _
										"uint", $nID)
	Return $bResult[0]
EndFunc


Func SetForegroundWindow($hWnd)
	Local $bResult = DllCall($hUser32, "int", "SetForegroundWindow", _
										"hwnd", $hWnd)
	Return $bResult[0]
EndFunc


Func GetSysColor($nIndex)
    Local $nResult = DllCall($hUser32, "int", "GetSysColor", _
    									"int", $nIndex)
    Return $nResult[0]
EndFunc


Func GetSysColorBrush($nIndex)
    Local $hResult = DllCall($hUser32, "hwnd", "GetSysColorBrush", _
    									"int", $nIndex)
    Return $hResult[0]
EndFunc


Func DrawTextW($hDC, $pText, $nLen, $pRect, $nFormat)
	Local $nResult = DllCall($hUser32, "int", "DrawTextW", _
										"hwnd", $hDC, _
										"ptr", $pText, _
										"int", $nLen, _
										"ptr", $pRect, _
										"int", $nFormat)
	Return $nResult[0]
EndFunc


Func FillRect($hDC, $pRect, $hBrush)
	Local $nResult = DllCall($hUser32, "int", "FillRect", _
										"hwnd", $hDC, _
										"ptr", $pRect, _
										"hwnd", $hBrush)
	Return $nResult[0]
EndFunc


Func FrameRect($hDC, $pRect, $hBrush)
	Local $nResult = DllCall($hUser32, "int", "FrameRect", _
										"hwnd", $hDC, _
										"ptr", $pRect, _
										"hwnd", $hBrush)
	Return $nResult[0]
EndFunc


Func InflateRect($pRect, $nX, $nY)
	Local $nResult = DllCall($hUser32, "int", "InflateRect", _
										"ptr", $pRect, _
										"int", $nX, _
										"int", $nY)
    
	Return $nResult[0]
EndFunc


Func DrawIconEx($hDC, $nX, $nY, $hIcon, $xW, $yW, $nStep, $hBrush, $nFlags)
	Local $nResult = DllCall($hUser32, "int", "DrawIconEx", _
										"hwnd", $hDC, _
										"int", $nX, _
										"int", $nY, _
										"hwnd", $hIcon, _
										"int", $xW, _
										"int", $yW, _
										"uint", $nStep, _
										"hwnd", $hBrush, _
										"uint", $nFlags)
	Return $nResult[0]
EndFunc


Func DrawEdge($hDC, $pRect, $nEdge, $nFlags)
	Local $nResult = DllCall($hUser32, "int", "DrawEdge", _
										"hwnd", $hDC, _
										"ptr", $pRect, _
										"uint", $nEdge, _
										"uint", $nFlags)
    
	Return $nResult[0]
EndFunc

												
Func GetWindowLongW($hWnd, $nIndex)
	Local $nResult = DllCall($hUser32, "long", "GetWindowLongW", _
										"hwnd", $hWnd, _
										"int", $nIndex)
	Return $nResult[0]
EndFunc


Func GetFocus()
	Local $hResult = DllCall($hUser32, "hwnd", "GetFocus")
	Return $hResult[0]
EndFunc


Func GetDlgCtrlID($hWnd)
	Local $nResult = DllCall($hUser32, "int", "GetDlgCtrlID", _
										"hwnd", $hWnd)
	Return $nResult[0]
EndFunc


Func GetComboBoxInfo($hCtrl, $pCBI)
	Local $nResult = DllCall($hUser32, "int", "GetComboBoxInfo", _
										"hwnd", $hCtrl, _
										"ptr", $pCBI)
	Return $nResult[0]
EndFunc


Func GetWindowPlacement($hWnd, $pWP)
	Local $nResult = DllCall($hUser32, "int", "GetWindowPlacement", _
										"hwnd", $hWnd, _
										"ptr", $pWP)
	Return $nResult[0]
EndFunc


Func InvalidateRect($hWnd, $pRect, $bErase)
	Local $nResult = DllCall($hUser32, "int", "InvalidateRect", _
										"hWnd", $hWnd, _
										"ptr",$pRect, _
										"int", $bErase)
	Return $nResult[0]
EndFunc


Func RegisterWindowMessageW($pMsg)
	Local $nResult = DllCall($hUser32, "uint", "RegisterWindowMessageW", _
										"ptr", $pMsg)
	Return $nResult[0]
EndFunc


Func SetWindowPos($hWnd, $hWndAfter, $nX, $nY, $nW, $nH, $nFlags)
	Local $nResult = DllCall($hUser32, "int", "SetWindowPos", _
										"hwnd", $hWnd, _
										"hwnd", $hWndAfter, _
										"int", $nX, _
										"int", $nY, _
										"int", $nW, _
										"int", $nH, _
										"uint", $nFlags)
	Return $nResult[0]
EndFunc


Func GetWindowTextLength($hWnd)
	Local $nResult = DllCall($hUser32, "int", "GetWindowTextLengthW", _
										"hwnd", $hWnd)
	Return $nResult[0]
EndFunc


Func GetWindowTextW($hWnd, $lpBuffer, $nBufferLen)
	Local $nResult = DllCall($hUser32, "int", "GetWindowTextW", _
										"hwnd", $hWnd, _
										"long_ptr", $lpBuffer, _
										"int", $nBufferLen)
	Return $nResult[0]
EndFunc


Func FindWindowExW($hParent, $hChild, $sClass, $sName)
	Local $nResult = DllCall($hUser32, "hwnd", "FindWindowExW", _
										"hwnd", $hParent, _
										"hwnd", $hChild, _
										"wstr", $sClass, _
										"wstr", $sName)
	Return $nResult[0]
EndFunc


Func GetClientRect($hWnd, $lpRect)
	Local $nResult = DllCall($hUser32, "int", "GetClientRect", _
										"hwnd", $hWnd, _
										"long_ptr", $lpRect)
	Return $nResult[0]
EndFunc


Func GetShellWindow()
	Local $hResult = DllCall($hUser32, "hwnd", "GetShellWindow")
	Return $hResult[0]
EndFunc


Func ShowScrollBar($hWnd, $nBar, $bShow)
	Local $nResult = DllCall($hUser32, "int", "ShowScrollBar", _
										"hwnd", $hWnd, _
										"int", $nBar, _
										"int", $bShow)
	Return $nResult[0]
EndFunc


Func SetLayeredWindowAttributes($hWnd, $nClr, $nAlpha, $nFlags)
	Local $nResult = DllCall($hUser32, "int", "SetLayeredWindowAttributes", _
										"hwnd", $hWnd, _
										"dword", $nClr, _
										"int", $nAlpha, _
										"dword", $nFlags)
	Return $nResult[0]
EndFunc


;**********************************************************************
; NETAPI32.DLL
;**********************************************************************
Func NetWkstaGetInfo($pServer, $nLevel, $pBuffer)
	Local $nResult = DllCall($hNetapi32, "dword", "NetWkstaGetInfo", _
													"ptr", $pServer, _
													"dword", $nLevel, _
													"ptr", $pBuffer)
	Return $nResult[0]
EndFunc


Func NetJoinDomain($pServer, $pDomain, $pAccountOU, $pAccount, $pPassword, $nOptions)
	Local $nResult = DllCall($hNetapi32, "dword", "NetJoinDomain", _
													"ptr", $pServer, _
													"ptr", $pDomain, _
													"ptr", $pAccountOU, _
													"ptr", $pAccount, _
													"ptr", $pPassword, _
													"dword", $nOptions)
	Return $nResult[0]
EndFunc


Func NetApiBufferFree($pBuffer)
	Local $nResult = DllCall($hNetapi32, "dword", "NetApiBufferFree", _
													"ptr", $pBuffer)
	Return $nResult[0]
EndFunc


Func NetUserAdd($pServer, $nLevel, $pBuffer, $pError)
	Local $nResult = DllCall($hNetapi32, "dword", "NetUserAdd", _
														"ptr", $pServer, _
														"dword", $nLevel, _
														"ptr", $pBuffer, _
														"ptr", $pError)
	Return $nResult[0]
EndFunc


Func NetUserDel($pServer, $pUser)
	Local $nResult = DllCall($hNetapi32, "dword", "NetUserDel", _
														"ptr", $pServer, _
														"ptr", $pUser)
	Return $nResult[0]
EndFunc


Func NetLocalGroupAddMembers($pServer, $pGroup, $nLevel, $pBuffer, $nEntries)
	Local $nResult = DllCall($hNetapi32, "dword", "NetLocalGroupAddMembers", _
														"ptr", $pServer, _
														"ptr", $pGroup, _
														"dword", $nLevel, _
														"ptr", $pBuffer, _
														"long", $nEntries)

	Return $nResult[0]
EndFunc


Func NetLocalGroupGetMembers($pServer, $pGroup, $nLevel, $pBuffer, $nMaxBuffer, $pEntriesRead, $pMaxEntries, $pHandle)
	Local $nResult = DllCall($hNetapi32, "dword", "NetLocalGroupGetMembers", _
														"ptr", $pServer, _
														"ptr", $pGroup, _
														"dword", $nLevel, _
														"ptr", $pBuffer, _
														"dword", $nMaxBuffer, _
														"ptr", $pEntriesRead, _
														"ptr", $pMaxEntries, _
														"ptr", $pHandle)
	Return $nResult[0]
EndFunc


Func NetUserGetInfo($pServer, $pUser, $nLevel, $pBuffer)
	Local $nResult = DllCall($hNetapi32, "dword", "NetUserGetInfo", _
														"ptr", $pServer, _
														"ptr", $pUser, _
														"dword", $nLevel, _
														"ptr", $pBuffer)
	Return $nResult[0]
EndFunc


Func NetUserSetInfo($pServer, $pUser, $nLevel, $pBuffer, $pError)
	Local $nResult = DllCall($hNetapi32, "dword", "NetUserSetInfo", _
														"ptr", $pServer, _
														"ptr", $pUser, _
														"dword", $nLevel, _
														"ptr", $pBuffer, _
														"ptr", $pError)
	Return $nResult[0]
EndFunc


Func NetUserEnum($pServer, $nLevel, $nFilter, $pBuffer, $nMaxBuffer, $pEntriesRead, $pMaxEntries, $pHandle)
	Local $nResult = DllCall($hNetapi32, "dword", "NetUserEnum", _
														"ptr", $pServer, _
														"dword", $nLevel, _
														"dword", $nFilter, _
														"ptr", $pBuffer, _
														"dword", $nMaxBuffer, _
														"ptr", $pEntriesRead, _
														"ptr", $pMaxEntries, _
														"ptr", $pHandle)
	Return $nResult[0]
EndFunc


Func NetShareEnum($pServer, $nLevel, $pBuffer, $nMaxBuffer, $pEntriesRead, $pMaxEntries, $pHandle)
	Local $nResult = DllCall($hNetapi32, "dword", "NetShareEnum", _
														"ptr", $pServer, _
														"dword", $nLevel, _
														"ptr", $pBuffer, _
														"dword", $nMaxBuffer, _
														"ptr", $pEntriesRead, _
														"ptr", $pMaxEntries, _
														"ptr", $pHandle)
	Return $nResult[0]
EndFunc


Func NetShareAdd($pServer, $nLevel, $pBuffer, $pError)
	Local $nResult = DllCall($hNetapi32, "dword", "NetShareAdd", _
														"ptr", $pServer, _
														"dword", $nLevel, _
														"ptr", $pBuffer, _
														"ptr", $pError)
	Return $nResult[0]
EndFunc


Func NetShareDel($pServer, $pShare, $nReserved)
	Local $nResult = DllCall($hNetapi32, "dword", "NetShareDel", _
														"ptr", $pServer, _
														"ptr", $pShare, _
														"dword", $nReserved)
	Return $nResult[0]
EndFunc


Func NetShareGetInfo($pServer, $pShare, $nLevel, $pBuffer)
	Local $nResult = DllCall($hNetapi32, "dword", "NetShareGetInfo", _
														"ptr", $pServer, _
														"ptr", $pShare, _
														"dword", $nLevel, _
														"ptr", $pBuffer)
	Return $nResult[0]
EndFunc


Func NetUseEnum($pReserved, $nLevel, $pBuffer, $nMaxBuffer, $pEntriesRead, $pMaxEntries, $pHandle)
	Local $nResult = DllCall($hNetapi32, "dword", "NetUseEnum", _
														"ptr", $pReserved, _
														"dword", $nLevel, _
														"ptr", $pBuffer, _
														"dword", $nMaxBuffer, _
														"ptr", $pEntriesRead, _
														"ptr", $pMaxEntries, _
														"ptr", $pHandle)
	Return $nResult[0]
EndFunc


Func NetUseGetInfo($pReserved, $pName, $nLevel, $pBuffer)
	Local $nResult = DllCall($hNetapi32, "dword", "NetUseGetInfo", _
														"ptr", $pReserved, _
														"ptr", $pName, _
														"dword", $nLevel, _
														"ptr", $pBuffer)
	Return $nResult[0]
EndFunc


;**********************************************************************
; MSVCRT.DLL
;**********************************************************************
Func _localtime64($pTime)
	Local $nResult = DllCall("msvcrt.dll", "long_ptr:cdecl", "_localtime64", _
													"ptr", $pTime)
	Return $nResult[0]
EndFunc


Func wcslen($pString)
	Local $nResult = DllCall("msvcrt.dll", "uint:cdecl", "wcslen", _
													"ptr", $pString)
	Return $nResult[0]
EndFunc


Func wcscpy($Dst, $Src)
	Local $sResult = DllCall("msvcrt.dll", "wstr:cdecl", "wcscpy", _
														"wstr", $Dst, _
														"ptr", $Src)
	Return $sResult[0]
EndFunc


Func _wsplitpath($sPath, $pDrv, $pDir, $pFile, $pExt)
	DllCall("msvcrt.dll", "none:cdecl", "_wsplitpath", _
										"wstr", $sPath, _
										"ptr", $pDrv, _
										"ptr", $pDir, _
										"ptr", $pFile, _
										"ptr", $pExt)
EndFunc


Func wcsftime($pDestStr, $nSize, $sFormat, $pTime)
	Local $sResult = DllCall("msvcrt.dll", "uint:cdecl", "wcsftime", _
										"long_ptr", $pDestStr, _
										"uint", $nSize, _
										"wstr", $sFormat, _
										"long_ptr", $pTime)
	Return $sResult[0]
EndFunc


Func _wsetlocale($nCat, $sLocale)
	Local $sResult = DllCall("msvcrt.dll", "long_ptr:cdecl", "_wsetlocale", _
										"int", $nCat, _
										"wstr", $sLocale)
	Return $sResult[0]
EndFunc


;**********************************************************************
; ADVAPI32.DLL
;**********************************************************************
Func RegOpenKeyExA($nMainKey, $sSubKey, $nReserved, $nSamDesired)
	Local $nResult = DllCall($hAdvapi32, "long", "RegOpenKeyExA", _
													"long", $nMainKey, _
													"str", $sSubKey, _
													"long", $nReserved, _
													"long", $nSamDesired, _
													"long*", 0)
	Return $nResult[5]
EndFunc


Func RegSetValueExA($hKey, $sValue, $nReserved, $nType, $sData, $nSize)
	Local $nResult = DllCall($hAdvapi32, "long", "RegSetValueExA", _
													"hwnd", $hKey, _
													"str", $sValue, _
													"long", $nReserved, _
													"long", $nType, _
													"str", $sData, _
													"long", $nSize)
	Return $nResult[0]
EndFunc


Func RegCloseKey($hKey)
	Local $nResult = DllCall($hAdvapi32, "long", "RegCloseKey", _
													"hwnd", $hKey)
	Return $nResult[0]
EndFunc


Func OpenSCManagerW($pMachine, $pDatabase, $nAccessNeeded)
	Local $hResult = DllCall($hAdvapi32, "hwnd", "OpenSCManagerW", _
													"ptr", $pMachine, _
													"ptr", $pDatabase, _
													"dword", $nAccessNeeded)
	Local $nError = GetLastError()
	If $hResult[0] = 0 Then
		Debug("ER: OpenSCManagerW: " & $nError)
	Else
		Debug("OK: OpenSCManagerW: " & $hResult[0])
	EndIf
	SetLastError($nError)
		
	Return $hResult[0]
EndFunc


Func OpenServiceW($hSCM, $sService, $nAccessNeeded)
	Local $hResult = DllCall($hAdvapi32, "hwnd", "OpenServiceW", _
													"hwnd", $hSCM, _
													"wstr", $sService, _
													"dword", $nAccessNeeded)
	Local $nError = GetLastError()
	If $hResult[0] = 0 Then
		Debug("ER: OpenServiceW - " & $sService & " :" & $nError)
	Else
		Debug("OK: OpenServiceW - " & $sService & " :" & $hResult[0])
	EndIf
	SetLastError($nError)
	
	Return $hResult[0]
EndFunc


Func QueryServiceStatus($hService, $pStatus)
  	Local $nResult = DllCall($hAdvapi32, "int", "QueryServiceStatus", _
													"hwnd", $hService, _
													"ptr", $pStatus)
	Local $nError = GetLastError()
	If $nResult[0] = 0 Then
		Debug("ER: QueryServiceStatus - " & $hService & " :" & $nError)
	Else
		Debug("OK: QueryServiceStatus - " & $hService & " :" & $nResult[0])
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc


Func ControlService($hService, $nControl, $pLastStatus)
	Local $nResult = DllCall($hAdvapi32, "int", "ControlService", _
													"hwnd", $hService, _
													"dword", $nControl, _
													"ptr", $pLastStatus)
	Local $nError = GetLastError()
	If $nResult[0] = 0 Then
		Debug("ER: ControlService - " & $hService & " :" & $nError)
	Else
		Debug("OK: ControlService - " & $hService & " :" & $nResult[0])
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc


Func StartServiceW($hService, $nArguments, $pArgumentsPass)
	Local $nResult = DllCall($hAdvapi32, "int", "StartServiceW", _
													"hwnd", $hService, _
													"dword", $nArguments, _
													"ptr", $pArgumentsPass)
	Local $nError = GetLastError()
	If $nResult[0] = 0 Then	
		Debug("ER: StartServiceW - " & $hService & " :" & $nError)
	Else
		Debug("OK: StartServiceW - " & $hService & " :" & $nResult[0])
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc


Func EnumDependentServicesW($hService, $nServiceState, $pServices, $nSize, $pNeeded, $pCount)
	Local $nResult = DllCall($hAdvapi32, "int", "EnumDependentServicesW", _
													"hwnd", $hService, _
													"dword", $nServiceState, _
													"ptr", $pServices, _
													"dword", $nSize, _
													"ptr", $pNeeded, _
													"ptr", $pCount)
	Local $nError = GetLastError()
	If $nResult[0] = 0 Then
		Debug("ER: EnumDependentServicesW - " & $hService & " :" & $nError)
	Else
		Debug("OK: EnumDependentServicesW - " & $hService & " :" & $nResult[0])
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc


Func CloseServiceHandle($hService)
	Local $nResult = DllCall($hAdvapi32, "int", "CloseServiceHandle", _
													"hwnd", $hService)
	Local $nError = GetLastError()
	If $nResult[0] = 0 Then
		Debug("ER: CloseServiceHandle - " & $hService & " :" & $nError)
	Else
		Debug("OK: CloseServiceHandle - " & $hService & " :" & $nResult[0])
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc


Func CreateWellKnownSid($nType, $pSID, $pNewSID, $pBytes)
	Local $nResult	= DllCall($hAdvapi32, "int", "CreateWellKnownSid", _
													"int", $nType, _
													"ptr", $pSID, _
													"ptr", $pNewSID, _
													"ptr", $pBytes)
	Return $nResult[0]
EndFunc


Func LookupAccountSidW($pServer, $pSID, $pName, $pSizeName, $pDomain, $pSizeDomain, $pType)
	Local $nResult	= DllCall($hAdvapi32, "int", "LookupAccountSidW", _
													"ptr", $pServer, _
													"ptr", $pSID, _
													"ptr", $pName, _
													"ptr", $pSizeName, _
													"ptr", $pDomain, _
													"ptr", $pSizeDomain, _
													"ptr", $pType)
	Return $nResult[0]
EndFunc


;**********************************************************************
; COMCTL32.DLL
;**********************************************************************
Func ImageList_Create($nImageWidth, $nImageHeight, $nFlags, $nInitial, $nGrow)
	Local $hResult = DllCall($hComctl32, "hwnd", "ImageList_Create", _
													"int", $nImageWidth, _
													"int", $nImageHeight, _
													"int", $nFlags, _
													"int", $nInitial, _
													"int", $nGrow)
	Return $hResult[0]
EndFunc


Func ImageList_AddIcon($hIml, $hIcon)
	Local $nResult = DllCall($hComctl32, "int", "ImageList_AddIcon", _
												"hwnd", $hIml, _
												"hwnd", $hIcon)
	Return $nResult[0]
EndFunc


Func ImageList_ReplaceIcon($hIml, $nIdx, $hIcon)
	Local $nResult = DllCall($hComctl32, "int", "ImageList_ReplaceIcon", _
												"hwnd", $hIml, _
												"int", $nIdx, _
												"hwnd", $hIcon)
	Return $nResult[0]
EndFunc


Func ImageList_Destroy($hIml)
	Local $nResult = DllCall($hComctl32, "int", "ImageList_Destroy", _
												"hwnd", $hIml)
	Return $nResult[0]
EndFunc


Func ImageList_Draw($hIml, $nIndex, $hDC, $nX, $nY, $nStyle)
	Local $bResult = DllCall($hComctl32, "int", "ImageList_Draw", _
												"hwnd", $hIml, _
												"int", $nIndex, _
												"hwnd", $hDC, _
												"int", $nX, _
												"int", $nY, _
												"int", $nStyle)
	Return $bResult[0]
EndFunc


Func ImageList_Merge($hIml1, $nIdx1, $hIml2, $nIdx2, $nX, $nY)
	Local $hResult = DllCall($hComctl32, "hwnd", "ImageList_Merge", _
												"hwnd", $hIml1, _
												"int", $nIdx1, _
												"hwnd", $hIml2, _
												"int", $nIdx2, _
												"int", $nX, _
												"int", $nY)
	Return $hResult[0]
EndFunc


Func ImageList_GetIcon($hIml, $nIdx, $nFlags)
	Local $hResult = DllCall($hComctl32, "int", "ImageList_GetIcon", _
												"hwnd", $hIml, _
												"int", $nIdx, _
												"uint", $nFlags)
	Return $hResult[0]
EndFunc


Func CreateMRUListW($pMRUI)
	Local $hResult = DllCall($hComctl32, "hwnd", 400, _
												"ptr", $pMRUI)
	Return $hResult[0]
EndFunc


Func FreeMRUList($hMRU)
	Local $nResult = DllCall($hComctl32, "int", 152, _
												"hwnd", $hMRU)
	Return $nResult[0]
EndFunc


Func AddMRUStringW($hMRU, $pText)
	Local $nResult = DllCall($hComctl32, "int", 401, _
												"hwnd", $hMRU, _
												"ptr", $pText)
	Return $nResult[0]
EndFunc


Func EnumMRUListW($hMRU, $nItem, $pData, $nLenData)
	Local $hResult = DllCall($hComctl32, "int", 403, _
												"hwnd", $hMRU, _
												"int", $nItem, _
												"ptr", $pData, _
												"uint", $nLenData)
	Return $hResult[0]
EndFunc


;**********************************************************************
; WLANAPI.DLL
;**********************************************************************
Func WlanOpenHandle($nClientVersion, $pReserved, $pVersionUsed, $pSession)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanOpenHandle", _
									"dword", $nClientVersion, _
									"ptr", $pReserved, _
									"ptr", $pVersionUsed, _
									"ptr", $pSession)	
	Return $nResult[0]
EndFunc


Func WlanCloseHandle($hSession, $pReserved, $bLog = TRUE)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanCloseHandle", _
									"hwnd", $hSession, _
									"ptr", $pReserved)
	Return $nResult[0]
EndFunc


Func WlanRegisterNotification($hSession, $nNotifySrc, $bIgnoreDupli, $pFuncCallback, $pCallbackCxt, $pReserved, $pPrevNotifySrv)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanRegisterNotification", _
									"hwnd", $hSession, _
									"dword", $nNotifySrc, _
									"int", $bIgnoreDupli, _
									"ptr", $pFuncCallback, _
									"ptr", $pCallbackCxt, _
									"ptr", $pReserved, _
									"ptr", $pPrevNotifySrv)	
	Return $nResult[0]
EndFunc


Func WlanEnumInterfaces($hSession, $pReserved, $pInterfaceList)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanEnumInterfaces", _
									"hwnd", $hSession, _
									"ptr", $pReserved, _
									"ptr", $pInterfaceList)

	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanEnumInterfaces")
	Else
		Debug("ER: WlanEnumInterfaces: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanFreeMemory($pMemory)
	DllCall($hWlanapi, "none", "WlanFreeMemory", _
							"ptr", $pMemory)
EndFunc


Func WlanGetProfileList($hSession, $pGUID, $pReserved, $pProfileInfoList)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanGetProfileList", _
											"hwnd", $hSession, _
											"ptr", $pGUID, _
											"ptr", $pReserved, _
											"ptr", $pProfileInfoList)
											
	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanGetProfileList")
	Else
		Debug("ER: WlanGetProfileList: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanGetProfile($hSession, $pGUID, $pProfileName, $pReserved, $pProfile, $pFlags, $pAccess)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanGetProfile", _
											"hwnd", $hSession, _
											"ptr", $pGUID, _
											"ptr", $pProfileName, _
											"ptr", $pReserved, _
											"ptr", $pProfile, _
											"ptr", $pFlags, _
											"ptr", $pAccess)
											
	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanGetProfile")
	Else
		Debug("ER: WlanGetProfile: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanGetAvailableNetworkList($hSession, $pGUID, $nFlags, $pReserved, $pBuffer)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanGetAvailableNetworkList", _
											"hwnd", $hSession, _
											"ptr", $pGUID, _
											"dword", $nFlags, _
											"ptr", $pReserved, _
											"ptr", $pBuffer)
											
	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanGetAvailableNetworkList")
	Else
		Debug("ER: WlanGetAvailableNetworkList: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanScan($hSession, $pGUID, $pDot11Ssid, $pData, $pReserved)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanScan", _
											"hwnd", $hSession, _
											"ptr", $pGUID, _
											"ptr", $pDot11Ssid, _
											"ptr", $pData, _
											"ptr", $pReserved)

	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanScan")
	Else
		Debug("ER: WlanScan: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanConnect($hSession, $pGUID, $pConnParams, $pReserved)
  	Local $nResult = DllCall($hWlanapi, "dword", "WlanConnect", _
											"hwnd", $hSession, _
											"ptr", $pGUID, _
											"ptr", $pConnParams, _
											"ptr", $pReserved)

	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanConnect")
	Else
		Debug("ER: WlanConnect: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanDisconnect($hSession, $pGUID, $pReserved)
  	Local $nResult = DllCall($hWlanapi, "dword", "WlanDisconnect", _
											"hwnd", $hSession, _
											"ptr", $pGUID, _
											"ptr", $pReserved)

	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanDisconnect")
	Else
		Debug("ER: WlanDisconnect: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanDeleteProfile($hSession, $pGUID, $pProfile, $pReserved)
  	Local $nResult = DllCall($hWlanapi, "dword", "WlanDeleteProfile", _
													"hwnd", $hSession, _
													"ptr", $pGUID, _
													"ptr", $pProfile, _
													"ptr", $pReserved)

	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanDeleteProfile")
	Else
		Debug("ER: WlanDeleteProfile: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanSetProfile($hSession, $pGUID, $nFlags, $pProfile, $pSecurity, $bOverwrite, $pReserved, $pReasonCode)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanSetProfile", _
													"hwnd", $hSession, _
													"ptr", $pGUID, _
													"int", $nFlags, _
													"ptr", $pProfile, _
													"ptr", $pSecurity, _
													"int", $bOverwrite, _
													"ptr", $pReserved, _
													"ptr", $pReasonCode)
	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanSetProfile")
	Else
		Debug("ER: WlanSetProfile: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanReasonCodeToString($nCode, $nSize, $pBuffer, $pReserved)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanReasonCodeToString", _
													"dword", $nCode, _
													"dword", $nSize, _
													"ptr", $pBuffer, _
													"ptr", $pReserved)
	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanReasonCodeToString")
	Else
		Debug("ER: WlanReasonCodeToString: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanQueryInterface($hSession, $pGUID, $nCode, $pReserved, $pSize, $pBuffer, $pType, $bLog = TRUE)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanQueryInterface", _
													"hwnd", $hSession, _
													"ptr", $pGUID, _
													"int", $nCode, _
													"ptr", $pReserved, _
													"ptr", $pSize, _
													"ptr", $pBuffer, _
													"ptr", $pType)
	If $nResult[0] = $ERROR_SUCCESS Then
		If $bLog Then Debug("OK: WlanQueryInterface")
	Else
		If $bLog Then Debug("ER: WlanQueryInterface: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanUIEditProfile($nVersion, $pProfile, $pGUID, $hWnd, $nPage, $pReserved, $pReasonCode)
	Local $nResult = DllCall("wlanui.dll", "dword", "WlanUIEditProfile", _
											"dword", $nVersion, _
											"ptr", $pProfile, _
											"ptr", $pGUID, _
											"hwnd", $hWnd, _
											"int", $nPage, _
											"ptr", $pReserved, _
											"ptr", $pReasonCode)
	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanUIEditProfile")
	Else
		Debug("ER: WlanUIEditProfile: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


Func WlanSetProfilePosition($hSession, $pGUID, $pProfile, $nPosition, $pReserved)
	Local $nResult = DllCall($hWlanapi, "dword", "WlanSetProfilePosition", _
													"hwnd", $hSession, _
													"ptr", $pGUID, _
													"ptr", $pProfile, _
													"dword", $nPosition, _
													"ptr", $pReserved)
	If $nResult[0] = $ERROR_SUCCESS Then
		Debug("OK: WlanSetProfilePosition")
	Else
		Debug("ER: WlanSetProfilePosition: " & $nResult[0])
	EndIf
	
	Return $nResult[0]
EndFunc


;**********************************************************************
; GDI32.DLL
;**********************************************************************
Func GetDeviceCaps($hDC, $nIndex)
	Local $nResult = DllCall($hGdi32, "int", "GetDeviceCaps", _
										"hwnd", $hDC, _
										"int", $nIndex)
	Return $nResult[0]
EndFunc


Func GetTextMetricsW($hDC, $lpTM)
Local $nResult = DllCall($hGDI32, "int", "GetTextMetricsW", _
									"int", $hDC, _
									"long_ptr", $lpTM)
	Return $nResult[0]
EndFunc


Func CreateFontW($nHeight, $nWidth, $nEscape, $nOrientn, $fnWeight, $bItalic, $bUnderline, _
				$bStrikeout, $nCharset, $nOutputPrec, $nClipPrec, $nQuality, $nPitch, $ptrFontName)
	Local $hResult = DllCall($hGdi32, "hwnd", "CreateFontW", _
												"int", $nHeight, _
												"int", $nWidth, _
												"int", $nEscape, _
												"int", $nOrientn, _
												"int", $fnWeight, _
												"long", $bItalic, _
												"long", $bUnderline, _
												"long", $bStrikeout, _
												"long", $nCharset, _
												"long", $nOutputPrec, _
												"long", $nClipPrec, _
												"long", $nQuality, _
												"long", $nPitch, _
												"ptr", $ptrFontName)
	Return $hResult[0]
EndFunc


Func GetStockObject($nObj)
	Local $hResult = DllCall($hGdi32, "hwnd", "GetStockObject", _
												"int", $nObj)
	Return $hResult[0]
EndFunc


Func CreateSolidBrush($nColor)
	Local $hResult = DllCall($hGdi32, "hwnd", "CreateSolidBrush", _
												"int", $nColor)
	Return $hResult[0]
EndFunc


Func SetBkColor($hDC, $nColor)
	Local $nResult = DllCall($hGdi32, "dword", "SetBkColor", _
												"hwnd", $hDC, _
												"dword", $nColor)
	Return $nResult[0]
EndFunc


Func SetTextColor($hDC, $nColor)
	Local $nResult = DllCall($hGdi32, "dword", "SetTextColor", _
												"hwnd", $hDC, _
												"dword", $nColor)
	Return $nResult[0]
EndFunc


Func SelectObject($hDC, $hObj)
	Local $hResult = DllCall($hGdi32, "hwnd", "SelectObject", _
												"hwnd", $hDC, _
												"hwnd", $hObj)
	Return $hResult[0]
EndFunc


Func DeleteObject($hObj)
	Local $nResult = DllCall($hGdi32, "hwnd", "DeleteObject", _
												"hwnd", $hObj)
	Return $nResult[0]
EndFunc


Func SetBkMode($hDC, $nMode)
	Local $hResult = DllCall($hGdi32, "int", "SetBkMode", _
												"hwnd", $hDC, _
												"int", $nMode)
	Return $hResult[0]
EndFunc


Func DeleteDC($hDC)
	Local $hResult = DllCall($hGdi32, "int", "DeleteDC", _
												"hwnd", $hDC)
	Return $hResult[0]
EndFunc


Func GetTextExtentPoint32W($hDC, $pString, $nLen, $pSize)
	Local $nResult = DllCall($hGdi32, "int", "GetTextExtentPoint32W", _
												"hwnd", $hDC, _
												"long_ptr", $pString, _
												"int", $nLen, _
												"long_ptr", $pSize)
	Return $nResult[0]
EndFunc


;**********************************************************************
; MPR.DLL
;**********************************************************************
Func WNetOpenEnumW($nScope, $nType, $nUsage, $pNetRes, $pEnum)
    Local $nResult = DllCall($hMpr, "dword", "WNetOpenEnumW", _
                                                "dword", $nScope, _
                                                "dword", $nType, _
                                                "dword", $nUsage, _
                                                "ptr", $pNetRes, _
                                                "ptr", $pEnum)
    Return $nResult[0]
EndFunc


Func WNetCloseEnum($hEnum)
    Local $nResult = DllCall($hMpr, "dword", "WNetCloseEnum", _
                                                "hwnd", $hEnum)

    Return $nResult[0]
EndFunc


Func WNetEnumResourceW($hEnum, $pCount, $pBuffer, $pSize)
    Local $nResult = DllCall($hMpr, "dword", "WNetEnumResourceW", _
                                                "hwnd", $hEnum, _
                                                "ptr", $pCount, _
                                                "ptr", $pBuffer, _
                                                "ptr", $pSize)
    Return $nResult[0]
EndFunc


;**********************************************************************
; WS2_32.DLL
;**********************************************************************
Func inet_ntop($nFamily, $pAddr, $pBuffer, $nSize)
	Local $nResult = DllCall($hWs2_32, "ptr", "inet_ntop", _
												"int", $nFamily, _
												"ptr", $pAddr, _
												"ptr", $pBuffer, _
												"int", $nSize)
	Return $nResult[0]
EndFunc 


Func inet_ntoa($nAddr)
	Local $nResult = DllCall($hWs2_32, "ptr", "inet_ntoa", _
												"ulong", $nAddr)
	Return $nResult[0]
EndFunc


Func inet_addr($pAddr)
	Local $nResult = DllCall($hWs2_32, "ulong", "inet_addr", _
												"ptr", $pAddr)
	Return $nResult[0]
EndFunc


Func WSAStartup($nVersion, $pWSAData)
	Local $nResult = DllCall($hWs2_32, "int", "WSAStartup", _
												"ushort", $nVersion, _
												"long_ptr", $pWSAData)
	Return $nResult[0]
EndFunc


Func WSACleanup()
	Local $nResult = DllCall($hWs2_32, "int", "WSACleanup")
	
	Return $nResult[0]
EndFunc


Func gethostbyname($pName)
	Local $pResult = DllCall($hWs2_32, "ptr", "gethostbyname", _
										"ptr", $pName)
	
	Return $pResult[0]
EndFunc


Func gethostbyaddr($pAddr)
	Local $pResult = DllCall($hWs2_32, "ptr", "gethostbyaddr", _
													"long*", $pAddr, _
													"int", 4, _
													"int", $AF_INET)
	Return $pResult[0]
EndFunc


Func WSAAddressToStringW($pAddr, $nAddrLen, $pProtInfo, $pStr, $pStrLen)
	Local $nResult = DllCall($hWs2_32, "int", "WSAAddressToStringW", _
												"long_ptr", $pAddr, _
												"dword", $nAddrLen, _
												"long_ptr", $pProtInfo, _
												"long_ptr", $pStr, _
												"long_ptr", $pStrLen)
	Return $nResult[0]
EndFunc


;**********************************************************************
; OTHER
;**********************************************************************
Func ExtractIconExW($sIconFile, $nIconID, $ptrIconLarge, $ptrIconSmall, $nIcons)
	Local $nResult = DllCall($hShell32, "int", "ExtractIconExW", _
					"wstr", $sIconFile, _
					"int", $nIconID, _
					"ptr", $ptrIconLarge, _
					"ptr", $ptrIconSmall, _
					"int", $nIcons)
	Return $nResult[0]
EndFunc


Func Shell_NotifyIconW($nMessage, $pNID)
	Local $nResult = DllCall($hShell32, "int", "Shell_NotifyIconW", _
													"int", $nMessage, _
													"ptr", $pNID)
	Return $nResult[0]
EndFunc


Func SetThemeAppProperties($nFlags)
	DllCall("uxtheme.dll", "none", "SetThemeAppProperties", _
									"int", $nFlags)
EndFunc


Func SetWindowTheme($hWnd, $sAppName, $sIdList)
	DllCall("uxtheme.dll", "none", "SetWindowTheme", _
									"hwnd", $hWnd, _
									"wstr", $sAppName, _
									"wstr", $sIdList)
EndFunc


Func UpdateDriverForPlugAndPlayDevicesW($hWnd, $sHardwareID, $sInfpath, $nFlags, $pReboot)
	Local $nResult = DllCall("newdev.dll", "int", "UpdateDriverForPlugAndPlayDevicesW", _
											"hwnd", $hWnd, _
											"wstr", $sHardwareID, _
											"wstr", $sInfpath, _
											"dword", $nFlags, _
											"ptr", $pReboot)											
	Local $nError = GetLastError()
	If $nResult[0] Then
		Debug("OK: UpdateDriverForPlugAndPlayDevicesW")
	Else
		Debug("ER: UpdateDriverForPlugAndPlayDevicesW: " & $nError)
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc


Func PathIsUNCW($sPath)
	Local $nResult = DllCall("shlwapi.dll", "int", "PathIsUNCW", _
													"wstr", $sPath)
	Return $nResult[0]
EndFunc


Func DiInstallDevice($hWnd, $hDeviceInfoSet, $pDeviceInfoData, $pDriverInfoData, $nFlags, $pReboot)
	Local $nResult = DllCall("newdev.dll", "int", "DiInstallDevice", _
													"hwnd", $hWnd, _
													"hwnd", $hDeviceInfoSet, _
													"ptr", $pDeviceInfoData, _
													"ptr", $pDriverInfoData, _
													"dword", $nFlags, _
													"ptr", $pReboot)											
	Local $nError = GetLastError()
	If $nResult[0] Then
		Debug("OK: DiInstallDevice")
	Else
		Debug("ER: DiInstallDevice: " & $nError)
	EndIf
	SetLastError($nError)
	
	Return $nResult[0]
EndFunc